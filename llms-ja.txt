================================================================================
HEMLOCK PROGRAMMING LANGUAGE - COMPLETE DOCUMENTATION (日本語)
================================================================================

This file contains the complete documentation for the Hemlock programming
language and the hpm package manager in 日本語.
It is optimized for LLM consumption.

Source: https://github.com/hemlang/hem-doc

--------------------------------------------------------------------------------
TABLE OF CONTENTS
--------------------------------------------------------------------------------

  1. ようこそ
  2. 言語リファレンス

[はじめに]
  3. インストール
  4. クイックスタート
  5. チュートリアル
  6. 学習パス

[言語ガイド]
  7. エラー処理
  8. オブジェクト
  9. パターンマッチング
  10. メモリ管理
  11. モジュール
  12. ルーン
  13. 制御フロー
  14. 型
  15. 文字列
  16. 構文
  17. 配列
  18. 関数

[高度なトピック]
  19. FFI
  20. File IO
  21. アトミック操作
  22. コマンドライン引数
  23. コマンド実行
  24. シグナル処理
  25. バンドルとパッケージング
  26. プロファイリング
  27. 非同期と並行処理

[APIリファレンス]
  28. ファイルAPI
  29. メモリAPI
  30. 並行処理API
  31. 型システム
  32. 文字列API
  33. 演算子
  34. 組み込み関数
  35. 配列API

[設計と思想]
  36. シグネチャ構文
  37. 実装の詳細
  38. 設計思想

[コントリビューション]
  39. ガイドライン
  40. テスト

[hpm: はじめに]
  41. インストール
  42. クイックスタート
  43. プロジェクトセットアップ

[hpm: ユーザーガイド]
  44. コマンド
  45. トラブルシューティング
  46. 設定

[hpm: パッケージ開発]
  47. バージョニング
  48. パッケージの作成
  49. パッケージ仕様

[hpm: リファレンス]
  50. アーキテクチャ
  51. 終了コード


================================================================================
DOCUMENTATION
================================================================================

--------------------------------------------------------------------------------
## ようこそ
--------------------------------------------------------------------------------

# Hemlock へようこそ

> 「安全でないものを安全に書くための、小さく安全でない言語」

**Hemlock** は、C言語のパワーとモダンなスクリプトの使いやすさを組み合わせたシステムスクリプト言語です。手動メモリ管理、明示的な制御、構造化された非同期並行処理が組み込まれています。

## Hemlock とは？

Hemlock は以下を求めるプログラマー向けに設計されています：

- メモリと実行の**明示的な制御**
- モダンな利便性を備えた**C言語ライクな構文**
- **隠れた動作やマジックがない**
- pthread ベースの並行処理による**真の並列非同期**

Hemlock はガベージコレクション付きのメモリ安全な言語ではありません。代わりに、安全のためのツール（`buffer`、型アノテーション、境界チェック）を提供しますが、それらの使用を強制しません（`ptr`、手動メモリ管理、安全でない操作）。

## クイック例

```hemlock
// こんにちは、Hemlock！
fn greet(name: string): string {
    return `こんにちは、${name}！`;
}

let message = greet("世界");
print(message);

// 手動メモリ管理
let buf = buffer(64);
buf[0] = 72;  // 'H'
buf[1] = 105; // 'i'
print(buf);
free(buf);
```

## 機能一覧

| 機能 | 説明 |
|------|------|
| **型システム** | i8-i64、u8-u64、f32/f64、bool、string、rune、ptr、buffer、array、object |
| **メモリ** | `alloc()`、`buffer()`、`free()` による手動管理 |
| **非同期** | 組み込みの `async`/`await` と真の pthread 並列処理 |
| **FFI** | 共有ライブラリから C 関数を直接呼び出し |
| **標準ライブラリ** | crypto、http、sqlite、json など40のモジュール |

## はじめに

始める準備はできましたか？以下の手順で始めましょう：

1. **[インストール](getting-started-installation)** - Hemlock をダウンロードしてセットアップ
2. **[クイックスタート](getting-started-quick-start)** - 数分で最初のプログラムを作成
3. **[チュートリアル](getting-started-tutorial)** - ステップバイステップで Hemlock を学ぶ

## ドキュメントセクション

- **はじめに** - インストール、クイックスタートガイド、チュートリアル
- **言語ガイド** - 構文、型、関数などの詳細
- **高度なトピック** - 非同期プログラミング、FFI、シグナル、アトミック操作
- **APIリファレンス** - 組み込み関数と標準ライブラリの完全なリファレンス
- **設計と思想** - Hemlock がこのような設計になっている理由を理解する

## パッケージマネージャー

Hemlock には依存関係を管理するためのパッケージマネージャー **hpm** が付属しています：

```bash
hpm init my-project
hpm add some-package
hpm run
```

詳細については hpm ドキュメントセクションを参照してください。

---

左側のナビゲーションを使用してドキュメントを探索するか、検索バーを使用して特定のトピックを検索してください。


--------------------------------------------------------------------------------
## 言語リファレンス
--------------------------------------------------------------------------------

# Hemlock言語設計思想

> 「安全でないことを安全に記述するための、小さく安全でない言語」

このドキュメントは、Hemlockを使用するAIアシスタント向けのコア設計原則を記載しています。
詳細なドキュメントについては、`docs/README.md` と `stdlib/docs/` ディレクトリを参照してください。

---

## コアアイデンティティ

Hemlockは**システムスクリプト言語**であり、手動メモリ管理と明示的な制御を備えています：
- モダンなスクリプト言語の使いやすさを持つCのパワー
- 構造化された非同期並行処理が組み込み
- 隠れた動作やマジックがない

**Hemlockではないもの：** メモリセーフ、GC言語、複雑さを隠すもの
**Hemlockであるもの：** 暗黙より明示、教育的、システム作業のための「Cスクリプト層」

---

## 設計原則

### 1. 暗黙より明示
- セミコロン必須（ASIなし）
- 手動メモリ管理（alloc/free）
- 型注釈はオプションだが実行時にチェック

### 2. デフォルトで動的、選択で型付け
- すべての値は実行時型タグを持つ
- リテラルは型を推論：`42` → i32、`5000000000` → i64、`3.14` → f64
- オプションの型注釈は実行時チェックを強制

### 3. アンセーフは機能
- ポインタ演算が許可（ユーザーの責任）
- 生の`ptr`には境界チェックなし（安全のために`buffer`を使用）
- 二重解放によるクラッシュを許可

### 4. 構造化された並行処理がファーストクラス
- pthreadベースの並列処理を持つ`async`/`await`組み込み
- 通信用チャネル
- タスク管理用の`spawn`/`join`/`detach`

### 5. Cライクな構文
- `{}`ブロックは常に必須
- コメント：`// 行` と `/* ブロック */`
- 演算子はCと同じ：`+`、`-`、`*`、`%`、`&&`、`||`、`!`、`&`、`|`、`^`、`<<`、`>>`
- インクリメント/デクリメント：`++x`、`x++`、`--x`、`x--`（前置と後置）
- 複合代入：`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`
- `/`は常にfloatを返す（整数除算には`divi()`を使用）
- 型構文：`let x: type = value;`

---

## クイックリファレンス

### 型
```
符号付き：   i8, i16, i32, i64
符号なし：   u8, u16, u32, u64
浮動小数点： f32, f64
その他：     bool, string, rune, array, ptr, buffer, null, object, file, task, channel
エイリアス： integer (i32), number (f64), byte (u8)
```

**型昇格：** i8 → i16 → i32 → i64 → f32 → f64（floatが常に優先、ただしi64/u64 + f32 → f64で精度を保持）

### リテラル
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64（> i32 最大値）
let hex = 0xDEADBEEF;    // 16進リテラル
let bin = 0b1010;        // 2進リテラル
let oct = 0o777;         // 8進リテラル
let sep = 1_000_000;     // 数値セパレータ使用可能
let pi = 3.14;           // f64
let half = .5;           // f64（先頭ゼロなし）
let s = "hello";         // string
let esc = "\x41\u{1F600}"; // 16進とUnicodeエスケープ
let ch = 'A';            // rune
let emoji = '🚀';        // rune（Unicode）
let arr = [1, 2, 3];     // array
let obj = { x: 10 };     // object
```

### 型変換
```hemlock
// 型コンストラクタ関数 - 文字列を型にパース
let n = i32("42");       // 文字列をi32にパース
let f = f64("3.14");     // 文字列をf64にパース
let b = bool("true");    // 文字列をboolにパース（"true"または"false"）

// すべての数値型をサポート
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// 16進数と負数
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// 型エイリアスも動作
let x = integer("100");  // i32("100")と同じ
let y = number("1.5");   // f64("1.5")と同じ
let z = byte("200");     // u8("200")と同じ

// 数値型間の変換
let big = i64(42);       // i32からi64へ
let truncated = i32(3.99); // f64からi32へ（3に切り捨て）

// 型注釈は型を検証（文字列をパースしない）
let f: f64 = 100;        // 注釈によるi32からf64へ（数値変換OK）
// let n: i32 = "42";    // エラー - 文字列パースにはi32("42")を使用
```

### イントロスペクション
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5（バイト単位の文字列長）
len([1, 2, 3]);          // 3（配列長）
```

### メモリ
```hemlock
let p = alloc(64);       // 生ポインタ
let b = buffer(64);      // 安全なバッファ（境界チェック付き）
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // 手動クリーンアップ必須
```

### 制御フロー
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // 無限ループ（while(true)よりクリーン）
switch (x) { case 1: break; default: break; }  // Cスタイルのフォールスルー
defer cleanup();         // 関数が戻るときに実行

// ネストされたループでの対象指定break/continue用ループラベル
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // 外側ループをbreak
        if (i == 3) { continue outer; }  // 外側ループをcontinue
    }
}
```

### パターンマッチング
```hemlock
// match式 - 値を返す
let result = match (value) {
    0 => "zero",                    // リテラルパターン
    1 | 2 | 3 => "small",           // ORパターン
    n if n < 10 => "medium",        // ガード式
    n => "large: " + n              // 変数バインディング
};

// 型パターン
match (val) {
    n: i32 => "integer",
    s: string => "string",
    _ => "other"                    // ワイルドカード
}

// オブジェクトの分解
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// restを使った配列の分解
match (arr) {
    [] => "empty",
    [first, ...rest] => "head: " + first,
    _ => "other"
}

// ネストされたパターン
match (user) {
    { name, address: { city } } => name + " in " + city
}
```

完全なドキュメントについては`docs/language-guide/pattern-matching.md`を参照してください。

### Null合体演算子
```hemlock
// Null合体（??）- 左がnon-nullなら左を、そうでなければ右を返す
let name = user.name ?? "Anonymous";
let first = a ?? b ?? c ?? "fallback";

// Null合体代入（??=）- nullの場合のみ代入
let config = null;
config ??= { timeout: 30 };    // configは{ timeout: 30 }になる
config ??= { timeout: 60 };    // configは変更されない（nullではない）

// プロパティとインデックスでも動作
obj.field ??= "default";
arr[0] ??= "first";

// 安全なナビゲーション（?.）- オブジェクトがnullならnullを返す
let city = user?.address?.city;  // どの部分がnullでもnull
let upper = name?.to_upper();    // 安全なメソッド呼び出し
let item = arr?.[0];             // 安全なインデックス
```

### 関数
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Hello") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // 匿名/クロージャ

// 式本体関数（アロー構文）
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // 匿名式本体

// パラメータ修飾子
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // 参照渡し
fn print_all(const items: array) { for (i in items) { print(i); } }  // 不変
```

### 名前付き引数
```hemlock
// 関数は名前付き引数で呼び出し可能
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// 位置引数（従来型）
create_user("Alice", 25, false);

// 名前付き引数 - 任意の順序で指定可能
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// 必要なものだけ名前で指定してオプションパラメータをスキップ
create_user("David", active: false);  // デフォルトage=18を使用

// 名前付き引数は位置引数の後に来る必要がある
create_user("Eve", age: 21);          // OK：位置引数の後に名前付き
// create_user(name: "Bad", 25);      // エラー：名前付きの後に位置引数
```

**ルール：**
- 名前付き引数は`name: value`構文を使用
- 位置引数の後なら任意の順序で使用可能
- 名前付き引数の後に位置引数は使用不可
- デフォルト/オプションパラメータで動作
- 不明なパラメータ名は実行時エラー

### オブジェクトと列挙型
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// オブジェクトショートハンド構文（ES6スタイル）
let name = "Alice";
let age = 30;
let person = { name, age };         // { name: name, age: age }と同等

// オブジェクトスプレッド演算子
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // defaultsをコピーし、sizeをオーバーライド

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### 複合型（交差型/ダック型）
```hemlock
// 構造型を定義
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// 複合型：オブジェクトはすべての型を満たす必要がある
let person: HasName & HasAge = { name: "Alice", age: 30 };

// 複合型を使った関数パラメータ
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

// 3つ以上の型
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// 余分なフィールドは許可（ダック型）
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Engineering"  // OK - 余分なフィールドは無視
};
```

複合型は、別の`interface`キーワードなしでインターフェースのような動作を提供し、
既存の`define`とダック型のパラダイムの上に構築されています。

### 型エイリアス
```hemlock
// シンプルな型エイリアス
type Integer = i32;
type Text = string;

// 関数型エイリアス
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// 複合型エイリアス（再利用可能なインターフェースに最適）
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// ジェネリック型エイリアス
type Pair<T> = { first: T, second: T };

// 型エイリアスの使用
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

型エイリアスは複雑な型に名前付きショートカットを作成し、可読性と保守性を向上させます。

### 関数型
```hemlock
// パラメータ用の関数型注釈
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// 関数を返す高階関数
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// 非同期関数型
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// 複数パラメータを持つ関数型
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Constパラメータ
```hemlock
// Constパラメータ - 深い不変性
fn print_all(const items: array) {
    // items.push(4);  // エラー：constパラメータを変更できない
    for (item in items) {
        print(item);
    }
}

// オブジェクトでのconst - どのパスからも変更不可
fn describe(const person: object) {
    print(person.name);       // OK：読み取りは許可
    // person.name = "Bob";   // エラー：変更できない
}

// 読み取り用のネストされたアクセスは許可
fn get_city(const user: object) {
    return user.address.city;  // OK：ネストされたプロパティの読み取り
}
```

`const`修飾子は、ネストされたプロパティを含むパラメータのあらゆる変更を防ぎます。
これにより、入力を変更すべきでない関数のコンパイル時安全性が提供されます。

### Refパラメータ（参照渡し）
```hemlock
// Refパラメータ - 呼び出し元の変数を直接変更
fn increment(ref x: i32) {
    x = x + 1;  // 元の変数を変更
}

let count = 10;
increment(count);
print(count);  // 11 - 元が変更された

// 古典的なswap関数
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// refと通常のパラメータを混在
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

`ref`修飾子は呼び出し元の変数への参照を渡し、関数がそれを直接変更できるようにします。
`ref`がない場合、プリミティブは値渡し（コピー）されます。値を返さずに呼び出し元の
状態を変更する必要がある場合に`ref`を使用します。

**ルール：**
- `ref`パラメータには変数を渡す必要があり、リテラルや式は不可
- すべての型で動作（プリミティブ、配列、オブジェクト）
- 型注釈と組み合わせ可能：`ref x: i32`
- `const`と組み合わせ不可（反対の意味）

### Defineでのメソッドシグネチャ
```hemlock
// メソッドシグネチャを持つdefine（インターフェースパターン）
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // 必須メソッドシグネチャ
}

// オブジェクトは必須メソッドを提供する必要がある
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// ?を使ったオプションメソッド
define Serializable {
    fn serialize(): string,        // 必須
    fn pretty?(): string           // オプションメソッド
}

// Self型は定義型を参照
define Cloneable {
    fn clone(): Self   // オブジェクトと同じ型を返す
}
```

`define`ブロック内のメソッドシグネチャはカンマ区切り（TypeScriptインターフェースのような）を使用し、
オブジェクトが満たすべき契約を確立し、Hemlockのダック型システムでインターフェースのような
プログラミングパターンを可能にします。

### エラーハンドリング
```hemlock
try { throw "error"; } catch (e) { print(e); } finally { cleanup(); }
panic("unrecoverable");  // 即座に終了、catchできない
```

### 非同期/並行処理
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // またはjoin(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**メモリ所有権：** タスクはプリミティブ値のコピーを受け取りますが、ポインタは共有します。スポーンされたタスクに`ptr`を渡す場合、タスクが完了するまでメモリが有効であることを保証する必要があります。`free()`の前に`join()`を使用するか、完了を通知するためにチャネルを使用してください。

### ユーザー入力
```hemlock
let name = read_line();          // stdinから行を読み取り（ブロック）
print("Hello, " + name);
eprint("Error message");         // stderrに出力

// read_line()はEOFでnullを返す
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Got:", line);
}
```

### ファイルI/O
```hemlock
let f = open("file.txt", "r");  // モード：r, w, a, r+, w+, a+
let content = f.read();
f.write("data");
f.seek(0);
f.close();
```

### シグナル
```hemlock
signal(SIGINT, fn(sig) { print("Interrupted"); });
raise(SIGUSR1);
```

---

## 文字列メソッド（19個）

`substr`、`slice`、`find`、`contains`、`split`、`trim`、`to_upper`、`to_lower`、
`starts_with`、`ends_with`、`replace`、`replace_all`、`repeat`、`char_at`、
`byte_at`、`chars`、`bytes`、`to_bytes`、`deserialize`

テンプレート文字列：`` `Hello ${name}!` ``

**文字列の可変性：** 文字列はインデックス代入（`s[0] = 'H'`）で変更可能ですが、すべての文字列メソッドは元を変更せず新しい文字列を返します。これにより、必要な場合のインプレース変更を可能にしながら、メソッドチェーンを関数型に保ちます。

**文字列長プロパティ：**
```hemlock
let s = "hello 🚀";
print(s.length);       // 7（文字/rune数）
print(s.byte_length);  // 10（バイト数 - 絵文字はUTF-8で4バイト）
```

## 配列メソッド（18個）

`push`、`pop`、`shift`、`unshift`、`insert`、`remove`、`find`、`contains`、
`slice`、`join`、`concat`、`reverse`、`first`、`last`、`clear`、`map`、`filter`、`reduce`

型付き配列：`let nums: array<i32> = [1, 2, 3];`

---

## 標準ライブラリ（40モジュール）

`@stdlib/`プレフィックスでインポート：
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| モジュール | 説明 |
|--------|-------------|
| `arena` | アリーナメモリアロケータ（バンプアロケーション） |
| `args` | コマンドライン引数パース |
| `assert` | アサーションユーティリティ |
| `async` | ThreadPool、parallel_map |
| `async_fs` | 非同期ファイルI/O操作 |
| `collections` | HashMap、Queue、Stack、Set、LinkedList、LRUCache |
| `compression` | gzip、gunzip、deflate |
| `crypto` | aes_encrypt、rsa_sign、random_bytes |
| `csv` | CSVパースと生成 |
| `datetime` | DateTimeクラス、フォーマット、パース |
| `encoding` | base64_encode、hex_encode、url_encode |
| `env` | getenv、setenv、exit、get_pid |
| `fmt` | 文字列フォーマットユーティリティ |
| `fs` | read_file、write_file、list_dir、exists |
| `glob` | ファイルパターンマッチング |
| `hash` | sha256、sha512、md5、djb2 |
| `http` | http_get、http_post、http_request |
| `ipc` | プロセス間通信 |
| `iter` | イテレータユーティリティ |
| `json` | parse、stringify、pretty、get、set |
| `logging` | レベル付きLogger |
| `math` | sin、cos、sqrt、pow、rand、PI、E |
| `net` | TcpListener、TcpStream、UdpSocket |
| `os` | platform、arch、cpu_count、hostname |
| `path` | ファイルパス操作 |
| `process` | fork、exec、wait、kill |
| `random` | 乱数生成 |
| `regex` | compile、test（POSIX ERE） |
| `retry` | バックオフ付きリトライロジック |
| `semver` | セマンティックバージョニング |
| `shell` | シェルコマンドユーティリティ |
| `sqlite` | SQLiteデータベース、query、exec、トランザクション |
| `strings` | pad_left、is_alpha、reverse、lines |
| `terminal` | ANSIカラーとスタイル |
| `testing` | describe、test、expect |
| `time` | now、time_ms、sleep、clock |
| `toml` | TOMLパースと生成 |
| `url` | URLパースと操作 |
| `uuid` | UUID生成 |
| `websocket` | WebSocketクライアント |

詳細なモジュールドキュメントについては`stdlib/docs/`を参照してください。

---

## FFI（外部関数インターフェース）

共有ライブラリからC関数を宣言して呼び出し：
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Hello!");  // 6
let pid = getpid();
```

モジュールからFFI関数をエクスポート：
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

動的FFI（実行時バインディング）：
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Hello from C!");
ffi_close(lib);
```

型：`FFI_INT`、`FFI_DOUBLE`、`FFI_POINTER`、`FFI_STRING`、`FFI_VOID`など

---

## アトミック操作

アトミック操作によるロックフリー並行プログラミング：

```hemlock
// アトミックi32用のメモリを確保
let p = alloc(4);
ptr_write_i32(p, 0);

// アトミックload/store
let val = atomic_load_i32(p);        // アトミックに読み取り
atomic_store_i32(p, 42);             // アトミックに書き込み

// fetch-and-modify操作（古い値を返す）
let old = atomic_add_i32(p, 10);     // 加算、古い値を返す
old = atomic_sub_i32(p, 5);          // 減算、古い値を返す
old = atomic_and_i32(p, 0xFF);       // ビット単位AND
old = atomic_or_i32(p, 0x10);        // ビット単位OR
old = atomic_xor_i32(p, 0x0F);       // ビット単位XOR

// Compare-and-swap（CAS）
let success = atomic_cas_i32(p, 42, 100);  // *p == 42なら100に設定
// スワップが成功したらtrue、そうでなければfalseを返す

// アトミック交換
old = atomic_exchange_i32(p, 999);   // スワップ、古い値を返す

free(p);

// i64バリアントも使用可能（atomic_load_i64、atomic_add_i64など）

// メモリフェンス（フルバリア）
atomic_fence();
```

すべての操作はシーケンシャル一貫性（`memory_order_seq_cst`）を使用します。

---

## プロジェクト構造

```
hemlock/
├── src/
│   ├── frontend/         # 共有：lexer、parser、AST、modules
│   ├── backends/
│   │   ├── interpreter/  # hemlock：ツリーウォーキングインタプリタ
│   │   └── compiler/     # hemlockc：Cコードジェネレータ
│   ├── tools/
│   │   ├── lsp/          # Language Server Protocol
│   │   └── bundler/      # バンドル/パッケージツール
├── runtime/              # コンパイル済みプログラムランタイム（libhemlock_runtime.a）
├── stdlib/               # 標準ライブラリ（40モジュール）
│   └── docs/             # モジュールドキュメント
├── docs/                 # 完全なドキュメント
│   ├── language-guide/   # 型、文字列、配列など
│   ├── reference/        # APIリファレンス
│   └── advanced/         # 非同期、FFI、シグナルなど
├── tests/                # 625+テスト
└── examples/             # サンプルプログラム
```

---

## コードスタイルガイドライン

### 定数とマジックナンバー

Cコードベースに数値定数を追加する際は、以下のガイドラインに従ってください：

1. **`include/hemlock_limits.h`に定数を定義** - このファイルは、すべてのコンパイル時および実行時の制限、容量、名前付き定数の中心的な場所です。

2. **`HML_`プレフィックスを持つ説明的な名前を使用** - すべての定数は名前空間の明確さのために`HML_`プレフィックスを付ける必要があります。

3. **マジックナンバーを避ける** - ハードコードされた数値をnamed定数に置き換えてください。例：
   - 型範囲制限：`HML_I8_MIN`、`HML_I8_MAX`、`HML_U32_MAX`
   - バッファ容量：`HML_INITIAL_ARRAY_CAPACITY`、`HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - 時間変換：`HML_NANOSECONDS_PER_SECOND`、`HML_MILLISECONDS_PER_SECOND`
   - ハッシュシード：`HML_DJB2_HASH_SEED`
   - ASCII値：`HML_ASCII_CASE_OFFSET`、`HML_ASCII_PRINTABLE_START`

4. **`hemlock_limits.h`をインクルード** - ソースファイルは定数にアクセスするためにこのヘッダー（多くの場合`internal.h`経由）をインクルードする必要があります。

5. **目的を文書化** - 各定数が何を表すかを説明するコメントを追加してください。

---

## やってはいけないこと

❌ 暗黙の動作を追加（ASI、GC、自動クリーンアップ）
❌ 複雑さを隠す（マジック最適化、隠れた参照カウント）
❌ 既存のセマンティクスを破壊（セミコロン、手動メモリ、可変文字列）
❌ 暗黙の変換で精度を失う
❌ マジックナンバーを使用 - 代わりに`hemlock_limits.h`にnamed定数を定義

---

## テスト

```bash
make test              # インタプリタテストを実行
make test-compiler     # コンパイラテストを実行
make parity            # パリティテストを実行（両方が一致する必要がある）
make test-all          # すべてのテストスイートを実行
```

**重要：** 非同期/並行処理の問題によりテストがハングすることがあります。テスト実行時は常にタイムアウトを使用してください：
```bash
timeout 60 make test   # 60秒タイムアウト
timeout 120 make parity
```

テストカテゴリ：primitives、memory、strings、arrays、functions、objects、async、ffi、defer、signals、switch、bitwise、typed_arrays、modules、stdlib_*

---

## コンパイラ/インタプリタアーキテクチャ

Hemlockには共通のフロントエンドを共有する2つの実行バックエンドがあります：

```
ソース（.hml）
    ↓
┌─────────────────────────────┐
│  共有フロントエンド           │
│  - Lexer（src/frontend/）    │
│  - Parser（src/frontend/）   │
│  - AST（src/frontend/）      │
└─────────────────────────────┘
    ↓                    ↓
┌────────────┐    ┌────────────┐
│ インタプリタ │    │  コンパイラ │
│ (hemlock)  │    │ (hemlockc) │
│            │    │            │
│ ツリーウォー│    │ 型チェック  │
│ ク評価     │    │ AST → C    │
│            │    │ gccリンク  │
└────────────┘    └────────────┘
```

### コンパイラ型チェック

コンパイラ（`hemlockc`）にはコンパイル時型チェックが含まれており、**デフォルトで有効**です：

```bash
hemlockc program.hml -o program    # 型チェック後、コンパイル
hemlockc --check program.hml       # 型チェックのみ、コンパイルしない
hemlockc --no-type-check prog.hml  # 型チェックを無効化
hemlockc --strict-types prog.hml   # 暗黙の'any'型に警告
```

型チェッカーは：
- コンパイル時に型注釈を検証
- 型注釈のないコードを動的（`any`型）として扱う - 常に有効
- アンボックス化のための最適化ヒントを提供
- 許容的な数値変換を使用（範囲は実行時に検証）

### ディレクトリ構造

```
hemlock/
├── src/
│   ├── frontend/           # 共有：lexer、parser、AST、modules
│   │   ├── lexer.c
│   │   ├── parser/
│   │   ├── ast.c
│   │   └── module.c
│   ├── backends/
│   │   ├── interpreter/    # hemlock：ツリーウォーキングインタプリタ
│   │   │   ├── main.c
│   │   │   ├── runtime/
│   │   │   └── builtins/
│   │   └── compiler/       # hemlockc：Cコードジェネレータ
│   │       ├── main.c
│   │       └── codegen/
│   ├── tools/
│   │   ├── lsp/            # 言語サーバー
│   │   └── bundler/        # バンドル/パッケージツール
├── runtime/                # コンパイル済みプログラム用libhemlock_runtime.a
├── stdlib/                 # 共有標準ライブラリ
└── tests/
    ├── parity/             # 両方のバックエンドでパスする必要があるテスト
    ├── interpreter/        # インタプリタ固有のテスト
    └── compiler/           # コンパイラ固有のテスト
```

---

## パリティファースト開発

**インタプリタとコンパイラは、同じ入力に対して同一の出力を生成する必要があります。**

### 開発ポリシー

言語機能を追加または変更する際：

1. **設計** - 共有フロントエンドでAST/セマンティック変更を定義
2. **インタプリタ実装** - ツリーウォーキング評価を追加
3. **コンパイラ実装** - Cコード生成を追加
4. **パリティテスト追加** - `tests/parity/`に`.expected`ファイル付きでテストを記述
5. **検証** - マージ前に`make parity`を実行

### パリティテスト構造

```
tests/parity/
├── language/       # コア言語機能（制御フロー、クロージャなど）
├── builtins/       # 組み込み関数（print、typeof、memoryなど）
├── methods/        # 文字列と配列メソッド
└── modules/        # import/export、stdlibインポート
```

各テストには2つのファイルがあります：
- `feature.hml` - テストプログラム
- `feature.expected` - 期待される出力（両方のバックエンドで一致する必要がある）

### パリティテスト結果

| ステータス | 意味 |
|--------|---------|
| `✓ PASSED` | インタプリタとコンパイラの両方が期待される出力と一致 |
| `◐ INTERP_ONLY` | インタプリタは動作、コンパイラは失敗（コンパイラ修正が必要） |
| `◑ COMPILER_ONLY` | コンパイラは動作、インタプリタは失敗（まれ） |
| `✗ FAILED` | 両方失敗（テストまたは実装のバグ） |

### パリティが必要なもの

- すべての言語構造（if、while、for、switch、defer、try/catch）
- すべての演算子（算術、ビット単位、論理、比較）
- すべての組み込み関数（print、typeof、allocなど）
- すべての文字列と配列メソッド
- 型強制と昇格ルール
- 実行時エラーのエラーメッセージ

### 異なっても良いもの

- パフォーマンス特性
- メモリレイアウトの詳細
- デバッグ/スタックトレースのフォーマット
- コンパイルエラー（コンパイラはコンパイル時により多くをキャッチする可能性がある）

### パリティテストの追加

```bash
# 1. テストファイルを作成
cat > tests/parity/language/my_feature.hml << 'EOF'
// テストの説明
let x = some_feature();
print(x);
EOF

# 2. インタプリタから期待される出力を生成
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. パリティを検証
make parity
```

---

## バージョン

**v1.8.0** - 以下を含む現在のリリース：
- **パターンマッチング**（`match`式）- 強力な分解と制御フロー：
  - リテラル、ワイルドカード、変数バインディングパターン
  - ORパターン（`1 | 2 | 3`）
  - ガード式（`n if n > 0`）
  - オブジェクト分解（`{ x, y }`）
  - restを使った配列分解（`[first, ...rest]`）
  - 型パターン（`n: i32`）
  - インタプリタとコンパイラ間の完全なパリティ
- **コンパイラヘルパー注釈** - GCC/Clang制御用の11の最適化注釈：
  - `@inline`、`@noinline` - 関数インライン化制御
  - `@hot`、`@cold` - 分岐予測ヒント
  - `@pure`、`@const` - 副作用注釈
  - `@flatten` - 関数内のすべての呼び出しをインライン化
  - `@optimize(level)` - 関数ごとの最適化レベル（"0"、"1"、"2"、"3"、"s"、"fast"）
  - `@warn_unused` - 戻り値が無視された場合に警告
  - `@section(name)` - カスタムELFセクション配置（例：`@section(".text.hot")`）
- **式本体関数**（`fn double(x): i32 => x * 2;`）- 簡潔な単一式関数構文
- **単一行文** - ブレースなし`if`、`while`、`for`構文（例：`if (x > 0) print(x);`）
- **型エイリアス**（`type Name = Type;`）- 複雑な型のnamed ショートカット
- **関数型注釈**（`fn(i32): i32`）- ファーストクラス関数型
- **Constパラメータ**（`fn(const x: array)`）- パラメータの深い不変性
- **Refパラメータ**（`fn(ref x: i32)`）- 直接呼び出し元変更用の参照渡し
- **defineでのメソッドシグネチャ**（`fn method(): Type`）- インターフェースのような契約（カンマ区切り）
- メソッドシグネチャでの**Self型** - 定義型を参照
- **Loopキーワード**（`loop { }`）- よりクリーンな無限ループ、`while (true)`を置き換え
- **ループラベル**（`outer: while`）- ネストされたループでの対象指定break/continue
- **オブジェクトショートハンド**（`{ name }`）- ES6スタイルのショートハンドプロパティ構文
- **オブジェクトスプレッド**（`{ ...obj }`）- オブジェクトフィールドのコピーとマージ
- **複合ダック型**（`A & B & C`）- 構造型のための交差型
- 関数呼び出しの**名前付き引数**（`foo(name: "value", age: 30)`）
- 安全なnullハンドリングのための**Null合体演算子**（`??`、`??=`、`?.`）
- **8進リテラル**（`0o777`、`0O123`）
- **数値セパレータ**（`1_000_000`、`0xFF_FF`、`0b1111_0000`）
- **ブロックコメント**（`/* ... */`）
- 文字列/runeでの**16進エスケープシーケンス**（`\x41` = 'A'）
- 文字列での**Unicodeエスケープシーケンス**（`\u{1F600}` = 😀）
- **先頭ゼロなしのfloatリテラル**（`.5`、`.123`、`.5e2`）
- hemlockc での**コンパイル時型チェック**（デフォルトで有効）
- リアルタイム診断用の型チェック付き**LSP統合**
- **複合代入演算子**（`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`）
- **インクリメント/デクリメント演算子**（`++x`、`x++`、`--x`、`x--`）
- **型精度修正**：i64/u64 + f32 → f64で精度を保持
- アンボックス化最適化ヒント付き統一型システム
- 完全な型システム（i8-i64、u8-u64、f32/f64、bool、string、rune、ptr、buffer、array、object、enum、file、task、channel）
- 19メソッド付きUTF-8文字列
- map/filter/reduceを含む18メソッド付き配列
- `talloc()`と`sizeof()`を使った手動メモリ管理
- 真のpthread並列処理を持つAsync/await
- ロックフリー並行プログラミング用アトミック操作
- 40 stdlibモジュール（+ arena、assert、semver、toml、retry、iter、random、shell）
- 再利用可能なライブラリラッパー用の`export extern fn`を持つCインターオペ用FFI
- コンパイラでのFFI構造体サポート（C構造体を値渡し）
- FFIポインタヘルパー（`ptr_null`、`ptr_read_*`、`ptr_write_*`）
- defer、try/catch/finally/throw、panic
- ファイルI/O、シグナルハンドリング、コマンド実行
- GitHubベースのレジストリを持つ[hpm](https://github.com/hemlang/hpm)パッケージマネージャ
- 100%インタプリタパリティを持つコンパイラバックエンド（Cコード生成）
- go-to-definitionとfind-referencesを持つLSPサーバー
- O(1)ルックアップのためのAST最適化パスと変数解決
- 動的関数呼び出し用apply()ビルトイン
- アンバッファードチャネルと多パラメータサポート
- 159パリティテスト（100%パス率）

---

## 哲学

> 私たちは安全であるためのツール（`buffer`、型注釈、境界チェック）を提供しますが、それらを使用することを強制しません（`ptr`、手動メモリ、安全でない操作）。

**機能がHemlockに適合するかどうかわからない場合は、「これはプログラマにより明示的な制御を与えるか、それとも何かを隠すか？」と問いかけてください。**

隠す場合、それはおそらくHemlockには属しません。



################################################################################
# はじめに
################################################################################

--------------------------------------------------------------------------------
## インストール
--------------------------------------------------------------------------------

# インストール

このガイドでは、お使いのシステムにHemlockをビルドしてインストールする方法を説明します。

## クイックインストール（推奨）

Hemlockをインストールする最も簡単な方法は、ワンライナーインストールスクリプトを使用することです：

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash
```

これにより、お使いのプラットフォーム（LinuxまたはmacOS、x86_64またはarm64）向けの最新のビルド済みバイナリがダウンロードおよびインストールされます。

### インストールオプション

```bash
# カスタムプレフィックスにインストール（デフォルト：~/.local）
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local

# 特定のバージョンをインストール
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0

# シェルのPATHを自動的に更新してインストール
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path
```

インストール後、動作を確認します：

```bash
hemlock --version
```

---

## ソースからのビルド

ビルド済みバイナリがお使いのシステムで動作しない場合、またはソースからビルドしたい場合は、以下の手順に従ってください。

## 前提条件

### 必要な依存関係

Hemlockのビルドには以下の依存関係が必要です：

- **Cコンパイラ**: GCCまたはClang（C11標準）
- **Make**: GNU Make
- **libffi**: 外部関数インターフェースライブラリ（FFIサポート用）
- **OpenSSL**: 暗号化ライブラリ（ハッシュ関数用：md5、sha1、sha256）
- **libwebsockets**: WebSocketおよびHTTPクライアント/サーバーサポート
- **zlib**: 圧縮ライブラリ

### 依存関係のインストール

**macOS:**
```bash
# Homebrewがまだインストールされていない場合はインストール
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Xcode Command Line Toolsをインストール
xcode-select --install

# Homebrew経由で依存関係をインストール
brew install libffi openssl@3 libwebsockets
```

**macOSユーザーへの注意**: MakefileはHomebrewのインストールを自動的に検出し、正しいinclude/ライブラリパスを設定します。HemlockはIntel（x86_64）とApple Silicon（arm64）の両方のアーキテクチャをサポートしています。

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev
```

**Fedora/RHEL:**
```bash
sudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel
```

**Arch Linux:**
```bash
sudo pacman -S base-devel libffi openssl libwebsockets zlib
```

## ソースからのビルド

### 1. リポジトリをクローン

```bash
git clone https://github.com/hemlang/hemlock.git
cd hemlock
```

### 2. Hemlockをビルド

```bash
make
```

これによりHemlockインタプリタがコンパイルされ、実行ファイルがカレントディレクトリに配置されます。

### 3. インストールの確認

```bash
./hemlock --version
```

Hemlockのバージョン情報が表示されるはずです。

### 4. ビルドのテスト

すべてが正しく動作することを確認するためにテストスイートを実行します：

```bash
make test
```

すべてのテストがパスするはずです。失敗がある場合は、issueとして報告してください。

## システム全体へのインストール（オプション）

Hemlockをシステム全体（例：`/usr/local/bin`）にインストールするには：

```bash
sudo make install
```

これにより、フルパスを指定せずにどこからでも`hemlock`を実行できるようになります。

## Hemlockの実行

### インタラクティブREPL

Read-Eval-Print Loopを開始します：

```bash
./hemlock
```

プロンプトが表示され、Hemlockコードを入力できます：

```
Hemlock REPL
> print("Hello, World!");
Hello, World!
> let x = 42;
> print(x * 2);
84
>
```

REPLを終了するには`Ctrl+D`または`Ctrl+C`を使用します。

### プログラムの実行

Hemlockスクリプトを実行：

```bash
./hemlock program.hml
```

コマンドライン引数付きで実行：

```bash
./hemlock program.hml arg1 arg2 "argument with spaces"
```

## ディレクトリ構造

ビルド後のHemlockディレクトリは次のようになります：

```
hemlock/
├── hemlock           # コンパイル済みインタプリタ実行ファイル
├── src/              # ソースコード
├── include/          # ヘッダーファイル
├── tests/            # テストスイート
├── examples/         # サンプルプログラム
├── docs/             # ドキュメント
├── stdlib/           # 標準ライブラリ
├── Makefile          # ビルド設定
└── README.md         # プロジェクトREADME
```

## ビルドオプション

### デバッグビルド

デバッグシンボル付きで最適化なしでビルド：

```bash
make debug
```

### クリーンビルド

すべてのコンパイル済みファイルを削除：

```bash
make clean
```

スクラッチから再ビルド：

```bash
make clean && make
```

## トラブルシューティング

### macOS: ライブラリが見つからないエラー

ライブラリが見つからないエラー（`-lcrypto`、`-lffi`など）が発生した場合：

1. Homebrewの依存関係がインストールされていることを確認：
   ```bash
   brew install libffi openssl@3 libwebsockets
   ```

2. Homebrewのパスを確認：
   ```bash
   brew --prefix libffi
   brew --prefix openssl
   ```

3. Makefileはこれらのパスを自動検出するはずです。検出されない場合は、`brew`がPATHにあることを確認：
   ```bash
   which brew
   ```

### macOS: BSD型エラー（`u_int`、`u_char`が見つからない）

`u_int`や`u_char`のような不明な型名に関するエラーが表示された場合：

1. これはv1.0.0以降で`_POSIX_C_SOURCE`の代わりに`_DARWIN_C_SOURCE`を使用することで修正されています
2. 最新バージョンのコードを使用していることを確認
3. クリーンして再ビルド：
   ```bash
   make clean && make
   ```

### Linux: libffiが見つからない

`ffi.h`や`-lffi`が見つからないエラーが発生した場合：

1. `libffi-dev`がインストールされていることを確認（上記の依存関係を参照）
2. `pkg-config`で見つけられるか確認：
   ```bash
   pkg-config --cflags --libs libffi
   ```
3. 見つからない場合は、`PKG_CONFIG_PATH`を設定する必要があるかもしれません：
   ```bash
   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
   ```

### コンパイルエラー

コンパイルエラーが発生した場合：

1. C11互換のコンパイラがあることを確認
2. macOSでは、Clang（デフォルト）を使用してみてください：
   ```bash
   make CC=clang
   ```
3. Linuxでは、GCCを使用してみてください：
   ```bash
   make CC=gcc
   ```
4. すべての依存関係がインストールされていることを確認
5. スクラッチから再ビルドを試してください：
   ```bash
   make clean && make
   ```

### テストの失敗

テストが失敗した場合：

1. 最新バージョンのコードを使用していることを確認
2. スクラッチから再ビルドを試してください：
   ```bash
   make clean && make test
   ```
3. macOSでは、最新のXcode Command Line Toolsがあることを確認：
   ```bash
   xcode-select --install
   ```
4. GitHubで以下の情報を含めてissueを報告してください：
   - お使いのプラットフォーム（macOSバージョン / Linuxディストリビューション）
   - アーキテクチャ（x86_64 / arm64）
   - テスト出力
   - `make -v`と`gcc --version`（または`clang --version`）の出力

## 次のステップ

- [クイックスタートガイド](#getting-started-quick-start) - 最初のHemlockプログラムを書く
- [チュートリアル](#getting-started-tutorial) - ステップバイステップでHemlockを学ぶ
- [言語ガイド](#language-guide-syntax) - Hemlockの機能を探索


--------------------------------------------------------------------------------
## クイックスタート
--------------------------------------------------------------------------------

# クイックスタート

数分でHemlockを使い始めましょう！

## 最初のプログラム

`hello.hml`というファイルを作成します：

```hemlock
print("Hello, Hemlock!");
```

インタプリタで実行：

```bash
./hemlock hello.hml
```

またはネイティブ実行ファイルにコンパイル：

```bash
./hemlockc hello.hml -o hello
./hello
```

出力：
```
Hello, Hemlock!
```

### インタプリタ vs コンパイラ

Hemlockにはプログラムを実行する2つの方法があります：

| ツール | ユースケース | 型チェック |
|------|----------|---------------|
| `hemlock` | クイックスクリプト、REPL、開発 | 実行時のみ |
| `hemlockc` | 本番バイナリ、より良いパフォーマンス | コンパイル時（デフォルト） |

コンパイラ（`hemlockc`）は実行ファイルを生成する前にコードの型チェックを行い、エラーを早期に発見します。

## 基本構文

### 変数

```hemlock
// 変数は'let'で宣言
let x = 42;
let name = "Alice";
let pi = 3.14159;

// 型注釈はオプション
let count: i32 = 100;
let ratio: f64 = 0.618;
```

**重要**: Hemlockではセミコロンは**必須**です！

### 型

Hemlockには豊富な型システムがあります：

```hemlock
// 整数
let small: i8 = 127;          // 8ビット符号付き
let byte: u8 = 255;           // 8ビット符号なし
let num: i32 = 2147483647;    // 32ビット符号付き（デフォルト）
let big: i64 = 9223372036854775807;  // 64ビット符号付き

// 浮動小数点
let f: f32 = 3.14;            // 32ビット浮動小数点
let d: f64 = 2.71828;         // 64ビット浮動小数点（デフォルト）

// 文字列と文字
let text: string = "Hello";   // UTF-8文字列
let emoji: rune = '🚀';       // Unicodeコードポイント

// 真偽値とnull
let flag: bool = true;
let empty = null;
```

### 制御フロー

```hemlock
// if文
if (x > 0) {
    print("positive");
} else if (x < 0) {
    print("negative");
} else {
    print("zero");
}

// whileループ
let i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}

// forループ
for (let j = 0; j < 10; j = j + 1) {
    print(j);
}
```

### 関数

```hemlock
// 名前付き関数
fn add(a: i32, b: i32): i32 {
    return a + b;
}

let result = add(5, 3);  // 8

// 匿名関数
let multiply = fn(x, y) {
    return x * y;
};

print(multiply(4, 7));  // 28
```

## 文字列の操作

Hemlockの文字列は**ミュータブル**で**UTF-8**です：

```hemlock
let s = "hello";
s[0] = 'H';              // "Hello"になる
print(s);

// 文字列メソッド
let upper = s.to_upper();     // "HELLO"
let words = "a,b,c".split(","); // ["a", "b", "c"]
let sub = s.substr(1, 3);     // "ell"

// 連結
let greeting = "Hello" + ", " + "World!";
print(greeting);  // "Hello, World!"
```

## 配列

混合型の動的配列：

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// 配列メソッド
numbers.push(6);        // [1, 2, 3, 4, 5, 6]
let last = numbers.pop();  // 6
let slice = numbers.slice(1, 4);  // [2, 3, 4]

// 混合型も可能
let mixed = [1, "two", true, null];
```

## オブジェクト

JavaScriptスタイルのオブジェクト：

```hemlock
// オブジェクトリテラル
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
person.age = 31;     // フィールドを変更

// 'self'を使ったメソッド
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## メモリ管理

Hemlockは**手動メモリ管理**を使用します：

```hemlock
// 安全なバッファ（推奨）
let buf = buffer(64);   // 64バイトを確保
buf[0] = 65;            // 最初のバイトを'A'に設定
print(buf[0]);          // 65
free(buf);              // メモリを解放

// 生ポインタ（上級者向け）
let ptr = alloc(100);
memset(ptr, 0, 100);    // ゼロで埋める
free(ptr);
```

**重要**: `alloc()`したものは`free()`する必要があります！

## エラーハンドリング

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Error: " + e);
} finally {
    print("Done");
}
```

## コマンドライン引数

`args`配列経由でプログラム引数にアクセス：

```hemlock
// script.hml
print("Script:", args[0]);
print(`Arguments: ${args.length - 1}`);

let i = 1;
while (i < args.length) {
    print(`  arg ${i}: ${args[i]}`);
    i = i + 1;
}
```

実行：
```bash
./hemlock script.hml hello world
```

出力：
```
Script: script.hml
Arguments: 2
  arg 1: hello
  arg 2: world
```

## ファイルI/O

```hemlock
// ファイルへ書き込み
let f = open("data.txt", "w");
f.write("Hello, File!");
f.close();

// ファイルから読み込み
let f2 = open("data.txt", "r");
let content = f2.read();
print(content);  // "Hello, File!"
f2.close();
```

## 次のステップ

基本を学んだので、さらに探索しましょう：

- [チュートリアル](#getting-started-tutorial) - 包括的なステップバイステップガイド
- [言語ガイド](#language-guide-syntax) - すべての機能の詳細
- [サンプル](../../examples/) - 実世界のサンプルプログラム
- [APIリファレンス](#reference-builtins) - 完全なAPIドキュメント

## よくある落とし穴

### セミコロンの忘れ

```hemlock
// ❌ エラー：セミコロンがない
let x = 42
let y = 10

// ✅ 正しい
let x = 42;
let y = 10;
```

### メモリ解放の忘れ

```hemlock
// ❌ メモリリーク
let buf = buffer(100);
// ... bufを使用 ...
// free(buf)を呼び忘れ！

// ✅ 正しい
let buf = buffer(100);
// ... bufを使用 ...
free(buf);
```

### ブレースは必須

```hemlock
// ❌ エラー：ブレースがない
if (x > 0)
    print("positive");

// ✅ 正しい
if (x > 0) {
    print("positive");
}
```

## ヘルプを得る

- [完全なドキュメント](../README.md)を読む
- [サンプルディレクトリ](../../examples/)を確認
- 使用パターンについては[テストファイル](../../tests/)を参照
- GitHubでissueを報告


--------------------------------------------------------------------------------
## チュートリアル
--------------------------------------------------------------------------------

# Hemlockチュートリアル

Hemlockを学ぶための包括的なステップバイステップガイドです。

## 目次

1. [Hello World](#hello-world)
2. [変数と型](#変数と型)
3. [算術と演算](#算術と演算)
4. [制御フロー](#制御フロー)
5. [関数](#関数)
6. [文字列とRune](#文字列とrune)
7. [配列](#配列)
8. [オブジェクト](#オブジェクト)
9. [メモリ管理](#メモリ管理)
10. [エラーハンドリング](#エラーハンドリング)
11. [ファイルI/O](#ファイルio)
12. [まとめ](#まとめ)

## Hello World

伝統的な最初のプログラムから始めましょう：

```hemlock
print("Hello, World!");
```

これを`hello.hml`として保存し、実行します：

```bash
./hemlock hello.hml
```

**ポイント：**
- `print()`はstdoutに出力する組み込み関数
- 文字列はダブルクォートで囲む
- セミコロンは**必須**

## 変数と型

### 変数の宣言

```hemlock
// 基本的な変数宣言
let x = 42;
let name = "Alice";
let pi = 3.14159;

print(x);      // 42
print(name);   // Alice
print(pi);     // 3.14159
```

### 型注釈

型はデフォルトで推論されますが、明示的にも指定できます：

```hemlock
let age: i32 = 30;
let height: f64 = 5.9;
let initial: rune = 'A';
let active: bool = true;
```

### 型推論

Hemlockは値に基づいて型を推論します：

```hemlock
let small = 42;              // i32（32ビットに収まる）
let large = 5000000000;      // i64（i32には大きすぎる）
let decimal = 3.14;          // f64（浮動小数点のデフォルト）
let text = "hello";          // string
let flag = true;             // bool
```

### 型チェック

```hemlock
// typeof()で型をチェック
print(typeof(42));        // "i32"
print(typeof(3.14));      // "f64"
print(typeof("hello"));   // "string"
print(typeof(true));      // "bool"
print(typeof(null));      // "null"
```

## 算術と演算

### 基本的な算術

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13
print(a - b);   // 7
print(a * b);   // 30
print(a / b);   // 3（整数除算）
print(a == b);  // false
print(a > b);   // true
```

### 型昇格

型を混合すると、Hemlockはより大きい/より精度の高い型に昇格します：

```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // resultはf64（10.0 + 3.5 = 13.5）

print(result);       // 13.5
print(typeof(result)); // "f64"
```

### ビット演算

```hemlock
let a = 12;  // 2進数で1100
let b = 10;  // 2進数で1010

print(a & b);   // 8  (AND)
print(a | b);   // 14 (OR)
print(a ^ b);   // 6  (XOR)
print(a << 1);  // 24（左シフト）
print(a >> 1);  // 6 （右シフト）
print(~a);      // -13 (NOT)
```

## 制御フロー

### if文

```hemlock
let x = 10;

if (x > 0) {
    print("positive");
} else if (x < 0) {
    print("negative");
} else {
    print("zero");
}
```

**注意：** 単一の文でもブレースは**常に必須**です。

### whileループ

```hemlock
let count = 0;
while (count < 5) {
    print(`Count: ${count}`);
    count = count + 1;
}
```

### forループ

```hemlock
// Cスタイルのforループ
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

// for-inループ（配列）
let items = [10, 20, 30, 40];
for (let item in items) {
    print(`Item: ${item}`);
}
```

### switch文

```hemlock
let day = 3;

switch (day) {
    case 1:
        print("Monday");
        break;
    case 2:
        print("Tuesday");
        break;
    case 3:
        print("Wednesday");
        break;
    default:
        print("Other day");
        break;
}
```

### breakとcontinue

```hemlock
// break：ループを早期終了
let i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// 出力：0, 1, 2, 3, 4

// continue：次のイテレーションにスキップ
for (let j = 0; j < 5; j = j + 1) {
    if (j == 2) {
        continue;
    }
    print(j);
}
// 出力：0, 1, 3, 4
```

## 関数

### 名前付き関数

```hemlock
fn greet(name: string): string {
    return "Hello, " + name + "!";
}

let message = greet("Alice");
print(message);  // "Hello, Alice!"
```

### 匿名関数

```hemlock
let add = fn(a, b) {
    return a + b;
};

print(add(5, 3));  // 8
```

### 再帰

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### クロージャ

関数は環境をキャプチャします：

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

### 高階関数

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 21);
print(result);  // 42
```

## 文字列とRune

### 文字列の基本

文字列は**ミュータブル**で**UTF-8**です：

```hemlock
let s = "hello";
print(s.length);      // 5（文字数）
print(s.byte_length); // 5（バイト数）

// ミューテーション
s[0] = 'H';
print(s);  // "Hello"
```

### 文字列メソッド

```hemlock
let text = "  Hello, World!  ";

// 大文字小文字変換
print(text.to_upper());  // "  HELLO, WORLD!  "
print(text.to_lower());  // "  hello, world!  "

// トリミング
print(text.trim());      // "Hello, World!"

// 部分文字列抽出
let hello = text.substr(2, 5);  // "Hello"
let world = text.slice(9, 14);  // "World"

// 検索
let pos = text.find("World");   // 9
let has = text.contains("o");   // true

// 分割
let parts = "a,b,c".split(","); // ["a", "b", "c"]

// 置換
let s = "hello world".replace("world", "there");
print(s);  // "hello there"
```

### Rune（Unicodeコードポイント）

```hemlock
let ch: rune = 'A';
let emoji: rune = '🚀';

print(ch);      // 'A'
print(emoji);   // U+1F680

// Rune + 文字列の連結
let msg = '>' + " Important";
print(msg);  // "> Important"

// runeと整数間の変換
let code: i32 = ch;     // 65（ASCIIコード）
let r: rune = 128640;   // U+1F680（🚀）
```

## 配列

### 配列の基本

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// 要素を変更
numbers[2] = 99;
print(numbers[2]);  // 99
```

### 配列メソッド

```hemlock
let arr = [10, 20, 30];

// 末尾に追加/削除
arr.push(40);           // [10, 20, 30, 40]
let last = arr.pop();   // 40、arrは[10, 20, 30]になる

// 先頭に追加/削除
arr.unshift(5);         // [5, 10, 20, 30]
let first = arr.shift(); // 5、arrは[10, 20, 30]になる

// インデックスで挿入/削除
arr.insert(1, 15);      // [10, 15, 20, 30]
let removed = arr.remove(2);  // 20

// 検索
let index = arr.find(15);     // 1
let has = arr.contains(10);   // true

// スライス
let slice = arr.slice(0, 2);  // [10, 15]

// 文字列に結合
let text = arr.join(", ");    // "10, 15, 30"
```

### イテレーション

```hemlock
let items = ["apple", "banana", "cherry"];

// for-inループ
for (let item in items) {
    print(item);
}

// 手動イテレーション
let i = 0;
while (i < items.length) {
    print(items[i]);
    i = i + 1;
}
```

## オブジェクト

### オブジェクトリテラル

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
print(person.age);   // 30

// フィールドの追加/変更
person.email = "alice@example.com";
person.age = 31;
```

### メソッドと`self`

```hemlock
let calculator = {
    value: 0,
    add: fn(x) {
        self.value = self.value + x;
    },
    get: fn() {
        return self.value;
    }
};

calculator.add(10);
calculator.add(5);
print(calculator.get());  // 15
```

### 型定義（ダック型）

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,  // デフォルト付きオプション
}

let p = { name: "Bob", age: 25 };
let typed: Person = p;  // ダック型が構造を検証

print(typeof(typed));   // "Person"
print(typed.active);    // true（デフォルトが適用）
```

### JSONシリアライゼーション

```hemlock
let obj = { x: 10, y: 20, name: "test" };

// オブジェクトからJSON
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// JSONからオブジェクト
let restored = json.deserialize();
print(restored.name);  // "test"
```

## メモリ管理

### 安全なバッファ（推奨）

```hemlock
// バッファを確保
let buf = buffer(10);
print(buf.length);    // 10
print(buf.capacity);  // 10

// 値を設定（境界チェック付き）
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// 値にアクセス
print(buf[0]);  // 65

// 完了時に解放必須
free(buf);
```

### 生ポインタ（上級者向け）

```hemlock
// 生メモリを確保
let ptr = alloc(100);

// ゼロで埋める
memset(ptr, 0, 100);

// データをコピー
let src = alloc(50);
memcpy(ptr, src, 50);

// 両方を解放
free(src);
free(ptr);
```

### メモリ関数

```hemlock
// 再確保
let p = alloc(64);
p = realloc(p, 128);  // 128バイトにリサイズ
free(p);

// 型付き確保（将来）
// let arr = talloc(i32, 100);  // 100個のi32の配列
```

## エラーハンドリング

### try/catch

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Error: " + e);
}
// 出力：Error: division by zero
```

### finallyブロック

```hemlock
let file = null;

try {
    file = open("data.txt", "r");
    let content = file.read();
    print(content);
} catch (e) {
    print("Error: " + e);
} finally {
    // 常に実行
    if (file != null) {
        file.close();
    }
}
```

### オブジェクトをthrow

```hemlock
try {
    throw { code: 404, message: "Not found" };
} catch (e) {
    print(`Error ${e.code}: ${e.message}`);
}
// 出力：Error 404: Not found
```

### panic（回復不能エラー）

```hemlock
fn validate(x) {
    if (x < 0) {
        panic("x must be non-negative");
    }
    return x * 2;
}

validate(-5);  // プログラムは終了：panic: x must be non-negative
```

## ファイルI/O

### ファイルの読み込み

```hemlock
// ファイル全体を読み込み
let f = open("data.txt", "r");
let content = f.read();
print(content);
f.close();

// 特定のバイト数を読み込み
let f2 = open("data.txt", "r");
let chunk = f2.read(100);  // 100バイト読み込み
f2.close();
```

### ファイルへの書き込み

```hemlock
// テキストを書き込み
let f = open("output.txt", "w");
f.write("Hello, File!\n");
f.write("Second line\n");
f.close();

// ファイルに追記
let f2 = open("output.txt", "a");
f2.write("Appended line\n");
f2.close();
```

### バイナリI/O

```hemlock
// バイナリデータを書き込み
let buf = buffer(256);
buf[0] = 255;
buf[1] = 128;

let f = open("data.bin", "w");
f.write_bytes(buf);
f.close();

// バイナリデータを読み込み
let f2 = open("data.bin", "r");
let data = f2.read_bytes(256);
print(data[0]);  // 255
f2.close();

free(buf);
free(data);
```

### ファイルプロパティ

```hemlock
let f = open("/path/to/file.txt", "r");

print(f.path);    // "/path/to/file.txt"
print(f.mode);    // "r"
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

## まとめ

シンプルな単語カウンタプログラムを作りましょう：

```hemlock
// wordcount.hml - ファイル内の単語をカウント

fn count_words(filename: string): i32 {
    let file = null;
    let count = 0;

    try {
        file = open(filename, "r");
        let content = file.read();

        // 空白で分割してカウント
        let words = content.split(" ");
        count = words.length;

    } catch (e) {
        print("Error reading file: " + e);
        return -1;
    } finally {
        if (file != null) {
            file.close();
        }
    }

    return count;
}

// メインプログラム
if (args.length < 2) {
    print("Usage: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    let words = count_words(filename);

    if (words >= 0) {
        print(`Word count: ${words}`);
    }
}
```

実行：
```bash
./hemlock wordcount.hml data.txt
```

## 次のステップ

おめでとうございます！Hemlockの基本を学びました。次に探索するものはこちらです：

- [非同期と並行処理](#advanced-async-concurrency) - 真のマルチスレッド
- [FFI](#advanced-ffi) - C関数を呼び出す
- [シグナルハンドリング](#advanced-signals) - プロセスシグナル
- [APIリファレンス](#reference-builtins) - 完全なAPIドキュメント
- [サンプル](../../examples/) - より実世界のプログラム

## 練習問題

練習のためにこれらのプログラムを作ってみてください：

1. **電卓**: +、-、*、/の簡単な電卓を実装
2. **ファイルコピー**: 1つのファイルを別のファイルにコピー
3. **フィボナッチ**: フィボナッチ数を生成
4. **JSONパーサー**: JSONファイルを読み込んでパース
5. **テキストプロセッサ**: ファイル内のテキストを検索・置換

Hemlockで楽しいコーディングを！


--------------------------------------------------------------------------------
## 学習パス
--------------------------------------------------------------------------------

# 学習パス

目標によって必要な知識は異なります。作りたいものに合ったパスを選んでください。

---

## パス1：クイックスクリプトと自動化

**目標：** タスクを自動化し、ファイルを処理し、仕事を片付けるスクリプトを書く。

**生産性までの時間：** 速い - すぐに便利なスクリプトを書き始められます。

### 学ぶこと

1. **[クイックスタート](#getting-started-quick-start)** - 最初のプログラム、基本構文
2. **[文字列](#language-guide-strings)** - テキスト処理、分割、検索
3. **[配列](#language-guide-arrays)** - リスト、フィルタリング、データ変換
4. **[ファイルI/O](#advanced-file-io)** - ファイルの読み書き
5. **[コマンドライン引数](#advanced-command-line-args)** - ユーザーからの入力を取得

### 今はスキップ

- メモリ管理（スクリプトでは自動）
- 非同期/並行処理（シンプルなスクリプトには過剰）
- FFI（Cインターオペが必要な場合のみ）

### サンプルプロジェクト：ファイルリネーマー

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// すべての.txtファイルを.mdにリネーム
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Renamed: ${file} -> ${new_name}`);
    }
}
```

---

## パス2：データ処理と分析

**目標：** データをパースし、変換し、レポートを生成する。

**生産性までの時間：** 速い - Hemlockの文字列と配列メソッドがこれを簡単にします。

### 学ぶこと

1. **[クイックスタート](#getting-started-quick-start)** - 基本
2. **[文字列](#language-guide-strings)** - パース、分割、フォーマット
3. **[配列](#language-guide-arrays)** - データ変換用のmap、filter、reduce
4. **[オブジェクト](#language-guide-objects)** - 構造化データ
5. **標準ライブラリ：**
   - **[@stdlib/json](#stdlib-json)** - JSONパース
   - **[@stdlib/csv](#stdlib-csv)** - CSVファイル
   - **[@stdlib/fs](#stdlib-fs)** - ファイル操作

### サンプルプロジェクト：CSVアナライザー

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("sales.csv"));

// 合計売上を計算
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Total sales: $${total}`);

// トップセラーを見つける
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Top sale: ${top.product} - $${top.amount}`);
```

---

## パス3：WebとネットワークプログラミングPath 3: Web & Network Programming

**目標：** HTTPクライアントを構築し、APIを操作し、サーバーを作成する。

**生産性までの時間：** 中程度 - 非同期の基本の理解が必要。

### 学ぶこと

1. **[クイックスタート](#getting-started-quick-start)** - 基本
2. **[関数](#language-guide-functions)** - コールバックとクロージャ
3. **[エラーハンドリング](#language-guide-error-handling)** - ネットワークエラー用のtry/catch
4. **[非同期と並行処理](#advanced-async-concurrency)** - spawn、await、channels
5. **標準ライブラリ：**
   - **[@stdlib/http](#stdlib-http)** - HTTPリクエスト
   - **[@stdlib/json](#stdlib-json)** - API用JSON
   - **[@stdlib/net](#stdlib-net)** - TCP/UDPソケット
   - **[@stdlib/url](#stdlib-url)** - URLパース

### サンプルプロジェクト：APIクライアント

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// GETリクエスト
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name}: ${user.email}`);
}

// POSTリクエスト
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`Created user with ID: ${parse(result.body).id}`);
```

---

## パス4：システムプログラミング

**目標：** 低レベルコードを書き、メモリを操作し、Cライブラリとインターフェースする。

**生産性までの時間：** 長め - メモリ管理の理解が必要。

### 学ぶこと

1. **[クイックスタート](#getting-started-quick-start)** - 基本
2. **[型](#language-guide-types)** - i32、u8、ptrなどの理解
3. **[メモリ管理](#language-guide-memory)** - alloc、free、バッファ
4. **[FFI](#advanced-ffi)** - C関数の呼び出し
5. **[シグナル](#advanced-signals)** - シグナルハンドリング

### 主要概念

**メモリ安全性チェックリスト：**
- [ ] すべての`alloc()`に対応する`free()`がある
- [ ] 生の`ptr`が必要でなければ`buffer()`を使用
- [ ] 解放後はポインタを`null`に設定
- [ ] クリーンアップを保証するために`try/finally`を使用

**FFI用の型マッピング：**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long`（64ビット） |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### サンプルプロジェクト：カスタムメモリプール

```hemlock
// シンプルなバンプアロケータ
let pool_size = 1024 * 1024;  // 1MB
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Pool exhausted";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// 使用例
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();  // すべてのメモリを再利用
pool_destroy();  // クリーンアップ
```

---

## パス5：並列・並行プログラム

**目標：** 複数のCPUコアでコードを実行し、レスポンシブなアプリケーションを構築する。

**生産性までの時間：** 中程度 - async構文は簡単ですが、並列処理の推論には練習が必要。

### 学ぶこと

1. **[クイックスタート](#getting-started-quick-start)** - 基本
2. **[関数](#language-guide-functions)** - クロージャ（非同期で重要）
3. **[非同期と並行処理](#advanced-async-concurrency)** - 完全な詳細解説
4. **[アトミック](#advanced-atomics)** - ロックフリープログラミング

### 主要概念

**Hemlockの非同期モデル：**
- `async fn` - 別のスレッドで実行できる関数を定義
- `spawn(fn, args...)` - 実行を開始、タスクハンドルを返す
- `join(task)`または`await task` - 完了を待ち、結果を取得
- `channel(size)` - タスク間でデータを送信するためのキューを作成

**重要：** タスクは値の*コピー*を受け取ります。ポインタを渡す場合、タスクが完了するまでメモリが有効であることを保証する責任があります。

### サンプルプロジェクト：並列ファイルプロセッサ

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// すべてのファイルを並列処理
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// 結果を収集
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name}: ${count} lines`);
    total_lines = total_lines + count;
}

print(`Total: ${total_lines} lines`);
```

---

## 最初に学ぶこと（どのパスでも）

目標に関係なく、これらの基本から始めましょう：

### 第1週：コア基本

1. **[クイックスタート](#getting-started-quick-start)** - 最初のプログラムを書いて実行
2. **[構文](#language-guide-syntax)** - 変数、演算子、制御フロー
3. **[関数](#language-guide-functions)** - 関数の定義と呼び出し

### 第2週：データハンドリング

4. **[文字列](#language-guide-strings)** - テキスト操作
5. **[配列](#language-guide-arrays)** - コレクションとイテレーション
6. **[オブジェクト](#language-guide-objects)** - 構造化データ

### 第3週：堅牢性

7. **[エラーハンドリング](#language-guide-error-handling)** - try/catch/throw
8. **[モジュール](#language-guide-modules)** - import/export、stdlibの使用

### その後：上記からパスを選択

---

## チートシート：他の言語からの移行

### Pythonから

| Python | Hemlock | 備考 |
|--------|---------|-------|
| `x = 42` | `let x = 42;` | セミコロン必須 |
| `def fn():` | `fn name() { }` | ブレース必須 |
| `if x:` | `if (x) { }` | 括弧とブレース必須 |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Cスタイルforループ |
| `for item in list:` | `for (item in array) { }` | for-inは同じ動作 |
| `list.append(x)` | `array.push(x);` | 異なるメソッド名 |
| `len(s)` | `s.length`または`len(s)` | 両方とも動作 |
| 自動メモリ | `ptr`は手動 | ほとんどの型は自動クリーンアップ |

### JavaScriptから

| JavaScript | Hemlock | 備考 |
|------------|---------|-------|
| `let x = 42` | `let x = 42;` | 同じ（セミコロン必須） |
| `const x = 42` | `let x = 42;` | constキーワードなし |
| `function fn()` | `fn name() { }` | 異なるキーワード |
| `() => x` | `fn() { return x; }` | アロー関数なし |
| `async/await` | `async/await` | 同じ構文 |
| `Promise` | `spawn/join` | 異なるモデル |
| 自動GC | `ptr`は手動 | ほとんどの型は自動クリーンアップ |

### C/C++から

| C | Hemlock | 備考 |
|---|---------|-------|
| `int x = 42;` | `let x: i32 = 42;` | 型はコロンの後 |
| `malloc(n)` | `alloc(n)` | 同じ概念 |
| `free(p)` | `free(p)` | 同じ |
| `char* s = "hi"` | `let s = "hi";` | 文字列は管理される |
| `#include` | `import { } from` | モジュールインポート |
| すべて手動 | ほとんどの型は自動 | `ptr`のみ手動が必要 |

---

## ヘルプを得る

- **[用語集](../glossary.md)** - プログラミング用語の定義
- **[サンプル](../../examples/)** - 完全な動作プログラム
- **[テスト](../../tests/)** - 機能の使い方を見る
- **GitHubのIssue** - 質問やバグ報告

---

## 難易度レベル

ドキュメント全体で以下のマーカーが表示されます：

| マーカー | 意味 |
|--------|---------|
| **初級** | プログラミング経験不要 |
| **中級** | 基本的なプログラミング知識を前提 |
| **上級** | システム概念の理解が必要 |

「初級」とマークされたものが分かりにくい場合は、[用語集](../glossary.md)で用語の定義を確認してください。



################################################################################
# 言語ガイド
################################################################################

--------------------------------------------------------------------------------
## エラー処理
--------------------------------------------------------------------------------

# エラーハンドリング

Hemlockは`try`、`catch`、`finally`、`throw`、`panic`による例外ベースのエラーハンドリングをサポートしています。このガイドでは、例外による回復可能なエラーとpanicによる回復不可能なエラーについて説明します。

## 概要

```hemlock
// 基本的なエラーハンドリング
try {
    risky_operation();
} catch (e) {
    print("Error: " + e);
}

// クリーンアップ付き
try {
    process_file();
} catch (e) {
    print("Failed: " + e);
} finally {
    cleanup();
}

// エラーのスロー
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

## Try-Catch-Finally

### 構文

**基本的なtry/catch：**
```hemlock
try {
    // 危険なコード
} catch (e) {
    // エラーを処理、eはスローされた値を含む
}
```

**Try/finally：**
```hemlock
try {
    // 危険なコード
} finally {
    // 例外がスローされても常に実行
}
```

**Try/catch/finally：**
```hemlock
try {
    // 危険なコード
} catch (e) {
    // エラーを処理
} finally {
    // クリーンアップコード
}
```

### Tryブロック

tryブロックは文を順次実行します：

```hemlock
try {
    print("Starting...");
    risky_operation();
    print("Success!");  // 例外がなければ実行
}
```

**動作：**
- 文を順番に実行
- 例外がスローされた場合：`catch`または`finally`にジャンプ
- 例外がない場合：`finally`（存在すれば）を実行して続行

### Catchブロック

catchブロックはスローされた値を受け取ります：

```hemlock
try {
    throw "oops";
} catch (error) {
    print("Caught: " + error);  // error = "oops"
    // errorはここでのみアクセス可能
}
// errorはここではアクセスできない
```

**Catchパラメータ：**
- スローされた値（任意の型）を受け取る
- catchブロックにスコープされる
- 任意の名前を付けられる（慣例として`e`、`err`、または`error`）

**catchでできること：**
```hemlock
try {
    risky_operation();
} catch (e) {
    // エラーをログ
    print("Error: " + e);

    // 同じエラーを再スロー
    throw e;

    // 別のエラーをスロー
    throw "different error";

    // デフォルト値を返す
    return null;

    // 処理して続行
    // （再スローなし）
}
```

### Finallyブロック

finallyブロックは**常に実行されます**：

```hemlock
try {
    print("1: try");
    throw "error";
} catch (e) {
    print("2: catch");
} finally {
    print("3: finally");  // 常に実行
}
print("4: after");

// 出力：1: try, 2: catch, 3: finally, 4: after
```

**finallyが実行されるタイミング：**
- tryブロックの後（例外がない場合）
- catchブロックの後（例外がキャッチされた場合）
- try/catchに`return`、`break`、または`continue`が含まれていても
- 制御フローがtry/catchを抜ける前

**returnとfinally：**
```hemlock
fn example() {
    try {
        return 1;  // finallyの実行後に1を返す
    } finally {
        print("cleanup");  // 戻る前に実行
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // finallyのreturnが上書き - 2を返す
    }
}
```

**制御フローとfinally：**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) {
            break;  // finallyの実行後にbreak
        }
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

## Throw文

### 基本的なThrow

任意の値を例外としてスロー：

```hemlock
throw "error message";
throw 404;
throw { code: 500, message: "Internal error" };
throw null;
throw ["error", "details"];
```

**実行：**
1. 式を評価
2. 最も近い囲んでいる`catch`に即座にジャンプ
3. `catch`がない場合、コールスタックを伝播

### エラーのスロー

```hemlock
fn validate_age(age: i32) {
    if (age < 0) {
        throw "Age cannot be negative";
    }
    if (age > 150) {
        throw "Age is unrealistic";
    }
}

try {
    validate_age(-5);
} catch (e) {
    print("Validation error: " + e);
}
```

### エラーオブジェクトのスロー

構造化されたエラー情報を作成：

```hemlock
fn read_file(path: string) {
    if (!file_exists(path)) {
        throw {
            type: "FileNotFound",
            path: path,
            message: "File does not exist"
        };
    }
    // ... ファイルを読み込み
}

try {
    read_file("missing.txt");
} catch (e) {
    if (e.type == "FileNotFound") {
        print("File not found: " + e.path);
    }
}
```

### 再スロー

エラーをキャッチして再スロー：

```hemlock
fn wrapper() {
    try {
        risky_operation();
    } catch (e) {
        print("Logging error: " + e);
        throw e;  // 呼び出し元に再スロー
    }
}

try {
    wrapper();
} catch (e) {
    print("Caught in main: " + e);
}
```

## キャッチされない例外

例外がキャッチされずにコールスタックの最上部に伝播した場合：

```hemlock
fn foo() {
    throw "uncaught!";
}

foo();  // クラッシュ：Runtime error: uncaught!
```

**動作：**
- プログラムがクラッシュ
- stderrにエラーメッセージを出力
- 非ゼロのステータスコードで終了
- スタックトレースは将来のバージョンで追加予定

## Panic - 回復不可能なエラー

### Panicとは？

`panic()`はプログラムを即座に終了させるべき**回復不可能なエラー**用です：

```hemlock
panic();                    // デフォルトメッセージ："panic!"
panic("custom message");    // カスタムメッセージ
panic(42);                  // 非文字列値も出力される
```

**セマンティクス：**
- 終了コード1でプログラムを**即座に終了**
- stderrにエラーメッセージを出力：`panic: <message>`
- try/catchで**キャッチ不可能**
- バグや回復不可能なエラーに使用

### Panic vs Throw

```hemlock
// throw - 回復可能なエラー（キャッチ可能）
try {
    throw "recoverable error";
} catch (e) {
    print("Caught: " + e);  // 正常にキャッチ
}

// panic - 回復不可能なエラー（キャッチ不可能）
try {
    panic("unrecoverable error");  // プログラムは即座に終了
} catch (e) {
    print("This never runs");       // 実行されない
}
```

### Panicを使用するタイミング

**panicを使用する場面：**
- **バグ**：到達不可能なコードに到達した
- **無効な状態**：データ構造の破損が検出された
- **回復不可能なエラー**：重要なリソースが利用不可能
- **アサーション失敗**：`assert()`では不十分な場合

**例：**
```hemlock
// 到達不可能なコード
fn process_state(state: i32) {
    if (state == 1) {
        return "ready";
    } else if (state == 2) {
        return "running";
    } else if (state == 3) {
        return "stopped";
    } else {
        panic("invalid state: " + typeof(state));  // 発生してはならない
    }
}

// 重要なリソースのチェック
fn init_system() {
    let config = read_file("config.json");
    if (config == null) {
        panic("config.json not found - cannot start");
    }
    // ...
}

// データ構造の不変条件
fn pop_stack(stack) {
    if (stack.length == 0) {
        panic("pop() called on empty stack");
    }
    return stack.pop();
}
```

### Panicを使用しないタイミング

**代わりにthrowを使用する場面：**
- ユーザー入力の検証
- ファイルが見つからない
- ネットワークエラー
- 予期されるエラー条件

```hemlock
// 悪い：予期されるエラーにpanic
fn divide(a, b) {
    if (b == 0) {
        panic("division by zero");  // 厳しすぎる
    }
    return a / b;
}

// 良い：予期されるエラーにthrow
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";  // 回復可能
    }
    return a / b;
}
```

## 制御フローとの相互作用

### Try/Catch/Finally内のReturn

```hemlock
fn example() {
    try {
        return 1;  // finallyの実行後に1を返す
    } finally {
        print("cleanup");
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // finallyのreturnがtryのreturnを上書き - 2を返す
    }
}
```

**ルール：** finallyブロックの戻り値はtry/catchの戻り値を上書きします。

### Try/Catch/Finally内のBreak/Continue

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) { break; }  // finallyの実行後にbreak
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

**ルール：** Break/continueはfinallyブロックの後に実行されます。

### ネストされたTry/Catch

```hemlock
try {
    try {
        throw "inner";
    } catch (e) {
        print("Caught: " + e);  // 出力：Caught: inner
        throw "outer";  // 別のエラーを再スロー
    }
} catch (e) {
    print("Caught: " + e);  // 出力：Caught: outer
}
```

**ルール：** ネストされたtry/catchブロックは期待通りに動作し、内側のcatchが先に発生します。

## よくあるパターン

### パターン：リソースクリーンアップ

クリーンアップには常に`finally`を使用：

```hemlock
fn process_file(filename) {
    let file = null;
    try {
        file = open(filename);
        let content = file.read();
        process(content);
    } catch (e) {
        print("Error processing file: " + e);
    } finally {
        if (file != null) {
            file.close();  // エラー時も常にクローズ
        }
    }
}
```

### パターン：エラーラッピング

低レベルのエラーにコンテキストを追加：

```hemlock
fn load_config(path) {
    try {
        let content = read_file(path);
        return parse_json(content);
    } catch (e) {
        throw "Failed to load config from " + path + ": " + e;
    }
}
```

### パターン：エラーリカバリ

エラー時にフォールバックを提供：

```hemlock
fn safe_divide(a, b) {
    try {
        if (b == 0) {
            throw "division by zero";
        }
        return a / b;
    } catch (e) {
        print("Error: " + e);
        return null;  // フォールバック値
    }
}
```

### パターン：バリデーション

バリデーションに例外を使用：

```hemlock
fn validate_user(user) {
    if (user.name == null || user.name == "") {
        throw "Name is required";
    }
    if (user.age < 0 || user.age > 150) {
        throw "Invalid age";
    }
    if (user.email == null || !user.email.contains("@")) {
        throw "Invalid email";
    }
}

try {
    validate_user({ name: "Alice", age: -5, email: "invalid" });
} catch (e) {
    print("Validation failed: " + e);
}
```

### パターン：複数のエラータイプ

エラーオブジェクトを使用してエラータイプを区別：

```hemlock
fn process_data(data) {
    if (data == null) {
        throw { type: "NullData", message: "Data is null" };
    }

    if (typeof(data) != "array") {
        throw { type: "TypeError", message: "Expected array" };
    }

    if (data.length == 0) {
        throw { type: "EmptyData", message: "Array is empty" };
    }

    // ... 処理
}

try {
    process_data(null);
} catch (e) {
    if (e.type == "NullData") {
        print("No data provided");
    } else if (e.type == "TypeError") {
        print("Wrong data type: " + e.message);
    } else {
        print("Error: " + e.message);
    }
}
```

## ベストプラクティス

1. **例外は例外的なケースに使用** - 通常の制御フローには使用しない
2. **意味のあるエラーをスロー** - コンテキストを含む文字列またはオブジェクト
3. **クリーンアップには常にfinallyを使用** - リソースの解放を確実に
4. **キャッチして無視しない** - 少なくともエラーをログ
5. **適切に再スロー** - 処理できない場合は呼び出し元に処理させる
6. **バグにはpanicを使用** - 回復不可能なエラーにはpanicを使用
7. **例外をドキュメント化** - 関数がスローできるものを明確に

## よくある落とし穴

### 落とし穴：エラーを飲み込む

```hemlock
// 悪い：サイレントな失敗
try {
    risky_operation();
} catch (e) {
    // エラーを無視 - サイレントな失敗
}

// 良い：ログまたは処理
try {
    risky_operation();
} catch (e) {
    print("Operation failed: " + e);
    // 適切に処理
}
```

### 落とし穴：Finallyのオーバーライド

```hemlock
// 悪い：finallyがreturnを上書き
fn get_value() {
    try {
        return 42;
    } finally {
        return 0;  // 42ではなく0を返す！
    }
}

// 良い：finallyでreturnしない
fn get_value() {
    try {
        return 42;
    } finally {
        cleanup();  // クリーンアップのみ、returnなし
    }
}
```

### 落とし穴：クリーンアップ忘れ

```hemlock
// 悪い：エラー時にファイルがクローズされないかも
fn process() {
    let file = open("data.txt");
    let content = file.read();  // スローするかも
    file.close();  // エラー時は到達しない
}

// 良い：finallyを使用
fn process() {
    let file = null;
    try {
        file = open("data.txt");
        let content = file.read();
    } finally {
        if (file != null) {
            file.close();
        }
    }
}
```

### 落とし穴：予期されるエラーにPanicを使用

```hemlock
// 悪い：予期されるエラーにpanic
fn read_config(path) {
    if (!file_exists(path)) {
        panic("Config file not found");  // 厳しすぎる
    }
    return read_file(path);
}

// 良い：予期されるエラーにthrow
fn read_config(path) {
    if (!file_exists(path)) {
        throw "Config file not found: " + path;  // 回復可能
    }
    return read_file(path);
}
```

## 例

### 例：基本的なエラーハンドリング

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    print(divide(10, 0));
} catch (e) {
    print("Error: " + e);  // 出力：Error: division by zero
}
```

### 例：リソース管理

```hemlock
fn copy_file(src, dst) {
    let src_file = null;
    let dst_file = null;

    try {
        src_file = open(src, "r");
        dst_file = open(dst, "w");

        let content = src_file.read();
        dst_file.write(content);

        print("File copied successfully");
    } catch (e) {
        print("Failed to copy file: " + e);
        throw e;  // 再スロー
    } finally {
        if (src_file != null) { src_file.close(); }
        if (dst_file != null) { dst_file.close(); }
    }
}
```

### 例：ネストされたエラーハンドリング

```hemlock
fn process_users(users) {
    let success_count = 0;
    let error_count = 0;

    let i = 0;
    while (i < users.length) {
        try {
            validate_user(users[i]);
            save_user(users[i]);
            success_count = success_count + 1;
        } catch (e) {
            print("Failed to process user: " + e);
            error_count = error_count + 1;
        }
        i = i + 1;
    }

    print("Processed: " + typeof(success_count) + " success, " + typeof(error_count) + " errors");
}
```

### 例：カスタムエラータイプ

```hemlock
fn create_error(type, message, details) {
    return {
        type: type,
        message: message,
        details: details,
        toString: fn() {
            return self.type + ": " + self.message;
        }
    };
}

fn divide(a, b) {
    if (typeof(a) != "i32" && typeof(a) != "f64") {
        throw create_error("TypeError", "a must be a number", { value: a });
    }
    if (typeof(b) != "i32" && typeof(b) != "f64") {
        throw create_error("TypeError", "b must be a number", { value: b });
    }
    if (b == 0) {
        throw create_error("DivisionByZero", "Cannot divide by zero", { a: a, b: b });
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    print(e.toString());
    if (e.type == "DivisionByZero") {
        print("Details: a=" + typeof(e.details.a) + ", b=" + typeof(e.details.b));
    }
}
```

### 例：リトライロジック

```hemlock
fn retry(operation, max_attempts) {
    let attempt = 0;

    while (attempt < max_attempts) {
        try {
            return operation();  // 成功！
        } catch (e) {
            attempt = attempt + 1;
            if (attempt >= max_attempts) {
                throw "Operation failed after " + typeof(max_attempts) + " attempts: " + e;
            }
            print("Attempt " + typeof(attempt) + " failed, retrying...");
        }
    }
}

fn unreliable_operation() {
    // シミュレートされた不安定な操作
    if (random() < 0.7) {
        throw "Operation failed";
    }
    return "Success";
}

try {
    let result = retry(unreliable_operation, 3);
    print(result);
} catch (e) {
    print("All retries failed: " + e);
}
```

## 実行順序

実行順序の理解：

```hemlock
try {
    print("1: try block start");
    throw "error";
    print("2: never reached");
} catch (e) {
    print("3: catch block");
} finally {
    print("4: finally block");
}
print("5: after try/catch/finally");

// 出力：
// 1: try block start
// 3: catch block
// 4: finally block
// 5: after try/catch/finally
```

## 現在の制限事項

- **スタックトレースなし** - キャッチされない例外はスタックトレースを表示しない（計画中）
- **一部の組み込み関数がexit** - 一部の組み込み関数はスローではなく`exit()`する（レビュー予定）
- **カスタム例外タイプなし** - 任意の値をスローできるが、正式な例外階層はない

## 関連トピック

- [関数](#language-guide-functions) - 例外と関数のreturn
- [制御フロー](#language-guide-control-flow) - 例外が制御フローに与える影響
- [メモリ](#language-guide-memory) - メモリクリーンアップにfinallyを使用

## 参照

- **例外のセマンティクス**：CLAUDE.mdの「Error Handling」セクションを参照
- **Panic vs Throw**：異なるエラータイプに対する異なる使用例
- **Finally保証**：return/break/continueがあっても常に実行


--------------------------------------------------------------------------------
## オブジェクト
--------------------------------------------------------------------------------

# オブジェクト

HemlockはJavaScriptスタイルのオブジェクトを実装しており、ヒープ割り当て、動的フィールド、メソッド、ダックタイピングを備えています。オブジェクトはデータと動作を組み合わせた柔軟なデータ構造です。

## 概要

```hemlock
// 無名オブジェクト
let person = { name: "Alice", age: 30, city: "NYC" };
print(person.name);  // "Alice"

// メソッドを持つオブジェクト
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## オブジェクトリテラル

### 基本構文

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};
```

**構文：**
- 波括弧`{}`がオブジェクトを囲む
- キーと値のペアはカンマで区切る
- キーは識別子（引用符不要）
- 値は任意の型

### 空のオブジェクト

```hemlock
let obj = {};  // 空のオブジェクト

// 後でフィールドを追加
obj.name = "Alice";
obj.age = 30;
```

### ネストされたオブジェクト

```hemlock
let user = {
    info: {
        name: "Bob",
        age: 25
    },
    active: true,
    settings: {
        theme: "dark",
        notifications: true
    }
};

print(user.info.name);           // "Bob"
print(user.settings.theme);      // "dark"
```

### 混合型の値

```hemlock
let mixed = {
    number: 42,
    text: "hello",
    flag: true,
    data: null,
    items: [1, 2, 3],
    config: { x: 10, y: 20 }
};
```

### 短縮プロパティ構文

変数名がプロパティ名と一致する場合、短縮構文を使用：

```hemlock
let name = "Alice";
let age = 30;
let active = true;

// 短縮：{ name } は { name: name } と等価
let person = { name, age, active };

print(person.name);   // "Alice"
print(person.age);    // 30
print(person.active); // true
```

**短縮と通常のプロパティを混合：**
```hemlock
let city = "NYC";
let obj = { name, age, city, role: "admin" };
```

### スプレッド演算子

スプレッド演算子（`...`）は1つのオブジェクトからすべてのフィールドを別のオブジェクトにコピーします：

```hemlock
let base = { x: 1, y: 2 };
let extended = { ...base, z: 3 };

print(extended.x);  // 1
print(extended.y);  // 2
print(extended.z);  // 3
```

**スプレッドで値を上書き：**
```hemlock
let defaults = { theme: "light", size: "medium", debug: false };
let custom = { ...defaults, theme: "dark" };

print(custom.theme);  // "dark"（上書き）
print(custom.size);   // "medium"（デフォルトから）
print(custom.debug);  // false（デフォルトから）
```

**複数のスプレッド（後のスプレッドが前を上書き）：**
```hemlock
let a = { x: 1 };
let b = { y: 2 };
let merged = { ...a, ...b, z: 3 };

print(merged.x);  // 1
print(merged.y);  // 2
print(merged.z);  // 3

// 後のスプレッドが前を上書き
let first = { val: "first" };
let second = { val: "second" };
let combined = { ...first, ...second };
print(combined.val);  // "second"
```

**短縮とスプレッドを組み合わせ：**
```hemlock
let status = "active";
let data = { id: 1, name: "Item" };
let full = { ...data, status };

print(full.id);      // 1
print(full.name);    // "Item"
print(full.status);  // "active"
```

**設定上書きパターン：**
```hemlock
let defaultConfig = {
    debug: false,
    timeout: 30,
    retries: 3
};

let prodConfig = { ...defaultConfig, timeout: 60 };
let devConfig = { ...defaultConfig, debug: true };

print(prodConfig.timeout);  // 60
print(devConfig.debug);     // true
```

**注意：** スプレッドは浅いコピーを実行します。ネストされたオブジェクトは参照を共有します：
```hemlock
let nested = { inner: { val: 42 } };
let copied = { ...nested };
print(copied.inner.val);  // 42（nested.innerと同じ参照）
```

## フィールドアクセス

### ドット記法

```hemlock
let person = { name: "Alice", age: 30 };

// フィールドを読み取り
let name = person.name;      // "Alice"
let age = person.age;        // 30

// フィールドを変更
person.age = 31;
print(person.age);           // 31
```

### 動的フィールド追加

実行時に新しいフィールドを追加：

```hemlock
let person = { name: "Alice" };

// 新しいフィールドを追加
person.email = "alice@example.com";
person.phone = "555-1234";

print(person.email);  // "alice@example.com"
```

### フィールド削除

**注意：** フィールド削除は現在サポートされていません。代わりに`null`を設定：

```hemlock
let obj = { x: 10, y: 20 };

// フィールドを削除できない（サポートされていない）
// obj.x = undefined;  // Hemlockには'undefined'がない

// 回避策：nullを設定
obj.x = null;
```

## メソッドと`self`

### メソッドの定義

メソッドはオブジェクトフィールドに格納された関数です：

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
    decrement: fn() {
        self.count = self.count - 1;
    },
    get: fn() {
        return self.count;
    }
};
```

### `self`キーワード

関数がメソッドとして呼び出されると、`self`は自動的にオブジェクトにバインドされます：

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;  // selfはcounterを参照
    }
};

counter.increment();  // selfはcounterにバインド
print(counter.count);  // 1
```

**動作の仕組み：**
- メソッド呼び出しは関数式がプロパティアクセスかどうかをチェックして検出
- `self`は呼び出し時にオブジェクトに自動的にバインド
- `self`は読み取り専用（`self`自体を再代入できない）

### メソッド呼び出しの検出

```hemlock
let obj = {
    value: 10,
    method: fn() {
        return self.value;
    }
};

// メソッドとして呼び出し - selfがバインド
print(obj.method());  // 10

// 関数として呼び出し - selfはnull（エラー）
let f = obj.method;
print(f());  // エラー：selfが定義されていない
```

### パラメータを持つメソッド

```hemlock
let calculator = {
    result: 0,
    add: fn(x) {
        self.result = self.result + x;
    },
    multiply: fn(x) {
        self.result = self.result * x;
    },
    get: fn() {
        return self.result;
    }
};

calculator.add(5);
calculator.multiply(2);
print(calculator.get());  // 10
```

## `define`による型定義

### 基本的な型定義

`define`でオブジェクトの形状を定義：

```hemlock
define Person {
    name: string,
    age: i32,
    active: bool,
}

// オブジェクトを作成し型付き変数に代入
let p = { name: "Alice", age: 30, active: true };
let typed_p: Person = p;  // ダックタイピングが構造を検証

print(typeof(typed_p));  // "Person"
```

**`define`が行うこと：**
- 必須フィールドを持つ型を宣言
- ダックタイピング検証を有効に
- `typeof()`用のオブジェクトの型名を設定

### ダックタイピング

オブジェクトは**構造的互換性**を使用して`define`に対して検証されます：

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK：すべての必須フィールドを持つ
let p1: Person = { name: "Alice", age: 30 };

// OK：追加フィールドは許可
let p2: Person = {
    name: "Bob",
    age: 25,
    city: "NYC",
    active: true
};

// エラー：必須フィールド'age'がない
let p3: Person = { name: "Carol" };

// エラー：'age'の型が違う
let p4: Person = { name: "Dave", age: "thirty" };
```

**ダックタイピングのルール：**
- すべての必須フィールドが存在する必要がある
- フィールドの型が一致する必要がある
- 追加フィールドは許可され保持される
- 検証は代入時に行われる

### オプションフィールド

フィールドはデフォルト値でオプションにできます：

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,       // デフォルト値付きオプション
    nickname?: string,   // オプション、デフォルトはnull
}

// 必須フィールドのみのオブジェクト
let p = { name: "Alice", age: 30 };
let typed_p: Person = p;

print(typed_p.active);    // true（デフォルトが適用）
print(typed_p.nickname);  // null（デフォルトなし）

// オプションフィールドを上書き可能
let p2: Person = { name: "Bob", age: 25, active: false };
print(p2.active);  // false（上書き）
```

**オプションフィールドの構文：**
- `field?: default_value` - デフォルト付きオプション
- `field?: type` - 型注釈付きオプション、デフォルトはnull
- オプションフィールドはダックタイピング時に欠落していれば追加される

### 型チェック

```hemlock
define Point {
    x: i32,
    y: i32,
}

let p = { x: 10, y: 20 };
let point: Point = p;  // ここで型チェックが行われる

print(typeof(point));  // "Point"
print(typeof(p));      // "object"（元は無名のまま）
```

**型チェックが行われるタイミング：**
- 型付き変数への代入時
- すべての必須フィールドが存在するか検証
- フィールドの型が一致するか検証（暗黙の変換付き）
- オブジェクトの型名を設定

## Defineのメソッドシグネチャ

Defineブロックはメソッドシグネチャを指定でき、インターフェースのような契約を作成：

### 必須メソッド

```hemlock
define Comparable {
    value: i32,
    fn compare(other: Self): i32;  // 必須メソッドシグネチャ
}

// オブジェクトは必須メソッドを提供する必要がある
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};
```

### オプションメソッド

```hemlock
define Serializable {
    fn serialize(): string;       // 必須
    fn pretty?(): string;         // オプションメソッド（存在しなくてよい）
}
```

### `Self`型

`Self`は定義中の型を参照し、再帰的な型定義を可能に：

```hemlock
define Cloneable {
    fn clone(): Self;  // オブジェクトと同じ型を返す
}

define Comparable {
    fn compare(other: Self): i32;  // パラメータとして同じ型を取る
    fn equals(other: Self): bool;
}

let item: Cloneable = {
    value: 42,
    clone: fn() {
        return { value: self.value, clone: self.clone };
    }
};
```

### フィールドとメソッドの混合

```hemlock
define Entity {
    id: i32,
    name: string,
    fn validate(): bool;
    fn serialize(): string;
}

let user: Entity = {
    id: 1,
    name: "Alice",
    validate: fn() { return self.id > 0 && self.name != ""; },
    serialize: fn() { return '{"id":' + self.id + ',"name":"' + self.name + '"}'; }
};
```

## 複合型（交差型）

複合型は`&`を使用して、オブジェクトが複数の型定義を満たすことを要求：

### 基本的な複合型

```hemlock
define HasName { name: string }
define HasAge { age: i32 }

// 複合型：オブジェクトはすべての型を満たす必要がある
let person: HasName & HasAge = { name: "Alice", age: 30 };
```

### 複合型の関数パラメータ

```hemlock
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

greet({ name: "Bob", age: 25, city: "NYC" });  // 追加フィールドはOK
```

### 3つ以上の型

```hemlock
define HasEmail { email: string }

fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

### 複合型の型エイリアス

```hemlock
// 複合型の名前付きエイリアスを作成
type Person = HasName & HasAge;
type Employee = HasName & HasAge & HasEmail;

let emp: Employee = {
    name: "Charlie",
    age: 35,
    email: "charlie@example.com"
};
```

**複合型のダックタイピング：** 追加フィールドは常に許可されます - オブジェクトはすべての構成型が要求するフィールドを少なくとも持っていればよいです。

## JSONシリアライゼーション

### JSONへのシリアライズ

オブジェクトをJSON文字列に変換：

```hemlock
// obj.serialize() - オブジェクトをJSON文字列に変換
let obj = { x: 10, y: 20, name: "test" };
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// ネストされたオブジェクト
let nested = { inner: { a: 1, b: 2 }, outer: 3 };
print(nested.serialize());  // {"inner":{"a":1,"b":2},"outer":3}
```

### JSONからのデシリアライズ

JSON文字列をオブジェクトにパース：

```hemlock
// json.deserialize() - JSON文字列をオブジェクトにパース
let json_str = '{"x":10,"y":20,"name":"test"}';
let obj = json_str.deserialize();

print(obj.name);   // "test"
print(obj.x);      // 10
```

### 循環参照の検出

循環参照は検出されエラーになります：

```hemlock
let obj = { x: 10 };
obj.me = obj;  // 循環参照を作成

obj.serialize();  // エラー：serialize()が循環参照を検出
```

### サポートされる型

JSONシリアライゼーションがサポートする型：

- **数値**：i8-i32、u8-u32、f32、f64
- **真偽値**：true、false
- **文字列**：エスケープシーケンス付き
- **Null**：null値
- **オブジェクト**：ネストされたオブジェクト
- **配列**：ネストされた配列

**サポートされない：**
- 関数（無視される）
- ポインタ（エラー）
- バッファ（エラー）

### エラーハンドリング

シリアライゼーションとデシリアライゼーションはエラーをスローできます：

```hemlock
// 無効なJSONはエラーをスロー
try {
    let bad = "not valid json".deserialize();
} catch (e) {
    print("Parse error:", e);
}

// ポインタはシリアライズできない
let obj = { ptr: alloc(10) };
try {
    obj.serialize();
} catch (e) {
    print("Serialize error:", e);
}
```

### ラウンドトリップの例

シリアライズとデシリアライズの完全な例：

```hemlock
define Config {
    host: string,
    port: i32,
    debug: bool
}

// 作成してシリアライズ
let config: Config = {
    host: "localhost",
    port: 8080,
    debug: true
};
let json = config.serialize();
print(json);  // {"host":"localhost","port":8080,"debug":true}

// デシリアライズして復元
let restored = json.deserialize();
print(restored.host);  // "localhost"
print(restored.port);  // 8080
```

## 組み込み関数

### `typeof(value)`

型名を文字列として返します：

```hemlock
let obj = { x: 10 };
print(typeof(obj));  // "object"

define Person { name: string, age: i32 }
let p: Person = { name: "Alice", age: 30 };
print(typeof(p));    // "Person"
```

**戻り値：**
- 無名オブジェクト：`"object"`
- 型付きオブジェクト：カスタム型名（例：`"Person"`）

## 実装の詳細

### メモリモデル

- **ヒープ割り当て** - すべてのオブジェクトはヒープに割り当て
- **浅いコピー** - 代入は参照をコピー、オブジェクトではない
- **動的フィールド** - 名前/値ペアの動的配列として格納
- **参照カウント** - オブジェクトはスコープを抜けると自動的に解放

### 参照セマンティクス

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // 浅いコピー（同じ参照）

obj2.x = 20;
print(obj1.x);  // 20（両方が同じオブジェクトを参照）
```

### メソッドの格納

メソッドはフィールドに格納された関数です：

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// methodはobj.methodに格納された関数
print(typeof(obj.method));  // "function"
```

## よくあるパターン

### パターン：コンストラクタ関数

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### パターン：オブジェクトビルダー

```hemlock
fn PersonBuilder() {
    return {
        name: null,
        age: null,

        setName: fn(n) {
            self.name = n;
            return self;  // チェーンを有効に
        },

        setAge: fn(a) {
            self.age = a;
            return self;
        },

        build: fn() {
            return { name: self.name, age: self.age };
        }
    };
}

let person = PersonBuilder()
    .setName("Alice")
    .setAge(30)
    .build();
```

### パターン：状態オブジェクト

```hemlock
let state = {
    status: "idle",
    data: null,
    error: null,

    setState: fn(new_status) {
        self.status = new_status;
    },

    setData: fn(new_data) {
        self.data = new_data;
        self.status = "success";
    },

    setError: fn(err) {
        self.error = err;
        self.status = "error";
    }
};
```

### パターン：設定オブジェクト

```hemlock
let config = {
    defaults: {
        timeout: 30,
        retries: 3,
        debug: false
    },

    get: fn(key) {
        if (self.defaults[key] != null) {
            return self.defaults[key];
        }
        return null;
    },

    set: fn(key, value) {
        self.defaults[key] = value;
    }
};
```

## ベストプラクティス

1. **構造には`define`を使用** - 期待されるオブジェクトの形状を文書化
2. **ファクトリ関数を優先** - コンストラクタでオブジェクトを作成
3. **オブジェクトをシンプルに** - 深くネストしすぎない
4. **`self`の使用を文書化** - メソッドの動作を明確に
5. **代入時に検証** - ダックタイピングでエラーを早期にキャッチ
6. **循環参照を避ける** - シリアライゼーションエラーの原因
7. **オプションフィールドを使用** - 適切なデフォルトを提供

## よくある落とし穴

### 落とし穴：参照 vs 値

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // 浅いコピー

obj2.x = 20;
print(obj1.x);  // 20（驚き！両方が変更）

// 避けるには：新しいオブジェクトを作成
let obj3 = { x: obj1.x };  // ディープコピー（手動）
```

### 落とし穴：非メソッド呼び出しでの`self`

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// 動作：メソッドとして呼び出し
print(obj.method());  // 10

// エラー：関数として呼び出し
let f = obj.method;
print(f());  // エラー：selfが定義されていない
```

### 落とし穴：オブジェクト内の生のポインタ

```hemlock
// オブジェクトは自動解放されるが、内部の生のポインタはされない
fn create_objects() {
    let obj = { data: alloc(1000) };  // 生のptrは手動解放が必要
    // スコープを抜けるとobjは自動解放されるが、obj.dataはリーク！
}

// 解決策：スコープを抜ける前に生のポインタを解放
fn safe_create() {
    let obj = { data: alloc(1000) };
    // ... obj.dataを使用 ...
    free(obj.data);  // 生のポインタを明示的に解放
}  // obj自体は自動解放
```

### 落とし穴：型の混乱

```hemlock
let obj = { x: 10 };

define Point { x: i32, y: i32 }

// エラー：必須フィールド'y'がない
let p: Point = obj;
```

## 例

### 例：ベクトル数学

```hemlock
fn createVector(x, y) {
    return {
        x: x,
        y: y,

        add: fn(other) {
            return createVector(
                self.x + other.x,
                self.y + other.y
            );
        },

        length: fn() {
            return sqrt(self.x * self.x + self.y * self.y);
        },

        toString: fn() {
            return "(" + typeof(self.x) + ", " + typeof(self.y) + ")";
        }
    };
}

let v1 = createVector(3, 4);
let v2 = createVector(1, 2);
let v3 = v1.add(v2);

print(v3.toString());  // "(4, 6)"
```

### 例：シンプルなデータベース

```hemlock
fn createDatabase() {
    let records = [];
    let next_id = 1;

    return {
        insert: fn(data) {
            let record = { id: next_id, data: data };
            records.push(record);
            next_id = next_id + 1;
            return record.id;
        },

        find: fn(id) {
            let i = 0;
            while (i < records.length) {
                if (records[i].id == id) {
                    return records[i];
                }
                i = i + 1;
            }
            return null;
        },

        count: fn() {
            return records.length;
        }
    };
}

let db = createDatabase();
let id = db.insert({ name: "Alice", age: 30 });
let record = db.find(id);
print(record.data.name);  // "Alice"
```

### 例：イベントエミッター

```hemlock
fn createEventEmitter() {
    let listeners = {};

    return {
        on: fn(event, handler) {
            if (listeners[event] == null) {
                listeners[event] = [];
            }
            listeners[event].push(handler);
        },

        emit: fn(event, data) {
            if (listeners[event] != null) {
                let i = 0;
                while (i < listeners[event].length) {
                    listeners[event][i](data);
                    i = i + 1;
                }
            }
        }
    };
}

let emitter = createEventEmitter();

emitter.on("message", fn(data) {
    print("Received: " + data);
});

emitter.emit("message", "Hello!");
```

## 制限事項

現在の制限事項：

- **ディープコピーなし** - ネストされたオブジェクトは手動でコピーする必要がある（スプレッドは浅い）
- **値渡しなし** - オブジェクトは常に参照で渡される
- **計算プロパティなし** - `{[key]: value}`構文がない
- **`self`は読み取り専用** - メソッド内で`self`を再代入できない
- **プロパティ削除なし** - 一度追加したフィールドを削除できない

**注意：** オブジェクトは参照カウントされ、スコープを抜けると自動的に解放されます。詳細は[メモリ管理](memory.md#internal-reference-counting)を参照してください。

## 関連トピック

- [関数](#language-guide-functions) - メソッドはオブジェクトに格納された関数
- [配列](#language-guide-arrays) - 配列もオブジェクトのような性質を持つ
- [型](#language-guide-types) - ダックタイピングと型定義
- [エラーハンドリング](#language-guide-error-handling) - エラーオブジェクトのスロー

## 参照

- **ダックタイピング**：ダックタイピングの詳細はCLAUDE.mdの「Objects」セクションを参照
- **JSON**：JSONシリアライゼーションの詳細はCLAUDE.mdを参照
- **メモリ**：オブジェクトの割り当ては[メモリ](#language-guide-memory)を参照


--------------------------------------------------------------------------------
## パターンマッチング
--------------------------------------------------------------------------------

# パターンマッチング

Hemlockは`match`式による強力なパターンマッチングを提供し、値の分解、型のチェック、複数のケースの処理を簡潔に行う方法を提供します。

## 基本構文

```hemlock
let result = match (value) {
    pattern1 => expression1,
    pattern2 => expression2,
    _ => default_expression
};
```

Match式は`value`を各パターンに順番に評価し、最初にマッチしたアームの式の結果を返します。

## パターンの種類

### リテラルパターン

正確な値にマッチ：

```hemlock
let x = 42;
let msg = match (x) {
    0 => "zero",
    1 => "one",
    42 => "the answer",
    _ => "other"
};
print(msg);  // "the answer"
```

サポートされるリテラル：
- **整数**：`0`、`42`、`-5`
- **浮動小数点数**：`3.14`、`-0.5`
- **文字列**：`"hello"`、`"world"`
- **真偽値**：`true`、`false`
- **Null**：`null`

### ワイルドカードパターン（`_`）

バインドせずに任意の値にマッチ：

```hemlock
let x = "anything";
let result = match (x) {
    "specific" => "found it",
    _ => "wildcard matched"
};
```

### 変数バインディングパターン

マッチした値を変数にバインド：

```hemlock
let x = 100;
let result = match (x) {
    0 => "zero",
    n => "value is " + n  // nは100にバインド
};
print(result);  // "value is 100"
```

### ORパターン（`|`）

複数の選択肢にマッチ：

```hemlock
let x = 2;
let size = match (x) {
    1 | 2 | 3 => "small",
    4 | 5 | 6 => "medium",
    _ => "large"
};

// 文字列でも動作
let cmd = "quit";
let action = match (cmd) {
    "exit" | "quit" | "q" => "exiting",
    "help" | "h" | "?" => "showing help",
    _ => "unknown"
};
```

### ガード式（`if`）

パターンに条件を追加：

```hemlock
let x = 15;
let category = match (x) {
    n if n < 0 => "negative",
    n if n == 0 => "zero",
    n if n < 10 => "small",
    n if n < 100 => "medium",
    n => "large: " + n
};
print(category);  // "medium"

// 複雑なガード
let y = 12;
let result = match (y) {
    n if n % 2 == 0 && n > 10 => "even and greater than 10",
    n if n % 2 == 0 => "even",
    n => "odd"
};
```

### 型パターン

型に基づいてチェックとバインド：

```hemlock
let val = 42;
let desc = match (val) {
    num: i32 => "integer: " + num,
    str: string => "string: " + str,
    flag: bool => "boolean: " + flag,
    _ => "other type"
};
print(desc);  // "integer: 42"
```

サポートされる型：`i8`、`i16`、`i32`、`i64`、`u8`、`u16`、`u32`、`u64`、`f32`、`f64`、`bool`、`string`、`array`、`object`

## 分解パターン

### オブジェクトの分解

オブジェクトからフィールドを抽出：

```hemlock
let point = { x: 10, y: 20 };
let result = match (point) {
    { x, y } => "point at " + x + "," + y
};
print(result);  // "point at 10,20"

// リテラルフィールド値を使用
let origin = { x: 0, y: 0 };
let name = match (origin) {
    { x: 0, y: 0 } => "origin",
    { x: 0, y } => "on y-axis at " + y,
    { x, y: 0 } => "on x-axis at " + x,
    { x, y } => "point at " + x + "," + y
};
print(name);  // "origin"
```

### 配列の分解

配列の構造と要素にマッチ：

```hemlock
let arr = [1, 2, 3];
let desc = match (arr) {
    [] => "empty",
    [x] => "single: " + x,
    [x, y] => "pair: " + x + "," + y,
    [x, y, z] => "triple: " + x + "," + y + "," + z,
    _ => "many elements"
};
print(desc);  // "triple: 1,2,3"

// リテラル値を使用
let pair = [1, 2];
let result = match (pair) {
    [0, 0] => "both zero",
    [1, x] => "starts with 1, second is " + x,
    [x, 1] => "ends with 1",
    _ => "other"
};
print(result);  // "starts with 1, second is 2"
```

### 配列の残余パターン（`...`）

残りの要素をキャプチャ：

```hemlock
let nums = [1, 2, 3, 4, 5];

// 先頭と残り
let result = match (nums) {
    [first, ...rest] => "first: " + first,
    [] => "empty"
};
print(result);  // "first: 1"

// 最初の2要素
let result2 = match (nums) {
    [a, b, ...rest] => "first two: " + a + "," + b,
    _ => "too short"
};
print(result2);  // "first two: 1,2"
```

### ネストされた分解

複雑なデータのためにパターンを組み合わせ：

```hemlock
let user = {
    name: "Alice",
    address: { city: "NYC", zip: 10001 }
};

let result = match (user) {
    { name, address: { city, zip } } => name + " lives in " + city,
    _ => "unknown"
};
print(result);  // "Alice lives in NYC"

// 配列を含むオブジェクト
let data = { items: [1, 2, 3], count: 3 };
let result2 = match (data) {
    { items: [first, ...rest], count } => "first: " + first + ", total: " + count,
    _ => "no items"
};
print(result2);  // "first: 1, total: 3"
```

## 式としてのMatch

Matchは値を返す式です：

```hemlock
// 直接代入
let grade = 85;
let letter = match (grade) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    n if n >= 70 => "C",
    n if n >= 60 => "D",
    _ => "F"
};

// 文字列連結内
let msg = "Grade: " + match (grade) {
    n if n >= 70 => "passing",
    _ => "failing"
};

// 関数のreturn内
fn classify(n: i32): string {
    return match (n) {
        0 => "zero",
        n if n > 0 => "positive",
        _ => "negative"
    };
}
```

## パターンマッチングのベストプラクティス

1. **順序が重要**：パターンは上から下にチェックされる；具体的なパターンを一般的なパターンの前に配置
2. **網羅性のためにワイルドカードを使用**：すべてのケースがカバーされていると確信がない限り、常に`_`フォールバックを含める
3. **ネストした条件よりガードを優先**：ガードは意図をより明確にする
4. **手動フィールドアクセスより分解を使用**：より簡潔で安全

```hemlock
// 良い：範囲チェックにガード
match (score) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    _ => "below B"
}

// 良い：フィールドアクセスの代わりに分解
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// 避ける：過度に複雑なネストされたパターン
// 代わりに、複数のmatchに分割するかガードを使用することを検討
```

## 他の言語との比較

| 機能 | Hemlock | Rust | JavaScript |
|---------|---------|------|------------|
| 基本的なマッチング | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |
| 分解 | はい | はい | 部分的（switchは分解しない） |
| ガード | `n if n > 0 =>` | `n if n > 0 =>` | なし |
| ORパターン | `1 \| 2 \| 3 =>` | `1 \| 2 \| 3 =>` | `case 1: case 2: case 3:` |
| 残余パターン | `[a, ...rest]` | `[a, rest @ ..]` | なし |
| 型パターン | `n: i32` | `match`アームで型 | なし |
| 値を返す | はい | はい | いいえ（文） |

## 実装に関する注意

パターンマッチングはインタープリタとコンパイラの両方のバックエンドで完全なパリティを持って実装されています - 両方とも同じ入力に対して同一の結果を生成します。この機能はHemlock v1.8.0以降で利用可能です。


--------------------------------------------------------------------------------
## メモリ管理
--------------------------------------------------------------------------------

# メモリ管理

Hemlockは、割り当てと解放の明示的な制御を持つ**手動メモリ管理**を採用しています。このガイドでは、Hemlockのメモリモデル、2つのポインタ型、および完全なメモリAPIについて説明します。

---

## メモリ入門：基礎

**プログラミング初心者の方**はここから始めてください。すでにメモリ管理を理解している場合は、[設計思想](#設計思想)にスキップしてください。

### メモリ管理とは？

プログラムがデータ（テキスト、数値、リスト）を保存する必要がある場合、それを置く場所が必要です。その場所はコンピュータのメモリ（RAM）から来ます。メモリ管理とは：

1. **スペースを取得する** - 必要なときにメモリを要求する
2. **スペースを使用する** - データの読み書き
3. **返却する** - 終わったらメモリを返す

### なぜ重要なのか？

限られた本がある図書館を想像してください：
- 本を借り続けて返さなければ、最終的に本がなくなる
- すでに返した本を読もうとすると、混乱したり問題が発生する

メモリも同じように動作します。メモリを返すのを忘れると、プログラムは徐々にメモリを多く使用していきます（「メモリリーク」）。解放後のメモリを使用しようとすると、悪いことが起こります。

### 良いニュース

**ほとんどの場合、これについて考える必要はありません！**

Hemlockはほとんどの一般的な型を自動的にクリーンアップします：

```hemlock
fn example() {
    let name = "Alice";       // Hemlockがこれを管理
    let numbers = [1, 2, 3];  // これも
    let person = { age: 30 }; // これも

    // 関数が終了すると、これらはすべて自動的にクリーンアップされる！
}
```

### 考える必要があるとき

手動メモリ管理が必要なのは以下を使用する場合のみ：

1. **`alloc()`** - 生のメモリ割り当て（`ptr`を返す）
2. **`buffer()`** - 早期解放が必要な場合（オプション - スコープ終了時に自動解放）

```hemlock
// これは手動クリーンアップが必要：
let raw = alloc(100);   // 生のメモリ - あなたが解放する必要がある
// ... rawを使用 ...
free(raw);              // 必須！さもなければメモリリーク

// これは自動的にクリーンアップされる（ただし早期解放は可能）：
let buf = buffer(100);  // 安全なバッファ
// ... bufを使用 ...
// free(buf);           // オプション - スコープ終了時に自動解放
```

### シンプルなルール

> **`alloc()`を呼び出したら、`free()`を呼び出す必要がある。**
>
> それ以外はすべて自動的に処理される。

### どちらを使うべき？

| 状況 | 使用するもの | 理由 |
|-----------|----------|-----|
| **始めたばかり** | `buffer()` | 安全、境界チェック、自動クリーンアップ |
| **バイトストレージが必要** | `buffer()` | 安全で簡単 |
| **Cライブラリ（FFI）と連携** | `alloc()` / `ptr` | C相互運用に必須 |
| **最大パフォーマンス** | `alloc()` / `ptr` | 境界チェックのオーバーヘッドなし |
| **分からない** | `buffer()` | 常により安全な選択 |

### クイック例：安全 vs 生

```hemlock
// 推奨：安全なバッファ
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // エラー - Hemlockが停止（境界チェック）
    free(data);             // クリーンアップ
}

// 上級者向け：生のポインタ（必要な場合のみ）
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // 危険 - 境界チェックなし、メモリ破壊！
    free(data);             // クリーンアップ
}
```

**`buffer()`から始めましょう。生のポインタが特に必要な場合のみ`alloc()`を使用してください。**

---

## 設計思想

Hemlockは、合理的なデフォルトを持つ明示的なメモリ管理の原則に従います：
- ガベージコレクションなし（予測不可能な一時停止なし）
- 一般的な型（string、array、object、buffer）の内部参照カウント
- 生のポインタ（`ptr`）は手動の`free()`が必要

このハイブリッドアプローチにより、必要なときは完全な制御（生のポインタ）を提供しつつ、一般的な使用例（スコープ終了時に自動解放される参照カウント型）での一般的なバグを防ぎます。

## 内部参照カウント

ランタイムは**内部参照カウント**を使用してオブジェクトの寿命を管理します。参照カウント型のほとんどのローカル変数では、クリーンアップは自動的かつ決定論的です。

### 参照カウントが処理するもの

ランタイムは以下の場合に参照カウントを自動的に管理します：

1. **変数が再代入される** - 古い値が解放される：
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first"は内部的に解放、"second"のref_count = 1
   ```

2. **スコープを抜ける** - ローカル変数が解放される：
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // 関数が戻るとarrが解放される
   ```

3. **コンテナが解放される** - 要素が解放される：
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // obj1とobj2の参照カウントがデクリメントされる
   ```

### `free()`が必要な場合 vs 自動の場合

**自動（`free()`不要）：** 参照カウント型のローカル変数はスコープを抜けると解放される：

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... 使用する ...
}  // 関数が戻るとすべて自動的に解放 - free()不要
```

**手動の`free()`が必要：**

1. **生のポインタ** - `alloc()`には参照カウントがない：
   ```hemlock
   let p = alloc(64);
   // ... pを使用 ...
   free(p);  // 常に必須 - そうでなければリーク
   ```

2. **早期クリーンアップ** - スコープ終了前に解放してメモリを早く解放：
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... bigの使用終了 ...
       free(big);  // 今すぐ解放、関数の戻りを待たない
       // ... bigを必要としない追加の処理 ...
   }
   ```

3. **長期間存続するデータ** - グローバルまたは永続構造体に格納されたデータ：
   ```hemlock
   let cache = {};  // モジュールレベル、解放されない限りプログラム終了まで存続

   fn cleanup() {
       free(cache);  // 長期間存続するデータの手動クリーンアップ
   }
   ```

### 参照カウント vs ガベージコレクション

| 側面 | Hemlock参照カウント | ガベージコレクション |
|--------|---------------------|-------------------|
| クリーンアップのタイミング | 決定論的（refが0になると即座） | 非決定論的（GCが決定） |
| ユーザーの責任 | `free()`を呼ぶ必要がある | 完全自動 |
| ランタイムの一時停止 | なし | 「世界を止める」一時停止 |
| 可視性 | 隠れた実装の詳細 | 通常不可視 |
| 循環 | 訪問済みセットの追跡で処理 | トレースで処理 |

### 参照カウントを持つ型

| 型 | 参照カウント | 備考 |
|------|------------|-------|
| `ptr` | いいえ | 常に手動の`free()`が必要 |
| `buffer` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |
| `array` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |
| `object` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |
| `string` | はい | 完全自動、`free()`不要 |
| `function` | はい | 完全自動（クロージャ環境） |
| `task` | はい | スレッドセーフなアトミック参照カウント |
| `channel` | はい | スレッドセーフなアトミック参照カウント |
| プリミティブ | いいえ | スタック割り当て、ヒープ割り当てなし |

### なぜこの設計か？

このハイブリッドアプローチにより：
- **明示的な制御** - いつ解放するかを決定できる
- **スコープバグからの安全性** - 再代入でリークしない
- **予測可能なパフォーマンス** - GCの一時停止なし
- **クロージャのサポート** - 関数が安全に変数をキャプチャできる

設計思想は変わりません：あなたが制御しますが、ランタイムが再代入時のリークやコンテナでの二重解放などの一般的なバグを防ぐのを助けます。

## 2つのポインタ型

Hemlockは、異なる安全特性を持つ2つの異なるポインタ型を提供します：

### `ptr` - 生のポインタ（危険）

生のポインタは**ただのアドレス**で、最小限の安全保証しかありません：

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // 解放を覚えておく必要がある
```

**特徴：**
- ただの8バイトのアドレス
- 境界チェックなし
- 長さの追跡なし
- ユーザーが完全に寿命を管理
- エキスパートとFFI向け

**使用例：**
- 低レベルシステムプログラミング
- 外部関数インターフェース（FFI）
- パフォーマンスクリティカルなコード
- 完全な制御が必要な場合

**危険：**
```hemlock
let p = alloc(10);
let q = p + 100;  // 割り当て範囲をはるかに超えている - 許可されるが危険
free(p);
let x = *p;       // ダングリングポインタ - 未定義動作
free(p);          // 二重解放 - クラッシュする
```

### `buffer` - 安全なラッパー（推奨）

バッファは**境界チェックされたアクセス**を提供しつつ、手動解放が必要です：

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // 境界チェックあり
print(b.length);        // 64
free(b);                // まだ手動
```

**特徴：**
- ポインタ + 長さ + 容量
- アクセス時に境界チェック
- まだ手動の`free()`が必要
- ほとんどのコードでより良いデフォルト

**プロパティ：**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100（現在のサイズ）
print(buf.capacity);    // 100（割り当て容量）
```

**境界チェック：**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // エラー：インデックスが範囲外
```

## メモリAPI

### コア割り当て

**`alloc(bytes)` - 生のメモリを割り当て**
```hemlock
let p = alloc(1024);  // 1KBを割り当て、ptrを返す
// ... メモリを使用
free(p);
```

**`buffer(size)` - 安全なバッファを割り当て**
```hemlock
let buf = buffer(256);  // 256バイトのバッファを割り当て
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - メモリを解放**
```hemlock
let p = alloc(100);
free(p);  // メモリリークを避けるために解放必須

let buf = buffer(100);
free(buf);  // ptrとbufferの両方で動作
```

**重要：** `free()`は`ptr`と`buffer`型の両方で動作します。

### メモリ操作

**`memset(ptr, byte, size)` - メモリを埋める**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // 100バイトをゼロクリア
memset(p, 65, 10);     // 最初の10バイトを'A'で埋める
free(p);
```

**`memcpy(dest, src, size)` - メモリをコピー**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // srcからdstに50バイトをコピー
free(src);
free(dst);
```

**`realloc(ptr, size)` - 割り当てをリサイズ**
```hemlock
let p = alloc(100);
// ... 100バイトを使用
p = realloc(p, 200);   // 200バイトにリサイズ
// ... 200バイトを使用
free(p);
```

**注意：** `realloc()`後、古いポインタは無効になる可能性があります。常に返されたポインタを使用してください。

### 型付き割り当て

Hemlockは便利のために型付き割り当てヘルパーを提供します：

```hemlock
let arr = talloc(i32, 100);  // 100個のi32値を割り当て（400バイト）
let size = sizeof(i32);      // 4を返す（バイト）
```

**`sizeof(type)`**は型のバイトサイズを返します：
- `sizeof(i8)` / `sizeof(u8)` → 1
- `sizeof(i16)` / `sizeof(u16)` → 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` → 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` → 8
- `sizeof(ptr)` → 8（64ビットシステム）

**`talloc(type, count)`**は`type`の`count`要素を割り当てます：

```hemlock
let ints = talloc(i32, 10);   // 10個のi32値に40バイト
let floats = talloc(f64, 5);  // 5個のf64値に40バイト
free(ints);
free(floats);
```

## よくあるパターン

### パターン：割り当て、使用、解放

メモリ管理の基本パターン：

```hemlock
// 1. 割り当て
let data = alloc(1024);

// 2. 使用
memset(data, 0, 1024);
// ... 処理を行う

// 3. 解放
free(data);
```

### パターン：安全なバッファの使用

境界チェックされたアクセスにはバッファを優先：

```hemlock
let buf = buffer(256);

// 安全な反復
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### パターン：try/finallyによるリソース管理

エラー時もクリーンアップを確実に：

```hemlock
let data = alloc(1024);
try {
    // ... 危険な操作
    process(data);
} finally {
    free(data);  // エラー時も常に解放
}
```

## メモリ安全性の考慮事項

### 二重解放

**許可されるがクラッシュする：**
```hemlock
let p = alloc(100);
free(p);
free(p);  // クラッシュ：二重解放を検出
```

**防止策：**
```hemlock
let p = alloc(100);
free(p);
p = null;  // 解放後にnullを設定

if (p != null) {
    free(p);  // 実行されない
}
```

### ダングリングポインタ

**許可されるが未定義動作：**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // 未定義：解放されたメモリを読み取り
```

**防止策：** 解放後のメモリにアクセスしない。

### メモリリーク

**作成しやすく、デバッグしにくい：**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // 解放を忘れた！
    return;  // メモリがリーク
}
```

**防止策：** 常に`alloc()`と`free()`をペアにする：
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... pを使用
    } finally {
        free(p);  // 常に解放
    }
}
```

### ポインタ演算

**許可されるが危険：**
```hemlock
let p = alloc(10);
let q = p + 100;  // 割り当て境界をはるかに超えている
*q = 42;          // 未定義：範囲外の書き込み
free(p);
```

**境界チェックにはバッファを使用：**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // エラー：境界チェックがオーバーフローを防止
```

## ベストプラクティス

1. **デフォルトで`buffer`** - 特に生の`ptr`が必要でない限り`buffer`を使用
2. **alloc/freeをマッチ** - すべての`alloc()`には正確に1つの`free()`
3. **try/finallyを使用** - 例外処理でクリーンアップを確実に
4. **解放後にnull** - use-after-freeをキャッチするために解放後にポインタをnullに設定
5. **境界チェック** - 自動境界チェックにはバッファのインデックスを使用
6. **所有権を文書化** - どのコードが各割り当てを所有し解放するかを明確に

## 例

### 例：動的文字列ビルダー

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // 呼び出し元が解放する必要がある
}

let msg = build_message(5);
// ... msgを使用
free(msg);
```

### 例：安全な配列操作

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // 配列を埋める
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // 処理
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // 常にクリーンアップ
    }
}
```

### 例：メモリプールパターン

```hemlock
// シンプルなメモリプール（簡略化）
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool exhausted";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// プールを使用
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// プール全体を一度に解放
free(pool);
```

## 制限事項

注意すべき現在の制限事項：

- **生のポインタは手動解放が必要** - `alloc()`は参照カウントのない`ptr`を返す
- **カスタムアロケータなし** - システムのmalloc/freeのみ

**注意：** 参照カウント型（string、array、object、buffer）はスコープを抜けると自動的に解放されます。`alloc()`からの生の`ptr`のみ明示的な`free()`が必要です。

## 関連トピック

- [文字列](#language-guide-strings) - 文字列のメモリ管理とUTF-8エンコーディング
- [配列](#language-guide-arrays) - 動的配列とそのメモリ特性
- [オブジェクト](#language-guide-objects) - オブジェクトの割り当てと寿命
- [エラーハンドリング](#language-guide-error-handling) - クリーンアップにtry/finallyを使用

## 参照

- **設計思想**: CLAUDE.mdの「Memory Management」セクションを参照
- **型システム**: `ptr`と`buffer`型の詳細は[型](#language-guide-types)を参照
- **FFI**: 生のポインタは外部関数インターフェースに不可欠


--------------------------------------------------------------------------------
## モジュール
--------------------------------------------------------------------------------

# Hemlockモジュールシステム

このドキュメントでは、Hemlockに実装されたES6スタイルのimport/exportモジュールシステムについて説明します。

## 概要

HemlockはES6スタイルのimport/export構文を持つファイルベースのモジュールシステムをサポートしています。モジュールは：
- **シングルトン**：各モジュールは1回だけロードされキャッシュされる
- **ファイルベース**：モジュールはディスク上の.hmlファイルに対応
- **明示的インポート**：依存関係はimport文で宣言
- **トポロジカル実行**：依存関係は依存先より先に実行

パッケージ管理とサードパーティ依存関係については、[hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm)を参照してください。

## 構文

### Export文

**インライン名前付きエクスポート：**
```hemlock
export fn add(a, b) {
    return a + b;
}

export const PI = 3.14159;
export let counter = 0;
```

**エクスポートリスト：**
```hemlock
fn add(a, b) { return a + b; }
fn subtract(a, b) { return a - b; }

export { add, subtract };
```

**Export Extern（FFI関数）：**
```hemlock
import "libc.so.6";

// 他のモジュールで使用するためにFFI関数をエクスポート
export extern fn strlen(s: string): i32;
export extern fn getpid(): i32;
```

FFI関数のエクスポートの詳細については、[FFIドキュメント](../advanced/ffi.md#exporting-ffi-functions)を参照してください。

**Export Define（構造体型）：**
```hemlock
// 構造体型定義をエクスポート
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}
```

**重要：** エクスポートされた構造体型は、モジュールがロードされるとグローバルに登録されます。モジュールから何かをインポートすると自動的に利用可能になります - 名前で明示的にインポートする必要はありません（できません）：

```hemlock
// 良い - 構造体型はどのインポート後も自動的に利用可能
import { some_function } from "./my_module.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };  // 動作する！

// 悪い - 構造体型を明示的にインポートできない
import { Vector2 } from "./my_module.hml";  // エラー：未定義の変数 'Vector2'
```

構造体型のエクスポートの詳細については、[FFIドキュメント](../advanced/ffi.md#exporting-struct-types)を参照してください。

**再エクスポート：**
```hemlock
// 別のモジュールから再エクスポート
export { add, subtract } from "./math.hml";
```

### Import文

**名前付きインポート：**
```hemlock
import { add, subtract } from "./math.hml";
print(add(1, 2));  // 3
```

**名前空間インポート：**
```hemlock
import * as math from "./math.hml";
print(math.add(1, 2));  // 3
print(math.PI);  // 3.14159
```

**エイリアス：**
```hemlock
import { add as sum, subtract as diff } from "./math.hml";
print(sum(1, 2));  // 3
```

## モジュール解決

### パスの種類

**相対パス：**
```hemlock
import { foo } from "./module.hml";       // 同じディレクトリ
import { bar } from "../parent.hml";      // 親ディレクトリ
import { baz } from "./sub/nested.hml";   // サブディレクトリ
```

**絶対パス：**
```hemlock
import { foo } from "/absolute/path/to/module.hml";
```

**拡張子の処理：**
- `.hml`拡張子は省略可能 - 自動的に追加される
- `./math`は`./math.hml`に解決

## 機能

### 循環依存の検出

モジュールシステムは循環依存を検出してエラーを報告します：

```
Error: Circular dependency detected when loading '/path/to/a.hml'
```

### モジュールキャッシング

モジュールは1回ロードされキャッシュされます。同じモジュールの複数のインポートは同じインスタンスを返します：

```hemlock
// counter.hml
export let count = 0;
export fn increment() {
    count = count + 1;
}

// a.hml
import { count, increment } from "./counter.hml";
increment();
print(count);  // 1

// b.hml
import { count } from "./counter.hml";  // 同じインスタンス！
print(count);  // まだ1（共有状態）
```

### インポートの不変性

インポートされたバインディングは再代入できません：

```hemlock
import { add } from "./math.hml";
add = fn() { };  // エラー：インポートされたバインディングを再代入できない
```

## 実装の詳細

### アーキテクチャ

**ファイル：**
- `include/module.h` - モジュールシステムAPI
- `src/module.c` - モジュールのロード、キャッシング、実行
- `src/parser.c`のパーササポート
- `src/interpreter/runtime.c`のランタイムサポート

**主要コンポーネント：**
1. **ModuleCache**：絶対パスでインデックスされたロード済みモジュールを維持
2. **Module**：ASTとエクスポートを持つロード済みモジュールを表す
3. **パス解決**：相対/絶対パスを正規パスに解決
4. **トポロジカル実行**：依存順序でモジュールを実行

### モジュールロードプロセス

1. **パースフェーズ**：モジュールファイルをトークン化してパース
2. **依存関係解決**：インポートされたモジュールを再帰的にロード
3. **サイクル検出**：モジュールがすでにロード中かチェック
4. **キャッシング**：絶対パスでキャッシュにモジュールを格納
5. **実行フェーズ**：トポロジカル順序（依存関係が先）で実行

### API

```c
// 高レベルAPI
int execute_file_with_modules(const char *file_path,
                               int argc, char **argv,
                               ExecutionContext *ctx);

// 低レベルAPI
ModuleCache* module_cache_new(const char *initial_dir);
void module_cache_free(ModuleCache *cache);
Module* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);
void execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);
```

## テスト

テストモジュールは`tests/modules/`と`tests/parity/modules/`にあります：

- `math.hml` - エクスポートを持つ基本モジュール
- `test_import_named.hml` - 名前付きインポートテスト
- `test_import_namespace.hml` - 名前空間インポートテスト
- `test_import_alias.hml` - インポートエイリアステスト
- `export_extern.hml` - export extern FFI関数テスト（Linux）

## パッケージインポート（hpm）

[hpm](https://github.com/hemlang/hpm)がインストールされていれば、GitHubからサードパーティパッケージをインポートできます：

```hemlock
// パッケージルートからインポート（package.jsonの"main"を使用）
import { app, router } from "hemlang/sprout";

// サブパスからインポート
import { middleware } from "hemlang/sprout/middleware";

// 標準ライブラリ（Hemlockに組み込み）
import { HashMap } from "@stdlib/collections";
```

パッケージは`hem_modules/`にインストールされ、GitHub `owner/repo`構文を使用して解決されます。

```bash
# パッケージをインストール
hpm install hemlang/sprout

# バージョン制約付きでインストール
hpm install hemlang/sprout@^1.0.0
```

詳細は[hpmドキュメント](https://github.com/hemlang/hpm)を参照してください。

## 現在の制限事項

1. **動的インポートなし**：ランタイム関数としての`import()`はサポートされていない
2. **条件付きエクスポートなし**：エクスポートはトップレベルでなければならない
3. **静的ライブラリパス**：FFIライブラリインポートは静的パスを使用（プラットフォーム固有）

## 将来の作業

- `import()`関数による動的インポート
- 条件付きエクスポート
- モジュールメタデータ（`import.meta`）
- ツリーシェイキングとデッドコード除去

## 例

動作するモジュールシステムの例は`tests/modules/`を参照してください。

モジュール構造の例：
```
project/
├── main.hml
├── lib/
│   ├── math.hml
│   ├── string.hml
│   └── index.hml（バレルモジュール）
└── utils/
    └── helpers.hml
```

使用例：
```hemlock
// lib/math.hml
export fn add(a, b) { return a + b; }
export fn multiply(a, b) { return a * b; }

// lib/index.hml（バレル）
export { add, multiply } from "./math.hml";

// main.hml
import { add } from "./lib/index.hml";
print(add(2, 3));  // 5
```


--------------------------------------------------------------------------------
## ルーン
--------------------------------------------------------------------------------

# ルーン

ルーンはHemlockでの文字操作のために、**Unicodeコードポイント**（U+0000からU+10FFFF）を独自の型として表現します。バイト（u8）とは異なり、ルーンはあらゆる言語の文字や絵文字を表現できる完全なUnicode文字です。

## 概要

```hemlock
let ch = 'A';           // ルーンリテラル
let emoji = '🚀';       // マルチバイト文字を1つのルーンとして
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // 文字列 + ルーンの連結
let r = '>' + " msg";   // ルーン + 文字列の連結
```

## ルーンとは？

ルーンはUnicodeコードポイントを表す**32ビットの値**です：

- **範囲：** 0から0x10FFFF（1,114,111個の有効なコードポイント）
- **数値型ではない** - 文字表現に使用
- **u8/charとは異なる** - ルーンは完全なUnicode、u8はただのバイト
- **文字列のインデックスで返される** - `str[0]`はバイトではなくルーンを返す

**なぜルーンか？**
- Hemlock文字列はUTF-8エンコード
- 1つのUnicode文字はUTF-8で1〜4バイト
- ルーンにより、部分的なバイトではなく完全な文字を扱える

## ルーンリテラル

### 基本構文

シングルクォートでルーンリテラルを表記：

```hemlock
let a = 'A';            // ASCII文字
let b = '0';            // 数字文字
let c = '!';            // 句読点
let d = ' ';            // スペース
```

### マルチバイトUTF-8文字

ルーンはあらゆるUnicode文字を表現可能：

```hemlock
// 絵文字
let rocket = '🚀';      // 絵文字（U+1F680）
let heart = '❤';        // ハート（U+2764）
let smile = '😀';       // 笑顔（U+1F600）

// CJK文字
let chinese = '中';     // 中国語（U+4E2D）
let japanese = 'あ';    // ひらがな（U+3042）
let korean = '한';      // ハングル（U+D55C）

// 記号
let check = '✓';        // チェックマーク（U+2713）
let arrow = '→';        // 右矢印（U+2192）
```

### エスケープシーケンス

特殊文字のための一般的なエスケープシーケンス：

```hemlock
let newline = '\n';     // 改行（U+000A）
let tab = '\t';         // タブ（U+0009）
let backslash = '\\';   // バックスラッシュ（U+005C）
let quote = '\'';       // シングルクォート（U+0027）
let dquote = '"';       // ダブルクォート（U+0022）
let null_char = '\0';   // ヌル文字（U+0000）
let cr = '\r';          // キャリッジリターン（U+000D）
```

**利用可能なエスケープシーケンス：**
- `\n` - 改行（ラインフィード）
- `\t` - 水平タブ
- `\r` - キャリッジリターン
- `\0` - ヌル文字
- `\\` - バックスラッシュ
- `\'` - シングルクォート
- `\"` - ダブルクォート

### Unicodeエスケープ

Unicodeコードポイントには`\u{XXXXXX}`構文を使用（最大6桁の16進数）：

```hemlock
let rocket = '\u{1F680}';   // 🚀 Unicodeエスケープで絵文字
let heart = '\u{2764}';     // ❤ ハート
let ascii = '\u{41}';       // 'A' エスケープで
let max = '\u{10FFFF}';     // 最大Unicodeコードポイント

// 先頭のゼロはオプション
let a = '\u{41}';           // '\u{0041}'と同じ
let b = '\u{0041}';
```

**ルール：**
- 範囲：`\u{0}`から`\u{10FFFF}`
- 16進数桁：1から6桁
- 大文字小文字を区別しない：`\u{1F680}`または`\u{1f680}`
- 有効なUnicode範囲外の値はエラー

## 文字列 + ルーンの連結

ルーンは文字列と連結可能：

```hemlock
// 文字列 + ルーン
let greeting = "Hello" + '!';       // "Hello!"
let decorated = "Text" + '✓';       // "Text✓"

// ルーン + 文字列
let prefix = '>' + " Message";      // "> Message"
let bullet = '•' + " Item";         // "• Item"

// 複数の連結
let msg = "Hi " + '👋' + " World " + '🌍';  // "Hi 👋 World 🌍"

// メソッドチェーンも動作
let result = ('>' + " Important").to_upper();  // "> IMPORTANT"
```

**動作の仕組み：**
- ルーンは自動的にUTF-8にエンコード
- 連結時に文字列に変換
- 文字列連結演算子がこれを透過的に処理

## 型変換

ルーンは他の型との間で変換可能。

### 整数 ↔ ルーン

コードポイント値を扱うために整数とルーンの間で変換：

```hemlock
// 整数からルーン（コードポイント値）
let code: rune = 65;            // 'A'（ASCII 65）
let emoji_code: rune = 128640;  // U+1F680（🚀）

// ルーンから整数（コードポイント値を取得）
let r = 'Z';
let value: i32 = r;             // 90（ASCII値）

let rocket = '🚀';
let code: i32 = rocket;         // 128640（U+1F680）
```

**範囲チェック：**
- 整数からルーン：[0, 0x10FFFF]の範囲内である必要がある
- 範囲外の値は実行時エラー
- ルーンから整数：常に成功（コードポイントを返す）

### ルーン → 文字列

ルーンは明示的に文字列に変換可能：

```hemlock
// 明示的な変換
let ch: string = 'H';           // "H"
let emoji: string = '🚀';       // "🚀"

// 連結時は自動
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8（バイト） → ルーン

任意のu8値（0-255）はルーンに変換可能：

```hemlock
// ASCII範囲（0-127）
let byte: u8 = 65;
let rune_val: rune = byte;      // 'A'

// 拡張ASCII / Latin-1（128-255）
let extended: u8 = 200;
let r: rune = extended;         // U+00C8（È）

// 注意：値0-127はASCII、128-255はLatin-1
```

### チェーン変換

型変換はチェーン可能：

```hemlock
// i32 → ルーン → 文字列
let code: i32 = 128512;         // 笑顔のコードポイント
let r: rune = code;             // 😀
let s: string = r;              // "😀"

// 1つの式で全部
let emoji: string = 128640;     // 暗黙のi32 → ルーン → 文字列（🚀）
```

## ルーン操作

### 出力

ルーンの表示方法はコードポイントに依存：

```hemlock
let ascii = 'A';
print(ascii);                   // 'A'（引用符付き、印刷可能ASCII）

let emoji = '🚀';
print(emoji);                   // U+1F680（非ASCIIはUnicode表記）

let tab = '\t';
print(tab);                     // U+0009（非印刷は16進数で）

let space = ' ';
print(space);                   // ' '（印刷可能）
```

**出力形式：**
- 印刷可能ASCII（32-126）：引用符付き文字 `'A'`
- 非印刷またはUnicode：16進表記 `U+XXXX`

### 型チェック

`typeof()`を使用して値がルーンかチェック：

```hemlock
let r = '🚀';
print(typeof(r));               // "rune"

let s = "text";
let ch = s[0];
print(typeof(ch));              // "rune"（インデックスはルーンを返す）

let num = 65;
print(typeof(num));             // "i32"
```

### 比較

ルーンは等価性で比較可能：

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// 大文字小文字を区別
let upper = 'A';
let lower = 'a';
print(upper == lower);          // false

// ルーンは整数（コードポイント値）と比較可能
print(a == 65);                 // true（暗黙の変換）
print('🚀' == 128640);          // true
```

**比較演算子：**
- `==` - 等しい
- `!=` - 等しくない
- `<`、`>`、`<=`、`>=` - コードポイント順序

```hemlock
print('A' < 'B');               // true（65 < 66）
print('a' > 'Z');               // true（97 > 90）
```

## 文字列インデックスとの連携

文字列のインデックスはバイトではなくルーンを返す：

```hemlock
let s = "Hello🚀";
let h = s[0];                   // 'H'（ルーン）
let rocket = s[5];              // '🚀'（ルーン）

print(typeof(h));               // "rune"
print(typeof(rocket));          // "rune"

// 必要なら文字列に変換
let h_str: string = h;          // "H"
let rocket_str: string = rocket; // "🚀"
```

**重要：** 文字列のインデックスはバイトオフセットではなくコードポイント位置を使用：

```hemlock
let text = "Hi🚀!";
// コードポイント位置：0='H', 1='i', 2='🚀', 3='!'
// バイト位置：      0='H', 1='i', 2-5='🚀', 6='!'

let r = text[2];                // '🚀'（コードポイント2）
print(typeof(r));               // "rune"
```

## 例

### 例：文字分類

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### 例：大文字小文字変換

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // 大文字に変換（32を引く）
        let code: i32 = r;
        code = code - 32;
        return code;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // 小文字に変換（32を足す）
        let code: i32 = r;
        code = code + 32;
        return code;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### 例：文字の反復

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Position " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("Hi🚀");
// Position 0: 'H'
// Position 1: 'i'
// Position 2: U+1F680
```

### 例：ルーンから文字列を構築

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let result = "";
    let i = 0;
    while (i < count) {
        result = result + ch;
        i = i + 1;
    }
    return result;
}

let line = repeat_char('=', 40);  // "========================================"
let stars = repeat_char('⭐', 5);  // "⭐⭐⭐⭐⭐"
```

## よくあるパターン

### パターン：文字フィルタ

```hemlock
fn filter_digits(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

let text = "abc123def456";
let digits = filter_digits(text);  // "123456"
```

### パターン：文字カウント

```hemlock
fn count_char(s: string, target: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == target) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = "hello world";
let l_count = count_char(text, 'l');  // 3
let o_count = count_char(text, 'o');  // 2
```

## ベストプラクティス

1. **文字操作にはルーンを使用** - テキスト処理でバイトを使おうとしない
2. **文字列のインデックスはルーンを返す** - `str[i]`がルーンを与えることを覚えておく
3. **Unicode対応の比較** - ルーンはあらゆるUnicode文字を処理
4. **必要なら変換** - ルーンは簡単に文字列や整数に変換可能
5. **絵文字でテスト** - 常にマルチバイト文字で文字操作をテスト

## よくある落とし穴

### 落とし穴：ルーン vs バイトの混乱

```hemlock
// やらない：ルーンをバイトとして扱う
let r: rune = '🚀';
let b: u8 = r;              // エラー：ルーンのコードポイント128640はu8に収まらない

// やる：適切な変換を使用
let r: rune = '🚀';
let code: i32 = r;          // OK：128640
```

### 落とし穴：文字列のバイトインデックス

```hemlock
// やらない：バイトインデックスを想定
let s = "🚀";
let byte = s.byte_at(0);    // 240（最初のUTF-8バイト、完全な文字ではない）

// やる：コードポイントインデックスを使用
let s = "🚀";
let rune = s[0];            // '🚀'（完全な文字）
let rune2 = s.char_at(0);   // '🚀'（明示的なメソッド）
```

## 関連トピック

- [文字列](#language-guide-strings) - 文字列操作とUTF-8の扱い
- [型](#language-guide-types) - 型システムと変換
- [制御フロー](#language-guide-control-flow) - 比較でのルーンの使用

## 参照

- **Unicode標準**：UnicodeコードポイントはUnicodeコンソーシアムによって定義
- **UTF-8エンコーディング**：UTF-8の詳細は[文字列](#language-guide-strings)を参照
- **型変換**：変換ルールは[型](#language-guide-types)を参照


--------------------------------------------------------------------------------
## 制御フロー
--------------------------------------------------------------------------------

# 制御フロー

Hemlockは、必須のブレースと明示的な構文を備えた、おなじみのCスタイルの制御フローを提供します。このガイドでは、条件分岐、ループ、switch文、演算子について説明します。

## 概要

利用可能な制御フロー機能：

- `if`/`else`/`else if` - 条件分岐
- `while`ループ - 条件ベースの反復
- `for`ループ - Cスタイルとfor-in反復
- `loop` - 無限ループ（`while (true)`よりクリーン）
- `switch`文 - 多方向分岐
- `break`/`continue` - ループ制御
- ループラベル - ネストされたループ向けのターゲット指定break/continue
- `defer` - 遅延実行（クリーンアップ）
- 論理演算子：`&&`、`||`、`!`
- 比較演算子：`==`、`!=`、`<`、`>`、`<=`、`>=`
- ビット演算子：`&`、`|`、`^`、`<<`、`>>`、`~`

## If文

### 基本的なIf/Else

```hemlock
if (x > 10) {
    print("large");
} else {
    print("small");
}
```

**ルール：**
- ブレースはすべてのブランチで**常に必須**
- 条件は括弧で囲む必要がある
- オプションのブレースなし（Cとは異なる）

### Elseなしのif

```hemlock
if (x > 0) {
    print("positive");
}
// elseブランチは不要
```

### Else-Ifチェーン

```hemlock
if (x > 100) {
    print("very large");
} else if (x > 50) {
    print("large");
} else if (x > 10) {
    print("medium");
} else {
    print("small");
}
```

**注意：** `else if`はネストされたif文の糖衣構文です。これらは等価です：

```hemlock
// else if（糖衣構文）
if (a) {
    foo();
} else if (b) {
    bar();
}

// 等価なネストされたif
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### ネストされたIf文

```hemlock
if (x > 0) {
    if (x < 10) {
        print("single digit positive");
    } else {
        print("multi-digit positive");
    }
} else {
    print("non-positive");
}
```

## Whileループ

条件ベースの反復：

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**無限ループ（旧スタイル）：**
```hemlock
while (true) {
    // ... 処理を行う
    if (should_exit) {
        break;
    }
}
```

**注意：** 無限ループには`loop`キーワードを推奨（下記参照）。

## Loop（無限ループ）

`loop`キーワードは無限ループのためのよりクリーンな構文を提供します：

```hemlock
loop {
    // ... 処理を行う
    if (should_exit) {
        break;
    }
}
```

**`while (true)`と等価ですが、意図がより明確です。**

### Breakを使った基本的なLoop

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// 出力：0, 1, 2, 3, 4
```

### Continueを使ったLoop

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // 3の出力をスキップ
    }
    print(i);
}
// 出力：1, 2, 4, 5
```

### ネストされたLoop

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// 出力：0, 1, 2, 10, 11, 12
```

### Loopの使用タイミング

- **`loop`を使用** - `break`で終了する意図的な無限ループ
- **`while`を使用** - 自然な終了条件がある場合
- **`for`を使用** - 既知の回数または コレクションを反復する場合

## Forループ

### Cスタイルのfor

古典的な3部構成のforループ：

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**構成要素：**
- **初期化子**：`let i = 0` - ループ前に1回実行
- **条件**：`i < 10` - 各反復前にチェック
- **更新**：`i = i + 1` - 各反復後に実行

**スコープ：**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// iはここではアクセスできない（ループスコープ）
```

### For-Inループ

配列要素の反復：

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // 各要素を出力
}
```

**インデックスと値を使用：**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`Index: ${i}, Value: ${arr[i]}`);
}
```

## Switch文

値に基づく多方向分岐：

### 基本的なSwitch

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("one");
        break;
    case 2:
        print("two");
        break;
    case 3:
        print("three");
        break;
}
```

### Defaultを使ったSwitch

```hemlock
let color = "blue";

switch (color) {
    case "red":
        print("stop");
        break;
    case "yellow":
        print("slow");
        break;
    case "green":
        print("go");
        break;
    default:
        print("unknown color");
        break;
}
```

**ルール：**
- `default`は他のどのcaseにもマッチしない場合にマッチ
- `default`はswitch本体のどこにでも配置可能
- defaultケースは1つのみ許可

### フォールスルー動作

`break`なしのcaseは次のcaseにフォールスルー（Cスタイルの動作）。これは**意図的な**もので、caseをグループ化するために使用できます：

```hemlock
let grade = 85;

switch (grade) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C or below");
        break;
}
```

**明示的なフォールスルーの例：**
```hemlock
let day = 3;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Weekday");
        break;
    case 6:
    case 7:
        print("Weekend");
        break;
}
```

**重要：** 一部のモダンな言語とは異なり、Hemlockは明示的な`fallthrough`キーワードを必要としません。caseは`break`、`return`、または`throw`で終了しない限り自動的にフォールスルーします。意図しないフォールスルーを防ぐために常に`break`を使用してください。

### Returnを使ったSwitch

関数内では、`return`はswitchを即座に終了します：

```hemlock
fn get_day_name(day: i32): string {
    switch (day) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        default:
            return "Unknown";
    }
}
```

### Switchの値の型

Switchは任意の値の型で動作します：

```hemlock
// 整数
switch (count) {
    case 0: print("zero"); break;
    case 1: print("one"); break;
}

// 文字列
switch (name) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// 真偽値
switch (flag) {
    case true: print("on"); break;
    case false: print("off"); break;
}
```

**注意：** caseは値の等価性を使用して比較されます。

## BreakとContinue

### Break

最も内側のループまたはswitchを終了：

```hemlock
// ループ内
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // ループを終了
    }
    print(i);
    i = i + 1;
}

// switch内
switch (x) {
    case 1:
        print("one");
        break;  // switchを終了
    case 2:
        print("two");
        break;
}
```

### Continue

ループの次の反復にスキップ：

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // iが5のとき反復をスキップ
    }
    print(i);  // 0,1,2,3,4,6,7,8,9を出力
}
```

**違い：**
- `break` - ループを完全に終了
- `continue` - 次の反復にスキップ

## ループラベル

ループラベルにより、`break`と`continue`が最も内側のループだけでなく、特定の外側のループをターゲットにできます。ネストされたループで外側のループを内側から制御する必要がある場合に便利です。

### ラベル付きBreak

内側のループから外側のループを終了：

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // 外側のwhileループを終了
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// 出力：0, 1, 2, 10（i=1, j=1で停止）
```

### ラベル付きContinue

外側のループの次の反復にスキップ：

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // 内側ループの残りをスキップし、外側を続行
        }
        print(i * 10 + j);
    }
}
// i=2, j=1のとき：次の外側反復にスキップ
```

### Forループでのラベル

ラベルはすべてのループタイプで動作します：

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### For-Inループでのラベル

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### Loopキーワードでのラベル

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### 複数のラベル

異なるネストレベルにラベルを設定できます：

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // 中間ループの次の反復にスキップ
            }
            if (a == 1 && b == 1) {
                break outer;      // 最外ループを終了
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### ラベル付きループでのラベルなしBreak/Continue

ラベルなしの`break`と`continue`は、外側のループにラベルがあっても通常通り動作します（最も内側のループに影響）：

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // 内側のループのみ終了
        }
        print(x * 10 + y);
    }
}
// 出力：0, 1, 10, 11, 20, 21
```

### ラベルの構文

- ラベルはコロンが続く識別子
- ラベルはループ文（`while`、`for`、`loop`）の直前に置く必要がある
- ラベル名は識別子のルールに従う（文字、数字、アンダースコア）
- 一般的な規約：`outer`、`inner`、`row`、`col`、説明的な名前

## Defer文

`defer`文は、現在の関数が戻るときに実行するコードをスケジュールします。ファイルのクローズ、リソースの解放、ロックの解除などのクリーンアップ操作に便利です。

### 基本的なDefer

```hemlock
fn example() {
    print("start");
    defer print("cleanup");  // 関数が戻るときに実行
    print("end");
}

example();
// 出力：
// start
// end
// cleanup
```

**主な動作：**
- 遅延された文は関数本体が完了した**後**に実行
- 遅延された文は関数が呼び出し元に戻る**前**に実行
- 遅延された文は関数が例外をスローしても常に実行

### 複数のDefer（LIFO順）

複数の`defer`文が使用される場合、**逆順**（後入れ先出し）で実行されます：

```hemlock
fn example() {
    defer print("first");   // 最後に実行
    defer print("second");  // 2番目に実行
    defer print("third");   // 最初に実行
    print("body");
}

example();
// 出力：
// body
// third
// second
// first
```

このLIFO順は意図的なものです - ネストされたリソースのクリーンアップの自然な順序（内側のリソースを外側より先にクローズ）に一致します。

### ReturnとDefer

遅延された文は`return`が制御を移す前に実行されます：

```hemlock
fn get_value(): i32 {
    defer print("cleanup");
    print("before return");
    return 42;
}

let result = get_value();
print("result:", result);
// 出力：
// before return
// cleanup
// result: 42
```

### 例外とDefer

遅延された文は例外がスローされても実行されます：

```hemlock
fn risky() {
    defer print("cleanup 1");
    defer print("cleanup 2");
    print("before throw");
    throw "error!";
    print("after throw");  // 到達しない
}

try {
    risky();
} catch (e) {
    print("Caught:", e);
}
// 出力：
// before throw
// cleanup 2
// cleanup 1
// Caught: error!
```

### リソースクリーンアップパターン

`defer`の主な使用例はリソースのクリーンアップを確実にすること：

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // エラー時も常にクローズ

    let content = file.read();
    // ... コンテンツを処理 ...

    // 関数が戻るときにファイルは自動的にクローズ
}
```

**deferなし（エラーが起きやすい）：**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // これがスローすると、file.close()は呼ばれない！
    process(content);
    file.close();
}
```

### クロージャとDefer

Deferはクロージャを使用して状態をキャプチャできます：

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Releasing resource");
        release(resource);
    }();  // 注意：即時実行関数式

    use_resource(resource);
}
```

### Deferを使用するタイミング

**deferを使用する場面：**
- ファイルとネットワーク接続のクローズ
- 割り当てられたメモリの解放
- ロックとミューテックスの解放
- リソースを取得する関数でのクリーンアップ

**Defer vs Finally：**
- `defer`は単一リソースのクリーンアップにシンプル
- `try/finally`はリカバリを伴う複雑なエラーハンドリングに適している

### ベストプラクティス

1. **リソース取得直後にdeferを配置：**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... ファイルを使用 ...
   ```

2. **複数のリソースには複数のdeferを使用：**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // 両方のファイルは逆順でクローズされる
   ```

3. **依存リソースにはLIFO順を考慮：**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // innerがouterより先に解放される（正しい依存順序）
   ```

## 論理演算子

### 論理AND（`&&`）

両方の条件がtrueである必要がある：

```hemlock
if (x > 0 && x < 10) {
    print("single digit positive");
}
```

**短絡評価：**
```hemlock
if (false && expensive_check()) {
    // expensive_check()は呼ばれない
}
```

### 論理OR（`||`）

少なくとも1つの条件がtrueである必要がある：

```hemlock
if (x < 0 || x > 100) {
    print("out of range");
}
```

**短絡評価：**
```hemlock
if (true || expensive_check()) {
    // expensive_check()は呼ばれない
}
```

### 論理NOT（`!`）

真偽値を否定：

```hemlock
if (!is_valid) {
    print("invalid");
}

if (!(x > 10)) {
    // 以下と同等：if (x <= 10)
}
```

## 比較演算子

### 等価性

```hemlock
if (x == 10) { }    // 等しい
if (x != 10) { }    // 等しくない
```

すべての型で動作：
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### 関係

```hemlock
if (x < 10) { }     // より小さい
if (x > 10) { }     // より大きい
if (x <= 10) { }    // 以下
if (x >= 10) { }    // 以上
```

**型の昇格が適用される：**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true（i32がi64に昇格）
```

## ビット演算子

Hemlockは整数操作のためのビット演算子を提供します。これらは**整数型のみ**（i8-i64、u8-u64）で動作します。

### 二項ビット演算子

**ビットAND（`&`）**
```hemlock
let a = 12;  // 2進数で1100
let b = 10;  // 2進数で1010
print(a & b);   // 8（1000）
```

**ビットOR（`|`）**
```hemlock
print(a | b);   // 14（1110）
```

**ビットXOR（`^`）**
```hemlock
print(a ^ b);   // 6（0110）
```

**左シフト（`<<`）**
```hemlock
print(a << 2);  // 48（110000）- 2ビット左にシフト
```

**右シフト（`>>`）**
```hemlock
print(a >> 1);  // 6（110）- 1ビット右にシフト
```

### 単項ビット演算子

**ビットNOT（`~`）**
```hemlock
let a = 12;
print(~a);      // -13（2の補数）

let c: u8 = 15;   // 2進数で00001111
print(~c);        // 240（u8で11110000）
```

### ビット演算の例

**符号なし型での例：**
```hemlock
let c: u8 = 15;   // 2進数で00001111
let d: u8 = 7;    // 2進数で00000111

print(c & d);     // 7（00000111）
print(c | d);     // 15（00001111）
print(c ^ d);     // 8（00001000）
print(~c);        // 240（u8で11110000）
```

**型の保持：**
```hemlock
// ビット演算はオペランドの型を保持
let x: u8 = 255;
let result = ~x;  // resultは値0のu8

let y: i32 = 100;
let result2 = y << 2;  // result2は値400のi32
```

**一般的なパターン：**
```hemlock
// ビットが設定されているか確認
if (flags & 0x04) {
    print("bit 2 is set");
}

// ビットを設定
flags = flags | 0x08;

// ビットをクリア
flags = flags & ~0x02;

// ビットをトグル
flags = flags ^ 0x01;
```

### 演算子の優先順位

ビット演算子はCスタイルの優先順位に従います：

1. `~`（単項NOT）- 最高、`!`と`-`と同レベル
2. `<<`、`>>`（シフト）- 比較より高く、`+`/`-`より低い
3. `&`（ビットAND）- `^`と`|`より高い
4. `^`（ビットXOR）- `&`と`|`の間
5. `|`（ビットOR）- `&`と`^`より低く、`&&`より高い
6. `&&`、`||`（論理）- 最低優先順位

**例：**
```hemlock
// &は|より優先順位が高い
let result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// シフトはビット演算子より優先順位が高い
let result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// 明確さのために括弧を使用
let result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**重要な注意：**
- ビット演算子は整数型のみで動作（浮動小数点数、文字列などでは動作しない）
- 型の昇格は標準ルールに従う（小さい型は大きい型に昇格）
- 右シフト（`>>`）は符号付き型では算術シフト、符号なし型では論理シフト
- シフト量は範囲チェックされない（大きなシフトの動作はプラットフォーム依存）

## 演算子の優先順位（完全版）

最高から最低への優先順位：

1. **単項**：`!`、`-`、`~`
2. **乗法**：`*`、`/`、`%`
3. **加法**：`+`、`-`
4. **シフト**：`<<`、`>>`
5. **関係**：`<`、`>`、`<=`、`>=`
6. **等価**：`==`、`!=`
7. **ビットAND**：`&`
8. **ビットXOR**：`^`
9. **ビットOR**：`|`
10. **論理AND**：`&&`
11. **論理OR**：`||`

**明確さのために括弧を使用：**
```hemlock
// 不明確
if (a || b && c) { }

// 明確
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## よくあるパターン

### パターン：入力検証

```hemlock
fn validate_age(age: i32): bool {
    if (age < 0 || age > 150) {
        return false;
    }
    return true;
}
```

### パターン：範囲チェック

```hemlock
fn in_range(value: i32, min: i32, max: i32): bool {
    return value >= min && value <= max;
}

if (in_range(score, 0, 100)) {
    print("valid score");
}
```

### パターン：状態マシン

```hemlock
let state = "start";

while (true) {
    switch (state) {
        case "start":
            print("Starting...");
            state = "running";
            break;

        case "running":
            if (should_pause) {
                state = "paused";
            } else if (should_stop) {
                state = "stopped";
            }
            break;

        case "paused":
            if (should_resume) {
                state = "running";
            }
            break;

        case "stopped":
            print("Stopped");
            break;
    }

    if (state == "stopped") {
        break;
    }
}
```

### パターン：フィルタリング付き反復

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 偶数のみを出力
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // 奇数をスキップ
    }
    print(arr[i]);
}
```

### パターン：早期終了

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // 早期終了
        }
    }
    return -1;  // 見つからない
}
```

## ベストプラクティス

1. **常にブレースを使用** - 単一文ブロックでも（構文で強制）
2. **明示的な条件** - 明確さのために`!x`ではなく`x == 0`を使用
3. **深いネストを避ける** - ネストした条件を関数に抽出
4. **早期returnを使用** - ガード句でネストを減らす
5. **複雑な条件を分割** - 名前付き真偽値変数に分割
6. **switchでdefault** - 常にdefaultケースを含める
7. **フォールスルーにコメント** - 意図的なフォールスルーを明示

## よくある落とし穴

### 落とし穴：条件内の代入

```hemlock
// これは許可されていない（条件内の代入なし）
if (x = 10) { }  // エラー：構文エラー

// 代わりに比較を使用
if (x == 10) { }  // OK
```

### 落とし穴：switch内のBreak忘れ

```hemlock
// 意図しないフォールスルー
switch (x) {
    case 1:
        print("one");
        // breakがない - フォールスルー！
    case 2:
        print("two");  // 1と2の両方で実行
        break;
}

// 修正：breakを追加
switch (x) {
    case 1:
        print("one");
        break;  // これで正しい
    case 2:
        print("two");
        break;
}
```

### 落とし穴：ループ変数のスコープ

```hemlock
// iはループにスコープされている
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // エラー：iはここで定義されていない
```

## 例

### 例：FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### 例：素数チェッカー

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### 例：メニューシステム

```hemlock
fn menu() {
    while (true) {
        print("1. Start");
        print("2. Settings");
        print("3. Exit");

        let choice = get_input();

        switch (choice) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("Goodbye!");
                return;
            default:
                print("Invalid choice");
                break;
        }
    }
}
```

## 関連トピック

- [関数](#language-guide-functions) - 関数呼び出しとreturnを使った制御フロー
- [エラーハンドリング](#language-guide-error-handling) - 例外を使った制御フロー
- [型](#language-guide-types) - 条件での型変換

## 参照

- **構文**：文の構文の詳細は[構文](#language-guide-syntax)を参照
- **演算子**：演算での型の昇格は[型](#language-guide-types)を参照


--------------------------------------------------------------------------------
## 型
--------------------------------------------------------------------------------

# 型システム

Hemlockは**動的型システム**を特徴とし、オプションの型注釈と実行時型チェックを備えています。

---

## 型選択ガイド：どの型を使うべき？

**型に慣れていない方**はここから始めてください。型システムに詳しい方は[設計思想](#設計思想)にスキップできます。

### 簡潔な答え

**Hemlockに任せましょう：**

```hemlock
let count = 42;        // Hemlockはこれが整数だと知っている
let price = 19.99;     // Hemlockはこれが小数だと知っている
let name = "Alice";    // Hemlockはこれがテキストだと知っている
let active = true;     // Hemlockはこれがyes/noだと知っている
```

Hemlockは値に対して自動的に適切な型を選びます。型を指定する*必要*はありません。

### 型注釈を追加するタイミング

以下の場合に型を追加します：

1. **サイズを明確にしたい** - `i8` vs `i64`はメモリやFFIで重要
2. **コードをドキュメント化したい** - 型は関数が何を期待するか示す
3. **早期にミスを検出したい** - Hemlockは実行時に型をチェック

```hemlock
// 型なし（問題なく動作）：
fn add(a, b) {
    return a + b;
}

// 型あり（より明示的）：
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### クイックリファレンス：数値型の選択

| 格納するもの | 推奨型 | 例 |
|---------------------|----------------|---------|
| 通常の整数 | `i32`（デフォルト） | `let count = 42;` |
| 非常に大きな数 | `i64` | `let population = 8000000000;` |
| 負にならないカウント | `u32` | `let items: u32 = 100;` |
| バイト（0-255） | `u8` | `let pixel: u8 = 255;` |
| 小数/分数 | `f64`（デフォルト） | `let price = 19.99;` |
| パフォーマンス重視の小数 | `f32` | `let x: f32 = 1.5;` |

### クイックリファレンス：すべての型

| カテゴリ | 型 | 使用場面 |
|----------|-------|-------------|
| **整数** | `i8`、`i16`、`i32`、`i64` | カウント、ID、年齢など |
| **正の数のみ** | `u8`、`u16`、`u32`、`u64` | バイト、サイズ、配列長 |
| **小数** | `f32`、`f64` | 金額、測定値、数学 |
| **Yes/No** | `bool` | フラグ、条件 |
| **テキスト** | `string` | 名前、メッセージ、あらゆるテキスト |
| **単一文字** | `rune` | 個々の文字、絵文字 |
| **リスト** | `array` | 値のコレクション |
| **名前付きフィールド** | `object` | 関連データのグループ化 |
| **生メモリ** | `ptr`、`buffer` | 低レベルプログラミング |
| **なし** | `null` | 値の不在 |

### 一般的なシナリオ

**「数値が欲しいだけ」**
```hemlock
let x = 42;  // 完了！Hemlockがi32を選ぶ
```

**「小数が必要」**
```hemlock
let price = 19.99;  // 完了！Hemlockがf64を選ぶ
```

**「バイトを扱っている（ファイル、ネットワーク）」**
```hemlock
let byte: u8 = 255;  // 0-255の範囲
```

**「本当に大きな数が必要」**
```hemlock
let big = 9000000000000;  // Hemlockが自動でi64を選ぶ（> i32 最大値）
// または明示的に：
let big: i64 = 9000000000000;
```

**「金額を格納している」**
```hemlock
// オプション1：浮動小数点（シンプルだが精度に限界あり）
let price: f64 = 19.99;

// オプション2：セントで格納（より精密）
let price_cents: i32 = 1999;  // $19.99を整数セントで
```

**「Cコードにデータを渡している（FFI）」**
```hemlock
// C言語の型に正確に合わせる
let c_int: i32 = 100;      // Cの'int'
let c_long: i64 = 100;     // Cの'long'（64ビット環境）
let c_char: u8 = 65;       // Cの'char'
let c_double: f64 = 3.14;  // Cの'double'
```

### 型が混在するとどうなる？

異なる型を組み合わせると、Hemlockは「大きい」型に昇格します：

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // resultはf64（12.5）
// 整数が自動的に小数になった
```

**経験則：** 浮動小数点は常に「勝つ」 - 整数と浮動小数点を混ぜると浮動小数点になります。

### 型エラー

間違った型を使おうとすると、Hemlockは実行時に教えてくれます：

```hemlock
let age: i32 = "thirty";  // エラー：型不一致 - i32を期待、stringを受け取った
```

型を変換するには、型コンストラクタ関数を使用します：

```hemlock
let text = "42";
let number = i32(text);   // 文字列を整数にパース：42
let back = text + "";     // すでに文字列
```

---

## 設計思想

- **デフォルトで動的** - すべての値は実行時型タグを持つ
- **選択で型付け** - オプションの型注釈は実行時チェックを強制
- **明示的な変換** - 暗黙の変換は明確な昇格ルールに従う
- **型について正直** - `typeof()`は常に真実を伝える

## プリミティブ型

### 整数型

**符号付き整数：**
```hemlock
let tiny: i8 = 127;              // 8ビット（-128から127）
let small: i16 = 32767;          // 16ビット（-32768から32767）
let normal: i32 = 2147483647;    // 32ビット（デフォルト）
let large: i64 = 9223372036854775807;  // 64ビット
```

**符号なし整数：**
```hemlock
let byte: u8 = 255;              // 8ビット（0から255）
let word: u16 = 65535;           // 16ビット（0から65535）
let dword: u32 = 4294967295;     // 32ビット（0から4294967295）
let qword: u64 = 18446744073709551615;  // 64ビット
```

**型エイリアス：**
```hemlock
let i: integer = 42;   // i32のエイリアス
let b: byte = 255;     // u8のエイリアス
```

### 浮動小数点型

```hemlock
let f: f32 = 3.14159;        // 32ビット浮動小数点
let d: f64 = 2.718281828;    // 64ビット浮動小数点（デフォルト）
let n: number = 1.618;       // f64のエイリアス
```

### 真偽値型

```hemlock
let flag: bool = true;
let active: bool = false;
```

### 文字列型

```hemlock
let text: string = "Hello, World!";
let empty: string = "";
```

文字列は**可変**、**UTF-8エンコード**、**ヒープ割り当て**です。

詳細は[文字列](#language-guide-strings)を参照してください。

### ルーン型

```hemlock
let ch: rune = 'A';
let emoji: rune = '🚀';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

ルーンは**Unicodeコードポイント**（U+0000からU+10FFFF）を表します。

詳細は[ルーン](#language-guide-runes)を参照してください。

### Null型

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null`は単一の値を持つ独自の型です。

## 複合型

### 配列型

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];  // 混合型も可能
let empty: array = [];
```

詳細は[配列](#language-guide-arrays)を参照してください。

### オブジェクト型

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

詳細は[オブジェクト](#language-guide-objects)を参照してください。

### ポインタ型

**生ポインタ：**
```hemlock
let p: ptr = alloc(64);
// 境界チェックなし、手動のライフタイム管理
free(p);
```

**安全なバッファ：**
```hemlock
let buf: buffer = buffer(64);
// 境界チェック付き、長さと容量を追跡
free(buf);
```

詳細は[メモリ管理](#language-guide-memory)を参照してください。

## 列挙型

列挙型は名前付き定数のセットを定義します：

### 基本的な列挙型

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// 比較
if (c == Color.RED) {
    print("It's red!");
}

// 列挙型でのswitch
switch (c) {
    case Color.RED:
        print("Stop");
        break;
    case Color.GREEN:
        print("Go");
        break;
    case Color.BLUE:
        print("Blue?");
        break;
}
```

### 値を持つ列挙型

列挙型は明示的な整数値を持つことができます：

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### 自動インクリメント値

明示的な値がない場合、列挙型は0から自動インクリメントします：

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// 明示的な値と自動値を混在可能
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### 列挙型の使用パターン

```hemlock
// 関数パラメータとして
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Urgent!");
    }
}

set_priority(Priority.HIGH);

// オブジェクト内で
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Fix bug",
    priority: Priority.HIGH
};
```

## 特殊型

### ファイル型

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

開いているファイルハンドルを表します。

### タスク型

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

非同期タスクハンドルを表します。

### チャネル型

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

タスク間の通信チャネルを表します。

### Void型

```hemlock
extern fn exit(code: i32): void;
```

値を返さない関数に使用（FFIのみ）。

## 型推論

### 整数リテラルの推論

Hemlockは値の範囲に基づいて整数型を推論します：

```hemlock
let a = 42;              // i32（32ビットに収まる）
let b = 5000000000;      // i64（> i32 最大値）
let c = 128;             // i32
let d: u8 = 128;         // u8（明示的な注釈）
```

**ルール：**
- i32範囲（-2147483648から2147483647）の値：`i32`と推論
- i32範囲外だがi64範囲内の値：`i64`と推論
- 他の型（i8、i16、u8、u16、u32、u64）には明示的な注釈を使用

### 浮動小数点リテラルの推論

```hemlock
let x = 3.14;        // f64（デフォルト）
let y: f32 = 3.14;   // f32（明示的）
```

### 指数表記

Hemlockは数値リテラルの指数表記をサポートします：

```hemlock
let a = 1e10;        // 10000000000.0（f64）
let b = 1e-12;       // 0.000000000001（f64）
let c = 3.14e2;      // 314.0（f64）
let d = 2.5e-3;      // 0.0025（f64）
let e = 1E10;        // 大文字小文字を区別しない
let f = 1e+5;        // 明示的な正の指数
```

**注意：** 指数表記を使用するリテラルは常に`f64`と推論されます。

### その他の型推論

```hemlock
let s = "hello";     // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## 型注釈

### 変数の注釈

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### 関数パラメータの注釈

```hemlock
fn greet(name: string, age: i32) {
    print("Hello, " + name + "!");
}
```

### 関数戻り値型の注釈

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### オブジェクト型の注釈（ダック型）

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## 型チェック

### 実行時型チェック

型注釈は**実行時**にチェックされ、コンパイル時ではありません：

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // 実行時エラー：型不一致

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "hello");     // 実行時エラー：型不一致
```

### 型クエリ

`typeof()`を使用して値の型をチェックします：

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("hello"));    // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## 型変換

### 暗黙の型昇格

演算で型を混在させると、Hemlockは「上位」の型に昇格します：

**昇格階層（低いから高い）：**
```
i8 → i16 → i32 → u32 → i64 → u64 → f32 → f64
      ↑     ↑     ↑
     u8    u16
```

**浮動小数点が常に勝つ：**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // resultはf64（13.5）
```

**大きいサイズが勝つ：**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sumはi64（300）
```

**精度の保持：** 64ビット整数とf32を混在させると、Hemlockは精度損失を避けるためにf64に昇格します（f32は24ビットの仮数部しかなく、i64/u64には不十分）：
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // resultはf64、f32ではない！
```

**例：**
```hemlock
u8 + i32  → i32
i32 + i64 → i64
u32 + u64 → u64
i32 + f32 → f32    // f32はi32に十分
i64 + f32 → f64    // i64の精度を保持するためにf64が必要
i64 + f64 → f64
i8 + f64  → f64
```

### 明示的な型変換

**整数 ↔ 浮動小数点：**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 → f64（42.0）

let x: f64 = 3.14;
let n: i32 = x;      // f64 → i32（3、切り捨て）
```

**整数 ↔ ルーン：**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 → rune（'A'）

let r: rune = 'Z';
let value: i32 = r;   // rune → i32（90）
```

**ルーン → 文字列：**
```hemlock
let ch: rune = '🚀';
let s: string = ch;   // rune → string（"🚀"）
```

**u8 → ルーン：**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 → rune（'A'）
```

### 型コンストラクタ関数

型名は値を変換またはパースする関数として使用できます：

**文字列を数値にパース：**
```hemlock
let n = i32("42");       // 文字列をi32にパース：42
let f = f64("3.14159");  // 文字列をf64にパース：3.14159
let b = bool("true");    // 文字列をboolにパース：true

// すべての数値型をサポート
let a = i8("-128");      // i8にパース
let c = u8("255");       // u8にパース
let d = i16("1000");     // i16にパース
let e = u16("50000");    // u16にパース
let g = i64("9000000000000"); // i64にパース
let h = u64("18000000000000"); // u64にパース
let j = f32("1.5");      // f32にパース
```

**16進数と負数：**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10（2進数）
```

**型エイリアスも動作：**
```hemlock
let x = integer("100");  // i32("100")と同じ
let y = number("1.5");   // f64("1.5")と同じ
let z = byte("200");     // u8("200")と同じ
```

**数値型間の変換：**
```hemlock
let big = i64(42);           // i32からi64
let truncated = i32(3.99);   // f64からi32（3に切り捨て）
let promoted = f64(100);     // i32からf64（100.0）
let narrowed = i8(127);      // i32からi8
```

**型注釈は数値変換を行う（文字列パースは行わない）：**
```hemlock
let f: f64 = 100;        // 注釈によるi32からf64へ（OK）
let s: string = 'A';     // 注釈によるルーンから文字列へ（OK）
let code: i32 = 'A';     // 注釈によるルーンからi32へ（コードポイントを取得、OK）

// 文字列パースには明示的な型コンストラクタが必要：
let n = i32("42");       // 文字列パースには型コンストラクタを使用
// let x: i32 = "42";    // エラー - 型注釈は文字列をパースしない
```

**エラー処理：**
```hemlock
// 無効な文字列は型コンストラクタ使用時にエラーをスロー
let bad = i32("hello");  // 実行時エラー："hello"をi32としてパースできない
let overflow = u8("256"); // 実行時エラー：256はu8の範囲外
```

**真偽値のパース：**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("yes");   // 実行時エラー："true"または"false"である必要がある
```

## 範囲チェック

型注釈は代入時に範囲チェックを強制します：

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // エラー：u8の範囲外

let a: i8 = 127;    // OK
let b: i8 = 128;    // エラー：i8の範囲外

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // エラー：u64は負になれない
```

## 型昇格の例

### 混合整数型

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32（30）

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32（300）
```

### 整数 + 浮動小数点

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32（12.5）
```

### 複雑な式

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64（70.0）
// 評価：b * c → f64(60.0)
//       a + f64(60.0) → f64(70.0)
```

## ダック型（オブジェクト）

オブジェクトは**構造型**（ダック型）を使用します：

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK：必要なフィールドをすべて持っている
let p1: Person = { name: "Alice", age: 30 };

// OK：余分なフィールドは許可
let p2: Person = { name: "Bob", age: 25, city: "NYC" };

// エラー：'age'フィールドがない
let p3: Person = { name: "Carol" };

// エラー：'age'の型が違う
let p4: Person = { name: "Dave", age: "thirty" };
```

**型チェックは代入時に行われる：**
- すべての必須フィールドが存在することを検証
- フィールドの型が一致することを検証
- 余分なフィールドは許可され、保持される
- `typeof()`用にオブジェクトの型名を設定

## オプションフィールド

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // デフォルト付きオプション
    timeout?: i32,     // オプション、デフォルトはnull
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false（デフォルト）
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true（オーバーライド）
```

## 型エイリアス

Hemlockは`type`キーワードを使用したカスタム型エイリアスをサポートします：

### 基本的な型エイリアス

```hemlock
// シンプルな型エイリアス
type Integer = i32;
type Text = string;

// エイリアスの使用
let x: Integer = 42;
let msg: Text = "hello";
```

### 関数型エイリアス

```hemlock
// 関数型エイリアス
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// 関数型エイリアスの使用
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### 複合型エイリアス

```hemlock
// 複数のdefineを1つの型に結合
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### ジェネリック型エイリアス

```hemlock
// ジェネリック型エイリアス
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// ジェネリックエイリアスの使用
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**注意：** 型エイリアスは透過的です - `typeof()`はエイリアスではなく基底の型名を返します。

## 型システムの制限

現在の制限：

- **関数のジェネリクスなし** - 関数の型パラメータは未サポート
- **ユニオン型なし** - 「AまたはB」を表現できない
- **Nullable型なし** - すべての型はnullになりうる（明示的なnullabilityには`?`サフィックスを使用）

**注意：** コンパイラ（`hemlockc`）はコンパイル時型チェックを提供します。インタープリタは実行時型チェックのみを行います。詳細は[コンパイラドキュメント](#design-implementation)を参照してください。

## ベストプラクティス

### 型注釈を使用するタイミング

**注釈を使用するケース：**
- 正確な型が重要（例：バイト値の`u8`）
- 関数インターフェースのドキュメント化
- 制約の強制（例：範囲チェック）

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // 実装
}
```

**注釈を使用しないケース：**
- リテラルから型が明らか
- 内部実装の詳細
- 不要な形式的記述

```hemlock
// 不要
let x: i32 = 42;

// より良い
let x = 42;
```

### 型安全パターン

**使用前にチェック：**
```hemlock
if (typeof(value) == "i32") {
    // i32として安全に使用可能
}
```

**関数引数の検証：**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "arguments must be integers";
    }
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

**柔軟性のためにダック型を使用：**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## 次のステップ

- [文字列](#language-guide-strings) - UTF-8文字列型と操作
- [ルーン](#language-guide-runes) - Unicodeコードポイント型
- [配列](#language-guide-arrays) - 動的配列型
- [オブジェクト](#language-guide-objects) - オブジェクトリテラルとダック型
- [メモリ](#language-guide-memory) - ポインタとバッファ型


--------------------------------------------------------------------------------
## 文字列
--------------------------------------------------------------------------------

# 文字列

Hemlock文字列は、完全なUnicodeサポートとテキスト処理のための豊富なメソッドセットを備えた**UTF-8ファーストクラスのミュータブルシーケンス**です。多くの言語とは異なり、Hemlock文字列はミュータブルで、Unicodeコードポイントとネイティブに連携します。

## 概要

```hemlock
let s = "hello";
s[0] = 'H';             // ルーンで変更（"Hello"になる）
print(s.length);        // 5（コードポイント数）
let c = s[0];           // ルーン（Unicodeコードポイント）を返す
let msg = s + " world"; // 連結
let emoji = "🚀";
print(emoji.length);    // 1（1つのコードポイント）
print(emoji.byte_length); // 4（4つのUTF-8バイト）
```

## プロパティ

Hemlock文字列の主な特徴：

- **UTF-8エンコード** - 完全なUnicodeサポート（U+0000からU+10FFFF）
- **ミュータブル** - Python、JavaScript、Java文字列とは異なる
- **コードポイントベースのインデックス** - バイトではなく`rune`（Unicodeコードポイント）を返す
- **ヒープ割り当て** - 内部容量追跡付き
- **2つのlengthプロパティ**：
  - `.length` - コードポイント数（文字数）
  - `.byte_length` - バイト数（UTF-8エンコーディングサイズ）

## UTF-8の動作

すべての文字列操作はバイトではなく**コードポイント**（文字）で動作：

```hemlock
let text = "Hello🚀World";
print(text.length);        // 11（コードポイント）
print(text.byte_length);   // 15（バイト、絵文字は4バイト）

// インデックスはコードポイントを使用
let h = text[0];           // 'H'（ルーン）
let rocket = text[5];      // '🚀'（ルーン）
```

**マルチバイト文字は1としてカウント：**
```hemlock
"Hello".length;      // 5
"🚀".length;         // 1（1つの絵文字）
"你好".length;       // 2（2つの中国語文字）
"café".length;       // 4（éは1つのコードポイント）
```

## 文字列リテラル

```hemlock
// 基本的な文字列
let s1 = "hello";
let s2 = "world";

// エスケープシーケンス付き
let s3 = "Line 1\nLine 2\ttabbed";
let s4 = "Quote: \"Hello\"";
let s5 = "Backslash: \\";

// Unicode文字
let s6 = "🚀 Emoji";
let s7 = "中文字符";
```

## テンプレート文字列（文字列補間）

埋め込み式のためにバッククォートを使用：

```hemlock
let name = "Alice";
let age = 30;

// 基本的な補間
let greeting = `Hello, ${name}!`;           // "Hello, Alice!"
let info = `${name} is ${age} years old`;   // "Alice is 30 years old"

// 補間内の式
let x = 5;
let y = 10;
let sum = `${x} + ${y} = ${x + y}`;         // "5 + 10 = 15"

// メソッド呼び出し
let upper = `Name: ${name.to_upper()}`;     // "Name: ALICE"

// ネストされたオブジェクト
let person = { name: "Bob", city: "NYC" };
let desc = `${person.name} lives in ${person.city}`;  // "Bob lives in NYC"

// 複数行（改行を保持）
let multi = `Line 1
Line 2
Line 3`;
```

**テンプレート文字列の機能：**
- `${...}`内の式は評価されて文字列に変換される
- 任意の有効な式が使用可能（変数、関数呼び出し、算術）
- バッククォート文字列は通常の文字列と同じエスケープシーケンスをサポート
- 連結なしで動的文字列を構築するのに便利

### テンプレート文字列内のエスケープ

テンプレート文字列にリテラルの`${`を含めるには、ドル記号をエスケープ：

```hemlock
let price = 100;
let text = `Price: \${price} or ${price}`;
// "Price: ${price} or 100"

// リテラルのバッククォート
let code = `Use \` for template strings`;
// "Use ` for template strings"
```

### 複雑な式

テンプレート文字列には任意の有効な式を含めることが可能：

```hemlock
// 三項演算子のような式
let age = 25;
let status = `Status: ${age >= 18 ? "adult" : "minor"}`;

// 配列アクセス
let items = ["apple", "banana", "cherry"];
let first = `First item: ${items[0]}`;

// 引数付き関数呼び出し
fn format_price(p) { return "$" + p; }
let msg = `Total: ${format_price(99.99)}`;  // "Total: $99.99"

// チェーンメソッド呼び出し
let name = "alice";
let formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;
// "Hello, Alice!"
```

### テンプレート文字列 vs 連結

テンプレート文字列は連結より読みやすいことが多い：

```hemlock
// 連結（読みにくい）
let msg1 = "Hello, " + name + "! You have " + count + " messages.";

// テンプレート文字列（読みやすい）
let msg2 = `Hello, ${name}! You have ${count} messages.`;
```

## インデックスと変更

### 文字の読み取り

インデックスは`rune`（Unicodeコードポイント）を返す：

```hemlock
let s = "Hello";
let first = s[0];      // 'H'（ルーン）
let last = s[4];       // 'o'（ルーン）

// UTF-8の例
let emoji = "Hi🚀!";
let rocket = emoji[2];  // '🚀'（コードポイントインデックス2のルーン）
```

### 文字の書き込み

文字列はミュータブル - 個々の文字を変更可能：

```hemlock
let s = "hello";
s[0] = 'H';            // "Hello"になる
s[4] = '!';            // "Hell!"になる

// Unicodeで
let msg = "Go!";
msg[0] = '🚀';         // "🚀o!"になる
```

## 連結

`+`を使用して文字列を連結：

```hemlock
let greeting = "Hello" + " " + "World";  // "Hello World"

// 変数で
let name = "Alice";
let msg = "Hi, " + name + "!";  // "Hi, Alice!"

// ルーンと（ルーンのドキュメントを参照）
let s = "Hello" + '!';          // "Hello!"
```

## 文字列メソッド

Hemlockは包括的なテキスト操作のための19個の文字列メソッドを提供します。

### 部分文字列とスライス

**`substr(start, length)`** - 位置と長さで部分文字列を抽出：
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world"（6から始めて長さ5）
let first = s.substr(0, 5);     // "hello"

// UTF-8の例
let text = "Hi🚀!";
let emoji = text.substr(2, 1);  // "🚀"（位置2、長さ1）
```

**`slice(start, end)`** - 範囲で部分文字列を抽出（endを含まない）：
```hemlock
let s = "hello world";
let slice = s.slice(0, 5);      // "hello"（インデックス0から4）
let slice2 = s.slice(6, 11);    // "world"
```

**違い：**
- `substr(start, length)` - 長さパラメータを使用
- `slice(start, end)` - 終了インデックスを使用（含まない）

### 検索

**`find(needle)`** - 最初の出現位置を検索：
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6（最初の出現のインデックス）
let pos2 = s.find("foo");       // -1（見つからない）
let pos3 = s.find("l");         // 2（最初の'l'）
```

**`contains(needle)`** - 文字列が部分文字列を含むかチェック：
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

### 分割とトリム

**`split(delimiter)`** - 文字列の配列に分割：
```hemlock
let csv = "apple,banana,cherry";
let parts = csv.split(",");     // ["apple", "banana", "cherry"]

let words = "one two three".split(" ");  // ["one", "two", "three"]

// 空の区切り文字は文字ごとに分割
let chars = "abc".split("");    // ["a", "b", "c"]
```

**`trim()`** - 先頭と末尾の空白を削除：
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let s2 = "\t\ntext\n\t";
let clean2 = s2.trim();         // "text"
```

### 大文字小文字変換

**`to_upper()`** - 大文字に変換：
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

// 非ASCIIを保持
let s2 = "café";
let upper2 = s2.to_upper();     // "CAFÉ"
```

**`to_lower()`** - 小文字に変換：
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"
```

### 接頭辞/接尾辞チェック

**`starts_with(prefix)`** - 接頭辞で始まるかチェック：
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

**`ends_with(suffix)`** - 接尾辞で終わるかチェック：
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

### 置換

**`replace(old, new)`** - 最初の出現を置換：
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");      // "hello there"

let s3 = "foo foo foo";
let s4 = s3.replace("foo", "bar");         // "bar foo foo"（最初のみ）
```

**`replace_all(old, new)`** - すべての出現を置換：
```hemlock
let s = "foo foo foo";
let s2 = s.replace_all("foo", "bar");      // "bar bar bar"

let s3 = "hello world, world!";
let s4 = s3.replace_all("world", "hemlock"); // "hello hemlock, hemlock!"
```

### 繰り返し

**`repeat(count)`** - 文字列をn回繰り返す：
```hemlock
let s = "ha";
let laugh = s.repeat(3);        // "hahaha"

let line = "=".repeat(40);      // "========================================"
```

### 文字とバイトアクセス

**`char_at(index)`** - インデックスのUnicodeコードポイントを取得（ルーンを返す）：
```hemlock
let s = "hello";
let char = s.char_at(0);        // 'h'（ルーン）

// UTF-8の例
let emoji = "🚀";
let rocket = emoji.char_at(0);  // ルーン U+1F680を返す
```

**`chars()`** - ルーン（コードポイント）の配列に変換：
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']（ルーンの配列）

// UTF-8の例
let text = "Hi🚀";
let chars2 = text.chars();      // ['H', 'i', '🚀']
```

**`byte_at(index)`** - インデックスのバイト値を取得（u8を返す）：
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104（'h'のASCII値）

// UTF-8の例
let emoji = "🚀";
let first_byte = emoji.byte_at(0);  // 240（最初のUTF-8バイト）
```

**`bytes()`** - バイト（u8値）の配列に変換：
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111]（u8の配列）

// UTF-8の例
let emoji = "🚀";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128]（4つのUTF-8バイト）
```

**`to_bytes()`** - 低レベルアクセス用にバッファに変換：
```hemlock
let s = "hello";
let buf = s.to_bytes();         // UTF-8バイトのバッファを返す
print(buf.length);              // 5
free(buf);                      // 解放を忘れずに
```

## メソッドチェーン

すべての文字列メソッドは新しい文字列を返すため、チェーンが可能：

```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ")
    .to_upper();                    // "FOO | BAR | BAZ"
```

## 完全なメソッドリファレンス

| メソッド | パラメータ | 戻り値 | 説明 |
|--------|-----------|---------|-------------|
| `substr(start, length)` | i32, i32 | string | 位置と長さで部分文字列を抽出 |
| `slice(start, end)` | i32, i32 | string | 範囲で部分文字列を抽出（endを含まない） |
| `find(needle)` | string | i32 | 最初の出現を検索（見つからない場合-1） |
| `contains(needle)` | string | bool | 部分文字列を含むかチェック |
| `split(delimiter)` | string | array | 文字列の配列に分割 |
| `trim()` | - | string | 先頭と末尾の空白を削除 |
| `to_upper()` | - | string | 大文字に変換 |
| `to_lower()` | - | string | 小文字に変換 |
| `starts_with(prefix)` | string | bool | 接頭辞で始まるかチェック |
| `ends_with(suffix)` | string | bool | 接尾辞で終わるかチェック |
| `replace(old, new)` | string, string | string | 最初の出現を置換 |
| `replace_all(old, new)` | string, string | string | すべての出現を置換 |
| `repeat(count)` | i32 | string | 文字列をn回繰り返す |
| `char_at(index)` | i32 | rune | インデックスのコードポイントを取得 |
| `byte_at(index)` | i32 | u8 | インデックスのバイト値を取得 |
| `chars()` | - | array | ルーンの配列に変換 |
| `bytes()` | - | array | u8バイトの配列に変換 |
| `to_bytes()` | - | buffer | バッファに変換（解放必須） |

## 例

### 例：テキスト処理

```hemlock
fn process_input(text: string): string {
    return text
        .trim()
        .to_lower()
        .replace_all("  ", " ");  // 空白を正規化
}

let input = "  HELLO   WORLD  ";
let clean = process_input(input);  // "hello world"
```

### 例：CSVパーサー

```hemlock
fn parse_csv_line(line: string): array {
    let trimmed = line.trim();
    let fields = trimmed.split(",");

    let result = [];
    let i = 0;
    while (i < fields.length) {
        result.push(fields[i].trim());
        i = i + 1;
    }

    return result;
}

let csv = "apple, banana , cherry";
let fields = parse_csv_line(csv);  // ["apple", "banana", "cherry"]
```

### 例：単語カウンター

```hemlock
fn count_words(text: string): i32 {
    let words = text.trim().split(" ");
    return words.length;
}

let sentence = "The quick brown fox";
let count = count_words(sentence);  // 4
```

### 例：文字列検証

```hemlock
fn is_valid_email(email: string): bool {
    if (!email.contains("@")) {
        return false;
    }

    if (!email.contains(".")) {
        return false;
    }

    if (email.starts_with("@") || email.ends_with("@")) {
        return false;
    }

    return true;
}

print(is_valid_email("user@example.com"));  // true
print(is_valid_email("invalid"));            // false
```

## メモリ管理

文字列は内部参照カウントでヒープ割り当て：

- **作成**：容量追跡付きでヒープに割り当て
- **連結**：新しい文字列を作成（古い文字列は変更されない）
- **メソッド**：ほとんどのメソッドは新しい文字列を返す
- **寿命**：文字列は参照カウントされスコープを抜けると自動的に解放

**自動クリーンアップ：**
```hemlock
fn create_strings() {
    let s = "hello";
    let s2 = s + " world";  // 新しい割り当て
}  // 関数が戻るとsとs2の両方が自動的に解放
```

**注意：** ローカル文字列変数はスコープを抜けると自動的にクリーンアップされます。`free()`はスコープ終了前の早期クリーンアップや長期間存続する/グローバルデータにのみ使用してください。詳細は[メモリ管理](memory.md#internal-reference-counting)を参照してください。

## ベストプラクティス

1. **コードポイントインデックスを使用** - 文字列はバイトオフセットではなくコードポイント位置を使用
2. **Unicodeでテスト** - 常にマルチバイト文字で文字列操作をテスト
3. **イミュータブル操作を優先** - 変更より新しい文字列を返すメソッドを使用
4. **境界をチェック** - 文字列のインデックスは境界チェックしない（無効時はnull/エラー）
5. **入力を正規化** - ユーザー入力には`trim()`と`to_lower()`を使用

## よくある落とし穴

### 落とし穴：バイト vs コードポイントの混乱

```hemlock
let emoji = "🚀";
print(emoji.length);        // 1（コードポイント）
print(emoji.byte_length);   // 4（バイト）

// バイトとコードポイントの操作を混ぜない
let byte = emoji.byte_at(0);  // 240（最初のバイト）
let char = emoji.char_at(0);  // '🚀'（完全なコードポイント）
```

### 落とし穴：変更のサプライズ

```hemlock
let s1 = "hello";
let s2 = s1;       // 浅いコピー
s1[0] = 'H';       // s1を変更
print(s2);         // まだ"hello"（文字列は値型）
```

## 関連トピック

- [ルーン](#language-guide-runes) - 文字列インデックスで使用されるUnicodeコードポイント型
- [配列](#language-guide-arrays) - 文字列メソッドは配列と連携することが多い
- [型](#language-guide-types) - 文字列型の詳細と変換

## 参照

- **UTF-8エンコーディング**：CLAUDE.mdの「Strings」セクションを参照
- **型変換**：文字列変換については[型](#language-guide-types)を参照
- **メモリ**：文字列割り当ての詳細は[メモリ](#language-guide-memory)を参照


--------------------------------------------------------------------------------
## 構文
--------------------------------------------------------------------------------

# 構文の概要

このドキュメントでは、Hemlockプログラムの基本的な構文規則と構造について説明します。

## コア構文規則

### セミコロンは必須

JavaScriptやPythonとは異なり、セミコロンは文の末尾で**常に必須**です：

```hemlock
let x = 42;
let y = 10;
print(x + y);
```

**これはエラーになります：**
```hemlock
let x = 42  // エラー：セミコロンがない
let y = 10  // エラー：セミコロンがない
```

### ブレースは常に必須

すべての制御フローブロックは、単一の文でもブレースを使用する必要があります：

```hemlock
// 正しい
if (x > 0) {
    print("positive");
}

// エラー：ブレースがない
if (x > 0)
    print("positive");
```

### コメント

```hemlock
// これは単一行コメント

/*
   これは
   複数行コメント
*/

let x = 42;  // インラインコメント
```

## 変数

### 宣言

変数は`let`で宣言：

```hemlock
let count = 0;
let name = "Alice";
let pi = 3.14159;
```

### 型注釈（オプション）

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let flag: bool = true;
let text: string = "hello";
```

### 定数

イミュータブルな値には`const`を使用：

```hemlock
const MAX_SIZE: i32 = 1000;
const PI: f64 = 3.14159;
```

constを再代入しようとすると実行時エラーになります：「Cannot assign to const variable」。

## 式

### 算術演算子

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13 - 加算
print(a - b);   // 7  - 減算
print(a * b);   // 30 - 乗算
print(a / b);   // 3  - 除算（整数）
```

### 比較演算子

```hemlock
print(a == b);  // false - 等しい
print(a != b);  // true  - 等しくない
print(a > b);   // true  - より大きい
print(a < b);   // false - より小さい
print(a >= b);  // true  - 以上
print(a <= b);  // false - 以下
```

### 論理演算子

```hemlock
let x = true;
let y = false;

print(x && y);  // false - AND
print(x || y);  // true  - OR
print(!x);      // false - NOT
```

### ビット演算子

```hemlock
let a = 12;  // 1100
let b = 10;  // 1010

print(a & b);   // 8  - ビットAND
print(a | b);   // 14 - ビットOR
print(a ^ b);   // 6  - ビットXOR
print(a << 2);  // 48 - 左シフト
print(a >> 1);  // 6  - 右シフト
print(~a);      // -13 - ビットNOT
```

### 演算子の優先順位

最高から最低：

1. `()` - グループ化
2. `!`、`~`、`-`（単項） - 単項演算子
3. `*`、`/` - 乗算、除算
4. `+`、`-` - 加算、減算
5. `<<`、`>>` - ビットシフト
6. `<`、`<=`、`>`、`>=` - 比較
7. `==`、`!=` - 等価
8. `&` - ビットAND
9. `^` - ビットXOR
10. `|` - ビットOR
11. `&&` - 論理AND
12. `||` - 論理OR

**例：**
```hemlock
let x = 2 + 3 * 4;      // 14（20ではない）
let y = (2 + 3) * 4;    // 20
let z = 5 << 2 + 1;     // 40（5 << 3）
```

## 制御フロー

### If文

```hemlock
if (condition) {
    // 本体
}

if (condition) {
    // thenブランチ
} else {
    // elseブランチ
}

if (condition1) {
    // ブランチ1
} else if (condition2) {
    // ブランチ2
} else {
    // デフォルトブランチ
}
```

### Whileループ

```hemlock
while (condition) {
    // 本体
}
```

**例：**
```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

### Forループ

**Cスタイルfor：**
```hemlock
for (initializer; condition; increment) {
    // 本体
}
```

**例：**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**For-in（配列）：**
```hemlock
for (let item in array) {
    // 本体
}
```

**例：**
```hemlock
let items = [10, 20, 30];
for (let x in items) {
    print(x);
}
```

### Switch文

```hemlock
switch (expression) {
    case value1:
        // 本体
        break;
    case value2:
        // 本体
        break;
    default:
        // デフォルト本体
        break;
}
```

**例：**
```hemlock
let day = 3;
switch (day) {
    case 1:
        print("Monday");
        break;
    case 2:
        print("Tuesday");
        break;
    case 3:
        print("Wednesday");
        break;
    default:
        print("Other");
        break;
}
```

### BreakとContinue

```hemlock
// Break：ループを終了
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        break;
    }
    print(i);
}

// Continue：次の反復にスキップ
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;
    }
    print(i);
}
```

## 関数

### 名前付き関数

```hemlock
fn function_name(param1: type1, param2: type2): return_type {
    // 本体
    return value;
}
```

**例：**
```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### 無名関数

```hemlock
let func = fn(params) {
    // 本体
};
```

**例：**
```hemlock
let multiply = fn(x, y) {
    return x * y;
};
```

### 型注釈（オプション）

```hemlock
// 注釈なし（型推論）
fn greet(name) {
    return "Hello, " + name;
}

// 注釈付き（実行時にチェック）
fn divide(a: i32, b: i32): f64 {
    return a / b;
}
```

## オブジェクト

### オブジェクトリテラル

```hemlock
let obj = {
    field1: value1,
    field2: value2,
};
```

**例：**
```hemlock
let person = {
    name: "Alice",
    age: 30,
    active: true,
};
```

### メソッド

```hemlock
let obj = {
    method: fn() {
        self.field = value;
    },
};
```

**例：**
```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
};
```

### 型定義

```hemlock
define TypeName {
    field1: type1,
    field2: type2,
    optional_field?: default_value,
}
```

**例：**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,
}
```

## 配列

### 配列リテラル

```hemlock
let arr = [element1, element2, element3];
```

**例：**
```hemlock
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];
let empty = [];
```

### 配列のインデックス

```hemlock
let arr = [10, 20, 30];
print(arr[0]);   // 10
arr[1] = 99;     // 要素を変更
```

## エラーハンドリング

### Try/Catch

```hemlock
try {
    // 危険なコード
} catch (e) {
    // エラーを処理
}
```

### Try/Finally

```hemlock
try {
    // 危険なコード
} finally {
    // 常に実行
}
```

### Try/Catch/Finally

```hemlock
try {
    // 危険なコード
} catch (e) {
    // エラーを処理
} finally {
    // クリーンアップ
}
```

### Throw

```hemlock
throw expression;
```

**例：**
```hemlock
if (x < 0) {
    throw "x must be positive";
}
```

### Panic

```hemlock
panic(message);
```

**例：**
```hemlock
panic("unrecoverable error");
```

## モジュール（実験的）

### Export文

```hemlock
export fn function_name() { }
export const CONSTANT = value;
export let variable = value;
export { name1, name2 };
```

### Import文

```hemlock
import { name1, name2 } from "./module.hml";
import * as namespace from "./module.hml";
import { name as alias } from "./module.hml";
```

## 非同期（実験的）

### 非同期関数

```hemlock
async fn function_name(params): return_type {
    // 本体
}
```

### Spawn/Join

```hemlock
let task = spawn(async_function, arg1, arg2);
let result = join(task);
```

### チャネル

```hemlock
let ch = channel(capacity);
ch.send(value);
let value = ch.recv();
ch.close();
```

## FFI（外部関数インターフェース）

### 共有ライブラリのインポート

```hemlock
import "library_name.so";
```

### 外部関数の宣言

```hemlock
extern fn function_name(param: type): return_type;
```

**例：**
```hemlock
import "libc.so.6";
extern fn strlen(s: string): i32;
```

## リテラル

### 整数リテラル

```hemlock
let decimal = 42;
let negative = -100;
let large = 5000000000;  // 自動的にi64

// 16進数（0xプレフィックス）
let hex = 0xDEADBEEF;
let hex2 = 0xFF;

// 2進数（0bプレフィックス）
let bin = 0b1010;
let bin2 = 0b11110000;

// 8進数（0oプレフィックス）
let oct = 0o777;
let oct2 = 0O123;

// 読みやすさのための数値セパレータ
let million = 1_000_000;
let hex_sep = 0xFF_FF_FF;
let bin_sep = 0b1111_0000_1010_0101;
let oct_sep = 0o77_77;
```

### 浮動小数点リテラル

```hemlock
let f = 3.14;
let e = 2.71828;
let sci = 1.5e-10;       // 指数表記
let sci2 = 2.5E+3;       // 大文字Eも動作
let no_lead = .5;        // 先頭のゼロなし（0.5）
let sep = 3.14_159_265;  // 数値セパレータ
```

### 文字列リテラル

```hemlock
let s = "hello";
let escaped = "line1\nline2\ttabbed";
let quote = "She said \"hello\"";

// 16進エスケープシーケンス
let hex_esc = "\x48\x65\x6c\x6c\x6f";  // "Hello"

// Unicodeエスケープシーケンス
let emoji = "\u{1F600}";               // 😀
let heart = "\u{2764}";                // ❤
let mixed = "Hello \u{1F30D}!";        // Hello 🌍!
```

**エスケープシーケンス：**
- `\n` - 改行
- `\t` - タブ
- `\r` - キャリッジリターン
- `\\` - バックスラッシュ
- `\"` - ダブルクォート
- `\'` - シングルクォート
- `\0` - ヌル文字
- `\xNN` - 16進エスケープ（2桁）
- `\u{XXXX}` - Unicodeエスケープ（1-6桁）

### ルーンリテラル

```hemlock
let ch = 'A';
let emoji = '🚀';
let escaped = '\n';
let unicode = '\u{1F680}';
let hex_rune = '\x41';      // 'A'
```

### 真偽値リテラル

```hemlock
let t = true;
let f = false;
```

### Nullリテラル

```hemlock
let nothing = null;
```

## スコープルール

### ブロックスコープ

変数は最も近い囲んでいるブロックにスコープされます：

```hemlock
let x = 1;  // 外側のスコープ

if (true) {
    let x = 2;  // 内側のスコープ（外側をシャドウ）
    print(x);   // 2
}

print(x);  // 1
```

### 関数スコープ

関数は独自のスコープを作成します：

```hemlock
let global = "global";

fn foo() {
    let local = "local";
    print(global);  // 外側のスコープを読める
}

foo();
// print(local);  // エラー：'local'はここで定義されていない
```

### クロージャスコープ

クロージャは囲んでいるスコープの変数をキャプチャします：

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;  // 'count'をキャプチャ
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
```

## 空白とフォーマット

### インデント

Hemlockは特定のインデントを強制しませんが、4スペースを推奨：

```hemlock
fn example() {
    if (true) {
        print("indented");
    }
}
```

### 改行

文は複数行にまたがることができます：

```hemlock
let result =
    very_long_function_name(
        arg1,
        arg2,
        arg3
    );
```

## Loop文

`loop`キーワードは無限ループのためのよりクリーンな構文を提供します：

```hemlock
loop {
    // ... 処理を行う
    if (done) {
        break;
    }
}
```

これは`while (true)`と等価ですが、意図がより明確です。

## 予約キーワード

以下のキーワードはHemlockで予約されています：

```
let, const, fn, if, else, while, for, in, loop, break, continue,
return, true, false, null, typeof, import, export, from,
try, catch, finally, throw, panic, async, await, spawn, join,
detach, channel, define, switch, case, default, extern, self,
type, defer, enum, ref, buffer, Self
```

## 次のステップ

- [型システム](#language-guide-types) - Hemlockの型システムを学ぶ
- [制御フロー](#language-guide-control-flow) - 制御構造の詳細
- [関数](#language-guide-functions) - 関数とクロージャをマスター
- [メモリ管理](#language-guide-memory) - ポインタとバッファを理解


--------------------------------------------------------------------------------
## 配列
--------------------------------------------------------------------------------

# 配列

Hemlockは、データ操作と処理のための包括的なメソッドを備えた**動的配列**を提供します。配列は混合型を保持でき、必要に応じて自動的に拡張されます。

## 概要

```hemlock
// 配列リテラル
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// 混合型を許可
let mixed = [1, "hello", true, null];

// 動的サイズ変更
arr.push(6);           // 自動的に拡張
arr.push(7);
print(arr.length);     // 7
```

## 配列リテラル

### 基本構文

```hemlock
let numbers = [1, 2, 3, 4, 5];
let strings = ["apple", "banana", "cherry"];
let booleans = [true, false, true];
```

### 空の配列

```hemlock
let arr = [];  // 空の配列

// 後で要素を追加
arr.push(1);
arr.push(2);
arr.push(3);
```

### 混合型

配列は異なる型を含むことができます：

```hemlock
let mixed = [
    42,
    "hello",
    true,
    null,
    [1, 2, 3],
    { x: 10, y: 20 }
];

print(mixed[0]);  // 42
print(mixed[1]);  // "hello"
print(mixed[4]);  // [1, 2, 3]（ネストされた配列）
```

### ネストされた配列

```hemlock
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

print(matrix[0][0]);  // 1
print(matrix[1][2]);  // 6
print(matrix[2][1]);  // 8
```

### 型付き配列

配列には要素の型を強制する型注釈を付けることができます：

```hemlock
// 型付き配列の構文
let nums: array<i32> = [1, 2, 3, 4, 5];
let names: array<string> = ["Alice", "Bob", "Carol"];
let flags: array<bool> = [true, false, true];

// 実行時の型チェック
let valid: array<i32> = [1, 2, 3];       // OK
let invalid: array<i32> = [1, "two", 3]; // 実行時エラー：型の不一致

// ネストされた型付き配列
let matrix: array<array<i32>> = [
    [1, 2, 3],
    [4, 5, 6]
];
```

**型注釈の動作：**
- 要素は配列に追加される際に型チェックされます
- 型の不一致は実行時エラーを引き起こします
- 型注釈がない場合、配列は混合型を受け入れます

## インデックス

### 要素の読み取り

ゼロインデックスアクセス：

```hemlock
let arr = [10, 20, 30, 40, 50];

print(arr[0]);  // 10（最初の要素）
print(arr[4]);  // 50（最後の要素）

// 範囲外はnullを返す（エラーなし）
print(arr[10]);  // null
```

### 要素の書き込み

```hemlock
let arr = [1, 2, 3];

arr[0] = 10;    // 既存を変更
arr[1] = 20;
print(arr);     // [10, 20, 3]

// 現在の長さを超えて代入可能（配列を拡張）
arr[5] = 60;    // [10, 20, 3, null, null, 60]を作成
```

### 負のインデックス

**サポートされていません** - 正のインデックスのみを使用：

```hemlock
let arr = [1, 2, 3];
print(arr[-1]);  // エラーまたは未定義動作

// 最後の要素にはlengthを使用
print(arr[arr.length - 1]);  // 3
```

## プロパティ

### `.length`プロパティ

要素数を返します：

```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);  // 5

// 空の配列
let empty = [];
print(empty.length);  // 0

// 変更後
arr.push(6);
print(arr.length);  // 6
```

## 配列メソッド

Hemlockは包括的な操作のための18個の配列メソッドを提供します。

### スタック操作

**`push(value)`** - 末尾に要素を追加：
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]

print(arr.length);     // 5
```

**`pop()`** - 最後の要素を削除して返す：
```hemlock
let arr = [1, 2, 3, 4, 5];
let last = arr.pop();  // 5を返し、arrは[1, 2, 3, 4]になる

print(last);           // 5
print(arr.length);     // 4
```

### キュー操作

**`shift()`** - 最初の要素を削除して返す：
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();   // 1を返し、arrは[2, 3]になる

print(first);              // 1
print(arr);                // [2, 3]
```

**`unshift(value)`** - 先頭に要素を追加：
```hemlock
let arr = [2, 3];
arr.unshift(1);            // [1, 2, 3]
arr.unshift(0);            // [0, 1, 2, 3]
```

### 挿入と削除

**`insert(index, value)`** - インデックス位置に要素を挿入：
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // インデックス2に3を挿入：[1, 2, 3, 4, 5]

arr.insert(0, 0);      // 先頭に挿入：[0, 1, 2, 3, 4, 5]
```

**`remove(index)`** - インデックス位置の要素を削除して返す：
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(2);  // 3を返し、arrは[1, 2, 4, 5]になる

print(removed);               // 3
print(arr);                   // [1, 2, 4, 5]
```

### 検索操作

**`find(value)`** - 最初の出現位置を検索：
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2（最初の出現のインデックス）
let idx2 = arr.find(99);     // -1（見つからない）

// 任意の型で動作
let words = ["apple", "banana", "cherry"];
let idx3 = words.find("banana");  // 1
```

**`contains(value)`** - 配列に値が含まれるか確認：
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false
```

### 抽出操作

**`slice(start, end)`** - 部分配列を抽出（endは含まない）：
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]（インデックス1, 2, 3）
let first = arr.slice(0, 2); // [1, 2]

// 元の配列は変更されない
print(arr);                  // [1, 2, 3, 4, 5]
```

**`first()`** - 最初の要素を取得（削除せずに）：
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1（削除せずに）
print(arr);                  // [1, 2, 3]（変更なし）
```

**`last()`** - 最後の要素を取得（削除せずに）：
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3（削除せずに）
print(arr);                  // [1, 2, 3]（変更なし）
```

### 変換操作

**`reverse()`** - 配列をその場で反転：
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]

print(arr);                  // [5, 4, 3, 2, 1]（変更された）
```

**`join(delimiter)`** - 要素を文字列に結合：
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// 混合型でも動作
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"
```

**`concat(other)`** - 別の配列と連結：
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]（新しい配列）

// 元の配列は変更されない
print(a);                    // [1, 2, 3]
print(b);                    // [4, 5, 6]
```

### ユーティリティ操作

**`clear()`** - すべての要素を削除：
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();                 // []

print(arr.length);           // 0
print(arr);                  // []
```

## メソッドチェーン

配列や値を返すメソッドはチェーンが可能です：

```hemlock
let result = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);  // [3, 4, 5]

let text = ["apple", "banana", "cherry"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

let numbers = [5, 3, 8, 1, 9]
    .slice(1, 4)
    .concat([10, 11]);  // [3, 8, 1, 10, 11]
```

## 完全なメソッドリファレンス

| メソッド | パラメータ | 戻り値 | 変更 | 説明 |
|--------|-----------|---------|---------|-------------|
| `push(value)` | any | void | はい | 末尾に要素を追加 |
| `pop()` | - | any | はい | 最後を削除して返す |
| `shift()` | - | any | はい | 最初を削除して返す |
| `unshift(value)` | any | void | はい | 先頭に要素を追加 |
| `insert(index, value)` | i32, any | void | はい | インデックス位置に挿入 |
| `remove(index)` | i32 | any | はい | インデックス位置を削除して返す |
| `find(value)` | any | i32 | いいえ | 最初の出現位置を検索（見つからない場合-1） |
| `contains(value)` | any | bool | いいえ | 値が含まれるか確認 |
| `slice(start, end)` | i32, i32 | array | いいえ | 部分配列を抽出（新しい配列） |
| `join(delimiter)` | string | string | いいえ | 文字列に結合 |
| `concat(other)` | array | array | いいえ | 連結（新しい配列） |
| `reverse()` | - | void | はい | その場で反転 |
| `first()` | - | any | いいえ | 最初の要素を取得 |
| `last()` | - | any | いいえ | 最後の要素を取得 |
| `clear()` | - | void | はい | すべての要素を削除 |
| `map(callback)` | fn | array | いいえ | 各要素を変換 |
| `filter(predicate)` | fn | array | いいえ | 条件に一致する要素を選択 |
| `reduce(callback, initial)` | fn, any | any | いいえ | 単一の値に畳み込み |

## 実装の詳細

### メモリモデル

- **ヒープ割り当て** - 動的容量
- **自動拡張** - 容量を超えると2倍に拡張
- **自動縮小なし** - 容量は減少しない
- **インデックスの境界チェックなし** - 安全のためにはメソッドを使用

### 容量管理

```hemlock
let arr = [];  // 初期容量：0

arr.push(1);   // 容量1に拡張
arr.push(2);   // 容量2に拡張
arr.push(3);   // 容量4に拡張（2倍）
arr.push(4);   // まだ容量4
arr.push(5);   // 容量8に拡張（2倍）
```

### 値の比較

`find()`と`contains()`は値の等価性を使用：

```hemlock
// プリミティブ：値で比較
let arr = [1, 2, 3];
arr.contains(2);  // true

// 文字列：値で比較
let words = ["hello", "world"];
words.contains("hello");  // true

// オブジェクト：参照で比較
let obj1 = { x: 10 };
let obj2 = { x: 10 };
let arr2 = [obj1];
arr2.contains(obj1);  // true（同じ参照）
arr2.contains(obj2);  // false（異なる参照）
```

## よくあるパターン

### 関数型操作（map/filter/reduce）

配列には組み込みの`map`、`filter`、`reduce`メソッドがあります：

```hemlock
// map - 各要素を変換
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

// filter - 条件に一致する要素を選択
let evens = numbers.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4]

// reduce - 単一の値に畳み込み
let sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

// 関数型操作のチェーン
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]
    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]
    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220
```

### パターン：スタックとしての配列

```hemlock
let stack = [];

// スタックにプッシュ
stack.push(1);
stack.push(2);
stack.push(3);

// スタックからポップ
let top = stack.pop();    // 3
let next = stack.pop();   // 2
```

### パターン：キューとしての配列

```hemlock
let queue = [];

// エンキュー（末尾に追加）
queue.push(1);
queue.push(2);
queue.push(3);

// デキュー（先頭から削除）
let first = queue.shift();   // 1
let second = queue.shift();  // 2
```

## ベストプラクティス

1. **直接インデックスよりメソッドを使用** - 境界チェックと明確性
2. **境界をチェック** - 直接インデックスは境界チェックしない
3. **不変操作を優先** - 変更より`slice()`と`concat()`を使用
4. **容量を初期化** - サイズが分かっている場合（現在はサポートされていない）
5. **メンバーシップには`contains()`を使用** - 手動ループより明確
6. **メソッドをチェーン** - ネストされた呼び出しより読みやすい

## よくある落とし穴

### 落とし穴：直接インデックスの範囲外

```hemlock
let arr = [1, 2, 3];

// 境界チェックなし！
arr[10] = 99;  // nullを含むスパース配列を作成
print(arr.length);  // 11（3ではない！）

// 改善：push()を使用するか長さをチェック
if (arr.length <= 10) {
    arr.push(99);
}
```

### 落とし穴：変更 vs. 新しい配列

```hemlock
let arr = [1, 2, 3];

// 元を変更
arr.reverse();
print(arr);  // [3, 2, 1]

// 新しい配列を返す
let sub = arr.slice(0, 2);
print(arr);  // [3, 2, 1]（変更なし）
print(sub);  // [3, 2]
```

### 落とし穴：参照の等価性

```hemlock
let obj = { x: 10 };
let arr = [obj];

// 同じ参照：true
arr.contains(obj);  // true

// 異なる参照：false
arr.contains({ x: 10 });  // false（異なるオブジェクト）
```

### 落とし穴：長期間存続する配列

```hemlock
// ローカルスコープの配列は自動解放されるが、グローバル/長期間の配列は注意が必要
let global_cache = [];  // モジュールレベル、プログラム終了まで持続

fn add_to_cache(item) {
    global_cache.push(item);  // 無限に拡大
}

// 長期間のデータには、以下を検討：
// - 定期的に配列をクリア：global_cache.clear();
// - 完了時に早期解放：free(global_cache);
```

## 例

### 例：配列の統計

```hemlock
fn mean(arr) {
    let sum = 0;
    let i = 0;
    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum / arr.length;
}

fn max(arr) {
    if (arr.length == 0) {
        return null;
    }

    let max_val = arr[0];
    let i = 1;
    while (i < arr.length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    return max_val;
}

let numbers = [3, 7, 2, 9, 1];
print(mean(numbers));  // 4.4
print(max(numbers));   // 9
```

### 例：配列の重複排除

```hemlock
fn unique(arr) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (!result.contains(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

let numbers = [1, 2, 2, 3, 1, 4, 3, 5];
let uniq = unique(numbers);  // [1, 2, 3, 4, 5]
```

### 例：配列のチャンク分割

```hemlock
fn chunk(arr, size) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        let chunk = arr.slice(i, i + size);
        result.push(chunk);
        i = i + size;
    }

    return result;
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
let chunks = chunk(numbers, 3);
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### 例：配列のフラット化

```hemlock
fn flatten(arr) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        if (typeof(arr[i]) == "array") {
            // ネストされた配列 - フラット化
            let nested = flatten(arr[i]);
            let j = 0;
            while (j < nested.length) {
                result.push(nested[j]);
                j = j + 1;
            }
        } else {
            result.push(arr[i]);
        }
        i = i + 1;
    }

    return result;
}

let nested = [1, [2, 3], [4, [5, 6]], 7];
let flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]
```

### 例：ソート（バブルソート）

```hemlock
fn sort(arr) {
    let n = arr.length;
    let i = 0;

    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // スワップ
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers);  // その場で変更
print(numbers);  // [1, 2, 5, 8, 9]
```

## 制限事項

現在の制限事項：

- **インデックスの境界チェックなし** - 直接アクセスはチェックされない
- **オブジェクトの参照等価性** - `find()`と`contains()`は参照比較を使用
- **配列の分割代入なし** - `let [a, b] = arr`構文はない
- **スプレッド演算子なし** - `[...arr1, ...arr2]`構文はない

**注意：** 配列は参照カウントされ、スコープを抜けると自動的に解放されます。詳細は[メモリ管理](memory.md#internal-reference-counting)を参照してください。

## 関連トピック

- [文字列](#language-guide-strings) - 配列メソッドに似た文字列メソッド
- [オブジェクト](#language-guide-objects) - 配列もオブジェクトのような性質を持つ
- [関数](#language-guide-functions) - 配列での高階関数
- [制御フロー](#language-guide-control-flow) - 配列の反復処理

## 参照

- **動的サイズ変更**: 配列は容量を2倍にしながら自動的に拡張
- **メソッド**: map/filter/reduceを含む18個の包括的なメソッド
- **メモリ**: 配列の割り当ての詳細は[メモリ](#language-guide-memory)を参照


--------------------------------------------------------------------------------
## 関数
--------------------------------------------------------------------------------

# 関数

Hemlockの関数は、変数に代入したり、引数として渡したり、他の関数から返したりできる**第一級の値**です。このガイドでは、関数の構文、クロージャ、再帰、高度なパターンについて説明します。

## 概要

```hemlock
// 名前付き関数の構文
fn add(a: i32, b: i32): i32 {
    return a + b;
}

// 無名関数
let multiply = fn(x, y) {
    return x * y;
};

// クロージャ
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
print(add5(3));  // 8
```

## 関数宣言

### 名前付き関数

```hemlock
fn greet(name: string): string {
    return "Hello, " + name;
}

let msg = greet("Alice");  // "Hello, Alice"
```

**構成要素：**
- `fn` - 関数キーワード
- `greet` - 関数名
- `(name: string)` - オプションの型付きパラメータ
- `: string` - オプションの戻り値の型
- `{ ... }` - 関数本体

### 無名関数

名前のない関数で、変数に代入します：

```hemlock
let square = fn(x) {
    return x * x;
};

print(square(5));  // 25
```

**名前付き vs. 無名：**
```hemlock
// これらは等価：
fn add(a, b) { return a + b; }

let add = fn(a, b) { return a + b; };
```

**注意：** 名前付き関数は、無名関数を使った変数代入に脱糖されます。

## パラメータ

### 基本パラメータ

```hemlock
fn example(a, b, c) {
    return a + b + c;
}

let result = example(1, 2, 3);  // 6
```

### 型注釈

パラメータへのオプションの型注釈：

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);      // OK
add(5, 10.5);    // 実行時の型チェックでf64に昇格
```

**型チェック：**
- 注釈がある場合、パラメータの型は呼び出し時にチェックされる
- 暗黙の型変換は標準の昇格ルールに従う
- 型の不一致は実行時エラーを引き起こす

### 値渡し

すべての引数は**コピー**されます（値渡し）：

```hemlock
fn modify(x) {
    x = 100;  // ローカルコピーのみを変更
}

let a = 10;
modify(a);
print(a);  // まだ10（変更されていない）
```

**注意：** オブジェクトと配列は参照で渡されます（参照がコピーされる）ので、その内容は変更できます：

```hemlock
fn modify_array(arr) {
    arr[0] = 99;  // 元の配列を変更
}

let a = [1, 2, 3];
modify_array(a);
print(a[0]);  // 99（変更された）
```

## 戻り値

### Return文

```hemlock
fn get_max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

### 戻り値の型注釈

戻り値のオプションの型注釈：

```hemlock
fn calculate(): f64 {
    return 3.14159;
}

fn get_name(): string {
    return "Alice";
}
```

**型チェック：**
- 戻り値の型は関数が戻るときにチェックされる（注釈がある場合）
- 型変換は標準の昇格ルールに従う

### 暗黙のReturn

戻り値の型注釈がない関数は暗黙的に`null`を返します：

```hemlock
fn print_message(msg) {
    print(msg);
    // 暗黙的にnullを返す
}

let result = print_message("hello");  // resultはnull
```

### 早期Return

```hemlock
fn find_first_negative(arr) {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // 早期終了
        }
    }
    return -1;  // 見つからない
}
```

### 値なしのReturn

値なしの`return;`は`null`を返します：

```hemlock
fn maybe_process(value) {
    if (value < 0) {
        return;  // nullを返す
    }
    return value * 2;
}
```

## 第一級関数

関数は他の値と同様に、代入、渡し、返すことができます。

### 変数としての関数

```hemlock
let operation = fn(x, y) { return x + y; };

print(operation(5, 3));  // 8

// 再代入
operation = fn(x, y) { return x * y; };
print(operation(5, 3));  // 15
```

### 引数としての関数

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 5);  // 10
```

### 戻り値としての関数

```hemlock
fn get_operation(op: string) {
    if (op == "add") {
        return fn(a, b) { return a + b; };
    } else if (op == "multiply") {
        return fn(a, b) { return a * b; };
    } else {
        return fn(a, b) { return 0; };
    }
}

let add = get_operation("add");
print(add(5, 3));  // 8
```

## クロージャ

関数は定義環境をキャプチャします（レキシカルスコープ）。

### 基本的なクロージャ

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

**動作の仕組み：**
- 内部関数は外側のスコープから`count`をキャプチャ
- `count`は返された関数の呼び出し間で持続
- `makeCounter()`の各呼び出しは独自の`count`を持つ新しいクロージャを作成

### パラメータを持つクロージャ

```hemlock
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

print(add5(3));   // 8
print(add10(3));  // 13
```

### 複数のクロージャ

```hemlock
fn makeOperations(x) {
    let add = fn(y) { return x + y; };
    let multiply = fn(y) { return x * y; };

    return { add: add, multiply: multiply };
}

let ops = makeOperations(5);
print(ops.add(3));       // 8
print(ops.multiply(3));  // 15
```

### レキシカルスコープ

関数はレキシカルスコープを通じて外側のスコープ変数にアクセスできます：

```hemlock
let global = 10;

fn outer() {
    let outer_var = 20;

    fn inner() {
        // globalとouter_varにアクセス可能
        print(global);      // 10
        print(outer_var);   // 20
    }

    inner();
}

outer();
```

クロージャは変数を参照でキャプチャするため、外側のスコープ変数の読み取りと変更の両方が可能です（上記の`makeCounter`の例を参照）。

## 再帰

関数は自分自身を呼び出すことができます。

### 基本的な再帰

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### 相互再帰

関数は互いを呼び出すことができます：

```hemlock
fn is_even(n: i32): bool {
    if (n == 0) {
        return true;
    }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) {
        return false;
    }
    return is_even(n - 1);
}

print(is_even(4));  // true
print(is_odd(4));   // false
```

### 再帰的データ処理

```hemlock
fn sum_array(arr: array, index: i32): i32 {
    if (index >= arr.length) {
        return 0;
    }
    return arr[index] + sum_array(arr, index + 1);
}

let numbers = [1, 2, 3, 4, 5];
print(sum_array(numbers, 0));  // 15
```

**注意：** 末尾呼び出し最適化はまだありません - 深い再帰はスタックオーバーフローを引き起こす可能性があります。

## 高階関数

他の関数を受け取るか返す関数。

### Mapパターン

```hemlock
fn map(arr, f) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        result.push(f(arr[i]));
        i = i + 1;
    }
    return result;
}

fn double(x) { return x * 2; }

let numbers = [1, 2, 3, 4, 5];
let doubled = map(numbers, double);  // [2, 4, 6, 8, 10]
```

### Filterパターン

```hemlock
fn filter(arr, predicate) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (predicate(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

fn is_even(x) { return x % 2 == 0; }

let numbers = [1, 2, 3, 4, 5, 6];
let evens = filter(numbers, is_even);  // [2, 4, 6]
```

### Reduceパターン

```hemlock
fn reduce(arr, f, initial) {
    let accumulator = initial;
    let i = 0;
    while (i < arr.length) {
        accumulator = f(accumulator, arr[i]);
        i = i + 1;
    }
    return accumulator;
}

fn add(a, b) { return a + b; }

let numbers = [1, 2, 3, 4, 5];
let sum = reduce(numbers, add, 0);  // 15
```

### 関数合成

```hemlock
fn compose(f, g) {
    return fn(x) {
        return f(g(x));
    };
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }

let double_then_increment = compose(increment, double);
print(double_then_increment(5));  // 11 (5*2 + 1)
```

## よくあるパターン

### パターン：ファクトリ関数

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### パターン：コールバック関数

```hemlock
fn process_async(data, callback) {
    // ... 処理を行う
    callback(data);
}

process_async("test", fn(result) {
    print("Processing complete: " + result);
});
```

### パターン：部分適用

```hemlock
fn partial(f, x) {
    return fn(y) {
        return f(x, y);
    };
}

fn multiply(a, b) {
    return a * b;
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

print(double(5));  // 10
print(triple(5));  // 15
```

### パターン：メモ化

```hemlock
fn memoize(f) {
    let cache = {};

    return fn(x) {
        if (cache.has(x)) {
            return cache[x];
        }

        let result = f(x);
        cache[x] = result;
        return result;
    };
}

fn expensive_fibonacci(n) {
    if (n <= 1) { return n; }
    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);
}

let fast_fib = memoize(expensive_fibonacci);
print(fast_fib(10));  // キャッシュによりはるかに高速
```

## 関数のセマンティクス

### 戻り値の型の要件

戻り値の型注釈がある関数は**必ず**値を返す必要があります：

```hemlock
fn get_value(): i32 {
    // エラー：return文がない
}

fn get_value(): i32 {
    return 42;  // OK
}
```

### 型チェック

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);        // OK
add(5.5, 10.5);    // f64に昇格、f64を返す
add("a", "b");     // 実行時エラー：型の不一致
```

### スコープルール

```hemlock
let global = "global";

fn outer() {
    let outer_var = "outer";

    fn inner() {
        let inner_var = "inner";
        // アクセス可能：inner_var、outer_var、global
    }

    // アクセス可能：outer_var、global
    // アクセス不可：inner_var
}

// アクセス可能：global
// アクセス不可：outer_var、inner_var
```

## ベストプラクティス

1. **型注釈を使用** - エラーのキャッチと意図の文書化に役立つ
2. **関数を小さく保つ** - 各関数は1つのことを行う
3. **純粋関数を優先** - 可能な限り副作用を避ける
4. **関数に明確な名前を付ける** - 説明的な動詞の名前を使用
5. **早期returnを使用** - ガード句でネストを減らす
6. **複雑なクロージャを文書化** - キャプチャされた変数を明確にする
7. **深い再帰を避ける** - 末尾呼び出し最適化がまだない

## よくある落とし穴

### 落とし穴：再帰の深さ

```hemlock
// 深い再帰はスタックオーバーフローを引き起こす可能性がある
fn count_down(n) {
    if (n == 0) { return; }
    count_down(n - 1);
}

count_down(100000);  // スタックオーバーフローでクラッシュする可能性
```

### 落とし穴：キャプチャされた変数の変更

```hemlock
fn make_counter() {
    let count = 0;
    return fn() {
        count = count + 1;  // キャプチャされた変数の読み取りと変更が可能
        return count;
    };
}
```

**注意：** これは機能しますが、すべてのクロージャが同じキャプチャされた環境を共有することに注意してください。

## 例

### 例：関数パイプライン

```hemlock
fn pipeline(value, ...functions) {
    let result = value;
    for (f in functions) {
        result = f(result);
    }
    return result;
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }
fn square(x) { return x * x; }

let result = pipeline(3, double, increment, square);
print(result);  // 49 ((3*2+1)^2)
```

### 例：イベントハンドラ

```hemlock
let handlers = [];

fn on_event(name: string, handler) {
    handlers.push({ name: name, handler: handler });
}

fn trigger_event(name: string, data) {
    let i = 0;
    while (i < handlers.length) {
        if (handlers[i].name == name) {
            handlers[i].handler(data);
        }
        i = i + 1;
    }
}

on_event("click", fn(data) {
    print("Clicked: " + data);
});

trigger_event("click", "button1");
```

### 例：カスタムコンパレータによるソート

```hemlock
fn sort(arr, compare) {
    // カスタムコンパレータによるバブルソート
    let n = arr.length;
    let i = 0;
    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (compare(arr[j], arr[j + 1]) > 0) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn ascending(a, b) {
    if (a < b) { return -1; }
    if (a > b) { return 1; }
    return 0;
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers, ascending);
print(numbers);  // [1, 2, 5, 8, 9]
```

## オプションパラメータ（デフォルト引数）

関数は`?:`構文を使用してデフォルト値を持つオプションパラメータを持つことができます：

```hemlock
fn greet(name, greeting?: "Hello") {
    return greeting + " " + name;
}

print(greet("Alice"));           // "Hello Alice"
print(greet("Bob", "Hi"));       // "Hi Bob"

fn add(a, b?: 10, c?: 100) {
    return a + b + c;
}

print(add(1));          // 111 (1 + 10 + 100)
print(add(1, 2));       // 103 (1 + 2 + 100)
print(add(1, 2, 3));    // 6   (1 + 2 + 3)
```

**ルール：**
- オプションパラメータは必須パラメータの後に来る必要がある
- デフォルト値は任意の式でよい
- 省略された引数はデフォルト値を使用

## 可変長引数関数（残余パラメータ）

関数は残余パラメータ（`...`）を使用して可変数の引数を受け取ることができます：

```hemlock
fn sum(...args) {
    let total = 0;
    for (arg in args) {
        total = total + arg;
    }
    return total;
}

print(sum(1, 2, 3));        // 6
print(sum(1, 2, 3, 4, 5));  // 15
print(sum());               // 0

fn log(prefix, ...messages) {
    for (msg in messages) {
        print(prefix + ": " + msg);
    }
}

log("INFO", "Starting", "Running", "Done");
// INFO: Starting
// INFO: Running
// INFO: Done
```

**ルール：**
- 残余パラメータは最後のパラメータである必要がある
- 残余パラメータは残りのすべての引数を配列に収集
- 通常のパラメータやオプションパラメータと組み合わせ可能

## 関数型注釈

関数型により、関数パラメータと戻り値に期待される正確なシグネチャを指定できます：

### 基本的な関数型

```hemlock
// 関数型の構文：fn(パラメータの型): 戻り値の型
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

let double = fn(n) { return n * 2; };
let result = apply(double, 5);  // 10
```

### 高階関数型

```hemlock
// 関数を返す関数
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

let add5 = make_adder(5);
print(add5(10));  // 15
```

### 非同期関数型

```hemlock
// 非同期関数型
fn run_task(handler: async fn(): void) {
    spawn(handler);
}

run_task(async fn() {
    print("Running async!");
});
```

### 関数型エイリアス

```hemlock
// 明確さのために名前付き関数型を作成
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

fn filter_with(arr: array, pred: Predicate): array {
    return arr.filter(pred);
}
```

## Constパラメータ

`const`修飾子は、関数内でパラメータが変更されることを防ぎます：

### 基本的なConstパラメータ

```hemlock
fn print_all(const items: array) {
    // items.push(4);  // エラー：constパラメータを変更できない
    for (item in items) {
        print(item);   // OK：読み取りは許可
    }
}

let nums = [1, 2, 3];
print_all(nums);
```

### 深い不変性

Constパラメータは深い不変性を強制します - いかなるパスからも変更できません：

```hemlock
fn describe(const person: object) {
    print(person.name);       // OK：読み取りは許可
    // person.name = "Bob";   // エラー：変更できない
    // person.address.city = "NYC";  // エラー：深いconst
}
```

### Constが防ぐもの

| 型 | Constでブロックされるもの | 許可されるもの |
|------|-----------------|---------|
| array | push、pop、shift、unshift、insert、remove、clear、reverse | slice、concat、map、filter、find、contains |
| object | フィールド代入 | フィールド読み取り |
| buffer | インデックス代入 | インデックス読み取り |
| string | インデックス代入 | すべてのメソッド（新しい文字列を返す） |

## 名前付き引数

関数は明確さと柔軟性のために名前付き引数で呼び出すことができます：

### 基本的な名前付き引数

```hemlock
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// 位置引数（従来の方法）
create_user("Alice", 25, false);

// 名前付き引数 - 任意の順序で可能
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);
```

### 位置引数と名前付き引数の混合

```hemlock
// 必要なものに名前を付けてオプションパラメータをスキップ
create_user("David", active: false);  // デフォルトのage=18を使用

// 名前付き引数は位置引数の後に来る必要がある
create_user("Eve", age: 21);          // OK
// create_user(name: "Bad", 25);      // エラー：名前付き引数の後に位置引数
```

### 名前付き引数のルール

- 名前付き引数には`名前: 値`構文を使用
- 名前付き引数は位置引数の後に任意の順序で指定可能
- 位置引数は名前付き引数の後に来ることはできない
- デフォルト/オプションパラメータと連携
- 不明なパラメータ名は実行時エラーを引き起こす

## 制限事項

現在の制限事項：

- **参照渡しなし** - `ref`キーワードはパースされるが未実装
- **関数のオーバーロードなし** - 1つの名前に1つの関数
- **末尾呼び出し最適化なし** - 深い再帰はスタックサイズで制限

## 関連トピック

- [制御フロー](#language-guide-control-flow) - 制御構造での関数の使用
- [オブジェクト](#language-guide-objects) - メソッドはオブジェクトに格納された関数
- [エラーハンドリング](#language-guide-error-handling) - 関数と例外処理
- [型](#language-guide-types) - 型注釈と変換

## 参照

- **クロージャ**：クロージャのセマンティクスについてはCLAUDE.mdの「Functions」セクションを参照
- **第一級の値**：関数は他の値と同様の値
- **レキシカルスコープ**：関数は定義環境をキャプチャ



################################################################################
# 高度なトピック
################################################################################

--------------------------------------------------------------------------------
## FFI
--------------------------------------------------------------------------------

# HemlockのFFI（Foreign Function Interface）

Hemlockは、libffiを使用して共有ライブラリからC関数を呼び出すための**FFI（Foreign Function Interface）**を提供し、既存のCライブラリやシステムAPIとの統合を可能にします。

## 目次

- [概要](#概要)
- [現在のステータス](#現在のステータス)
- [サポートされている型](#サポートされている型)
- [基本概念](#基本概念)
- [FFI関数のエクスポート](#ffi関数のエクスポート)
- [使用ケース](#使用ケース)
- [将来の開発](#将来の開発)
- [FFIコールバック](#ffiコールバック)
- [FFI構造体](#ffi構造体)
- [構造体型のエクスポート](#構造体型のエクスポート)
- [現在の制限事項](#現在の制限事項)
- [ベストプラクティス](#ベストプラクティス)

## 概要

Foreign Function Interface (FFI)により、Hemlockプログラムは以下のことができます：
- 共有ライブラリ（.so、.dylib、.dll）からC関数を呼び出す
- ラッパーコードを書かずに既存のCライブラリを使用
- システムAPIに直接アクセス
- サードパーティのネイティブライブラリと統合
- Hemlockと低レベルのシステム機能を橋渡し

**主な機能：**
- 動的ライブラリローディング
- C関数バインディング
- HemlockとC型間の自動型変換
- すべてのプリミティブ型のサポート
- ポータビリティのためのlibffiベースの実装

## 現在のステータス

FFIサポートはHemlockで利用可能で、以下の機能があります：

**実装済み：**
- 共有ライブラリからC関数を呼び出す
- すべてのプリミティブ型（整数、浮動小数点、ポインタ）のサポート
- 自動型変換
- libffiベースの実装
- 動的ライブラリローディング
- **関数ポインタコールバック** - Hemlock関数をCに渡す
- **extern関数のエクスポート** - モジュール間でFFIバインディングを共有
- **構造体の受け渡しと戻り値** - C互換の構造体を値で渡す
- **完全なポインタヘルパー** - すべての型の読み書き（i8-i64, u8-u64, f32, f64, ptr）
- **バッファ/ポインタ変換** - `buffer_ptr()`, `ptr_to_buffer()`
- **FFI型サイズ** - プラットフォーム対応の型サイズ用`ffi_sizeof()`
- **プラットフォーム型** - `size_t`, `usize`, `isize`, `intptr_t`のサポート

**開発中：**
- 文字列マーシャリングヘルパー
- エラー処理の改善

**テストカバレッジ：**
- コールバックテストを含むFFIテストがパス
- 基本的な関数呼び出しを検証
- 型変換をテスト
- qsortコールバック統合をテスト

## サポートされている型

### プリミティブ型

以下のHemlock型はC関数との間で受け渡しできます：

| Hemlock型 | C型 | サイズ | 備考 |
|--------------|--------|------|-------|
| `i8` | `int8_t` | 1バイト | 符号付き8ビット整数 |
| `i16` | `int16_t` | 2バイト | 符号付き16ビット整数 |
| `i32` | `int32_t` | 4バイト | 符号付き32ビット整数 |
| `i64` | `int64_t` | 8バイト | 符号付き64ビット整数 |
| `u8` | `uint8_t` | 1バイト | 符号なし8ビット整数 |
| `u16` | `uint16_t` | 2バイト | 符号なし16ビット整数 |
| `u32` | `uint32_t` | 4バイト | 符号なし32ビット整数 |
| `u64` | `uint64_t` | 8バイト | 符号なし64ビット整数 |
| `f32` | `float` | 4バイト | 32ビット浮動小数点 |
| `f64` | `double` | 8バイト | 64ビット浮動小数点 |
| `ptr` | `void*` | 8バイト | 生ポインタ |

### 型変換

**自動変換：**
- Hemlock整数 → C整数（範囲チェック付き）
- Hemlock浮動小数点 → C浮動小数点
- Hemlockポインタ → Cポインタ
- C戻り値 → Hemlock値

**型マッピングの例：**
```hemlock
// Hemlock → C
let i: i32 = 42;         // → int32_t (4バイト)
let f: f64 = 3.14;       // → double (8バイト)
let p: ptr = alloc(64);  // → void* (8バイト)

// C → Hemlock (戻り値)
// int32_t foo() → i32
// double bar() → f64
// void* baz() → ptr
```

## 基本概念

### 共有ライブラリ

FFIはコンパイルされた共有ライブラリで動作します：

**Linux:** `.so`ファイル
```
libexample.so
/usr/lib/libm.so
```

**macOS:** `.dylib`ファイル
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows:** `.dll`ファイル
```
example.dll
kernel32.dll
```

### 関数シグネチャ

FFIが正しく動作するには、C関数のシグネチャが既知である必要があります：

```c
// C関数シグネチャの例
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

これらは、ライブラリがロードされ、関数がバインドされるとHemlockから呼び出せます。

### プラットフォーム互換性

FFIはポータビリティのために**libffi**を使用します：
- x86、x86-64、ARM、ARM64で動作
- 呼び出し規約を自動的に処理
- プラットフォーム固有のABIの詳細を抽象化
- Linux、macOS、Windows（適切なlibffiを使用）をサポート

## FFI関数のエクスポート

`extern fn`で宣言されたFFI関数はモジュールからエクスポートでき、複数のファイルで共有できる再利用可能なライブラリラッパーを作成できます。

### 基本的なエクスポート構文

```hemlock
// string_utils.hml - C文字列関数をラップするライブラリモジュール
import "libc.so.6";

// extern関数を直接エクスポート
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// extern関数と一緒にラッパー関数もエクスポートできる
export fn string_length(s: string): i32 {
    return strlen(s);
}

export fn strings_equal(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### エクスポートされたFFI関数のインポート

```hemlock
// main.hml - エクスポートされたFFI関数を使用
import { strlen, string_length, strings_equal } from "./string_utils.hml";

let msg = "Hello, World!";
print(strlen(msg));           // 13 - 直接extern呼び出し
print(string_length(msg));    // 13 - ラッパー関数

print(strings_equal("foo", "foo"));  // true
print(strings_equal("foo", "bar"));  // false
```

### export externの使用ケース

**1. プラットフォーム抽象化**
```hemlock
// platform.hml - プラットフォームの違いを抽象化
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. ライブラリラッパー**
```hemlock
// crypto_lib.hml - 暗号ライブラリ関数をラップ
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Hemlockフレンドリーなラッパーを追加
export fn sha256_string(s: string): string {
    // extern関数を使用した実装
}
```

**3. 集中化されたFFI宣言**
```hemlock
// libc.hml - libcバインディングの中央モジュール
import "libc.so.6";

// 文字列関数
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// メモリ関数
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// プロセス関数
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

プロジェクト全体で使用：
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

### 通常のエクスポートとの組み合わせ

エクスポートされたextern関数と通常の関数エクスポートを混在させることができます：

```hemlock
// math_extended.hml
import "libm.so.6";

// 生のC関数をエクスポート
export extern fn sin(x: f64): f64;
export extern fn cos(x: f64): f64;
export extern fn tan(x: f64): f64;

// それらを使用するHemlock関数をエクスポート
export fn deg_to_rad(degrees: f64): f64 {
    return degrees * 3.14159265359 / 180.0;
}

export fn sin_degrees(degrees: f64): f64 {
    return sin(deg_to_rad(degrees));
}
```

### プラットフォーム固有のライブラリ

extern関数をエクスポートする際、ライブラリ名はプラットフォームによって異なることに注意してください：

```hemlock
// Linux用
import "libc.so.6";

// macOS用（異なるアプローチが必要）
import "libSystem.B.dylib";
```

現在、Hemlockの`import "library"`構文は静的なライブラリパスを使用するため、クロスプラットフォームFFIコードにはプラットフォーム固有のモジュールが必要な場合があります。

## 使用ケース

### 1. システムライブラリ

標準Cライブラリ関数にアクセス：

**数学関数：**
```hemlock
// libmからsqrtを呼び出す
let result = sqrt(16.0);  // 4.0
```

**メモリ割り当て：**
```hemlock
// libcからmalloc/freeを呼び出す
let ptr = malloc(1024);
free(ptr);
```

### 2. サードパーティライブラリ

既存のCライブラリを使用：

**例：画像処理**
```hemlock
// libpngまたはlibjpegをロード
// Cライブラリ関数を使用して画像を処理
```

**例：暗号化**
```hemlock
// OpenSSLまたはlibsodiumを使用
// FFI経由で暗号化/復号化
```

### 3. システムAPI

直接システムコール：

**例：POSIX API**
```hemlock
// getpid、getuidなどを呼び出す
// 低レベルのシステム機能にアクセス
```

### 4. パフォーマンスクリティカルなコード

最適化されたC実装を呼び出す：

```hemlock
// 高度に最適化されたCライブラリを使用
// SIMD操作、ベクトル化コード
// ハードウェアアクセラレーション関数
```

### 5. ハードウェアアクセス

ハードウェアライブラリとのインターフェース：

```hemlock
// 組み込みシステムでのGPIO制御
// USBデバイス通信
// シリアルポートアクセス
```

### 6. レガシーコード統合

既存のCコードベースを再利用：

```hemlock
// レガシーCアプリケーションから関数を呼び出す
// Hemlockへの段階的な移行
// 動作するCコードを保持
```

## 将来の開発

### 計画されている機能

**1. 構造体サポート**
```hemlock
// 将来：C構造体の受け渡し/戻り
define Point {
    x: f64,
    y: f64,
}

let p = Point { x: 1.0, y: 2.0 };
c_function_with_struct(p);
```

**2. 配列/バッファ処理**
```hemlock
// 将来：より良い配列の受け渡し
let arr = [1, 2, 3, 4, 5];
process_array(arr);  // C関数に渡す
```

**3. 関数ポインタコールバック** （実装済み！）
```hemlock
// Hemlock関数をコールバックとしてCに渡す
fn my_compare(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    return va - vb;
}

// C呼び出し可能な関数ポインタを作成
let cmp = callback(my_compare, ["ptr", "ptr"], "i32");

// qsortやコールバックを期待するC関数で使用
qsort(arr, count, elem_size, cmp);

// 完了時にクリーンアップ
callback_free(cmp);
```

**4. 文字列マーシャリング**
```hemlock
// 将来：自動文字列変換
let s = "hello";
c_string_function(s);  // C文字列に自動変換
```

**5. エラー処理**
```hemlock
// 将来：より良いエラー報告
try {
    let result = risky_c_function();
} catch (e) {
    print("FFI error: " + e);
}
```

**6. 型安全性**
```hemlock
// 将来：FFI用の型注釈
@ffi("libm.so")
fn sqrt(x: f64): f64;

let result = sqrt(16.0);  // 型チェック済み
```

### 機能

**v1.0：**
- 基本的なFFIとプリミティブ型
- 動的ライブラリローディング
- 関数呼び出し
- libffiクロージャによるコールバックサポート

**将来：**
- 構造体サポート
- 配列処理の改善
- 自動バインディング生成

## FFIコールバック

Hemlockは、libffiクロージャを使用してコールバックとしてC側にHemlock関数を渡すことをサポートしています。これにより、`qsort`、イベントループ、コールバックベースのライブラリなど、関数ポインタを期待するC APIとの統合が可能になります。

### コールバックの作成

`callback()`を使用してHemlock関数からC呼び出し可能な関数ポインタを作成：

```hemlock
// callback(function, param_types, return_type) -> ptr
let cb = callback(my_function, ["ptr", "ptr"], "i32");
```

**パラメータ：**
- `function`：ラップするHemlock関数
- `param_types`：型名文字列の配列（例：`["ptr", "i32"]`）
- `return_type`：戻り値の型文字列（例：`"i32"`, `"void"`）

**サポートされるコールバック型：**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - 符号付き整数
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - 符号なし整数
- `"f32"`, `"f64"` - 浮動小数点
- `"ptr"` - ポインタ
- `"void"` - 戻り値なし
- `"bool"` - ブール値

### 例：qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// 整数用の比較関数（昇順）
fn compare_ints(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// 5つの整数の配列を割り当て
let arr = alloc(20);  // 5 * 4バイト
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// コールバックを作成してソート
let cmp = callback(compare_ints, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// 配列はソート済み：[1, 2, 5, 8, 9]

// クリーンアップ
callback_free(cmp);
free(arr);
```

### ポインタヘルパー関数

Hemlockは生ポインタを扱うための包括的なヘルパー関数を提供します。これらはFFIコールバックや直接メモリ操作に不可欠です。

#### 整数型ヘルパー

| 関数 | 説明 |
|----------|-------------|
| `ptr_deref_i8(ptr)` | ポインタをデリファレンスしてi8を読み取り |
| `ptr_deref_i16(ptr)` | ポインタをデリファレンスしてi16を読み取り |
| `ptr_deref_i32(ptr)` | ポインタをデリファレンスしてi32を読み取り |
| `ptr_deref_i64(ptr)` | ポインタをデリファレンスしてi64を読み取り |
| `ptr_deref_u8(ptr)` | ポインタをデリファレンスしてu8を読み取り |
| `ptr_deref_u16(ptr)` | ポインタをデリファレンスしてu16を読み取り |
| `ptr_deref_u32(ptr)` | ポインタをデリファレンスしてu32を読み取り |
| `ptr_deref_u64(ptr)` | ポインタをデリファレンスしてu64を読み取り |
| `ptr_write_i8(ptr, value)` | ポインタ位置にi8を書き込み |
| `ptr_write_i16(ptr, value)` | ポインタ位置にi16を書き込み |
| `ptr_write_i32(ptr, value)` | ポインタ位置にi32を書き込み |
| `ptr_write_i64(ptr, value)` | ポインタ位置にi64を書き込み |
| `ptr_write_u8(ptr, value)` | ポインタ位置にu8を書き込み |
| `ptr_write_u16(ptr, value)` | ポインタ位置にu16を書き込み |
| `ptr_write_u32(ptr, value)` | ポインタ位置にu32を書き込み |
| `ptr_write_u64(ptr, value)` | ポインタ位置にu64を書き込み |

#### 浮動小数点型ヘルパー

| 関数 | 説明 |
|----------|-------------|
| `ptr_deref_f32(ptr)` | ポインタをデリファレンスしてf32（float）を読み取り |
| `ptr_deref_f64(ptr)` | ポインタをデリファレンスしてf64（double）を読み取り |
| `ptr_write_f32(ptr, value)` | ポインタ位置にf32を書き込み |
| `ptr_write_f64(ptr, value)` | ポインタ位置にf64を書き込み |

#### ポインタ型ヘルパー

| 関数 | 説明 |
|----------|-------------|
| `ptr_deref_ptr(ptr)` | ポインタへのポインタをデリファレンス |
| `ptr_write_ptr(ptr, value)` | ポインタ位置にポインタを書き込み |
| `ptr_offset(ptr, index, size)` | オフセットを計算：`ptr + index * size` |
| `ptr_read_i32(ptr)` | ポインタへのポインタ経由でi32を読み取り（qsortコールバック用） |
| `ptr_null()` | nullポインタ定数を取得 |

#### バッファ変換ヘルパー

| 関数 | 説明 |
|----------|-------------|
| `buffer_ptr(buffer)` | バッファから生ポインタを取得 |
| `ptr_to_buffer(ptr, size)` | ポインタからデータを新しいバッファにコピー |

#### FFIユーティリティ関数

| 関数 | 説明 |
|----------|-------------|
| `ffi_sizeof(type_name)` | FFI型のバイトサイズを取得 |

**`ffi_sizeof`でサポートされる型名：**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - 符号付き整数（1, 2, 4, 8バイト）
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - 符号なし整数（1, 2, 4, 8バイト）
- `"f32"`, `"f64"` - 浮動小数点（4, 8バイト）
- `"ptr"` - ポインタ（64ビットでは8バイト）
- `"size_t"`, `"usize"` - プラットフォーム依存のサイズ型
- `"intptr_t"`, `"isize"` - プラットフォーム依存の符号付きポインタ型

#### 例：異なる型での作業

```hemlock
let p = alloc(64);

// 整数の書き込みと読み取り
ptr_write_i8(p, 42);
print(ptr_deref_i8(p));  // 42

ptr_write_i64(ptr_offset(p, 1, 8), 9000000000);
print(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000

// 浮動小数点の書き込みと読み取り
ptr_write_f64(p, 3.14159);
print(ptr_deref_f64(p));  // 3.14159

// ポインタへのポインタ
let inner = alloc(4);
ptr_write_i32(inner, 999);
ptr_write_ptr(p, inner);
let retrieved = ptr_deref_ptr(p);
print(ptr_deref_i32(retrieved));  // 999

// 型サイズの取得
print(ffi_sizeof("i64"));  // 8
print(ffi_sizeof("ptr"));  // 8（64ビット環境）

// バッファ変換
let buf = buffer(64);
ptr_write_i32(buffer_ptr(buf), 12345);
print(ptr_deref_i32(buffer_ptr(buf)));  // 12345

free(inner);
free(p);
```

### コールバックの解放

**重要：**メモリリークを防ぐため、完了時に常にコールバックを解放してください：

```hemlock
let cb = callback(my_fn, ["ptr"], "void");
// ...コールバックを使用...
callback_free(cb);  // 完了時に解放
```

コールバックはプログラム終了時にも自動的に解放されます。

### コールバック内のクロージャ

コールバックはクロージャ環境をキャプチャするため、外部スコープの変数にアクセスできます：

```hemlock
let multiplier = 10;

fn scale(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // 外部スコープの'multiplier'にアクセス可能
    return (va * multiplier) - (vb * multiplier);
}

let cmp = callback(scale, ["ptr", "ptr"], "i32");
```

### スレッド安全性

コールバック呼び出しはスレッド安全性を確保するためにmutexでシリアライズされます。Hemlockインタープリターは完全にはスレッドセーフではないためです。これは以下を意味します：
- 一度に1つのコールバックのみが実行可能
- マルチスレッドCライブラリでも安全に使用可能
- コールバックが複数のスレッドから非常に頻繁に呼び出される場合、パフォーマンスに影響する可能性

### コールバック内のエラー処理

コールバック内でスローされた例外はCコードに伝播できません。代わりに：
- stderrに警告が出力される
- コールバックはデフォルト値（0またはNULL）を返す
- 例外はログに記録されるが伝播されない

```hemlock
fn risky_callback(a: ptr): i32 {
    throw "Something went wrong";  // 警告が出力され、0を返す
}
```

堅牢なエラー処理のために、入力を検証し、コールバック内でのスローを避けてください。

## FFI構造体

Hemlockは構造体を値でC関数に渡すことをサポートしています。構造体型は型注釈付きで定義すると、FFI用に自動的に登録されます。

### FFI互換構造体の定義

構造体がFFI互換となるのは、すべてのフィールドにFFI互換型を使用した明示的な型注釈がある場合です：

```hemlock
// FFI互換構造体
define Point {
    x: f64,
    y: f64,
}

// 複数のフィールド型を持つFFI互換構造体
define Rectangle {
    top_left: Point,      // ネストされた構造体
    width: f64,
    height: f64,
}

// FFI互換でない（型注釈のないフィールド）
define DynamicObject {
    name,                 // 型なし - FFIで使用不可
    value,
}
```

### FFIでの構造体の使用

構造体型を使用するextern関数を宣言：

```hemlock
// 構造体型を定義
define Vector2D {
    x: f64,
    y: f64,
}

// Cライブラリをインポート
import "libmath.so";

// 構造体を取る/返すextern関数を宣言
extern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;
extern fn vector_length(v: Vector2D): f64;

// 自然に使用
let a: Vector2D = { x: 3.0, y: 0.0 };
let b: Vector2D = { x: 0.0, y: 4.0 };
let result = vector_add(a, b);
print(result.x);  // 3.0
print(result.y);  // 4.0

let len = vector_length(result);
print(len);       // 5.0
```

### サポートされるフィールド型

構造体フィールドはこれらのFFI互換型を使用する必要があります：

| Hemlock型 | C型 | サイズ |
|--------------|--------|------|
| `i8` | `int8_t` | 1バイト |
| `i16` | `int16_t` | 2バイト |
| `i32` | `int32_t` | 4バイト |
| `i64` | `int64_t` | 8バイト |
| `u8` | `uint8_t` | 1バイト |
| `u16` | `uint16_t` | 2バイト |
| `u32` | `uint32_t` | 4バイト |
| `u64` | `uint64_t` | 8バイト |
| `f32` | `float` | 4バイト |
| `f64` | `double` | 8バイト |
| `ptr` | `void*` | 8バイト |
| `string` | `char*` | 8バイト |
| `bool` | `int` | 可変 |
| ネストされた構造体 | struct | 可変 |

### 構造体レイアウト

Hemlockはプラットフォームのネイティブ構造体レイアウトルール（C ABIに一致）を使用します：
- フィールドは型に応じてアラインメント
- 必要に応じてパディングが挿入
- 合計サイズは最大メンバーにアラインメントするようパディング

```hemlock
// 例：C互換レイアウト
define Mixed {
    a: i8,    // オフセット0、サイズ1
              // 3バイトパディング
    b: i32,   // オフセット4、サイズ4
}
// 合計サイズ：8バイト（パディング込み）

define Point3D {
    x: f64,   // オフセット0、サイズ8
    y: f64,   // オフセット8、サイズ8
    z: f64,   // オフセット16、サイズ8
}
// 合計サイズ：24バイト（パディング不要）
```

### ネストされた構造体

構造体は他の構造体を含むことができます：

```hemlock
define Inner {
    x: i32,
    y: i32,
}

define Outer {
    inner: Inner,
    z: i32,
}

import "mylib.so";
extern fn process_nested(data: Outer): i32;

let obj: Outer = {
    inner: { x: 1, y: 2 },
    z: 3,
};
let result = process_nested(obj);
```

### 構造体の戻り値

C関数は構造体を返すことができます：

```hemlock
define Point {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn get_origin(): Point;

let p = get_origin();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### 制限事項

- **構造体フィールドには型注釈が必要** - 型のないフィールドはFFI互換でない
- **構造体内の配列なし** - 代わりにポインタを使用
- **共用体なし** - 構造体型のみサポート
- **コールバックは構造体を返せない** - コールバック戻り値にはポインタを使用

### 構造体型のエクスポート

`export define`を使用してモジュールから構造体型定義をエクスポートできます：

```hemlock
// geometry.hml
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}

export fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {
    return { x: x, y: y, width: w, height: h };
}
```

**重要：**エクスポートされた構造体型はモジュールがロードされると**グローバルに**登録されます。モジュールから何かをインポートすると自動的に利用可能になります。名前で明示的にインポートする必要は（できません）：

```hemlock
// main.hml

// 良い例 - 構造体型はモジュールからのインポート後に自動的に利用可能
import { create_rect } from "./geometry.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };      // 動作 - Vector2はグローバルに利用可能
let r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // 動作

// 悪い例 - 構造体型を名前で明示的にインポートできない
import { Vector2 } from "./geometry.hml";  // エラー：未定義の変数 'Vector2'
```

この動作は、構造体型がモジュールのエクスポート環境に値として格納されるのではなく、モジュールロード時にグローバル型レジストリに登録されるためです。型はモジュールからインポートするすべてのコードで利用可能になります。

## 現在の制限事項

FFIには以下の制限事項があります：

**1. 手動型変換**
- 文字列変換を手動で管理する必要がある
- Hemlock文字列 ↔ C文字列の自動変換なし

**2. 限定的なエラー処理**
- 基本的なエラー報告
- コールバック内の例外はCに伝播できない

**3. 手動ライブラリローディング**
- ライブラリを手動でロードする必要がある
- 自動バインディング生成なし

**4. プラットフォーム固有のコード**
- ライブラリパスはプラットフォームによって異なる
- .so vs .dylib vs .dllを処理する必要がある

## ベストプラクティス

包括的なFFIドキュメントはまだ開発中ですが、一般的なベストプラクティスを以下に示します：

### 1. 型安全性

```hemlock
// 型を明示的に指定
let x: i32 = 42;
let result: f64 = c_function(x);
```

### 2. メモリ管理

```hemlock
// 割り当てられたメモリを解放することを忘れずに
let ptr = c_malloc(1024);
// ...ptrを使用
c_free(ptr);
```

### 3. エラーチェック

```hemlock
// 戻り値をチェック
let result = c_function();
if (result == null) {
    print("C function failed");
}
```

### 4. プラットフォーム互換性

```hemlock
// プラットフォームの違いを処理
// 適切なライブラリ拡張子を使用（.so、.dylib、.dll）
```

## 例

動作する例については、以下を参照してください：
- コールバックテスト：`/tests/ffi_callbacks/` - qsortコールバックの例
- stdlib FFI使用：`/stdlib/hash.hml`、`/stdlib/regex.hml`、`/stdlib/crypto.hml`
- サンプルプログラム：`/examples/`（利用可能な場合）

## ヘルプの取得

FFIはHemlockの新しい機能です。質問や問題については：

1. テストスイートで動作する例を確認
2. 低レベルの詳細についてはlibffiドキュメントを参照
3. プロジェクトのissuesを通じてバグ報告や機能リクエスト

## まとめ

HemlockのFFIは以下を提供します：

- 共有ライブラリからのC関数呼び出し
- プリミティブ型サポート（i8-i64, u8-u64, f32, f64, ptr）
- 自動型変換
- libffiベースのポータビリティ
- ネイティブライブラリ統合の基盤
- **関数ポインタコールバック** - Hemlock関数をCに渡す
- **extern関数のエクスポート** - モジュール間でFFIバインディングを共有
- **構造体の受け渡しと戻り** - C互換構造体を値で渡す
- **defineのエクスポート** - モジュール間で構造体型定義を共有（グローバルに自動インポート）
- **完全なポインタヘルパー** - すべての型の読み書き（i8-i64, u8-u64, f32, f64, ptr）
- **バッファ/ポインタ変換** - データマーシャリング用`buffer_ptr()`、`ptr_to_buffer()`
- **FFI型サイズ** - プラットフォーム対応の型サイズ用`ffi_sizeof()`
- **プラットフォーム型** - `size_t`、`usize`、`isize`、`intptr_t`、`uintptr_t`のサポート

**現在のステータス：**FFIはプリミティブ型、構造体、コールバック、モジュールエクスポート、完全なポインタヘルパー関数で完全な機能を備えています

**将来：**文字列マーシャリングヘルパー

**使用ケース：**システムライブラリ、サードパーティライブラリ、qsort、イベントループ、コールバックベースAPI、再利用可能なライブラリラッパー

## 貢献

FFIドキュメントは拡張中です。FFIで作業している場合：
- 使用ケースをドキュメント化
- サンプルコードを共有
- 問題や制限を報告
- 改善を提案

FFIシステムは、必要な場合に低レベルアクセスを提供しながら、実用的で安全になるよう設計されており、Hemlockの「暗黙より明示」と「unsafeはバグではなく機能」という哲学に従っています。


--------------------------------------------------------------------------------
## File IO
--------------------------------------------------------------------------------

# HemlockでのファイルI/O

Hemlockは、適切なエラー処理とリソース管理を備えたファイル操作のための**Fileオブジェクト API**を提供します。

## 目次

- [概要](#概要)
- [ファイルを開く](#ファイルを開く)
- [ファイルメソッド](#ファイルメソッド)
- [ファイルプロパティ](#ファイルプロパティ)
- [エラー処理](#エラー処理)
- [リソース管理](#リソース管理)
- [完全なAPIリファレンス](#完全なapiリファレンス)
- [一般的なパターン](#一般的なパターン)
- [ベストプラクティス](#ベストプラクティス)

## 概要

FileオブジェクトAPIは以下を提供します：

- **明示的なリソース管理** - ファイルは手動で閉じる必要がある
- **複数のオープンモード** - 読み取り、書き込み、追記、読み書き
- **テキストとバイナリ操作** - テキストとバイナリデータの両方を読み書き
- **シーク対応** - ファイル内でのランダムアクセス
- **包括的なエラーメッセージ** - コンテキスト対応のエラー報告

**重要：**ファイルは自動的に閉じられません。ファイルディスクリプタのリークを避けるために`f.close()`を呼び出す必要があります。

## ファイルを開く

ファイルを開くには`open(path, mode?)`を使用します：

```hemlock
let f = open("data.txt", "r");     // 読み取りモード（デフォルト）
let f2 = open("output.txt", "w");  // 書き込みモード（切り詰め）
let f3 = open("log.txt", "a");     // 追記モード
let f4 = open("data.bin", "r+");   // 読み書きモード
```

### オープンモード

| モード | 説明 | ファイルの存在が必要 | 切り詰め | 位置 |
|------|-------------|----------------|-----------|----------|
| `"r"` | 読み取り（デフォルト） | はい | いいえ | 先頭 |
| `"w"` | 書き込み | いいえ（作成） | はい | 先頭 |
| `"a"` | 追記 | いいえ（作成） | いいえ | 末尾 |
| `"r+"` | 読み書き | はい | いいえ | 先頭 |
| `"w+"` | 読み書き | いいえ（作成） | はい | 先頭 |
| `"a+"` | 読み取りと追記 | いいえ（作成） | いいえ | 末尾 |

### 例

**既存ファイルの読み取り：**
```hemlock
let f = open("config.json", "r");
// または単に：
let f = open("config.json");  // "r"がデフォルト
```

**書き込み用に新しいファイルを作成：**
```hemlock
let f = open("output.txt", "w");  // 作成または切り詰め
```

**ファイルへの追記：**
```hemlock
let f = open("log.txt", "a");  // 存在しない場合は作成
```

**読み書きモード：**
```hemlock
let f = open("data.bin", "r+");  // 既存ファイル、読み書き可能
```

## ファイルメソッド

### 読み取り

#### read(size?: i32): string

ファイルからテキストを読み取り（オプションのサイズパラメータ）。

**サイズなし（すべて読み取り）：**
```hemlock
let f = open("data.txt", "r");
let all = f.read();  // 現在位置からEOFまで読み取り
f.close();
```

**サイズ指定（特定バイト数を読み取り）：**
```hemlock
let f = open("data.txt", "r");
let chunk = f.read(1024);  // 最大1024バイト読み取り
let next = f.read(1024);   // 次の1024バイトを読み取り
f.close();
```

**戻り値：**読み取ったデータを含む文字列、またはEOFの場合は空文字列

**例 - ファイル全体の読み取り：**
```hemlock
let f = open("poem.txt", "r");
let content = f.read();
print(content);
f.close();
```

**例 - チャンクでの読み取り：**
```hemlock
let f = open("large.txt", "r");
while (true) {
    let chunk = f.read(4096);  // 4KBチャンク
    if (chunk == "") { break; }  // EOFに到達
    process(chunk);
}
f.close();
```

#### read_bytes(size: i32): buffer

バイナリデータを読み取り（バッファを返す）。

**パラメータ：**
- `size`（i32）- 読み取るバイト数

**戻り値：**読み取ったバイトを含むバッファ

```hemlock
let f = open("image.png", "r");
let binary = f.read_bytes(256);  // 256バイト読み取り
print(binary.length);  // 256（またはEOFの場合はそれ以下）

// 個々のバイトにアクセス
let first_byte = binary[0];
print(first_byte);

f.close();
```

**例 - バイナリファイル全体の読み取り：**
```hemlock
let f = open("data.bin", "r");
let size = 10240;  // 予想サイズ
let data = f.read_bytes(size);
f.close();

// バイナリデータを処理
let i = 0;
while (i < data.length) {
    let byte = data[i];
    // ...バイトを処理
    i = i + 1;
}
```

### 書き込み

#### write(data: string): i32

ファイルにテキストを書き込み（書き込んだバイト数を返す）。

**パラメータ：**
- `data`（string）- 書き込むテキスト

**戻り値：**書き込んだバイト数（i32）

```hemlock
let f = open("output.txt", "w");
let written = f.write("Hello, World!\n");
print("Wrote " + typeof(written) + " bytes");  // "Wrote 14 bytes"
f.close();
```

**例 - 複数行の書き込み：**
```hemlock
let f = open("output.txt", "w");
f.write("Line 1\n");
f.write("Line 2\n");
f.write("Line 3\n");
f.close();
```

**例 - ログファイルへの追記：**
```hemlock
let f = open("app.log", "a");
f.write("[INFO] Application started\n");
f.write("[INFO] User logged in\n");
f.close();
```

#### write_bytes(data: buffer): i32

バイナリデータを書き込み（書き込んだバイト数を返す）。

**パラメータ：**
- `data`（buffer）- 書き込むバイナリデータ

**戻り値：**書き込んだバイト数（i32）

```hemlock
let f = open("output.bin", "w");

// バイナリデータを作成
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

let bytes = f.write_bytes(buf);
print("Wrote " + typeof(bytes) + " bytes");

f.close();
```

**例 - バイナリファイルのコピー：**
```hemlock
let src = open("input.bin", "r");
let dst = open("output.bin", "w");

let data = src.read_bytes(1024);
while (data.length > 0) {
    dst.write_bytes(data);
    data = src.read_bytes(1024);
}

src.close();
dst.close();
```

### シーク

#### seek(position: i32): i32

特定の位置に移動（新しい位置を返す）。

**パラメータ：**
- `position`（i32）- ファイル先頭からのバイトオフセット

**戻り値：**新しい位置（i32）

```hemlock
let f = open("data.txt", "r");

// バイト100に移動
f.seek(100);

// 位置100から読み取り
let data = f.read(50);

// 先頭にリセット
f.seek(0);

f.close();
```

**例 - ランダムアクセス：**
```hemlock
let f = open("records.dat", "r");

// オフセット1000のレコードを読み取り
f.seek(1000);
let record1 = f.read_bytes(100);

// オフセット2000のレコードを読み取り
f.seek(2000);
let record2 = f.read_bytes(100);

f.close();
```

#### tell(): i32

ファイル内の現在位置を取得。

**戻り値：**現在のバイトオフセット（i32）

```hemlock
let f = open("data.txt", "r");

let pos1 = f.tell();  // 0（先頭）

f.read(100);
let pos2 = f.tell();  // 100（100バイト読み取り後）

f.seek(500);
let pos3 = f.tell();  // 500（シーク後）

f.close();
```

**例 - 読み取り量の測定：**
```hemlock
let f = open("data.txt", "r");

let start = f.tell();
let content = f.read();
let end = f.tell();

let bytes_read = end - start;
print("Read " + typeof(bytes_read) + " bytes");

f.close();
```

### クローズ

#### close()

ファイルを閉じる（冪等、複数回呼び出し可能）。

```hemlock
let f = open("data.txt", "r");
// ...ファイルを使用
f.close();
f.close();  // 安全 - 2回目のクローズでエラーなし
```

**重要な注意事項：**
- ファイルディスクリプタのリークを避けるため、常に完了時にファイルを閉じる
- クローズは冪等 - 複数回安全に呼び出し可能
- クローズ後、他のすべての操作はエラーになる
- エラー時でもファイルが閉じられるように`finally`ブロックを使用

## ファイルプロパティ

Fileオブジェクトには3つの読み取り専用プロパティがあります：

### path: string

ファイルを開くために使用されたファイルパス。

```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);  // "/path/to/file.txt"
f.close();
```

### mode: string

ファイルが開かれたモード。

```hemlock
let f = open("data.txt", "r");
print(f.mode);  // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);  // "w"
f2.close();
```

### closed: bool

ファイルが閉じられているかどうか。

```hemlock
let f = open("data.txt", "r");
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

**例 - ファイルが開いているか確認：**
```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ...コンテンツを処理
}

f.close();

if (f.closed) {
    print("File is now closed");
}
```

## エラー処理

すべてのファイル操作にはコンテキスト付きの適切なエラーメッセージが含まれます。

### 一般的なエラー

**ファイルが見つからない：**
```hemlock
let f = open("missing.txt", "r");
// エラー: Failed to open 'missing.txt': No such file or directory
```

**閉じたファイルからの読み取り：**
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// エラー: Cannot read from closed file 'data.txt'
```

**読み取り専用ファイルへの書き込み：**
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// エラー: Cannot write to file 'readonly.txt' opened in read-only mode
```

**書き込み専用ファイルからの読み取り：**
```hemlock
let f = open("output.txt", "w");
f.read();
// エラー: Cannot read from file 'output.txt' opened in write-only mode
```

### try/catchの使用

```hemlock
try {
    let f = open("data.txt", "r");
    let content = f.read();
    f.close();
    process(content);
} catch (e) {
    print("Error reading file: " + e);
}
```

## リソース管理

### 基本パターン

常にファイルを明示的に閉じる：

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### エラー処理付き（推奨）

エラー時でもファイルが閉じられるように`finally`を使用：

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // エラーでも常に閉じる
}
```

### 複数ファイル

```hemlock
let src = null;
let dst = null;

try {
    src = open("input.txt", "r");
    dst = open("output.txt", "w");

    let content = src.read();
    dst.write(content);
} finally {
    if (src != null) { src.close(); }
    if (dst != null) { dst.close(); }
}
```

### ヘルパー関数パターン

```hemlock
fn with_file(path: string, mode: string, callback) {
    let f = open(path, mode);
    try {
        return callback(f);
    } finally {
        f.close();
    }
}

// 使用方法：
with_file("data.txt", "r", fn(f) {
    return f.read();
});
```

## 完全なAPIリファレンス

### 関数

| 関数 | パラメータ | 戻り値 | 説明 |
|----------|-----------|---------|-------------|
| `open(path, mode?)` | path: string, mode?: string | File | ファイルを開く（モードのデフォルトは"r"） |

### メソッド

| メソッド | パラメータ | 戻り値 | 説明 |
|--------|-----------|---------|-------------|
| `read(size?)` | size?: i32 | string | テキストを読み取り（すべてまたは特定バイト） |
| `read_bytes(size)` | size: i32 | buffer | バイナリデータを読み取り |
| `write(data)` | data: string | i32 | テキストを書き込み、書き込んだバイト数を返す |
| `write_bytes(data)` | data: buffer | i32 | バイナリデータを書き込み、書き込んだバイト数を返す |
| `seek(position)` | position: i32 | i32 | 位置にシーク、新しい位置を返す |
| `tell()` | - | i32 | 現在位置を取得 |
| `close()` | - | null | ファイルを閉じる（冪等） |

### プロパティ（読み取り専用）

| プロパティ | 型 | 説明 |
|----------|------|-------------|
| `path` | string | ファイルパス |
| `mode` | string | オープンモード |
| `closed` | bool | ファイルが閉じられているかどうか |

## 一般的なパターン

### ファイル全体の読み取り

```hemlock
fn read_file(path: string): string {
    let f = open(path, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

let content = read_file("config.json");
```

### ファイル全体の書き込み

```hemlock
fn write_file(path: string, content: string) {
    let f = open(path, "w");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

write_file("output.txt", "Hello, World!");
```

### ファイルへの追記

```hemlock
fn append_file(path: string, content: string) {
    let f = open(path, "a");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

append_file("log.txt", "[INFO] Event occurred\n");
```

### 行の読み取り

```hemlock
fn read_lines(path: string) {
    let f = open(path, "r");
    try {
        let content = f.read();
        return content.split("\n");
    } finally {
        f.close();
    }
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### 大きなファイルのチャンク処理

```hemlock
fn process_large_file(path: string) {
    let f = open(path, "r");
    try {
        while (true) {
            let chunk = f.read(4096);  // 4KBチャンク
            if (chunk == "") { break; }

            // チャンクを処理
            process_chunk(chunk);
        }
    } finally {
        f.close();
    }
}
```

### バイナリファイルコピー

```hemlock
fn copy_file(src_path: string, dst_path: string) {
    let src = null;
    let dst = null;

    try {
        src = open(src_path, "r");
        dst = open(dst_path, "w");

        while (true) {
            let chunk = src.read_bytes(4096);
            if (chunk.length == 0) { break; }

            dst.write_bytes(chunk);
        }
    } finally {
        if (src != null) { src.close(); }
        if (dst != null) { dst.close(); }
    }
}

copy_file("input.dat", "output.dat");
```

### ファイルの切り詰め

```hemlock
fn truncate_file(path: string) {
    let f = open(path, "w");  // "w"モードは切り詰め
    f.close();
}

truncate_file("empty_me.txt");
```

### ランダムアクセス読み取り

```hemlock
fn read_at_offset(path: string, offset: i32, size: i32): string {
    let f = open(path, "r");
    try {
        f.seek(offset);
        return f.read(size);
    } finally {
        f.close();
    }
}

let data = read_at_offset("records.dat", 1000, 100);
```

### ファイルサイズ

```hemlock
fn file_size(path: string): i32 {
    let f = open(path, "r");
    try {
        // 末尾にシーク
        let end = f.seek(999999999);  // 大きな数
        f.seek(0);  // リセット
        return end;
    } finally {
        f.close();
    }
}

let size = file_size("data.txt");
print("File size: " + typeof(size) + " bytes");
```

### 条件付き読み書き

```hemlock
fn update_file(path: string, condition, new_content: string) {
    let f = open(path, "r+");
    try {
        let content = f.read();

        if (condition(content)) {
            f.seek(0);  // 先頭にリセット
            f.write(new_content);
        }
    } finally {
        f.close();
    }
}
```

## ベストプラクティス

### 1. 常にtry/finallyを使用

```hemlock
// 良い例
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();
}

// 悪い例 - エラー時にファイルが閉じられない可能性
let f = open("data.txt", "r");
let content = f.read();
process(content);  // これがスローするとファイルがリーク
f.close();
```

### 2. 操作前にファイル状態を確認

```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ...コンテンツを使用
}

f.close();
```

### 3. 適切なモードを使用

```hemlock
// 読み取りのみ？"r"を使用
let f = open("config.json", "r");

// 完全に置換？"w"を使用
let f = open("output.txt", "w");

// 末尾に追加？"a"を使用
let f = open("log.txt", "a");
```

### 4. エラーを優雅に処理

```hemlock
fn safe_read_file(path: string): string {
    try {
        let f = open(path, "r");
        try {
            return f.read();
        } finally {
            f.close();
        }
    } catch (e) {
        print("Warning: Could not read " + path + ": " + e);
        return "";
    }
}
```

### 5. 開いた逆順でファイルを閉じる

```hemlock
let f1 = null;
let f2 = null;
let f3 = null;

try {
    f1 = open("file1.txt", "r");
    f2 = open("file2.txt", "r");
    f3 = open("file3.txt", "r");

    // ...ファイルを使用
} finally {
    // 逆順で閉じる
    if (f3 != null) { f3.close(); }
    if (f2 != null) { f2.close(); }
    if (f1 != null) { f1.close(); }
}
```

### 6. 大きなファイルは全体を読み取らない

```hemlock
// 大きなファイルには悪い例
let f = open("huge.log", "r");
let content = f.read();  // ファイル全体をメモリにロード
f.close();

// 良い例 - チャンクで処理
let f = open("huge.log", "r");
try {
    while (true) {
        let chunk = f.read(4096);
        if (chunk == "") { break; }
        process_chunk(chunk);
    }
} finally {
    f.close();
}
```

## まとめ

HemlockのファイルI/O APIは以下を提供します：

- シンプルで明示的なファイル操作
- テキストとバイナリのサポート
- seek/tellによるランダムアクセス
- コンテキスト付きの明確なエラーメッセージ
- 冪等なクローズ操作

覚えておくべきこと：
- 常にファイルを手動で閉じる
- リソース安全のためにtry/finallyを使用
- 適切なオープンモードを選択
- エラーを優雅に処理
- 大きなファイルはチャンクで処理


--------------------------------------------------------------------------------
## アトミック操作
--------------------------------------------------------------------------------

# アトミック操作

Hemlockは**ロックフリー並行プログラミング**のためのアトミック操作を提供します。これらの操作により、従来のロックやミューテックスを使用せずに、複数のスレッド間で共有メモリを安全に操作できます。

## 目次

- [概要](#概要)
- [アトミックを使用する場面](#アトミックを使用する場面)
- [メモリモデル](#メモリモデル)
- [アトミックロードとストア](#アトミックロードとストア)
- [フェッチアンドモディファイ操作](#フェッチアンドモディファイ操作)
- [コンペアアンドスワップ (CAS)](#コンペアアンドスワップ-cas)
- [アトミックエクスチェンジ](#アトミックエクスチェンジ)
- [メモリフェンス](#メモリフェンス)
- [関数リファレンス](#関数リファレンス)
- [一般的なパターン](#一般的なパターン)
- [ベストプラクティス](#ベストプラクティス)
- [制限事項](#制限事項)

---

## 概要

アトミック操作は、中断の可能性なく完了する**不可分**な操作です。あるスレッドがアトミック操作を実行している間、他のスレッドはその操作が部分的に完了した状態を観察することはできません。

**主な特徴:**
- すべての操作で**逐次一貫性**（`memory_order_seq_cst`）を使用
- サポートされる型: **i32** と **i64**
- `alloc()`で確保した生ポインタに対して動作
- 明示的なロックなしでスレッドセーフ

**利用可能な操作:**
- Load/Store - アトミックに値を読み書き
- Add/Sub - 古い値を返す算術演算
- And/Or/Xor - 古い値を返すビット演算
- CAS - 条件付き更新のためのコンペアアンドスワップ
- Exchange - アトミックに値を交換
- Fence - 完全なメモリバリア

---

## アトミックを使用する場面

**アトミックを使用すべき場合:**
- タスク間で共有されるカウンタ（例：リクエスト数、進捗追跡）
- フラグとステータスインジケータ
- ロックフリーデータ構造
- 単純な同期プリミティブ
- パフォーマンスが重要な並行コード

**代わりにチャネルを使用すべき場合:**
- タスク間で複雑なデータを渡す場合
- プロデューサー・コンシューマーパターンを実装する場合
- メッセージパッシングセマンティクスが必要な場合

**使用例 - 共有カウンタ:**
```hemlock
// 共有カウンタを確保
let counter = alloc(4);
ptr_write_i32(counter, 0);

async fn worker(counter: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(counter, 1);
        i = i + 1;
    }
}

// 複数のワーカーを生成
let t1 = spawn(worker, counter, 1);
let t2 = spawn(worker, counter, 2);
let t3 = spawn(worker, counter, 3);

join(t1);
join(t2);
join(t3);

// カウンタは正確に3000になる（データ競合なし）
print(atomic_load_i32(counter));

free(counter);
```

---

## メモリモデル

すべてのHemlockアトミック操作は**逐次一貫性**（`memory_order_seq_cst`）を使用し、最も強いメモリ順序保証を提供します：

1. **アトミック性**: 各操作は不可分
2. **全順序付け**: すべてのスレッドが同じ操作順序を観察
3. **リオーダリングなし**: コンパイラやCPUによる操作の並び替えなし

これにより、弱いメモリ順序付けと比較して潜在的なパフォーマンスコストはありますが、並行コードの推論が簡単になります。

---

## アトミックロードとストア

### atomic_load_i32 / atomic_load_i64

メモリから値をアトミックに読み取ります。

**シグネチャ:**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**パラメータ:**
- `ptr` - メモリ位置へのポインタ（適切にアラインされている必要あり）

**戻り値:** メモリ位置の値

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let value = atomic_load_i32(p);
print(value);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

メモリに値をアトミックに書き込みます。

**シグネチャ:**
```hemlock
atomic_store_i32(ptr: ptr, value: i32): null
atomic_store_i64(ptr: ptr, value: i64): null
```

**パラメータ:**
- `ptr` - メモリ位置へのポインタ
- `value` - 格納する値

**戻り値:** `null`

**例:**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## フェッチアンドモディファイ操作

これらの操作は値をアトミックに変更し、**古い**（変更前の）値を返します。

### atomic_add_i32 / atomic_add_i64

値にアトミックに加算します。

**シグネチャ:**
```hemlock
atomic_add_i32(ptr: ptr, value: i32): i32
atomic_add_i64(ptr: ptr, value: i64): i64
```

**戻り値:** **古い**値（加算前）

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_add_i32(p, 10);
print(old);                    // 100（古い値）
print(atomic_load_i32(p));     // 110（新しい値）

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

値からアトミックに減算します。

**シグネチャ:**
```hemlock
atomic_sub_i32(ptr: ptr, value: i32): i32
atomic_sub_i64(ptr: ptr, value: i64): i64
```

**戻り値:** **古い**値（減算前）

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_sub_i32(p, 25);
print(old);                    // 100（古い値）
print(atomic_load_i32(p));     // 75（新しい値）

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

ビット単位ANDをアトミックに実行します。

**シグネチャ:**
```hemlock
atomic_and_i32(ptr: ptr, value: i32): i32
atomic_and_i64(ptr: ptr, value: i64): i64
```

**戻り値:** **古い**値（AND前）

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // 2進数で255: 11111111

let old = atomic_and_i32(p, 0x0F);  // 00001111とAND
print(old);                    // 255（古い値）
print(atomic_load_i32(p));     // 15（0xFF & 0x0F = 0x0F）

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

ビット単位ORをアトミックに実行します。

**シグネチャ:**
```hemlock
atomic_or_i32(ptr: ptr, value: i32): i32
atomic_or_i64(ptr: ptr, value: i64): i64
```

**戻り値:** **古い**値（OR前）

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // 2進数で15: 00001111

let old = atomic_or_i32(p, 0xF0);  // 11110000とOR
print(old);                    // 15（古い値）
print(atomic_load_i32(p));     // 255（0x0F | 0xF0 = 0xFF）

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

ビット単位XORをアトミックに実行します。

**シグネチャ:**
```hemlock
atomic_xor_i32(ptr: ptr, value: i32): i32
atomic_xor_i64(ptr: ptr, value: i64): i64
```

**戻り値:** **古い**値（XOR前）

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // 2進数で170: 10101010

let old = atomic_xor_i32(p, 0xFF);  // 11111111とXOR
print(old);                    // 170（古い値）
print(atomic_load_i32(p));     // 85（0xAA ^ 0xFF = 0x55）

free(p);
```

---

## コンペアアンドスワップ (CAS)

最も強力なアトミック操作です。現在の値と期待値をアトミックに比較し、一致する場合は新しい値で置き換えます。

### atomic_cas_i32 / atomic_cas_i64

**シグネチャ:**
```hemlock
atomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool
atomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool
```

**パラメータ:**
- `ptr` - メモリ位置へのポインタ
- `expected` - 期待する値
- `desired` - 期待値と一致した場合に格納する値

**戻り値:**
- `true` - スワップ成功（値が`expected`だったので`desired`になった）
- `false` - スワップ失敗（値が`expected`ではなかったので変更なし）

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS成功: 値は100なので999にスワップ
let success1 = atomic_cas_i32(p, 100, 999);
print(success1);               // true
print(atomic_load_i32(p));     // 999

// CAS失敗: 値は999であり100ではない
let success2 = atomic_cas_i32(p, 100, 888);
print(success2);               // false
print(atomic_load_i32(p));     // 999（変更なし）

free(p);
```

**ユースケース:**
- ロックとセマフォの実装
- ロックフリーデータ構造
- 楽観的並行制御
- アトミックな条件付き更新

---

## アトミックエクスチェンジ

値をアトミックにスワップし、古い値を返します。

### atomic_exchange_i32 / atomic_exchange_i64

**シグネチャ:**
```hemlock
atomic_exchange_i32(ptr: ptr, value: i32): i32
atomic_exchange_i64(ptr: ptr, value: i64): i64
```

**パラメータ:**
- `ptr` - メモリ位置へのポインタ
- `value` - 格納する新しい値

**戻り値:** **古い**値（交換前）

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_exchange_i32(p, 200);
print(old);                    // 100（古い値）
print(atomic_load_i32(p));     // 200（新しい値）

free(p);
```

---

## メモリフェンス

完全なメモリバリアで、フェンス前のすべてのメモリ操作が、フェンス後の操作の前にすべてのスレッドから可視になることを保証します。

### atomic_fence

**シグネチャ:**
```hemlock
atomic_fence(): null
```

**戻り値:** `null`

**例:**
```hemlock
// 以前のすべての書き込みが可視になることを保証
atomic_fence();
```

**注意:** ほとんどの場合、すべてのアトミック操作が既に逐次一貫性を使用しているため、明示的なフェンスは必要ありません。フェンスは非アトミックメモリ操作を同期する必要がある場合に有用です。

---

## 関数リファレンス

### i32操作

| 関数 | シグネチャ | 戻り値 | 説明 |
|----------|-----------|---------|-------------|
| `atomic_load_i32` | `(ptr)` | `i32` | アトミックに値をロード |
| `atomic_store_i32` | `(ptr, value)` | `null` | アトミックに値をストア |
| `atomic_add_i32` | `(ptr, value)` | `i32` | 加算して古い値を返す |
| `atomic_sub_i32` | `(ptr, value)` | `i32` | 減算して古い値を返す |
| `atomic_and_i32` | `(ptr, value)` | `i32` | ビット単位ANDして古い値を返す |
| `atomic_or_i32` | `(ptr, value)` | `i32` | ビット単位ORして古い値を返す |
| `atomic_xor_i32` | `(ptr, value)` | `i32` | ビット単位XORして古い値を返す |
| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | コンペアアンドスワップ |
| `atomic_exchange_i32` | `(ptr, value)` | `i32` | 交換して古い値を返す |

### i64操作

| 関数 | シグネチャ | 戻り値 | 説明 |
|----------|-----------|---------|-------------|
| `atomic_load_i64` | `(ptr)` | `i64` | アトミックに値をロード |
| `atomic_store_i64` | `(ptr, value)` | `null` | アトミックに値をストア |
| `atomic_add_i64` | `(ptr, value)` | `i64` | 加算して古い値を返す |
| `atomic_sub_i64` | `(ptr, value)` | `i64` | 減算して古い値を返す |
| `atomic_and_i64` | `(ptr, value)` | `i64` | ビット単位ANDして古い値を返す |
| `atomic_or_i64` | `(ptr, value)` | `i64` | ビット単位ORして古い値を返す |
| `atomic_xor_i64` | `(ptr, value)` | `i64` | ビット単位XORして古い値を返す |
| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | コンペアアンドスワップ |
| `atomic_exchange_i64` | `(ptr, value)` | `i64` | 交換して古い値を返す |

### メモリバリア

| 関数 | シグネチャ | 戻り値 | 説明 |
|----------|-----------|---------|-------------|
| `atomic_fence` | `()` | `null` | 完全なメモリバリア |

---

## 一般的なパターン

### パターン: アトミックカウンタ

```hemlock
// スレッドセーフなカウンタ
let counter = alloc(4);
ptr_write_i32(counter, 0);

fn increment(): i32 {
    return atomic_add_i32(counter, 1);
}

fn decrement(): i32 {
    return atomic_sub_i32(counter, 1);
}

fn get_count(): i32 {
    return atomic_load_i32(counter);
}

// 使用法
increment();  // 0を返す（古い値）
increment();  // 1を返す
increment();  // 2を返す
print(get_count());  // 3

free(counter);
```

### パターン: スピンロック

```hemlock
// シンプルなスピンロック実装
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = アンロック、1 = ロック

fn acquire() {
    // ロックを0から1に設定できるまでスピン
    while (!atomic_cas_i32(lock, 0, 1)) {
        // ビジーウェイト
    }
}

fn release() {
    atomic_store_i32(lock, 0);
}

// 使用法
acquire();
// ... クリティカルセクション ...
release();

free(lock);
```

### パターン: 一度だけの初期化

```hemlock
let initialized = alloc(4);
ptr_write_i32(initialized, 0);  // 0 = 未初期化、1 = 初期化済み

fn ensure_initialized() {
    // 初期化する側になろうとする
    if (atomic_cas_i32(initialized, 0, 1)) {
        // 競争に勝ったので初期化を実行
        do_expensive_init();
    }
    // そうでなければ、既に初期化済み
}
```

### パターン: アトミックフラグ

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn set_flag() {
    atomic_store_i32(flag, 1);
}

fn clear_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // フラグが既にセットされていればtrueを返す
    return atomic_exchange_i32(flag, 1) == 1;
}

fn check_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### パターン: 境界付きカウンタ

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);
let max_value = 100;

fn try_increment(): bool {
    while (true) {
        let current = atomic_load_i32(counter);
        if (current >= max_value) {
            return false;  // 最大値に達している
        }
        if (atomic_cas_i32(counter, current, current + 1)) {
            return true;  // インクリメント成功
        }
        // CAS失敗、他のスレッドが変更 - リトライ
    }
}
```

---

## ベストプラクティス

### 1. 適切なアラインメントを使用

ポインタはデータ型に対して適切にアラインされている必要があります：
- i32: 4バイトアラインメント
- i64: 8バイトアラインメント

`alloc()`からのメモリは通常、適切にアラインされています。

### 2. より高レベルの抽象化を優先

可能な場合は、タスク間通信にチャネルを使用してください。アトミックは低レベルであり、注意深い推論が必要です。

```hemlock
// こちらを優先:
let ch = channel(10);
spawn(fn() { ch.send(result); });
let value = ch.recv();

// 適切な場合は手動のアトミック協調よりも
```

### 3. ABA問題に注意

CASはABA問題の影響を受ける可能性があります：値がAからBに変わり、再びAに戻ります。CASは成功しますが、その間に状態が変わっている可能性があります。

### 4. 共有前に初期化

タスクを生成する前に、常にアトミック変数を初期化してください：

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);  // 生成前に初期化

let task = spawn(worker, counter);
```

### 5. すべてのタスク完了後に解放

タスクがまだアクセスしている可能性がある間は、アトミックメモリを解放しないでください：

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);

let t1 = spawn(worker, counter);
let t2 = spawn(worker, counter);

join(t1);
join(t2);

// これで解放しても安全
free(counter);
```

---

## 制限事項

### 現在の制限

1. **i32とi64のみサポート** - 他の型に対するアトミック操作なし
2. **ポインタアトミックなし** - ポインタをアトミックにロード/ストアできない
3. **逐次一貫性のみ** - 弱いメモリ順序付けは利用不可
4. **アトミック浮動小数点なし** - 必要な場合は整数表現を使用

### プラットフォームに関する注意

- アトミック操作は内部でC11の`<stdatomic.h>`を使用
- POSIXスレッドをサポートするすべてのプラットフォームで利用可能
- モダンな64ビットシステムではロックフリーであることが保証

---

## 関連項目

- [非同期/並行処理](#advanced-async-concurrency) - タスクの生成とチャネル
- [メモリ管理](#language-guide-memory) - ポインタとバッファの確保
- [メモリAPI](#reference-memory-api) - 確保関数


--------------------------------------------------------------------------------
## コマンドライン引数
--------------------------------------------------------------------------------

# Hemlockでのコマンドライン引数

Hemlockプログラムは、プログラム起動時に自動的に設定される組み込みの**`args`配列**を通じてコマンドライン引数にアクセスできます。

## 目次

- [概要](#概要)
- [args配列](#args配列)
- [プロパティ](#プロパティ)
- [反復パターン](#反復パターン)
- [一般的な使用ケース](#一般的な使用ケース)
- [引数解析パターン](#引数解析パターン)
- [ベストプラクティス](#ベストプラクティス)
- [完全な例](#完全な例)

## 概要

`args`配列は、Hemlockプログラムに渡されたコマンドライン引数へのアクセスを提供します：

- **常に利用可能** - すべてのHemlockプログラムで組み込みのグローバル変数
- **スクリプト名を含む** - `args[0]`は常にスクリプトのパス/名前を含む
- **文字列の配列** - すべての引数は文字列
- **ゼロインデックス** - 標準的な配列インデックス（0, 1, 2, ...）

## args配列

### 基本構造

```hemlock
// args[0]は常にスクリプトのファイル名
// args[1]からargs[n-1]が実際の引数
print(args[0]);        // "script.hml"
print(args.length);    // 引数の総数（スクリプト名を含む）
```

### 使用例

**コマンド：**
```bash
./hemlock script.hml hello world "test 123"
```

**script.hml内：**
```hemlock
print("Script name: " + args[0]);     // "script.hml"
print("Total args: " + typeof(args.length));  // "4"
print("First arg: " + args[1]);       // "hello"
print("Second arg: " + args[2]);      // "world"
print("Third arg: " + args[3]);       // "test 123"
```

### インデックスリファレンス

| インデックス | 内容 | 例の値 |
|-------|----------|---------------|
| `args[0]` | スクリプトパス/名前 | `"script.hml"`または`"./script.hml"` |
| `args[1]` | 最初の引数 | `"hello"` |
| `args[2]` | 2番目の引数 | `"world"` |
| `args[3]` | 3番目の引数 | `"test 123"` |
| ... | ... | ... |
| `args[n-1]` | 最後の引数 | （可変） |

## プロパティ

### 常に存在

`args`は**すべての**Hemlockプログラムで利用可能なグローバル配列です：

```hemlock
// 宣言やインポートは不要
print(args.length);  // すぐに動作
```

### スクリプト名を含む

`args[0]`は常にスクリプトのパス/名前を含みます：

```hemlock
print("Running: " + args[0]);
```

**args[0]の可能な値：**
- `"script.hml"` - ファイル名のみ
- `"./script.hml"` - 相対パス
- `"/home/user/script.hml"` - 絶対パス
- スクリプトの呼び出し方法に依存

### 型：文字列の配列

すべての引数は文字列として格納されます：

```hemlock
// 引数: ./hemlock script.hml 42 3.14 true

print(args[1]);  // "42"（文字列、数値ではない）
print(args[2]);  // "3.14"（文字列、数値ではない）
print(args[3]);  // "true"（文字列、ブール値ではない）

// 必要に応じて変換：
let num = 42;  // 必要に応じて手動でパース
```

### 最小長

常に少なくとも1（スクリプト名）：

```hemlock
print(args.length);  // 最小：1
```

**引数なしでも：**
```bash
./hemlock script.hml
```

```hemlock
// script.hml内:
print(args.length);  // 1（スクリプト名のみ）
```

### REPLの動作

REPLでは、`args.length`は0（空配列）です：

```hemlock
# REPLセッション
> print(args.length);
0
```

## 反復パターン

### 基本的な反復

`args[0]`（スクリプト名）をスキップして実際の引数を処理：

```hemlock
let i = 1;
while (i < args.length) {
    print("Argument " + typeof(i) + ": " + args[i]);
    i = i + 1;
}
```

**出力（`./hemlock script.hml foo bar baz`の場合）**
```
Argument 1: foo
Argument 2: bar
Argument 3: baz
```

### For-In反復（スクリプト名を含む）

```hemlock
for (let arg in args) {
    print(arg);
}
```

**出力：**
```
script.hml
foo
bar
baz
```

### 引数数のチェック

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <argument>");
    // exitまたはreturn
} else {
    let arg = args[1];
    // argを処理
}
```

### スクリプト名以外のすべての引数を処理

```hemlock
let actual_args = args.slice(1, args.length);

for (let arg in actual_args) {
    print("Processing: " + arg);
}
```

## 一般的な使用ケース

### 1. シンプルな引数処理

必須引数のチェック：

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    print("Processing file: " + filename);
    // ...ファイルを処理
}
```

**使用方法：**
```bash
./hemlock script.hml data.txt
# 出力: Processing file: data.txt
```

### 2. 複数引数

```hemlock
if (args.length < 3) {
    print("Usage: " + args[0] + " <input> <output>");
} else {
    let input_file = args[1];
    let output_file = args[2];

    print("Input: " + input_file);
    print("Output: " + output_file);

    // ファイルを処理...
}
```

**使用方法：**
```bash
./hemlock convert.hml input.txt output.txt
```

### 3. 可変数の引数

提供されたすべての引数を処理：

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        print("  " + args[i]);
        process_file(args[i]);
        i = i + 1;
    }
}
```

**使用方法：**
```bash
./hemlock batch.hml file1.txt file2.txt file3.txt
```

### 4. ヘルプメッセージ

```hemlock
if (args.length < 2 || args[1] == "--help" || args[1] == "-h") {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show this help message");
    print("  -v, --verbose  Enable verbose output");
} else {
    // 通常処理
}
```

### 5. 引数の検証

```hemlock
fn validate_file(filename: string): bool {
    // ファイルが存在するかチェック（例）
    return filename != "";
}

if (args.length < 2) {
    print("Error: No filename provided");
} else if (!validate_file(args[1])) {
    print("Error: Invalid file: " + args[1]);
} else {
    print("Processing: " + args[1]);
}
```

## 引数解析パターン

### 名前付き引数（フラグ）

名前付き引数のシンプルなパターン：

```hemlock
let verbose = false;
let output_file = "";
let input_file = "";

let i = 1;
while (i < args.length) {
    if (args[i] == "--verbose" || args[i] == "-v") {
        verbose = true;
    } else if (args[i] == "--output" || args[i] == "-o") {
        i = i + 1;
        if (i < args.length) {
            output_file = args[i];
        }
    } else {
        input_file = args[i];
    }
    i = i + 1;
}

if (verbose) {
    print("Verbose mode enabled");
}
print("Input: " + input_file);
print("Output: " + output_file);
```

**使用方法：**
```bash
./hemlock script.hml --verbose --output out.txt input.txt
./hemlock script.hml -v -o out.txt input.txt
```

### ブールフラグ

```hemlock
let debug = false;
let verbose = false;
let force = false;

let i = 1;
while (i < args.length) {
    if (args[i] == "--debug") {
        debug = true;
    } else if (args[i] == "--verbose") {
        verbose = true;
    } else if (args[i] == "--force") {
        force = true;
    }
    i = i + 1;
}
```

### 値引数

```hemlock
let config_file = "default.conf";
let port = 8080;

let i = 1;
while (i < args.length) {
    if (args[i] == "--config") {
        i = i + 1;
        if (i < args.length) {
            config_file = args[i];
        }
    } else if (args[i] == "--port") {
        i = i + 1;
        if (i < args.length) {
            port = 8080;  // 文字列をintにパースする必要がある
        }
    }
    i = i + 1;
}
```

### 位置引数と名前付き引数の混合

```hemlock
let input_file = "";
let output_file = "";
let verbose = false;

let i = 1;
let positional = [];

while (i < args.length) {
    if (args[i] == "--verbose") {
        verbose = true;
    } else {
        // 位置引数として扱う
        positional.push(args[i]);
    }
    i = i + 1;
}

// 位置引数を割り当て
if (positional.length > 0) {
    input_file = positional[0];
}
if (positional.length > 1) {
    output_file = positional[1];
}
```

### 引数パーサーヘルパー関数

```hemlock
fn parse_args() {
    let options = {
        verbose: false,
        output: "",
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                options.output = args[i];
            }
        } else {
            // 位置引数
            options.files.push(arg);
        }

        i = i + 1;
    }

    return options;
}

let opts = parse_args();
print("Verbose: " + typeof(opts.verbose));
print("Output: " + opts.output);
print("Files: " + typeof(opts.files.length));
```

## ベストプラクティス

### 1. 常に引数数をチェック

```hemlock
// 良い例
if (args.length < 2) {
    print("Usage: " + args[0] + " <file>");
} else {
    process_file(args[1]);
}

// 悪い例 - 引数がない場合にクラッシュする可能性
process_file(args[1]);  // args.length == 1の場合エラー
```

### 2. 使用方法情報を提供

```hemlock
fn show_usage() {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show help");
    print("  -v, --verbose  Verbose output");
}

if (args.length < 2) {
    show_usage();
}
```

### 3. 引数を検証

```hemlock
fn validate_args() {
    if (args.length < 2) {
        print("Error: Missing required argument");
        return false;
    }

    if (args[1] == "") {
        print("Error: Empty argument");
        return false;
    }

    return true;
}

if (!validate_args()) {
    // exitまたはusageを表示
}
```

### 4. 説明的な変数名を使用

```hemlock
// 良い例
let input_filename = args[1];
let output_filename = args[2];
let max_iterations = args[3];

// 悪い例
let a = args[1];
let b = args[2];
let c = args[3];
```

### 5. スペースを含むクォート引数を処理

シェルがこれを自動的に処理します：

```bash
./hemlock script.hml "file with spaces.txt"
```

```hemlock
print(args[1]);  // "file with spaces.txt"
```

### 6. 引数オブジェクトを作成

```hemlock
fn get_args() {
    return {
        script: args[0],
        input: args[1],
        output: args[2]
    };
}

let arguments = get_args();
print("Input: " + arguments.input);
```

## 完全な例

### 例1：ファイルプロセッサ

```hemlock
// 使用方法: ./hemlock process.hml <input> <output>

fn show_usage() {
    print("Usage: " + args[0] + " <input_file> <output_file>");
}

if (args.length < 3) {
    show_usage();
} else {
    let input = args[1];
    let output = args[2];

    print("Processing " + input + " -> " + output);

    // ファイルを処理
    let f_in = open(input, "r");
    let f_out = open(output, "w");

    try {
        let content = f_in.read();
        let processed = content.to_upper();  // 処理の例
        f_out.write(processed);

        print("Done!");
    } finally {
        f_in.close();
        f_out.close();
    }
}
```

### 例2：バッチファイルプロセッサ

```hemlock
// 使用方法: ./hemlock batch.hml <file1> <file2> <file3> ...

if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        let filename = args[i];
        print("  Processing: " + filename);

        try {
            let f = open(filename, "r");
            let content = f.read();
            f.close();

            // コンテンツを処理...
            print("    " + typeof(content.length) + " bytes");
        } catch (e) {
            print("    Error: " + e);
        }

        i = i + 1;
    }

    print("Done!");
}
```

### 例3：高度な引数パーサー

```hemlock
// 使用方法: ./hemlock app.hml [OPTIONS] <files...>
// オプション:
//   --verbose, -v     詳細出力を有効化
//   --output, -o FILE 出力ファイルを設定
//   --help, -h        ヘルプを表示

fn parse_arguments() {
    let config = {
        verbose: false,
        output: "output.txt",
        help: false,
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            config.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                config.output = args[i];
            } else {
                print("Error: --output requires a value");
            }
        } else if (arg == "--help" || arg == "-h") {
            config.help = true;
        } else if (arg.starts_with("--")) {
            print("Error: Unknown option: " + arg);
        } else {
            config.files.push(arg);
        }

        i = i + 1;
    }

    return config;
}

fn show_help() {
    print("Usage: " + args[0] + " [OPTIONS] <files...>");
    print("Options:");
    print("  --verbose, -v     Enable verbose output");
    print("  --output, -o FILE Set output file");
    print("  --help, -h        Show this help");
}

let config = parse_arguments();

if (config.help) {
    show_help();
} else if (config.files.length == 0) {
    print("Error: No input files specified");
    show_help();
} else {
    if (config.verbose) {
        print("Verbose mode enabled");
        print("Output file: " + config.output);
        print("Input files: " + typeof(config.files.length));
    }

    // ファイルを処理
    for (let file in config.files) {
        if (config.verbose) {
            print("Processing: " + file);
        }
        // ...ファイルを処理
    }
}
```

### 例4：設定ツール

```hemlock
// 使用方法: ./hemlock config.hml <action> [arguments]
// アクション:
//   get <key>
//   set <key> <value>
//   list

fn show_usage() {
    print("Usage: " + args[0] + " <action> [arguments]");
    print("Actions:");
    print("  get <key>         Get configuration value");
    print("  set <key> <value> Set configuration value");
    print("  list              List all configuration");
}

if (args.length < 2) {
    show_usage();
} else {
    let action = args[1];

    if (action == "get") {
        if (args.length < 3) {
            print("Error: 'get' requires a key");
        } else {
            let key = args[2];
            print("Getting: " + key);
            // ...設定から取得
        }
    } else if (action == "set") {
        if (args.length < 4) {
            print("Error: 'set' requires key and value");
        } else {
            let key = args[2];
            let value = args[3];
            print("Setting " + key + " = " + value);
            // ...設定に設定
        }
    } else if (action == "list") {
        print("Listing all configuration:");
        // ...設定をリスト
    } else {
        print("Error: Unknown action: " + action);
        show_usage();
    }
}
```

## まとめ

Hemlockのコマンドライン引数サポートは以下を提供します：

- グローバルに利用可能な組み込み`args`配列
- 引数へのシンプルな配列ベースのアクセス
- `args[0]`にスクリプト名
- すべての引数は文字列
- 配列メソッドが利用可能（.length, .sliceなど）

覚えておくべきこと：
- 要素にアクセスする前に常に`args.length`をチェック
- `args[0]`はスクリプト名
- 実際の引数は`args[1]`から開始
- すべての引数は文字列 - 必要に応じて変換
- ユーザーフレンドリーなツールのために使用方法情報を提供
- 処理前に引数を検証

一般的なパターン：
- シンプルな位置引数
- 名前付き/フラグ引数（--flag）
- 値引数（--option value）
- ヘルプメッセージ（--help）
- 引数検証


--------------------------------------------------------------------------------
## コマンド実行
--------------------------------------------------------------------------------

# Hemlockでのコマンド実行

Hemlockは、シェルコマンドを実行してその出力をキャプチャするための**`exec()`組み込み関数**を提供します。

## 目次

- [概要](#概要)
- [exec()関数](#exec関数)
- [結果オブジェクト](#結果オブジェクト)
- [基本的な使用方法](#基本的な使用方法)
- [高度な例](#高度な例)
- [エラー処理](#エラー処理)
- [実装の詳細](#実装の詳細)
- [セキュリティ上の考慮事項](#セキュリティ上の考慮事項)
- [制限事項](#制限事項)
- [使用ケース](#使用ケース)
- [ベストプラクティス](#ベストプラクティス)
- [完全な例](#完全な例)

## 概要

`exec()`関数により、Hemlockプログラムは以下のことができます：
- シェルコマンドを実行
- 標準出力（stdout）をキャプチャ
- 終了ステータスコードを確認
- シェル機能（パイプ、リダイレクトなど）を使用
- システムユーティリティと統合

**重要：**コマンドは`/bin/sh`を通じて実行され、完全なシェル機能を提供しますが、セキュリティ上の考慮事項も生じます。

## exec()関数

### シグネチャ

```hemlock
exec(command: string): object
```

**パラメータ：**
- `command`（string）- 実行するシェルコマンド

**戻り値：**2つのフィールドを持つオブジェクト：
- `output`（string）- コマンドのstdout出力
- `exit_code`（i32）- コマンドの終了ステータスコード

### 基本的な例

```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0
```

## 結果オブジェクト

`exec()`が返すオブジェクトは以下の構造を持ちます：

```hemlock
{
    output: string,      // コマンドのstdout（キャプチャされた出力）
    exit_code: i32       // プロセスの終了ステータス（0 = 成功）
}
```

### outputフィールド

コマンドによってstdoutに書き込まれたすべてのテキストを含みます。

**プロパティ：**
- コマンドが出力を生成しない場合は空文字列
- 改行と空白はそのまま含まれる
- 複数行の出力は保持される
- サイズ制限なし（動的に割り当て）

**例：**
```hemlock
let r1 = exec("echo test");
print(r1.output);  // "test\n"

let r2 = exec("ls");
print(r2.output);  // 改行付きのディレクトリリスト

let r3 = exec("true");
print(r3.output);  // ""（空文字列）
```

### exit_codeフィールド

コマンドの終了ステータスコード。

**値：**
- `0`は通常成功を示す
- `1-255`はエラーを示す（規則はコマンドによって異なる）
- `-1`はコマンドが実行できなかったか、異常終了した場合

**例：**
```hemlock
let r1 = exec("true");
print(r1.exit_code);  // 0（成功）

let r2 = exec("false");
print(r2.exit_code);  // 1（失敗）

let r3 = exec("ls /nonexistent");
print(r3.exit_code);  // 2（ファイルが見つからない、コマンドによって異なる）
```

## 基本的な使用方法

### 単純なコマンド

```hemlock
let r = exec("ls -la");
print(r.output);
print("Exit code: " + typeof(r.exit_code));
```

### 終了ステータスの確認

```hemlock
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Found: " + r.output);
} else {
    print("Pattern not found");
}
```

### パイプ付きコマンド

```hemlock
let r = exec("ps aux | grep hemlock");
print(r.output);
```

### 複数コマンド

```hemlock
let r = exec("cd /tmp && ls -la");
print(r.output);
```

### コマンド置換

```hemlock
let r = exec("echo $(date)");
print(r.output);  // 現在の日付
```

## 高度な例

### 失敗の処理

```hemlock
let r = exec("ls /nonexistent");
if (r.exit_code != 0) {
    print("Command failed with code: " + typeof(r.exit_code));
    print("Error output: " + r.output);  // 注意：stderrはキャプチャされない
}
```

### 複数行出力の処理

```hemlock
let r = exec("cat file.txt");
let lines = r.output.split("\n");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### コマンドチェーン

**&& (AND)の使用：**
```hemlock
let r1 = exec("mkdir -p /tmp/test && touch /tmp/test/file.txt");
if (r1.exit_code == 0) {
    print("Setup complete");
}
```

**|| (OR)の使用：**
```hemlock
let r = exec("command1 || command2");
// command1が失敗した場合のみcommand2を実行
```

**; (シーケンス)の使用：**
```hemlock
let r = exec("command1; command2");
// 成功/失敗に関係なく両方を実行
```

### パイプの使用

```hemlock
let r = exec("echo 'data' | base64");
print("Base64: " + r.output);
```

**複雑なパイプライン：**
```hemlock
let r = exec("cat /etc/passwd | grep root | cut -d: -f1");
print(r.output);
```

### 終了コードパターン

異なる終了コードは異なる状態を示します：

```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
} else if (r.exit_code == 1) {
    print("File does not exist");
} else {
    print("Test command failed: " + typeof(r.exit_code));
}
```

### 出力リダイレクト

```hemlock
// シェル内でstdoutをファイルにリダイレクト
let r1 = exec("echo 'test' > /tmp/output.txt");

// stderrをstdoutにリダイレクト（注意：stderrはまだHemlockにキャプチャされない）
let r2 = exec("command 2>&1");
```

### 環境変数

```hemlock
let r = exec("export VAR=value && echo $VAR");
print(r.output);  // "value\n"
```

### 作業ディレクトリの変更

```hemlock
let r = exec("cd /tmp && pwd");
print(r.output);  // "/tmp\n"
```

## エラー処理

### exec()が例外をスローする場合

`exec()`関数はコマンドが実行できない場合に例外をスローします：

```hemlock
try {
    let r = exec("nonexistent_command_xyz");
} catch (e) {
    print("Failed to execute: " + e);
}
```

**例外がスローされる場合：**
- `popen()`が失敗した場合（例：パイプを作成できない）
- システムリソース制限を超えた場合
- メモリ割り当てエラー

### exec()が例外をスローしない場合

```hemlock
// コマンドは実行されるがゼロ以外の終了コードを返す
let r1 = exec("false");
print(r1.exit_code);  // 1（例外ではない）

// コマンドが出力を生成しない
let r2 = exec("true");
print(r2.output);  // ""（例外ではない）

// シェルでコマンドが見つからない
let r3 = exec("nonexistent_cmd");
print(r3.exit_code);  // 127（例外ではない）
```

### 安全な実行パターン

```hemlock
fn safe_exec(command: string) {
    try {
        let r = exec(command);
        if (r.exit_code != 0) {
            print("Warning: Command failed with code " + typeof(r.exit_code));
            return "";
        }
        return r.output;
    } catch (e) {
        print("Error executing command: " + e);
        return "";
    }
}

let output = safe_exec("ls -la");
```

## 実装の詳細

### 動作の仕組み

**内部処理：**
- `popen()`を使用して`/bin/sh`経由でコマンドを実行
- stdoutのみをキャプチャ（stderrはキャプチャされない）
- 出力は動的にバッファリング（4KBから開始、必要に応じて拡張）
- 終了ステータスは`WIFEXITED()`と`WEXITSTATUS()`マクロを使用して抽出
- 出力文字列は適切にnull終端される

**プロセスフロー：**
1. `popen(command, "r")`がパイプを作成してプロセスをフォーク
2. 子プロセスが`/bin/sh -c "command"`を実行
3. 親が成長するバッファにパイプ経由でstdoutを読み取り
4. `pclose()`が子を待機し、終了ステータスを返す
5. 終了ステータスが抽出され、結果オブジェクトに格納

### パフォーマンスの考慮事項

**コスト：**
- 各呼び出しで新しいシェルプロセスを作成（約1-5msのオーバーヘッド）
- 出力は完全にメモリに格納（ストリーミングではない）
- ストリーミングサポートなし（コマンドの完了を待つ）
- 適度な出力サイズのコマンドに適している

**最適化：**
- バッファは4KBで開始し、満杯になると倍増（効率的なメモリ使用）
- 単一の読み取りループでシステムコールを最小化
- 追加の文字列コピーなし

**使用すべき場合：**
- 短時間実行のコマンド（< 1秒）
- 適度な出力サイズ（< 10MB）
- 合理的な間隔のバッチ操作

**使用すべきでない場合：**
- 長時間実行のデーモンやサービス
- ギガバイトの出力を生成するコマンド
- リアルタイムストリーミングデータ処理
- 高頻度実行（> 100回/秒）

## セキュリティ上の考慮事項

### シェルインジェクションのリスク

⚠️ **重要：**コマンドはシェル（`/bin/sh`）によって実行されるため、**シェルインジェクションが可能**です。

**脆弱なコード：**
```hemlock
// 危険 - これをしないでください
let filename = args[1];  // ユーザー入力
let r = exec("cat " + filename);  // シェルインジェクション！
```

**攻撃：**
```bash
./hemlock script.hml "; rm -rf /; echo pwned"
# 実行される: cat ; rm -rf /; echo pwned
```

### 安全なプラクティス

**1. サニタイズされていないユーザー入力を使用しない：**
```hemlock
// 悪い例
let user_input = args[1];
let r = exec("process " + user_input);  // 危険

// 良い例 - 最初に検証
fn is_safe_filename(name: string): bool {
    // 英数字、ダッシュ、アンダースコア、ドットのみを許可
    let i = 0;
    while (i < name.length) {
        let c = name[i];
        if (!(c >= 'a' && c <= 'z') &&
            !(c >= 'A' && c <= 'Z') &&
            !(c >= '0' && c <= '9') &&
            c != '-' && c != '_' && c != '.') {
            return false;
        }
        i = i + 1;
    }
    return true;
}

let filename = args[1];
if (is_safe_filename(filename)) {
    let r = exec("cat " + filename);
} else {
    print("Invalid filename");
}
```

**2. 拒否リストではなく許可リストを使用：**
```hemlock
// 良い例 - 厳密な許可リスト
let allowed_commands = ["status", "start", "stop", "restart"];
let cmd = args[1];

let found = false;
for (let allowed in allowed_commands) {
    if (cmd == allowed) {
        found = true;
        break;
    }
}

if (found) {
    exec("service myapp " + cmd);
} else {
    print("Invalid command");
}
```

**3. 特殊文字をエスケープ：**
```hemlock
fn shell_escape(s: string): string {
    // シンプルなエスケープ - シングルクォートで囲み、シングルクォートをエスケープ
    let escaped = s.replace_all("'", "'\\''");
    return "'" + escaped + "'";
}

let user_file = args[1];
let safe = shell_escape(user_file);
let r = exec("cat " + safe);
```

**4. ファイル操作にexec()を使用しない：**
```hemlock
// 悪い例 - ファイル操作にexecを使用
let r = exec("cat file.txt");

// 良い例 - HemlockのファイルAPIを使用
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### 権限の考慮事項

コマンドはHemlockプロセスと同じ権限で実行されます：

```hemlock
// Hemlockがrootで実行されている場合、exec()コマンドもrootで実行されます！
let r = exec("rm -rf /important");  // rootで実行している場合は危険
```

**ベストプラクティス：**必要最小限の権限でHemlockを実行してください。

## 制限事項

### 1. stderrキャプチャなし

stdoutのみがキャプチャされ、stderrはターミナルに出力されます：

```hemlock
let r = exec("ls /nonexistent");
// r.outputは空
// エラーメッセージはターミナルに表示され、キャプチャされない
```

**回避策 - stderrをstdoutにリダイレクト：**
```hemlock
let r = exec("ls /nonexistent 2>&1");
// これでエラーメッセージがr.outputに含まれる
```

### 2. ストリーミングなし

コマンドの完了を待つ必要があります：

```hemlock
let r = exec("long_running_command");
// コマンドが終了するまでブロック
// 出力を段階的に処理できない
```

### 3. タイムアウトなし

コマンドは無期限に実行できます：

```hemlock
let r = exec("sleep 1000");
// 1000秒間ブロック
// タイムアウトやキャンセルの方法がない
```

**回避策 - timeoutコマンドを使用：**
```hemlock
let r = exec("timeout 5 long_command");
// 5秒後にタイムアウト
```

### 4. シグナル処理なし

実行中のコマンドにシグナルを送信できません：

```hemlock
let r = exec("long_command");
// コマンドにSIGINT、SIGTERMなどを送信できない
```

### 5. プロセス制御なし

開始後のコマンドとやり取りできません：

```hemlock
let r = exec("interactive_program");
// プログラムに入力を送信できない
// 実行を制御できない
```

## 使用ケース

### 適した使用ケース

**1. システムユーティリティの実行：**
```hemlock
let r = exec("ls -la");
let r = exec("grep pattern file.txt");
let r = exec("find /path -name '*.txt'");
```

**2. Unixツールでのクイックデータ処理：**
```hemlock
let r = exec("cat data.txt | sort | uniq | wc -l");
print("Unique lines: " + r.output);
```

**3. システム状態の確認：**
```hemlock
let r = exec("df -h");
print("Disk usage:\n" + r.output);
```

**4. ファイル存在チェック：**
```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
}
```

**5. レポートの生成：**
```hemlock
let r = exec("ps aux | grep myapp | wc -l");
let count = r.output.trim();
print("Running instances: " + count);
```

**6. 自動化スクリプト：**
```hemlock
exec("git add .");
exec("git commit -m 'Auto commit'");
let r = exec("git push");
if (r.exit_code != 0) {
    print("Push failed");
}
```

### 推奨されない使用

**1. 長時間実行のサービス：**
```hemlock
// 悪い例
let r = exec("nginx");  // 永遠にブロック
```

**2. 対話型コマンド：**
```hemlock
// 悪い例 - 入力を提供できない
let r = exec("ssh user@host");
```

**3. 巨大な出力を生成するコマンド：**
```hemlock
// 悪い例 - 出力全体をメモリにロード
let r = exec("cat 10GB_file.log");
```

**4. リアルタイムストリーミング：**
```hemlock
// 悪い例 - 出力を段階的に処理できない
let r = exec("tail -f /var/log/app.log");
```

**5. ミッションクリティカルなエラー処理：**
```hemlock
// 悪い例 - stderrがキャプチャされない
let r = exec("critical_operation");
// 詳細なエラーメッセージを見ることができない
```

## ベストプラクティス

### 1. 常に終了コードを確認

```hemlock
let r = exec("important_command");
if (r.exit_code != 0) {
    print("Command failed!");
    // エラーを処理
}
```

### 2. 必要に応じて出力をトリム

```hemlock
let r = exec("echo test");
let clean = r.output.trim();  // 末尾の改行を削除
print(clean);  // "test"（改行なし）
```

### 3. 実行前に検証

```hemlock
fn is_valid_command(cmd: string): bool {
    // コマンドが安全かどうかを検証
    return true;  // 検証ロジック
}

if (is_valid_command(user_cmd)) {
    exec(user_cmd);
}
```

### 4. 重要な操作にはtry/catchを使用

```hemlock
try {
    let r = exec("critical_command");
    if (r.exit_code != 0) {
        throw "Command failed";
    }
} catch (e) {
    print("Error: " + e);
    // クリーンアップまたはリカバリ
}
```

### 5. exec()よりHemlockのAPIを優先

```hemlock
// 悪い例 - ファイル操作にexecを使用
let r = exec("cat file.txt");

// 良い例 - HemlockのFile APIを使用
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### 6. 必要に応じてstderrをキャプチャ

```hemlock
// stderrをstdoutにリダイレクト
let r = exec("command 2>&1");
// これでr.outputにstdoutとstderrの両方が含まれる
```

### 7. シェル機能を賢く使用

```hemlock
// 効率のためにパイプを使用
let r = exec("cat large.txt | grep pattern | head -n 10");

// コマンド置換を使用
let r = exec("echo Current user: $(whoami)");

// 条件付き実行を使用
let r = exec("test -f file.txt && cat file.txt");
```

## 完全な例

### 例1：システム情報収集

```hemlock
fn get_system_info() {
    print("=== System Information ===");

    // ホスト名
    let r1 = exec("hostname");
    print("Hostname: " + r1.output.trim());

    // アップタイム
    let r2 = exec("uptime");
    print("Uptime: " + r2.output.trim());

    // ディスク使用量
    let r3 = exec("df -h /");
    print("\nDisk Usage:");
    print(r3.output);

    // メモリ使用量
    let r4 = exec("free -h");
    print("Memory Usage:");
    print(r4.output);
}

get_system_info();
```

### 例2：ログ分析

```hemlock
fn analyze_log(logfile: string) {
    print("Analyzing log: " + logfile);

    // 総行数をカウント
    let r1 = exec("wc -l " + logfile);
    print("Total lines: " + r1.output.trim());

    // エラーをカウント
    let r2 = exec("grep -c ERROR " + logfile + " 2>/dev/null");
    let errors = r2.output.trim();
    if (r2.exit_code == 0) {
        print("Errors: " + errors);
    } else {
        print("Errors: 0");
    }

    // 警告をカウント
    let r3 = exec("grep -c WARN " + logfile + " 2>/dev/null");
    let warnings = r3.output.trim();
    if (r3.exit_code == 0) {
        print("Warnings: " + warnings);
    } else {
        print("Warnings: 0");
    }

    // 最近のエラー
    print("\nRecent errors:");
    let r4 = exec("grep ERROR " + logfile + " | tail -n 5");
    print(r4.output);
}

if (args.length < 2) {
    print("Usage: " + args[0] + " <logfile>");
} else {
    analyze_log(args[1]);
}
```

### 例3：Gitヘルパー

```hemlock
fn git_status() {
    let r = exec("git status --short");
    if (r.exit_code != 0) {
        print("Error: Not a git repository");
        return;
    }

    if (r.output == "") {
        print("Working directory clean");
    } else {
        print("Changes:");
        print(r.output);
    }
}

fn git_quick_commit(message: string) {
    print("Adding all changes...");
    let r1 = exec("git add -A");
    if (r1.exit_code != 0) {
        print("Error adding files");
        return;
    }

    print("Committing...");
    let safe_msg = message.replace_all("'", "'\\''");
    let r2 = exec("git commit -m '" + safe_msg + "'");
    if (r2.exit_code != 0) {
        print("Error committing");
        return;
    }

    print("Committed successfully");
    print(r2.output);
}

// 使用方法
git_status();
if (args.length > 1) {
    git_quick_commit(args[1]);
}
```

### 例4：バックアップスクリプト

```hemlock
fn backup_directory(source: string, dest: string) {
    print("Backing up " + source + " to " + dest);

    // バックアップディレクトリを作成
    let r1 = exec("mkdir -p " + dest);
    if (r1.exit_code != 0) {
        print("Error creating backup directory");
        return false;
    }

    // タイムスタンプ付きのtarballを作成
    let r2 = exec("date +%Y%m%d_%H%M%S");
    let timestamp = r2.output.trim();
    let backup_file = dest + "/backup_" + timestamp + ".tar.gz";

    print("Creating archive: " + backup_file);
    let r3 = exec("tar -czf " + backup_file + " " + source + " 2>&1");
    if (r3.exit_code != 0) {
        print("Error creating backup:");
        print(r3.output);
        return false;
    }

    print("Backup completed successfully");

    // バックアップサイズを表示
    let r4 = exec("du -h " + backup_file);
    print("Backup size: " + r4.output.trim());

    return true;
}

if (args.length < 3) {
    print("Usage: " + args[0] + " <source> <destination>");
} else {
    backup_directory(args[1], args[2]);
}
```

## まとめ

Hemlockの`exec()`関数は以下を提供します：

- シンプルなシェルコマンド実行
- 出力キャプチャ（stdout）
- 終了コードチェック
- 完全なシェル機能アクセス（パイプ、リダイレクトなど）
- システムユーティリティとの統合

覚えておくべきこと：
- 常に終了コードを確認
- セキュリティの影響（シェルインジェクション）に注意
- コマンドで使用する前にユーザー入力を検証
- 利用可能な場合はexec()よりHemlockのAPIを優先
- stderrはキャプチャされない（リダイレクトには`2>&1`を使用）
- コマンドは完了するまでブロック
- 長時間実行のサービスではなく、短時間ユーティリティに使用

**セキュリティチェックリスト：**
- サニタイズされていないユーザー入力を使用しない
- すべての入力を検証
- コマンドに許可リストを使用
- 必要に応じて特殊文字をエスケープ
- 最小権限で実行
- シェルコマンドよりHemlockのAPIを優先


--------------------------------------------------------------------------------
## シグナル処理
--------------------------------------------------------------------------------

# Hemlockでのシグナル処理

Hemlockは、SIGINT（Ctrl+C）、SIGTERM、カスタムシグナルなどのシステムシグナルを管理するための**POSIXシグナル処理**を提供します。これにより、低レベルのプロセス制御とプロセス間通信が可能になります。

## 目次

- [概要](#概要)
- [シグナルAPI](#シグナルapi)
- [シグナル定数](#シグナル定数)
- [基本的なシグナル処理](#基本的なシグナル処理)
- [高度なパターン](#高度なパターン)
- [シグナルハンドラの動作](#シグナルハンドラの動作)
- [安全性の考慮事項](#安全性の考慮事項)
- [一般的な使用ケース](#一般的な使用ケース)
- [完全な例](#完全な例)

## 概要

シグナル処理により、プログラムは以下のことができます：
- ユーザー割り込み（Ctrl+C、Ctrl+Z）に応答
- グレースフルシャットダウンを実装
- 終了リクエストを処理
- プロセス間通信にカスタムシグナルを使用
- アラーム/タイマーメカニズムを作成

**重要：**シグナル処理はHemlockの哲学において**本質的にアンセーフ**です。ハンドラはいつでも呼び出され、通常の実行を中断する可能性があります。ユーザーは適切な同期に責任を持ちます。

## シグナルAPI

### signal(signum, handler_fn)

シグナルハンドラ関数を登録します。

**パラメータ：**
- `signum`（i32）- シグナル番号（SIGINT、SIGTERMなどの定数）
- `handler_fn`（関数またはnull）- シグナル受信時に呼び出す関数、または`null`でデフォルトにリセット

**戻り値：**前のハンドラ関数（なければ`null`）

**例：**
```hemlock
fn my_handler(sig) {
    print("Caught signal: " + typeof(sig));
}

let old_handler = signal(SIGINT, my_handler);
```

**デフォルトにリセット：**
```hemlock
signal(SIGINT, null);  // SIGINTをデフォルト動作にリセット
```

### raise(signum)

現在のプロセスにシグナルを送信します。

**パラメータ：**
- `signum`（i32）- 送信するシグナル番号

**戻り値：**`null`

**例：**
```hemlock
raise(SIGUSR1);  // SIGUSR1ハンドラをトリガー
```

## シグナル定数

Hemlockは標準POSIXシグナル定数をi32値として提供します。

### 割り込みと終了

| 定数 | 値 | 説明 | 一般的なトリガー |
|----------|-------|-------------|----------------|
| `SIGINT` | 2 | キーボードからの割り込み | Ctrl+C |
| `SIGTERM` | 15 | 終了リクエスト | `kill`コマンド |
| `SIGQUIT` | 3 | キーボードからの終了 | Ctrl+\ |
| `SIGHUP` | 1 | ハングアップ検出 | ターミナルが閉じられた |
| `SIGABRT` | 6 | アボートシグナル | `abort()`関数 |

**例：**
```hemlock
signal(SIGINT, handle_interrupt);   // Ctrl+C
signal(SIGTERM, handle_terminate);  // killコマンド
signal(SIGHUP, handle_hangup);      // ターミナルが閉じる
```

### ユーザー定義シグナル

| 定数 | 値 | 説明 | 使用ケース |
|----------|-------|-------------|----------|
| `SIGUSR1` | 10 | ユーザー定義シグナル1 | カスタムIPC |
| `SIGUSR2` | 12 | ユーザー定義シグナル2 | カスタムIPC |

**例：**
```hemlock
// カスタム通信に使用
signal(SIGUSR1, reload_config);
signal(SIGUSR2, rotate_logs);
```

### プロセス制御

| 定数 | 値 | 説明 | 備考 |
|----------|-------|-------------|-------|
| `SIGALRM` | 14 | アラームクロックタイマー | `alarm()`後 |
| `SIGCHLD` | 17 | 子プロセスステータス変更 | プロセス管理 |
| `SIGCONT` | 18 | 停止していれば続行 | SIGSTOP後に再開 |
| `SIGSTOP` | 19 | プロセスを停止 | **キャッチ不可** |
| `SIGTSTP` | 20 | ターミナル停止 | Ctrl+Z |

**例：**
```hemlock
signal(SIGALRM, handle_timeout);
signal(SIGCHLD, handle_child_exit);
```

### I/Oシグナル

| 定数 | 値 | 説明 | 送信されるとき |
|----------|-------|-------------|-----------|
| `SIGPIPE` | 13 | パイプ破損 | 閉じたパイプへの書き込み |
| `SIGTTIN` | 21 | バックグラウンドでターミナルから読み取り | BGプロセスがTTYを読み取り |
| `SIGTTOU` | 22 | バックグラウンドでターミナルに書き込み | BGプロセスがTTYに書き込み |

**例：**
```hemlock
signal(SIGPIPE, handle_broken_pipe);
```

## 基本的なシグナル処理

### Ctrl+Cのキャッチ

```hemlock
let interrupted = false;

fn handle_interrupt(sig) {
    print("Caught SIGINT!");
    interrupted = true;
}

signal(SIGINT, handle_interrupt);

// プログラムは実行を継続...
// ユーザーがCtrl+Cを押す -> handle_interrupt()が呼び出される

while (!interrupted) {
    // 作業を実行...
}

print("Exiting due to interrupt");
```

### ハンドラ関数のシグネチャ

シグナルハンドラは1つの引数を受け取ります：シグナル番号（i32）

```hemlock
fn my_handler(signum) {
    print("Received signal: " + typeof(signum));
    // signumにはシグナル番号が含まれる（例：SIGINTの場合は2）

    if (signum == SIGINT) {
        print("This is SIGINT");
    }
}

signal(SIGINT, my_handler);
signal(SIGTERM, my_handler);  // 複数のシグナルに同じハンドラ
```

### 複数のシグナルハンドラ

異なるシグナルに異なるハンドラ：

```hemlock
fn handle_int(sig) {
    print("SIGINT received");
}

fn handle_term(sig) {
    print("SIGTERM received");
}

fn handle_usr1(sig) {
    print("SIGUSR1 received");
}

signal(SIGINT, handle_int);
signal(SIGTERM, handle_term);
signal(SIGUSR1, handle_usr1);
```

### デフォルト動作へのリセット

ハンドラとして`null`を渡すとデフォルト動作にリセット：

```hemlock
// カスタムハンドラを登録
signal(SIGINT, my_handler);

// 後で、デフォルトにリセット（SIGINTで終了）
signal(SIGINT, null);
```

### シグナルを手動で発生

自分のプロセスにシグナルを送信：

```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

// ハンドラを手動でトリガー
raise(SIGUSR1);
raise(SIGUSR1);

print(count);  // 2
```

## 高度なパターン

### グレースフルシャットダウンパターン

終了時のクリーンアップの一般的なパターン：

```hemlock
let should_exit = false;

fn handle_shutdown(sig) {
    print("Shutting down gracefully...");
    should_exit = true;
}

signal(SIGINT, handle_shutdown);
signal(SIGTERM, handle_shutdown);

// メインループ
while (!should_exit) {
    // 作業を実行...
    // should_exitフラグを定期的にチェック
}

print("Cleanup complete");
```

### シグナルカウンター

受信したシグナルの数を追跡：

```hemlock
let signal_count = 0;

fn count_signals(sig) {
    signal_count = signal_count + 1;
    print("Received " + typeof(signal_count) + " signals");
}

signal(SIGUSR1, count_signals);

// 後で...
print("Total signals: " + typeof(signal_count));
```

### シグナルによる設定リロード

```hemlock
let config = load_config();

fn reload_config(sig) {
    print("Reloading configuration...");
    config = load_config();
    print("Configuration reloaded");
}

signal(SIGHUP, reload_config);  // SIGHUPでリロード

// 設定をリロードするためにプロセスにSIGHUPを送信
// シェルから: kill -HUP <pid>
```

### SIGALRMを使用したタイムアウト

```hemlock
let timed_out = false;

fn handle_alarm(sig) {
    print("Timeout!");
    timed_out = true;
}

signal(SIGALRM, handle_alarm);

// アラームを設定（Hemlockではまだ実装されていない、例のみ）
// alarm(5);  // 5秒タイムアウト

while (!timed_out) {
    // タイムアウト付きで作業を実行
}
```

### シグナルベースのステートマシン

```hemlock
let state = 0;

fn next_state(sig) {
    state = (state + 1) % 3;
    print("State: " + typeof(state));
}

fn prev_state(sig) {
    state = (state - 1 + 3) % 3;
    print("State: " + typeof(state));
}

signal(SIGUSR1, next_state);  // 状態を進める
signal(SIGUSR2, prev_state);  // 戻る

// ステートマシンを制御：
// kill -USR1 <pid>  # 次の状態
// kill -USR2 <pid>  # 前の状態
```

## シグナルハンドラの動作

### 重要な注意事項

**ハンドラの実行：**
- ハンドラはシグナル受信時に**同期的に**呼び出される
- ハンドラは現在のプロセスコンテキストで実行
- シグナルハンドラは定義された関数のクロージャ環境を共有
- ハンドラは外部スコープの変数（グローバルやキャプチャされた変数など）にアクセスして変更可能

**ベストプラクティス：**
- ハンドラはシンプルで迅速に - 長時間実行の操作を避ける
- 複雑なロジックではなくフラグを設定
- ロックを取る可能性のある関数の呼び出しを避ける
- ハンドラが任意の操作を中断できることに注意

### キャッチできるシグナル

**キャッチして処理できる：**
- SIGINT、SIGTERM、SIGUSR1、SIGUSR2、SIGHUP、SIGQUIT
- SIGALRM、SIGCHLD、SIGCONT、SIGTSTP
- SIGPIPE、SIGTTIN、SIGTTOU
- SIGABRT（ただしハンドラが戻った後にプログラムはアボート）

**キャッチできない：**
- `SIGKILL`（9）- 常にプロセスを終了
- `SIGSTOP`（19）- 常にプロセスを停止

**システム依存：**
- 一部のシグナルはシステムによってデフォルト動作が異なる場合がある
- 詳細はプラットフォームのシグナルドキュメントを確認

### ハンドラの制限

```hemlock
fn complex_handler(sig) {
    // シグナルハンドラでこれらを避ける：

    // 長時間実行の操作
    // process_large_file();

    // ブロッキングI/O
    // let f = open("log.txt", "a");
    // f.write("Signal received\n");

    // 複雑な状態変更
    // rebuild_entire_data_structure();

    // シンプルなフラグ設定は安全
    let should_stop = true;

    // シンプルなカウンタ更新は通常安全
    let signal_count = signal_count + 1;
}
```

## 安全性の考慮事項

シグナル処理はHemlockの哲学において**本質的にアンセーフ**です。

### レースコンディション

ハンドラはいつでも呼び出され、通常の実行を中断する可能性があります：

```hemlock
let counter = 0;

fn increment(sig) {
    counter = counter + 1;  // カウンター更新中に呼び出されるとレースコンディション
}

signal(SIGUSR1, increment);

// メインコードもカウンターを変更
counter = counter + 1;  // シグナルハンドラに中断される可能性
```

**問題：**メインコードが`counter`を更新中にシグナルが到着すると、結果は予測不能です。

### 非同期シグナル安全性

Hemlockは非同期シグナル安全性を**保証しません**：
- ハンドラは任意のHemlockコードを呼び出せる（Cの制限された非同期シグナル安全関数とは異なり）
- これは柔軟性を提供するが、ユーザーの注意が必要
- ハンドラが共有状態を変更する場合、レースコンディションが可能

### 安全なシグナル処理のベストプラクティス

**1. アトミックフラグを使用**

シンプルなブール代入は一般的に安全：

```hemlock
let should_exit = false;

fn handler(sig) {
    should_exit = true;  // シンプルな代入は安全
}

signal(SIGINT, handler);

while (!should_exit) {
    // 作業...
}
```

**2. 共有状態を最小化**

```hemlock
let interrupt_count = 0;

fn handler(sig) {
    // この1つの変数のみを変更
    interrupt_count = interrupt_count + 1;
}
```

**3. 複雑な操作を延期**

```hemlock
let pending_reload = false;

fn signal_reload(sig) {
    pending_reload = true;  // フラグを設定するだけ
}

signal(SIGHUP, signal_reload);

// メインループで：
while (true) {
    if (pending_reload) {
        reload_config();  // ここで複雑な作業を実行
        pending_reload = false;
    }

    // 通常の作業...
}
```

**4. 再入可能性の問題を避ける**

```hemlock
let in_critical_section = false;
let data = [];

fn careful_handler(sig) {
    if (in_critical_section) {
        // メインコードが使用中はデータを変更しない
        return;
    }
    // 続行しても安全
}
```

## 一般的な使用ケース

### 1. グレースフルサーバーシャットダウン

```hemlock
let running = true;

fn shutdown(sig) {
    print("Shutdown signal received");
    running = false;
}

signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// サーバーメインループ
while (running) {
    handle_client_request();
}

cleanup_resources();
print("Server stopped");
```

### 2. 設定リロード（再起動なし）

```hemlock
let config = load_config("app.conf");
let reload_needed = false;

fn trigger_reload(sig) {
    reload_needed = true;
}

signal(SIGHUP, trigger_reload);

while (true) {
    if (reload_needed) {
        print("Reloading configuration...");
        config = load_config("app.conf");
        reload_needed = false;
    }

    // configを使用...
}
```

### 3. ログローテーション

```hemlock
let log_file = open("app.log", "a");
let rotate_needed = false;

fn trigger_rotate(sig) {
    rotate_needed = true;
}

signal(SIGUSR1, trigger_rotate);

while (true) {
    if (rotate_needed) {
        log_file.close();
        // 古いログの名前を変更し、新しいものを開く
        exec("mv app.log app.log.old");
        log_file = open("app.log", "a");
        rotate_needed = false;
    }

    // 通常のロギング...
    log_file.write("Log entry\n");
}
```

### 4. ステータス報告

```hemlock
let requests_handled = 0;

fn report_status(sig) {
    print("Status: " + typeof(requests_handled) + " requests handled");
}

signal(SIGUSR1, report_status);

while (true) {
    handle_request();
    requests_handled = requests_handled + 1;
}

// シェルから: kill -USR1 <pid>
```

### 5. デバッグモード切り替え

```hemlock
let debug_mode = false;

fn toggle_debug(sig) {
    debug_mode = !debug_mode;
    if (debug_mode) {
        print("Debug mode: ON");
    } else {
        print("Debug mode: OFF");
    }
}

signal(SIGUSR2, toggle_debug);

// シェルから: kill -USR2 <pid> で切り替え
```

## 完全な例

### 例1：クリーンアップ付き割り込みハンドラ

```hemlock
let running = true;
let signal_count = 0;

fn handle_signal(signum) {
    signal_count = signal_count + 1;

    if (signum == SIGINT) {
        print("Interrupt detected (Ctrl+C)");
        running = false;
    }

    if (signum == SIGUSR1) {
        print("User signal 1 received");
    }
}

// ハンドラを登録
signal(SIGINT, handle_signal);
signal(SIGUSR1, handle_signal);

// 作業をシミュレート
let i = 0;
while (running && i < 100) {
    print("Working... " + typeof(i));

    // 10回ごとにSIGUSR1をトリガー
    if (i == 10 || i == 20) {
        raise(SIGUSR1);
    }

    i = i + 1;
}

print("Total signals received: " + typeof(signal_count));
```

### 例2：マルチシグナルステートマシン

```hemlock
let state = "idle";
let request_count = 0;

fn start_processing(sig) {
    state = "processing";
    print("State: " + state);
}

fn stop_processing(sig) {
    state = "idle";
    print("State: " + state);
}

fn report_stats(sig) {
    print("State: " + state);
    print("Requests: " + typeof(request_count));
}

signal(SIGUSR1, start_processing);
signal(SIGUSR2, stop_processing);
signal(SIGHUP, report_stats);

while (true) {
    if (state == "processing") {
        // 作業を実行
        request_count = request_count + 1;
    }

    // 各イテレーションでチェック...
}
```

### 例3：ワーカープールコントローラ

```hemlock
let worker_count = 4;
let should_exit = false;

fn increase_workers(sig) {
    worker_count = worker_count + 1;
    print("Workers: " + typeof(worker_count));
}

fn decrease_workers(sig) {
    if (worker_count > 1) {
        worker_count = worker_count - 1;
    }
    print("Workers: " + typeof(worker_count));
}

fn shutdown(sig) {
    print("Shutting down...");
    should_exit = true;
}

signal(SIGUSR1, increase_workers);
signal(SIGUSR2, decrease_workers);
signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// メインループはworker_countに基づいてワーカープールを調整
while (!should_exit) {
    // worker_countに基づいてワーカーを管理
    // ...
}
```

### 例4：タイムアウトパターン

```hemlock
let operation_complete = false;
let timed_out = false;

fn timeout_handler(sig) {
    timed_out = true;
}

signal(SIGALRM, timeout_handler);

// 長い操作を開始
async fn long_operation() {
    // ...作業
    operation_complete = true;
}

let task = spawn(long_operation);

// タイムアウト付きで待機（手動チェック）
let elapsed = 0;
while (!operation_complete && elapsed < 1000) {
    // スリープまたはチェック
    elapsed = elapsed + 1;
}

if (!operation_complete) {
    print("Operation timed out");
    detach(task);  // 待機をあきらめる
} else {
    join(task);
    print("Operation completed");
}
```

## シグナルハンドラのデバッグ

### 診断プリントを追加

```hemlock
fn debug_handler(sig) {
    print("Handler called for signal: " + typeof(sig));
    print("Stack: (not yet available)");

    // ハンドラロジック...
}

signal(SIGINT, debug_handler);
```

### シグナル呼び出しをカウント

```hemlock
let handler_calls = 0;

fn counting_handler(sig) {
    handler_calls = handler_calls + 1;
    print("Handler call #" + typeof(handler_calls));

    // ハンドラロジック...
}
```

### raise()でテスト

```hemlock
fn test_handler(sig) {
    print("Test signal received: " + typeof(sig));
}

signal(SIGUSR1, test_handler);

// 手動で発生させてテスト
raise(SIGUSR1);
print("Handler should have been called");
```

## まとめ

Hemlockのシグナル処理は以下を提供します：

- 低レベルプロセス制御のためのPOSIXシグナル処理
- 15の標準シグナル定数
- シンプルなsignal()とraise() API
- クロージャサポート付きの柔軟なハンドラ関数
- 複数のシグナルでハンドラを共有可能

覚えておくべきこと：
- シグナル処理は本質的にアンセーフ - 注意して使用
- ハンドラはシンプルで高速に保つ
- 複雑な操作ではなく、状態変更にはフラグを使用
- ハンドラはいつでも実行を中断できる
- SIGKILLやSIGSTOPはキャッチできない
- raise()でハンドラを徹底的にテスト

一般的なパターン：
- グレースフルシャットダウン（SIGINT、SIGTERM）
- 設定リロード（SIGHUP）
- ログローテーション（SIGUSR1）
- ステータス報告（SIGUSR1/SIGUSR2）
- デバッグモード切り替え（SIGUSR2）


--------------------------------------------------------------------------------
## バンドルとパッケージング
--------------------------------------------------------------------------------

# バンドリングとパッケージング

Hemlockは、複数ファイルのプロジェクトを単一の配布可能ファイルにバンドルし、自己完結型の実行ファイルを作成するための組み込みツールを提供します。

## 概要

| コマンド | 出力 | 使用ケース |
|---------|--------|----------|
| `--bundle` | `.hmlc` または `.hmlb` | バイトコードを配布（実行にはHemlockが必要） |
| `--package` | 実行ファイル | スタンドアロンバイナリ（依存関係なし） |
| `--compile` | `.hmlc` | 単一ファイルをコンパイル（インポート解決なし） |

## バンドリング

バンドラーはエントリポイントからすべての`import`文を解決し、単一のファイルにフラット化します。

### 基本的な使用方法

```bash
# app.hmlとそのすべてのインポートをapp.hmlcにバンドル
hemlock --bundle app.hml

# 出力パスを指定
hemlock --bundle app.hml -o dist/app.hmlc

# 圧縮バンドル（.hmlb）を作成 - ファイルサイズが小さい
hemlock --bundle app.hml --compress -o app.hmlb

# 詳細出力（解決されたモジュールを表示）
hemlock --bundle app.hml --verbose
```

### 出力形式

**`.hmlc`（非圧縮）**
- シリアル化されたAST形式
- 読み込みと実行が高速
- デフォルトの出力形式

**`.hmlb`（圧縮）**
- zlib圧縮された`.hmlc`
- ファイルサイズが小さい（通常50-70%削減）
- 解凍のため起動がやや遅い

### バンドルファイルの実行

```bash
# 非圧縮バンドルを実行
hemlock app.hmlc

# 圧縮バンドルを実行
hemlock app.hmlb

# 引数を渡す
hemlock app.hmlc arg1 arg2
```

### 例：マルチモジュールプロジェクト

```
myapp/
├── main.hml
├── lib/
│   ├── math.hml
│   └── utils.hml
└── config.hml
```

```hemlock
// main.hml
import { add, multiply } from "./lib/math.hml";
import { log } from "./lib/utils.hml";
import { VERSION } from "./config.hml";

log(`App v${VERSION}`);
print(add(2, 3));
```

```bash
hemlock --bundle myapp/main.hml -o myapp.hmlc
hemlock myapp.hmlc  # すべての依存関係がバンドルされた状態で実行
```

### stdlibインポート

バンドラーは`@stdlib/`インポートを自動的に解決します：

```hemlock
import { HashMap } from "@stdlib/collections";
import { now } from "@stdlib/time";
```

バンドル時、stdlibモジュールは出力に含まれます。

## パッケージング

パッケージングは、バンドルされたバイトコードをHemlockインタープリターのコピーに埋め込むことで、自己完結型の実行ファイルを作成します。

### 基本的な使用方法

```bash
# app.hmlから実行ファイルを作成
hemlock --package app.hml

# 出力名を指定
hemlock --package app.hml -o myapp

# 圧縮をスキップ（起動が速い、ファイルが大きい）
hemlock --package app.hml --no-compress

# 詳細出力
hemlock --package app.hml --verbose
```

### パッケージ化された実行ファイルの実行

```bash
# パッケージ化された実行ファイルは直接実行される
./myapp

# 引数はスクリプトに渡される
./myapp arg1 arg2
```

### パッケージ形式

パッケージ化された実行ファイルはHMLP形式を使用します：

```
[hemlockバイナリ][HMLB/HMLCペイロード][payload_size:u64][HMLPマジック:u32]
```

パッケージ化された実行ファイルが実行されると：
1. ファイル末尾の埋め込みペイロードをチェック
2. 見つかった場合、ペイロードを解凍して実行
3. 見つからない場合、通常のHemlockインタープリターとして動作

### 圧縮オプション

| フラグ | 形式 | 起動 | サイズ |
|------|--------|---------|------|
| （デフォルト） | HMLB | 通常 | 小さい |
| `--no-compress` | HMLC | 速い | 大きい |

起動時間が重要なCLIツールには、`--no-compress`を使用してください。

## バンドルの検査

`--info`を使用してバンドルまたはコンパイル済みファイルを検査できます：

```bash
hemlock --info app.hmlc
```

出力：
```
=== File Info: app.hmlc ===
Size: 12847 bytes
Format: HMLC (compiled AST)
Version: 1
Flags: 0x0001 [DEBUG]
Strings: 42
Statements: 156
```

```bash
hemlock --info app.hmlb
```

出力：
```
=== File Info: app.hmlb ===
Size: 5234 bytes
Format: HMLB (compressed bundle)
Version: 1
Uncompressed: 12847 bytes
Compressed: 5224 bytes
Ratio: 59.3% reduction
```

## ネイティブコンパイル

真のネイティブ実行ファイル（インタープリターなし）には、Hemlockコンパイラを使用します：

```bash
# Cを経由してネイティブ実行ファイルにコンパイル
hemlockc app.hml -o app

# 生成されたCコードを保持
hemlockc app.hml -o app --keep-c

# Cのみを出力（コンパイルしない）
hemlockc app.hml -c -o app.c

# 最適化レベル
hemlockc app.hml -o app -O2
```

コンパイラはCコードを生成し、GCCを呼び出してネイティブバイナリを生成します。以下が必要です：
- Hemlockランタイムライブラリ（`libhemlock_runtime`）
- Cコンパイラ（デフォルトはGCC）

### コンパイラオプション

| オプション | 説明 |
|--------|-------------|
| `-o <file>` | 出力実行ファイル名 |
| `-c` | Cコードのみを出力 |
| `--emit-c <file>` | Cを指定ファイルに書き込む |
| `-k, --keep-c` | コンパイル後に生成されたCを保持 |
| `-O<level>` | 最適化レベル（0-3） |
| `--cc <path>` | 使用するCコンパイラ |
| `--runtime <path>` | ランタイムライブラリへのパス |
| `-v, --verbose` | 詳細出力 |

## 比較

| アプローチ | ポータビリティ | 起動 | サイズ | 依存関係 |
|----------|-------------|---------|------|--------------|
| `.hml` | ソースのみ | パース時間 | 最小 | Hemlock |
| `.hmlc` | Hemlockのみ | 速い | 小 | Hemlock |
| `.hmlb` | Hemlockのみ | 速い | より小さい | Hemlock |
| `--package` | スタンドアロン | 速い | 大きい | なし |
| `hemlockc` | ネイティブ | 最速 | 可変 | ランタイムライブラリ |

## ベストプラクティス

1. **開発**：高速な反復のために`.hml`ファイルを直接実行
2. **配布（Hemlockあり）**：より小さいファイルのために`--compress`でバンドル
3. **配布（スタンドアロン）**：依存関係ゼロのデプロイのためにパッケージ化
4. **パフォーマンス重視**：ネイティブコンパイルに`hemlockc`を使用

## トラブルシューティング

### "Cannot find stdlib"

バンドラーは以下の場所でstdlibを探します：
1. `./stdlib`（実行ファイルからの相対パス）
2. `../stdlib`（実行ファイルからの相対パス）
3. `/usr/local/lib/hemlock/stdlib`

Hemlockが正しくインストールされているか、ソースディレクトリから実行していることを確認してください。

### 循環依存

```
Error: Circular dependency detected when loading 'path/to/module.hml'
```

サイクルを解消するためにインポートをリファクタリングしてください。共通の型には共有モジュールの使用を検討してください。

### パッケージサイズが大きい

- デフォルトの圧縮を使用（`--no-compress`を使用しない）
- パッケージサイズには完全なインタープリターが含まれます（ベース約500KB-1MB）
- 最小サイズには、ネイティブコンパイルに`hemlockc`を使用


--------------------------------------------------------------------------------
## プロファイリング
--------------------------------------------------------------------------------

# プロファイリング

Hemlockには、**CPU時間分析**、**メモリトラッキング**、**リーク検出**のための組み込みプロファイラーが含まれています。プロファイラーは、プログラムのパフォーマンスボトルネックとメモリの問題を特定するのに役立ちます。

## 目次

- [概要](#概要)
- [クイックスタート](#クイックスタート)
- [プロファイリングモード](#プロファイリングモード)
- [出力形式](#出力形式)
- [リーク検出](#リーク検出)
- [レポートの理解](#レポートの理解)
- [フレームグラフ生成](#フレームグラフ生成)
- [ベストプラクティス](#ベストプラクティス)

---

## 概要

プロファイラーは`profile`サブコマンドでアクセスします：

```bash
hemlock profile [OPTIONS] <FILE>
```

**主な機能：**
- **CPUプロファイリング** - 各関数で費やされた時間を測定（自己時間と合計時間）
- **メモリプロファイリング** - ソース位置付きですべての割り当てを追跡
- **リーク検出** - 解放されなかったメモリを特定
- **複数の出力形式** - テキスト、JSON、フレームグラフ互換出力
- **関数ごとのメモリ統計** - どの関数が最もメモリを割り当てているかを確認

---

## クイックスタート

### CPU時間のプロファイル（デフォルト）

```bash
hemlock profile script.hml
```

### メモリ割り当てのプロファイル

```bash
hemlock profile --memory script.hml
```

### メモリリークの検出

```bash
hemlock profile --leaks script.hml
```

### フレームグラフデータの生成

```bash
hemlock profile --flamegraph script.hml > profile.folded
flamegraph.pl profile.folded > profile.svg
```

---

## プロファイリングモード

### CPUプロファイリング（デフォルト）

各関数で費やされた時間を測定し、以下を区別します：
- **自己時間** - 関数自体のコードを実行するのに費やされた時間
- **合計時間** - 自己時間に呼び出された関数で費やされた時間を加えたもの

```bash
hemlock profile script.hml
hemlock profile --cpu script.hml  # 明示的
```

**出力例：**
```
=== Hemlock Profiler Report ===

Total time: 1.234ms
Functions called: 5 unique

--- Top 5 by Self Time ---

Function                        Self      Total   Calls
--------                        ----      -----   -----
expensive_calc              0.892ms    0.892ms     100  (72.3%)
process_data                0.234ms    1.126ms      10  (19.0%)
helper                      0.067ms    0.067ms     500  (5.4%)
main                        0.041ms    1.234ms       1  (3.3%)
```

---

### メモリプロファイリング

ソース位置付きですべてのメモリ割り当て（`alloc`、`buffer`、`talloc`、`realloc`）を追跡します。

```bash
hemlock profile --memory script.hml
```

**出力例：**
```
=== Hemlock Profiler Report ===

Total time: 0.543ms
Functions called: 3 unique
Total allocations: 15 (4.2KB)

--- Top 3 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
allocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)
buffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)
main                        0.075ms    0.543ms       1        0B          0  (13.8%)

--- Top 10 Allocation Sites ---

Location                                      Total    Count
--------                                      -----    -----
src/data.hml:42                               1.5KB        5
src/data.hml:67                               1.0KB       10
src/main.hml:15                               512B         1
```

---

### 呼び出し回数モード

関数呼び出しのみをカウントする最小オーバーヘッドモード（タイミングなし）。

```bash
hemlock profile --calls script.hml
```

---

## 出力形式

### テキスト（デフォルト）

テーブル付きの人間が読みやすい要約。

```bash
hemlock profile script.hml
```

---

### JSON

他のツールとの統合のための機械可読形式。

```bash
hemlock profile --json script.hml
```

**出力例：**
```json
{
  "total_time_ns": 1234567,
  "function_count": 5,
  "total_alloc_bytes": 4096,
  "total_alloc_count": 15,
  "functions": [
    {
      "name": "expensive_calc",
      "source_file": "script.hml",
      "line": 10,
      "self_time_ns": 892000,
      "total_time_ns": 892000,
      "call_count": 100,
      "alloc_bytes": 0,
      "alloc_count": 0
    }
  ],
  "alloc_sites": [
    {
      "source_file": "script.hml",
      "line": 42,
      "total_bytes": 1536,
      "alloc_count": 5,
      "current_bytes": 0
    }
  ]
}
```

---

### フレームグラフ

[flamegraph.pl](https://github.com/brendangregg/FlameGraph)と互換性のある折りたたみスタック形式を生成します。

```bash
hemlock profile --flamegraph script.hml > profile.folded

# flamegraph.plでSVGを生成
flamegraph.pl profile.folded > profile.svg
```

**折りたたみ出力例：**
```
main;process_data;expensive_calc 892
main;process_data;helper 67
main;process_data 234
main 41
```

---

## リーク検出

`--leaks`フラグは解放されなかった割り当てのみを表示し、メモリリークの特定を容易にします。

```bash
hemlock profile --leaks script.hml
```

**リークのあるプログラム例：**
```hemlock
fn leaky() {
    let p1 = alloc(100);    // リーク - 解放されない
    let p2 = alloc(200);    // OK - 下で解放
    free(p2);
}

fn clean() {
    let b = buffer(64);
    free(b);                // 正しく解放
}

leaky();
clean();
```

**--leaksでの出力：**
```
=== Hemlock Profiler Report ===

Total time: 0.034ms
Functions called: 2 unique
Total allocations: 3 (388B)

--- Top 2 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
leaky                       0.021ms    0.021ms       1       300B          2  (61.8%)
clean                       0.013ms    0.013ms       1        88B          1  (38.2%)

--- Memory Leaks (1 site) ---

Location                                     Leaked      Total    Count
--------                                     ------      -----    -----
script.hml:2                                   100B       100B        1
```

リークレポートは以下を表示します：
- **Leaked** - プログラム終了時に未解放のバイト
- **Total** - このサイトで割り当てられた総バイト数
- **Count** - このサイトでの割り当て回数

---

## レポートの理解

### 関数統計

| 列 | 説明 |
|--------|-------------|
| Function | 関数名 |
| Self | 呼び出し先を除いた関数内の時間 |
| Total | 呼び出されたすべての関数を含む時間 |
| Calls | 関数が呼び出された回数 |
| Alloc | この関数によって割り当てられた総バイト数 |
| Count | この関数による割り当て回数 |
| (%) | プログラム総時間に対する割合 |

### 割り当てサイト

| 列 | 説明 |
|--------|-------------|
| Location | ソースファイルと行番号 |
| Total | この場所で割り当てられた総バイト数 |
| Count | 割り当て回数 |
| Leaked | プログラム終了時にまだ割り当てられているバイト（--leaksのみ） |

### 時間単位

プロファイラーは適切な単位を自動的に選択します：
- `ns` - ナノ秒（< 1us）
- `us` - マイクロ秒（< 1ms）
- `ms` - ミリ秒（< 1s）
- `s` - 秒

---

## コマンドリファレンス

```
hemlock profile [OPTIONS] <FILE>

OPTIONS:
    --cpu           CPU/時間プロファイリング（デフォルト）
    --memory        メモリ割り当てプロファイリング
    --calls         呼び出し回数のみ（最小オーバーヘッド）
    --leaks         未解放の割り当てのみを表示（--memoryを暗黙的に含む）
    --json          JSON形式で出力
    --flamegraph    フレームグラフ互換形式で出力
    --top N         上位N件を表示（デフォルト：20）
```

---

## フレームグラフ生成

フレームグラフは、プログラムが時間を費やしている場所を視覚化し、より広いバーはより多くの時間が費やされていることを示します。

### フレームグラフの生成

1. flamegraph.plをインストール：
   ```bash
   git clone https://github.com/brendangregg/FlameGraph
   ```

2. プログラムをプロファイル：
   ```bash
   hemlock profile --flamegraph script.hml > profile.folded
   ```

3. SVGを生成：
   ```bash
   ./FlameGraph/flamegraph.pl profile.folded > profile.svg
   ```

4. `profile.svg`をブラウザで開いてインタラクティブな視覚化を確認。

### フレームグラフの読み方

- **X軸**：総時間の割合（幅 = 時間の割合）
- **Y軸**：コールスタックの深さ（下 = エントリポイント、上 = リーフ関数）
- **色**：視覚的区別のためのランダム
- **クリック**：関数にズームインして呼び出し先を確認

---

## ベストプラクティス

### 1. 代表的なワークロードをプロファイル

現実的なデータと使用パターンでプロファイルしてください。小さなテストケースでは実際のボトルネックが明らかにならない場合があります。

```bash
# 良い例：本番環境に近いデータでプロファイル
hemlock profile --memory process_large_file.hml large_input.txt

# あまり有用でない：小さなテストケース
hemlock profile quick_test.hml
```

### 2. 開発中に--leaksを使用

メモリリークを早期に発見するため、定期的にリーク検出を実行：

```bash
hemlock profile --leaks my_program.hml
```

### 3. 前後を比較

最適化の効果を測定するため、最適化前後でプロファイル：

```bash
# 最適化前
hemlock profile --json script.hml > before.json

# 最適化後
hemlock profile --json script.hml > after.json

# 結果を比較
```

### 4. 大きなプログラムには--topを使用

最も重要な関数に焦点を当てるため出力を制限：

```bash
hemlock profile --top 10 large_program.hml
```

### 5. フレームグラフと組み合わせる

複雑なコールパターンでは、フレームグラフがテキスト出力より良い視覚化を提供：

```bash
hemlock profile --flamegraph complex_app.hml > app.folded
flamegraph.pl app.folded > app.svg
```

---

## プロファイラーオーバーヘッド

プロファイラーはプログラム実行にいくらかのオーバーヘッドを追加します：

| モード | オーバーヘッド | 使用ケース |
|------|----------|----------|
| `--calls` | 最小 | 関数呼び出しのカウントのみ |
| `--cpu` | 低 | 一般的なパフォーマンスプロファイリング |
| `--memory` | 中程度 | メモリ分析とリーク検出 |

最も正確な結果を得るには、複数回プロファイルして一貫したパターンを探してください。

---

## 関連項目

- [メモリ管理](#language-guide-memory) - ポインタとバッファ
- [メモリAPI](#reference-memory-api) - alloc、free、buffer関数
- [非同期/並行性](#advanced-async-concurrency) - 非同期コードのプロファイリング


--------------------------------------------------------------------------------
## 非同期と並行処理
--------------------------------------------------------------------------------

# Hemlockにおける非同期/並行処理

Hemlockは、async/await構文、タスクの生成、通信用チャネルを備えた**構造化並行処理**を提供します。実装はPOSIXスレッド（pthread）を使用した**真のマルチスレッド並列処理**を実現しています。

## 目次

- [概要](#概要)
- [スレッディングモデル](#スレッディングモデル)
- [非同期関数](#非同期関数)
- [タスクの生成](#タスクの生成)
- [チャネル](#チャネル)
- [例外の伝播](#例外の伝播)
- [実装の詳細](#実装の詳細)
- [ベストプラクティス](#ベストプラクティス)
- [パフォーマンス特性](#パフォーマンス特性)
- [現在の制限事項](#現在の制限事項)

## 概要

**これが意味すること：**
- ✅ **実際のOSスレッド** - 生成された各タスクは別々のpthread（POSIXスレッド）で実行される
- ✅ **真の並列処理** - タスクは複数のCPUコアで同時に実行される
- ✅ **カーネルスケジュール** - OSスケジューラがタスクを利用可能なコアに分散する
- ✅ **スレッドセーフなチャネル** - 同期にpthreadミューテックスと条件変数を使用

**これは以下ではない：**
- ❌ **グリーンスレッドではない** - ユーザー空間の協調的マルチタスクではない
- ❌ **async/awaitコルーチンではない** - JavaScript/Python asyncioのようなシングルスレッドイベントループではない
- ❌ **エミュレートされた並行処理ではない** - 疑似的な並列処理ではない

これは、OSスレッドを使用する際の**C、C++、Rustと同じスレッディングモデル**です。複数のコアにまたがる実際の並列実行が得られます。

## スレッディングモデル

### 1:1スレッディング

Hemlockは**1:1スレッディングモデル**を使用しています：
- 生成された各タスクは`pthread_create()`を介して専用のOSスレッドを作成する
- OSカーネルがスレッドを利用可能なCPUコアにスケジュールする
- プリエンプティブマルチタスク - OSがスレッド間を中断して切り替えることができる
- **GILなし** - Pythonとは異なり、並列処理を制限するグローバルインタプリタロックがない

### 同期メカニズム

- **ミューテックス** - チャネルはスレッドセーフなアクセスに`pthread_mutex_t`を使用
- **条件変数** - ブロッキングsend/recvは効率的な待機に`pthread_cond_t`を使用
- **ロックフリー操作** - タスク状態の遷移はアトミック

## 非同期関数

関数を`async`として宣言して、並行実行用に設計されていることを示すことができます：

```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
```

### 重要なポイント

- `async fn`は非同期関数を宣言する
- 非同期関数は`spawn()`を使用して並行タスクとして生成できる
- 非同期関数は直接呼び出すこともできる（現在のスレッドで同期的に実行）
- 生成されると、各タスクは**独自のOSスレッド**で実行される（コルーチンではない！）
- `await`キーワードは将来の使用のために予約されている

### 例：直接呼び出しとスポーンの比較

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// 直接呼び出し - 同期的に実行
let result1 = factorial(5);  // 120

// 生成されたタスク - 別のスレッドで実行
let task = spawn(factorial, 5);
let result2 = join(task);  // 120
```

## タスクの生成

`spawn()`を使用して非同期関数を**別のOSスレッドで並列に**実行します：

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// 複数のタスクを生成 - これらは異なるCPUコアで並列に実行される！
let t1 = spawn(factorial, 5);  // スレッド1
let t2 = spawn(factorial, 6);  // スレッド2
let t3 = spawn(factorial, 7);  // スレッド3

// 3つすべてが今同時に計算している！

// 結果を待つ
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
```

### 組み込み関数

#### spawn(async_fn, arg1, arg2, ...)

新しいpthreadで新しいタスクを作成し、タスクハンドルを返します。

**パラメータ：**
- `async_fn` - 実行する非同期関数
- `arg1, arg2, ...` - 関数に渡す引数

**戻り値：** タスクハンドル（`join()`や`detach()`で使用する不透明な値）

**例：**
```hemlock
async fn process(data: string, count: i32): i32 {
    // ... 処理ロジック
    return count * 2;
}

let task = spawn(process, "test", 42);
```

#### join(task)

タスクの完了を待ち（スレッドが終了するまでブロック）、結果を返します。

**パラメータ：**
- `task` - `spawn()`から返されたタスクハンドル

**戻り値：** 非同期関数が返した値

**例：**
```hemlock
let task = spawn(compute, 1000);
let result = join(task);  // compute()が終了するまでブロック
print(result);
```

**重要：** 各タスクは一度だけjoinできます。以降のjoinはエラーになります。

#### detach(task)

ファイアアンドフォーゲット実行（スレッドは独立して実行され、joinは許可されない）。

**パラメータ：**
- `task` - `spawn()`から返されたタスクハンドル

**戻り値：** `null`

**例：**
```hemlock
async fn background_work() {
    // 長時間実行されるバックグラウンドタスク
    // ...
}

let task = spawn(background_work);
detach(task);  // タスクは独立して実行され、joinできない
```

**重要：** デタッチされたタスクはjoinできません。タスクが完了すると、pthreadとTaskの両方の構造体が自動的にクリーンアップされます。

## チャネル

チャネルは、ブロッキングセマンティクスを持つ境界付きバッファを使用して、タスク間のスレッドセーフな通信を提供します。

### チャネルの作成

```hemlock
let ch = channel(10);  // バッファサイズ10のチャネルを作成
```

**パラメータ：**
- `capacity`（i32） - チャネルが保持できる値の最大数

**戻り値：** チャネルオブジェクト

### チャネルメソッド

#### send(value)

チャネルに値を送信します（満杯の場合はブロック）。

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let task = spawn(producer, ch, 5);
```

**動作：**
- チャネルにスペースがあれば、値はすぐに追加される
- チャネルが満杯の場合、送信者はスペースが利用可能になるまでブロックする
- チャネルが閉じられている場合、例外をスロー

#### recv()

チャネルから値を受信します（空の場合はブロック）。

```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let task = spawn(consumer, ch, 5);
```

**動作：**
- チャネルに値があれば、次の値をすぐに返す
- チャネルが空の場合、受信者は値が利用可能になるまでブロックする
- チャネルが閉じられ空の場合、`null`を返す

#### close()

チャネルを閉じます（閉じられたチャネルでのrecvはnullを返す）。

```hemlock
ch.close();
```

**動作：**
- 以降の`send()`操作を防ぐ（例外をスローする）
- 保留中の`recv()`操作は完了できる
- 空になると、`recv()`は`null`を返す

### select()による多重化

`select()`関数は、複数のチャネルを同時に待機し、いずれかのチャネルでデータが利用可能になったときに返します。

**シグネチャ：**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**パラメータ：**
- `channels` - チャネル値の配列
- `timeout_ms`（オプション） - ミリ秒単位のタイムアウト（-1または省略で無限待機）

**戻り値：**
- `{ channel, value }` - データを持っていたチャネルと受信した値を含むオブジェクト
- `null` - タイムアウト時（タイムアウトが指定されている場合）

**例：**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// プロデューサータスク
spawn(fn() {
    sleep(100);
    ch1.send("from channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("from channel 2");
});

// 最初の結果を待つ（ch2の方が速いはず）
let result = select([ch1, ch2]);
print(result.value);  // "from channel 2"

// 2番目の結果を待つ
let result2 = select([ch1, ch2]);
print(result2.value);  // "from channel 1"
```

**タイムアウト付き：**
```hemlock
let ch = channel(1);

// 送信者がいないのでタイムアウトする
let result = select([ch], 100);  // 100msタイムアウト
if (result == null) {
    print("タイムアウトしました！");
}
```

**ユースケース：**
- 複数のデータソースの中で最も速いものを待つ
- チャネル操作にタイムアウトを実装する
- 複数のイベントソースを持つイベントループパターン
- ファンイン：複数のチャネルを1つにマージ

**ファンインパターン：**
```hemlock
fn fan_in(channels: array, output: channel) {
    while (true) {
        let result = select(channels);
        if (result == null) {
            break;  // すべてのチャネルが閉じられた
        }
        output.send(result.value);
    }
    output.close();
}
```

### 完全なプロデューサー・コンシューマーの例

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// バッファサイズ付きでチャネルを作成
let ch = channel(10);

// プロデューサーとコンシューマーを生成
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// 完了を待つ
join(p);
let total = join(c);  // 100 (0+10+20+30+40)
print(total);
```

### マルチプロデューサー、マルチコンシューマー

チャネルは複数のプロデューサーとコンシューマー間で安全に共有できます：

```hemlock
async fn producer(id: i32, ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(id * 100 + i);
        i = i + 1;
    }
}

async fn consumer(id: i32, ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(20);

// 複数のプロデューサー
let p1 = spawn(producer, 1, ch, 5);
let p2 = spawn(producer, 2, ch, 5);

// 複数のコンシューマー
let c1 = spawn(consumer, 1, ch, 5);
let c2 = spawn(consumer, 2, ch, 5);

// すべてを待つ
join(p1);
join(p2);
let sum1 = join(c1);
let sum2 = join(c2);
print(sum1 + sum2);
```

## 例外の伝播

生成されたタスクでスローされた例外は、joinされたときに伝播されます：

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "タスクが失敗しました！";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("キャッチ: " + e);  // "キャッチ: タスクが失敗しました！"
}
```

### 例外処理パターン

**パターン1：タスク内で処理**
```hemlock
async fn safe_task() {
    try {
        // リスクのある操作
    } catch (e) {
        print("タスク内でエラー: " + e);
        return null;
    }
}

let task = spawn(safe_task);
join(task);  // 例外は伝播されない
```

**パターン2：呼び出し元に伝播**
```hemlock
async fn task_that_throws() {
    throw "エラー";
}

let task = spawn(task_that_throws);
try {
    join(task);
} catch (e) {
    print("タスクからキャッチ: " + e);
}
```

**パターン3：例外を持つデタッチされたタスク**
```hemlock
async fn detached_task() {
    try {
        // 作業
    } catch (e) {
        // 内部で処理する必要がある - 伝播できない
        print("エラー: " + e);
    }
}

let task = spawn(detached_task);
detach(task);  // デタッチされたタスクからは例外をキャッチできない
```

## 実装の詳細

### スレッディングアーキテクチャ

- **1:1スレッディング** - 生成された各タスクは`pthread_create()`を介して専用のOSスレッドを作成する
- **カーネルスケジュール** - OSカーネルがスレッドを利用可能なCPUコアにスケジュールする
- **プリエンプティブマルチタスク** - OSがスレッド間を中断して切り替えることができる
- **GILなし** - Pythonとは異なり、並列処理を制限するグローバルインタプリタロックがない

### チャネルの実装

チャネルはpthread同期を備えた循環バッファを使用します：

```
チャネル構造体：
- buffer[] - 値の固定サイズ配列
- capacity - 要素の最大数
- size - 現在の要素数
- head - 読み取り位置
- tail - 書き込み位置
- mutex - スレッドセーフなアクセス用のpthread_mutex_t
- not_empty - ブロッキングrecv用のpthread_cond_t
- not_full - ブロッキングsend用のpthread_cond_t
- closed - ブール値フラグ
- refcount - クリーンアップ用の参照カウント
```

**ブロッキング動作：**
- 満杯のチャネルでの`send()`: `not_full`条件変数で待機
- 空のチャネルでの`recv()`: `not_empty`条件変数で待機
- 両方とも反対の操作によって適切にシグナルされる

### メモリとクリーンアップ

- **joinされたタスク:** `join()`が返った後に自動的にクリーンアップされる
- **デタッチされたタスク:** タスクが完了すると自動的にクリーンアップされる
- **チャネル:** 参照カウントされ、使用されなくなったときに解放される

## ベストプラクティス

### 1. 常にチャネルを閉じる

```hemlock
async fn producer(ch) {
    // ... 値を送信
    ch.close();  // 重要：これ以上の値がないことを通知
}
```

### 2. 構造化並行処理を使用する

同じスコープ内でタスクを生成してjoinする：

```hemlock
fn process_data(data) {
    // タスクを生成
    let t1 = spawn(worker, data);
    let t2 = spawn(worker, data);

    // 返す前に常にjoinする
    let r1 = join(t1);
    let r2 = join(t2);

    return r1 + r2;
}
```

### 3. 例外を適切に処理する

```hemlock
async fn task() {
    try {
        // リスクのある操作
    } catch (e) {
        // エラーをログに記録
        throw e;  // 呼び出し元が知る必要がある場合は再スロー
    }
}
```

### 4. 適切なチャネル容量を使用する

- **小さい容量（1-10）:** 調整/シグナル用
- **中程度の容量（10-100）:** 一般的なプロデューサー・コンシューマー用
- **大きい容量（100以上）:** 高スループットシナリオ用

```hemlock
let signal_ch = channel(1);      // 調整
let work_ch = channel(50);       // ワークキュー
let buffer_ch = channel(1000);   // 高スループット
```

### 5. 必要な場合のみデタッチする

より良いリソース管理のために`detach()`よりも`join()`を優先する：

```hemlock
// 良い：joinして結果を取得
let task = spawn(work);
let result = join(task);

// 真のファイアアンドフォーゲットにのみdetachを使用
let bg_task = spawn(background_logging);
detach(bg_task);  // 独立して実行される
```

## パフォーマンス特性

### 真の並列処理

- **N個の生成されたタスクがN個のCPUコアを同時に利用できる**
- 実証済みの高速化 - ストレステストではウォール時間に対してCPU時間が8-9倍を示す（複数のコアが動作）
- コア数に応じた線形スケーリング（スレッド数まで）

### スレッドオーバーヘッド

- 各タスクには約8KBのスタック + pthreadオーバーヘッドがある
- スレッド作成コスト：約10-20μs
- コンテキストスイッチコスト：約1-5μs

### asyncを使用するタイミング

**良いユースケース：**
- 並列化可能なCPU集中型計算
- I/Oバウンド操作（ただしI/Oはまだブロッキング）
- 独立したデータの並行処理
- チャネルを使用したパイプラインアーキテクチャ

**理想的でないケース：**
- 非常に短いタスク（スレッドオーバーヘッドが支配的）
- 重い同期を持つタスク（競合オーバーヘッド）
- シングルコアシステム（並列化の利点なし）

### ブロッキングI/Oも安全

1つのタスクでのブロッキング操作は他をブロックしない：

```hemlock
async fn reader(filename: string) {
    let f = open(filename, "r");  // このスレッドのみブロック
    let content = f.read();       // このスレッドのみブロック
    f.close();
    return content;
}

// 両方が並行して読み取る（異なるスレッドで）
let t1 = spawn(reader, "file1.txt");
let t2 = spawn(reader, "file2.txt");

let c1 = join(t1);
let c2 = join(t2);
```

## スレッド安全性モデル

Hemlockは、タスクが共有可変状態ではなくチャネル経由で通信する**メッセージパッシング**並行処理モデルを使用します。

### 引数の分離

タスクを生成するとき、データ競合を防ぐために**引数はディープコピー**されます：

```hemlock
async fn modify_array(arr: array): array {
    arr.push(999);    // コピーを変更、元は変更されない
    arr[0] = -1;
    return arr;
}

let original = [1, 2, 3];
let task = spawn(modify_array, original);
let modified = join(task);

print(original.length);  // 3 - 変更されていない！
print(modified.length);  // 4 - 新しい要素がある
```

**ディープコピーされるもの：**
- 配列（およびすべての要素を再帰的に）
- オブジェクト（およびすべてのフィールドを再帰的に）
- 文字列
- バッファ

**共有されるもの（参照が保持される）：**
- チャネル（通信メカニズム - 意図的に共有）
- タスクハンドル（調整用）
- 関数（コードは不変）
- ファイルハンドル（OSが並行アクセスを管理）
- ソケットハンドル（OSが並行アクセスを管理）

**渡せないもの：**
- 生のポインタ（`ptr`） - 代わりに`buffer`を使用

### なぜメッセージパッシングなのか？

これはHemlockの「暗黙より明示」の哲学に従っています：

```hemlock
// 悪い例：共有可変状態（データ競合を引き起こす）
let counter = { value: 0 };
let t1 = spawn(fn() { counter.value = counter.value + 1; });  // 競合！
let t2 = spawn(fn() { counter.value = counter.value + 1; });  // 競合！

// 良い例：チャネル経由のメッセージパッシング
async fn increment(ch) {
    let val = ch.recv();
    ch.send(val + 1);
}

let ch = channel(1);
ch.send(0);
let t1 = spawn(increment, ch);
join(t1);
let result = ch.recv();  // 1 - 競合条件なし
```

### 参照カウントのスレッド安全性

すべての参照カウント操作は、解放後使用バグを防ぐために**アトミック操作**を使用します：
- `string_retain/release` - アトミック
- `array_retain/release` - アトミック
- `object_retain/release` - アトミック
- `buffer_retain/release` - アトミック
- `function_retain/release` - アトミック
- `channel_retain/release` - アトミック
- `task_retain/release` - アトミック

これにより、値がスレッド間で共有されている場合でも、安全なメモリ管理が保証されます。

### クロージャ環境へのアクセス

タスクは以下のクロージャ環境にアクセスできます：
- 組み込み関数（`print`、`len`など）
- グローバル関数定義
- 定数と変数

クロージャ環境は環境ごとのミューテックスによって保護されており、
並行読み書きがスレッドセーフになります：

```hemlock
let x = 10;

async fn read_closure(): i32 {
    return x;  // OK：クロージャ変数の読み取り（スレッドセーフ）
}

async fn modify_closure() {
    x = 20;  // OK：クロージャ変数への書き込み（ミューテックスで同期）
}
```

**注意：** 並行アクセスは同期されますが、複数のタスクから共有状態を変更すると
論理的な競合条件（非決定論的な順序）が発生する可能性があります。予測可能な動作のためには、
タスク通信にチャネルを使用するか、タスクから値を返してください。

タスクからデータを返す必要がある場合は、戻り値またはチャネルを使用してください。

## 現在の制限事項

### 1. ワークスティーリングスケジューラがない

タスクごとに1スレッドを使用するため、多くの短いタスクでは非効率になる可能性があります。

**現在：** 1000タスク = 1000スレッド（重いオーバーヘッド）

**計画中：** より効率的なワークスティーリング付きスレッドプール

### 3. 非同期I/O統合がない

ファイル/ネットワーク操作はまだスレッドをブロックします：

```hemlock
async fn read_file(path: string) {
    let f = open(path, "r");
    let content = f.read();  // スレッドをブロック
    f.close();
    return content;
}
```

**回避策：** 並行I/O操作には複数のスレッドを使用

### 4. 固定チャネル容量

チャネル容量は作成時に設定され、サイズ変更できません：

```hemlock
let ch = channel(10);
// 動的に20にサイズ変更できない
```

### 5. チャネルサイズは固定

チャネルバッファサイズは作成後に変更できません。

## 一般的なパターン

### 並列マップ

```hemlock
async fn map_worker(ch_in, ch_out, fn_transform) {
    while (true) {
        let val = ch_in.recv();
        if (val == null) { break; }

        let result = fn_transform(val);
        ch_out.send(result);
    }
    ch_out.close();
}

fn parallel_map(data, fn_transform, workers: i32) {
    let ch_in = channel(100);
    let ch_out = channel(100);

    // ワーカーを生成
    let tasks = [];
    let i = 0;
    while (i < workers) {
        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));
        i = i + 1;
    }

    // データを送信
    let i = 0;
    while (i < data.length) {
        ch_in.send(data[i]);
        i = i + 1;
    }
    ch_in.close();

    // 結果を収集
    let results = [];
    let i = 0;
    while (i < data.length) {
        results.push(ch_out.recv());
        i = i + 1;
    }

    // ワーカーを待つ
    let i = 0;
    while (i < tasks.length) {
        join(tasks[i]);
        i = i + 1;
    }

    return results;
}
```

### パイプラインアーキテクチャ

```hemlock
async fn stage1(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val * 2);
    }
    output_ch.close();
}

async fn stage2(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val + 10);
    }
    output_ch.close();
}

// パイプラインを作成
let ch1 = channel(10);
let ch2 = channel(10);
let ch3 = channel(10);

let s1 = spawn(stage1, ch1, ch2);
let s2 = spawn(stage2, ch2, ch3);

// 入力をフィード
ch1.send(1);
ch1.send(2);
ch1.send(3);
ch1.close();

// 出力を収集
print(ch3.recv());  // 12 (1 * 2 + 10)
print(ch3.recv());  // 14 (2 * 2 + 10)
print(ch3.recv());  // 16 (3 * 2 + 10)

join(s1);
join(s2);
```

### ファンアウト、ファンイン

```hemlock
async fn worker(id: i32, input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }

        // 値を処理
        let result = val * id;
        output_ch.send(result);
    }
}

let input = channel(10);
let output = channel(10);

// ファンアウト：複数のワーカー
let workers = 4;
let tasks = [];
let i = 0;
while (i < workers) {
    tasks.push(spawn(worker, i, input, output));
    i = i + 1;
}

// 作業を送信
let i = 0;
while (i < 10) {
    input.send(i);
    i = i + 1;
}
input.close();

// ファンイン：すべての結果を収集
let results = [];
let i = 0;
while (i < 10) {
    results.push(output.recv());
    i = i + 1;
}

// すべてのワーカーを待つ
let i = 0;
while (i < tasks.length) {
    join(tasks[i]);
    i = i + 1;
}
```

## まとめ

Hemlockの非同期/並行処理モデルは以下を提供します：

- ✅ OSスレッドを使用した真のマルチスレッド並列処理
- ✅ シンプルで構造化された並行処理プリミティブ
- ✅ 通信用のスレッドセーフなチャネル
- ✅ タスク間の例外伝播
- ✅ マルチコアシステムでの実証済みパフォーマンス
- ✅ **引数の分離** - ディープコピーによるデータ競合の防止
- ✅ **アトミック参照カウント** - スレッド間での安全なメモリ管理

これによりHemlockは以下に適しています：
- 並列計算
- 並行I/O操作
- パイプラインアーキテクチャ
- プロデューサー・コンシューマーパターン

以下の複雑さを回避しながら：
- 手動スレッド管理
- 低レベル同期プリミティブ
- デッドロックを起こしやすいロックベース設計
- 共有可変状態のバグ



################################################################################
# APIリファレンス
################################################################################

--------------------------------------------------------------------------------
## ファイルAPI
--------------------------------------------------------------------------------

# ファイルAPIリファレンス

HemlockのファイルI/Oシステムの完全なリファレンスです。

---

## 概要

Hemlockは適切なエラーハンドリングとリソース管理を備えた**ファイルオブジェクトAPI**をファイル操作に提供します。ファイルは手動でオープンおよびクローズする必要があります。

**主な機能：**
- メソッド付きファイルオブジェクト
- テキストとバイナリデータの読み書き
- シークと位置決め
- 適切なエラーメッセージ
- 手動リソース管理（RAIIなし）

---

## ファイル型

**型：** `file`

**説明：** I/O操作用のファイルハンドル

**プロパティ（読み取り専用）：**
- `.path` - ファイルパス（string）
- `.mode` - オープンモード（string）
- `.closed` - ファイルがクローズされているか（bool）

---

## ファイルのオープン

### open

読み取り、書き込み、または両方のためにファイルをオープンします。

**シグネチャ：**
```hemlock
open(path: string, mode?: string): file
```

**パラメータ：**
- `path` - ファイルパス（相対または絶対）
- `mode`（オプション）- オープンモード（デフォルト：`"r"`）

**戻り値：** ファイルオブジェクト

**モード：**
- `"r"` - 読み取り（デフォルト）
- `"w"` - 書き込み（既存ファイルを切り詰め）
- `"a"` - 追加
- `"r+"` - 読み取りと書き込み
- `"w+"` - 読み取りと書き込み（切り詰め）
- `"a+"` - 読み取りと追加

**例：**
```hemlock
// 読み取りモード（デフォルト）
let f = open("data.txt");
let f_read = open("data.txt", "r");

// 書き込みモード（切り詰め）
let f_write = open("output.txt", "w");

// 追加モード
let f_append = open("log.txt", "a");

// 読み取り/書き込みモード
let f_rw = open("data.bin", "r+");

// 読み取り/書き込み（切り詰め）
let f_rw_trunc = open("output.bin", "w+");

// 読み取り/追加
let f_ra = open("log.txt", "a+");
```

**エラーハンドリング：**
```hemlock
try {
    let f = open("missing.txt", "r");
} catch (e) {
    print("Failed to open:", e);
    // Error: Failed to open 'missing.txt': No such file or directory
}
```

**重要：** ファイルディスクリプタのリークを避けるため、`f.close()`で手動でクローズする必要があります。

---

## ファイルメソッド

### 読み取り

#### read

ファイルからテキストを読み取ります。

**シグネチャ：**
```hemlock
file.read(size?: i32): string
```

**パラメータ：**
- `size`（オプション）- 読み取るバイト数（省略時はEOFまで読み取り）

**戻り値：** ファイル内容の文字列

**例：**
```hemlock
let f = open("data.txt", "r");

// ファイル全体を読み取り
let all = f.read();
print(all);

// 特定のバイト数を読み取り
let chunk = f.read(1024);

f.close();
```

**動作：**
- 現在のファイル位置から読み取り
- EOFでは空文字列を返す
- ファイル位置を進める

**エラー：**
- クローズされたファイルからの読み取り
- 書き込み専用ファイルからの読み取り

---

#### read_bytes

ファイルからバイナリデータを読み取ります。

**シグネチャ：**
```hemlock
file.read_bytes(size: i32): buffer
```

**パラメータ：**
- `size` - 読み取るバイト数

**戻り値：** バイナリデータを含むバッファ

**例：**
```hemlock
let f = open("data.bin", "r");

// 256バイトを読み取り
let binary = f.read_bytes(256);
print(binary.length);       // 256

// バイナリデータを処理
let i = 0;
while (i < binary.length) {
    print(binary[i]);
    i = i + 1;
}

f.close();
```

**動作：**
- 正確なバイト数を読み取り
- バッファを返す（文字列ではない）
- ファイル位置を進める

---

### 書き込み

#### write

ファイルにテキストを書き込みます。

**シグネチャ：**
```hemlock
file.write(data: string): i32
```

**パラメータ：**
- `data` - 書き込む文字列

**戻り値：** 書き込まれたバイト数（i32）

**例：**
```hemlock
let f = open("output.txt", "w");

// テキストを書き込み
let written = f.write("Hello, World!\n");
print("Wrote", written, "bytes");

// 複数回書き込み
f.write("Line 1\n");
f.write("Line 2\n");
f.write("Line 3\n");

f.close();
```

**動作：**
- 現在のファイル位置に書き込み
- 書き込まれたバイト数を返す
- ファイル位置を進める

**エラー：**
- クローズされたファイルへの書き込み
- 読み取り専用ファイルへの書き込み

---

#### write_bytes

ファイルにバイナリデータを書き込みます。

**シグネチャ：**
```hemlock
file.write_bytes(data: buffer): i32
```

**パラメータ：**
- `data` - 書き込むバッファ

**戻り値：** 書き込まれたバイト数（i32）

**例：**
```hemlock
let f = open("output.bin", "w");

// バッファを作成
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// バッファを書き込み
let written = f.write_bytes(buf);
print("Wrote", written, "bytes");

f.close();
```

**動作：**
- バッファの内容をファイルに書き込み
- 書き込まれたバイト数を返す
- ファイル位置を進める

---

### シーク

#### seek

ファイル位置を特定のバイトオフセットに移動します。

**シグネチャ：**
```hemlock
file.seek(position: i32): i32
```

**パラメータ：**
- `position` - ファイル先頭からのバイトオフセット

**戻り値：** 新しいファイル位置（i32）

**例：**
```hemlock
let f = open("data.txt", "r");

// バイト100にジャンプ
f.seek(100);

// その位置から読み取り
let chunk = f.read(50);

// 先頭にリセット
f.seek(0);

// 先頭から読み取り
let all = f.read();

f.close();
```

**動作：**
- ファイル位置を絶対オフセットに設定
- 新しい位置を返す
- EOF以降へのシークは許可される（書き込み時にファイルにホールを作成）

---

#### tell

現在のファイル位置を取得します。

**シグネチャ：**
```hemlock
file.tell(): i32
```

**戻り値：** ファイル先頭からの現在のバイトオフセット（i32）

**例：**
```hemlock
let f = open("data.txt", "r");

print(f.tell());        // 0（先頭）

f.read(100);
print(f.tell());        // 100（読み取り後）

f.seek(50);
print(f.tell());        // 50（シーク後）

f.close();
```

---

### クローズ

#### close

ファイルをクローズします（冪等）。

**シグネチャ：**
```hemlock
file.close(): null
```

**戻り値：** `null`

**例：**
```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();

// 複数回呼び出しても安全
f.close();  // エラーなし
f.close();  // エラーなし
```

**動作：**
- ファイルハンドルをクローズ
- 保留中の書き込みをフラッシュ
- 冪等（複数回呼び出しても安全）
- `.closed`プロパティを`true`に設定

**重要：** ファイルディスクリプタのリークを避けるため、完了したら常にファイルをクローズしてください。

---

## ファイルプロパティ

### .path

ファイルパスを取得します。

**型：** `string`

**アクセス：** 読み取り専用

**例：**
```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);          // "/path/to/file.txt"
f.close();
```

---

### .mode

オープンモードを取得します。

**型：** `string`

**アクセス：** 読み取り専用

**例：**
```hemlock
let f = open("data.txt", "r");
print(f.mode);          // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);         // "w"
f2.close();
```

---

### .closed

ファイルがクローズされているかチェックします。

**型：** `bool`

**アクセス：** 読み取り専用

**例：**
```hemlock
let f = open("data.txt", "r");
print(f.closed);        // false

f.close();
print(f.closed);        // true
```

---

## エラーハンドリング

すべてのファイル操作にはコンテキスト付きの適切なエラーメッセージが含まれます：

### ファイルが見つからない
```hemlock
let f = open("missing.txt", "r");
// Error: Failed to open 'missing.txt': No such file or directory
```

### クローズされたファイルからの読み取り
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Error: Cannot read from closed file 'data.txt'
```

### 読み取り専用ファイルへの書き込み
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Error: Cannot write to file 'readonly.txt' opened in read-only mode
```

### try/catchの使用
```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    print(content);
} catch (e) {
    print("File error:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## リソース管理パターン

### 基本パターン

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### エラーハンドリング付き

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // エラー時も常にクローズ
}
```

### 安全なパターン

```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    // ... コンテンツを処理 ...
} catch (e) {
    print("Error:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## 使用例

### ファイル全体を読み取る

```hemlock
fn read_file(filename: string): string {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content;
}

let text = read_file("data.txt");
print(text);
```

### テキストファイルを書き込む

```hemlock
fn write_file(filename: string, content: string) {
    let f = open(filename, "w");
    f.write(content);
    f.close();
}

write_file("output.txt", "Hello, World!\n");
```

### ファイルに追加する

```hemlock
fn append_file(filename: string, line: string) {
    let f = open(filename, "a");
    f.write(line + "\n");
    f.close();
}

append_file("log.txt", "Log entry 1");
append_file("log.txt", "Log entry 2");
```

### バイナリファイルを読み取る

```hemlock
fn read_binary(filename: string, size: i32): buffer {
    let f = open(filename, "r");
    let data = f.read_bytes(size);
    f.close();
    return data;
}

let binary = read_binary("data.bin", 256);
print("Read", binary.length, "bytes");
```

### バイナリファイルを書き込む

```hemlock
fn write_binary(filename: string, data: buffer) {
    let f = open(filename, "w");
    f.write_bytes(data);
    f.close();
}

let buf = buffer(10);
buf[0] = 65;
write_binary("output.bin", buf);
```

### ファイルを行ごとに読み取る

```hemlock
fn read_lines(filename: string): array {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content.split("\n");
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Line", i, ":", lines[i]);
    i = i + 1;
}
```

### ファイルをコピーする

```hemlock
fn copy_file(src: string, dest: string) {
    let f_in = open(src, "r");
    let f_out = open(dest, "w");

    let content = f_in.read();
    f_out.write(content);

    f_in.close();
    f_out.close();
}

copy_file("input.txt", "output.txt");
```

### ファイルをチャンクで読み取る

```hemlock
fn process_chunks(filename: string) {
    let f = open(filename, "r");

    while (true) {
        let chunk = f.read(1024);  // 一度に1KBを読み取り
        if (chunk.length == 0) {
            break;  // EOF
        }

        // チャンクを処理
        print("Processing", chunk.length, "bytes");
    }

    f.close();
}

process_chunks("large_file.txt");
```

---

## 完全なメソッド要約

| メソッド | シグネチャ | 戻り値 | 説明 |
|---------------|--------------------------|-----------|------------------------------|
| `read`        | `(size?: i32)`           | `string`  | テキストを読み取り |
| `read_bytes`  | `(size: i32)`            | `buffer`  | バイナリデータを読み取り |
| `write`       | `(data: string)`         | `i32`     | テキストを書き込み |
| `write_bytes` | `(data: buffer)`         | `i32`     | バイナリデータを書き込み |
| `seek`        | `(position: i32)`        | `i32`     | ファイル位置を設定 |
| `tell`        | `()`                     | `i32`     | ファイル位置を取得 |
| `close`       | `()`                     | `null`    | ファイルをクローズ（冪等） |

---

## 完全なプロパティ要約

| プロパティ | 型 | アクセス | 説明 |
|-----------|----------|------------|--------------------------|
| `.path`   | `string` | 読み取り専用 | ファイルパス |
| `.mode`   | `string` | 読み取り専用 | オープンモード |
| `.closed` | `bool`   | 読み取り専用 | ファイルがクローズされているか |

---

## 旧APIからの移行

**旧API（削除済み）：**
- `read_file(path)` - `open(path, "r").read()`を使用
- `write_file(path, data)` - `open(path, "w").write(data)`を使用
- `append_file(path, data)` - `open(path, "a").write(data)`を使用
- `file_exists(path)` - 代替なし

**移行例：**
```hemlock
// 旧（v0.0）
let content = read_file("data.txt");
write_file("output.txt", content);

// 新（v0.1）
let f = open("data.txt", "r");
let content = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write(content);
f2.close();
```

---

## 関連項目

- [組み込み関数](#reference-builtins) - `open()`関数
- [メモリAPI](#reference-memory-api) - バッファ型
- [文字列API](#reference-string-api) - テキスト処理用の文字列メソッド


--------------------------------------------------------------------------------
## メモリAPI
--------------------------------------------------------------------------------

# メモリAPIリファレンス

Hemlockのメモリ管理関数とポインタ型の完全なリファレンスです。

---

## 概要

Hemlockは明示的な割り当てと解放による**手動メモリ管理**を提供します。メモリは2つのポインタ型で管理されます：生ポインタ（`ptr`）と安全なバッファ（`buffer`）。

**主な原則：**
- 明示的な割り当てと解放
- ガベージコレクションなし
- ユーザーが`free()`を呼び出す責任がある
- スコープ/再代入の安全性のための内部参照カウント（下記参照）

### 内部参照カウント

ランタイムはスコープを通じてオブジェクトのライフタイムを管理するために、内部的に参照カウントを使用します。ほとんどのローカル変数では、クリーンアップは自動的です。

**自動（`free()`不要）：**
- 参照カウント型（buffer、array、object、string）のローカル変数はスコープ終了時に解放される
- 変数が再代入されると古い値が解放される
- コンテナが解放されるとコンテナ要素が解放される

**手動`free()`が必要：**
- `alloc()`からの生ポインタ - 常に
- スコープ終了前の早期クリーンアップ
- 長寿命/グローバルデータ

詳細は[メモリ管理ガイド](../language-guide/memory.md#内部参照カウント)を参照してください。

---

## ポインタ型

### ptr（生ポインタ）

**型：** `ptr`

**説明：** 境界チェックや追跡なしの生メモリアドレス。

**サイズ：** 8バイト

**使用ケース：**
- 低レベルメモリ操作
- FFI（外部関数インターフェース）
- 最大パフォーマンス（オーバーヘッドなし）

**安全性：** 安全でない - 境界チェックなし、ユーザーがライフタイムを追跡する必要がある

**例：**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer（安全なバッファ）

**型：** `buffer`

**説明：** 境界チェック付きの安全なポインタラッパー。

**構造：** ポインタ + 長さ + 容量 + 参照カウント

**プロパティ：**
- `.length` - バッファサイズ（i32）
- `.capacity` - 割り当て容量（i32）

**使用ケース：**
- ほとんどのメモリ割り当て
- 安全性が重要な場合
- 動的配列

**安全性：** インデックスアクセス時に境界チェック

**参照カウント：** バッファは内部的に参照カウントされます。スコープ終了時または変数再代入時に自動的に解放されます。早期クリーンアップや長寿命データには`free()`を使用してください。

**例：**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // 境界チェックあり
print(b.length);        // 64
free(b);
```

---

## メモリ割り当て関数

### alloc

生メモリを割り当てます。

**シグネチャ：**
```hemlock
alloc(size: i32): ptr
```

**パラメータ：**
- `size` - 割り当てるバイト数

**戻り値：** 割り当てられたメモリへのポインタ（`ptr`）

**例：**
```hemlock
let p = alloc(1024);        // 1KBを割り当て
memset(p, 0, 1024);         // ゼロで初期化
free(p);                    // 終了時に解放

// 構造体用に割り当て
let struct_size = 16;
let p2 = alloc(struct_size);
```

**動作：**
- 初期化されていないメモリを返す
- メモリは手動で解放する必要がある
- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）

**関連項目：** より安全な代替として`buffer()`

---

### buffer

境界チェック付きの安全なバッファを割り当てます。

**シグネチャ：**
```hemlock
buffer(size: i32): buffer
```

**パラメータ：**
- `size` - バイト単位のバッファサイズ

**戻り値：** バッファオブジェクト

**例：**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// 境界チェック付きアクセス
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // エラー：範囲外

free(buf);
```

**プロパティ：**
- `.length` - 現在のサイズ（i32）
- `.capacity` - 割り当て容量（i32）

**動作：**
- メモリをゼロで初期化
- インデックスアクセス時に境界チェックを提供
- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）
- 手動で解放する必要がある

---

### free

割り当てられたメモリを解放します。

**シグネチャ：**
```hemlock
free(ptr: ptr | buffer): null
```

**パラメータ：**
- `ptr` - 解放するポインタまたはバッファ

**戻り値：** `null`

**例：**
```hemlock
// 生ポインタを解放
let p = alloc(1024);
free(p);

// バッファを解放
let buf = buffer(256);
free(buf);
```

**動作：**
- `alloc()`または`buffer()`で割り当てられたメモリを解放
- 二重解放はクラッシュを引き起こす（ユーザーの責任で回避）
- 無効なポインタの解放は未定義動作

**重要：** 割り当てたら、解放する。自動クリーンアップなし。

---

### realloc

割り当てられたメモリのサイズを変更します。

**シグネチャ：**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**パラメータ：**
- `ptr` - サイズ変更するポインタ
- `new_size` - バイト単位の新しいサイズ

**戻り値：** サイズ変更されたメモリへのポインタ（アドレスが異なる場合がある）

**例：**
```hemlock
let p = alloc(100);
// ... メモリを使用 ...

// より多くの領域が必要
p = realloc(p, 200);        // 200バイトになった
// ... 拡張されたメモリを使用 ...

free(p);
```

**動作：**
- メモリを新しい場所に移動する場合がある
- 既存データを保持（古い/新しいサイズの最小まで）
- 成功したreallocの後は古いポインタは無効（返されたポインタを使用）
- new_sizeが小さい場合、データは切り詰められる
- 割り当て失敗時は`null`を返す（元のポインタは有効なまま）

**重要：** 常に`null`をチェックし、結果でポインタ変数を更新してください。

---

## メモリ操作

### memset

メモリをバイト値で埋めます。

**シグネチャ：**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**パラメータ：**
- `ptr` - メモリへのポインタ
- `byte` - 埋めるバイト値（0-255）
- `size` - 埋めるバイト数

**戻り値：** `null`

**例：**
```hemlock
let p = alloc(100);

// メモリをゼロクリア
memset(p, 0, 100);

// 特定の値で埋める
memset(p, 0xFF, 100);

// バッファを初期化
let buf = alloc(256);
memset(buf, 65, 256);       // 'A'で埋める

free(p);
free(buf);
```

**動作：**
- 範囲内の各バイトにバイト値を書き込む
- バイト値は8ビット（0-255）に切り詰められる
- 境界チェックなし（安全でない）

---

### memcpy

ソースからデスティネーションにメモリをコピーします。

**シグネチャ：**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**パラメータ：**
- `dest` - デスティネーションポインタ
- `src` - ソースポインタ
- `size` - コピーするバイト数

**戻り値：** `null`

**例：**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// ソースを初期化
memset(src, 65, 100);

// デスティネーションにコピー
memcpy(dest, src, 100);

// destはsrcと同じデータを含む

free(src);
free(dest);
```

**動作：**
- srcからdestへバイト単位でコピー
- 境界チェックなし（安全でない）
- オーバーラップする領域は未定義動作（慎重に使用）

---

## 型付きメモリ操作

### sizeof

型のバイト数を取得します。

**シグネチャ：**
```hemlock
sizeof(type): i32
```

**パラメータ：**
- `type` - 型識別子（例：`i32`、`f64`、`ptr`）

**戻り値：** バイト数（i32）

**型サイズ：**

| 型 | サイズ（バイト） |
|------|--------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**例：**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// 配列割り当てサイズを計算
let count = 100;
let total = sizeof(i32) * count; // 400バイト
```

**動作：**
- 不明な型には0を返す
- 型識別子と型文字列の両方を受け付ける

---

### talloc

型付き値の配列を割り当てます。

**シグネチャ：**
```hemlock
talloc(type, count: i32): ptr
```

**パラメータ：**
- `type` - 割り当てる型（例：`i32`、`f64`、`ptr`）
- `count` - 要素数（正の数である必要がある）

**戻り値：** 割り当てられた配列へのポインタ、割り当て失敗時は`null`

**例：**
```hemlock
let arr = talloc(i32, 100);      // 100個のi32の配列（400バイト）
let floats = talloc(f64, 50);    // 50個のf64の配列（400バイト）
let bytes = talloc(u8, 1024);    // 1024バイトの配列

// 常に割り当て失敗をチェック
if (arr == null) {
    panic("allocation failed");
}

// 割り当てられたメモリを使用
// ...

free(arr);
free(floats);
free(bytes);
```

**動作：**
- `sizeof(type) * count`バイトを割り当て
- 初期化されていないメモリを返す
- `free()`で手動解放が必要
- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）
- countが正でない場合はパニック

---

## バッファプロパティ

### .length

バッファサイズを取得します。

**型：** `i32`

**アクセス：** 読み取り専用

**例：**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

バッファ容量を取得します。

**型：** `i32`

**アクセス：** 読み取り専用

**例：**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**注意：** 現在、`buffer()`で作成されたバッファでは`.length`と`.capacity`は同じです。

---

## 使用パターン

### 基本的な割り当てパターン

```hemlock
// 割り当て
let p = alloc(1024);
if (p == null) {
    panic("allocation failed");
}

// 使用
memset(p, 0, 1024);

// 解放
free(p);
```

### 安全なバッファパターン

```hemlock
// バッファを割り当て
let buf = buffer(256);
if (buf == null) {
    panic("buffer allocation failed");
}

// 境界チェック付きで使用
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// 解放
free(buf);
```

### 動的拡張パターン

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("allocation failed");
}

// ... メモリを使用 ...

// より多くの領域が必要 - 失敗をチェック
let new_p = realloc(p, 200);
if (new_p == null) {
    // 元のポインタはまだ有効、クリーンアップ
    free(p);
    panic("realloc failed");
}
p = new_p;
size = 200;

// ... 拡張されたメモリを使用 ...

free(p);
```

### メモリコピーパターン

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// コピーを作成
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## 安全性に関する考慮事項

**Hemlockのメモリ管理は設計上安全ではありません：**

### よくある落とし穴

**1. メモリリーク**
```hemlock
// 悪い例：メモリリーク
fn create_buffer() {
    let p = alloc(1024);
    return null;  // メモリがリーク！
}

// 良い例：適切なクリーンアップ
fn create_buffer() {
    let p = alloc(1024);
    // ... メモリを使用 ...
    free(p);
    return null;
}
```

**2. 解放後使用**
```hemlock
// 悪い例：解放後使用
let p = alloc(100);
free(p);
memset(p, 0, 100);  // クラッシュ：解放済みメモリを使用

// 良い例：解放後は使用しない
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// この後p2に触れない
```

**3. 二重解放**
```hemlock
// 悪い例：二重解放
let p = alloc(100);
free(p);
free(p);  // クラッシュ：二重解放

// 良い例：一度だけ解放
let p2 = alloc(100);
free(p2);
```

**4. バッファオーバーフロー（ptr）**
```hemlock
// 悪い例：ptrでのバッファオーバーフロー
let p = alloc(10);
memset(p, 65, 100);  // クラッシュ：割り当てを超えて書き込み

// 良い例：境界チェックにはbufferを使用
let buf = buffer(10);
// buf[100] = 65;  // エラー：境界チェックが失敗
```

**5. ダングリングポインタ**
```hemlock
// 悪い例：ダングリングポインタ
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // クラッシュ：p2はダングリング

// 良い例：所有権を慎重に追跡
let p = alloc(100);
// ... pを使用 ...
free(p);
// pへの他の参照を保持しない
```

**6. 割り当て失敗のチェック漏れ**
```hemlock
// 悪い例：nullをチェックしない
let p = alloc(1000000000);  // メモリ不足で失敗する可能性
memset(p, 0, 1000000000);   // クラッシュ：pがnull

// 良い例：常に割り当て結果をチェック
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("out of memory");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## 何をいつ使うか

### `buffer()`を使用する場合：
- 境界チェックが必要な場合
- 動的データを扱う場合
- 安全性が重要な場合
- Hemlockを学習中の場合

### `alloc()`を使用する場合：
- 最大パフォーマンスが必要な場合
- FFI/Cとのインターフェース
- 正確なメモリレイアウトを知っている場合
- エキスパートの場合

### `realloc()`を使用する場合：
- 割り当てを拡大/縮小する場合
- 動的配列
- データを保持する必要がある場合

---

## 完全な関数要約

| 関数 | シグネチャ | 戻り値 | 説明 |
|-----------|----------------------------------------|----------|----------------------------|
| `alloc`   | `(size: i32)`                          | `ptr`    | 生メモリを割り当て |
| `buffer`  | `(size: i32)`                          | `buffer` | 安全なバッファを割り当て |
| `free`    | `(ptr: ptr \| buffer)`                 | `null`   | メモリを解放 |
| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | 割り当てサイズを変更 |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | メモリを埋める |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | メモリをコピー |
| `sizeof`  | `(type)`                               | `i32`    | 型のバイトサイズを取得 |
| `talloc`  | `(type, count: i32)`                   | `ptr`    | 型付き配列を割り当て |

---

## 関連項目

- [型システム](#reference-type-system) - ポインタとバッファ型
- [組み込み関数](#reference-builtins) - すべての組み込み関数
- [文字列API](#reference-string-api) - 文字列の`.to_bytes()`メソッド


--------------------------------------------------------------------------------
## 並行処理API
--------------------------------------------------------------------------------

# 並行性APIリファレンス

Hemlockの非同期/並行性システムの完全なリファレンスです。

---

## 概要

Hemlockは、POSIXスレッド（pthreads）を使用した真のマルチスレッド並列処理を備えた**構造化された並行性**を提供します。各スポーンされたタスクは別のOSスレッドで実行され、複数のCPUコアにわたる実際の並列実行を可能にします。

**主な機能：**
- 真のマルチスレッド並列処理（グリーンスレッドではない）
- 非同期関数構文
- タスクのスポーンと結合
- スレッドセーフなチャネル
- 例外の伝播

**スレッディングモデル：**
- 実際のOSスレッド（POSIX pthreads）
- 真の並列処理（複数のCPUコア）
- カーネルスケジュール（プリエンプティブマルチタスキング）
- スレッドセーフな同期（ミューテックス、条件変数）

---

## 非同期関数

### 非同期関数の宣言

関数を`async`として宣言して、並行実行用に設計されていることを示すことができます。

**構文：**
```hemlock
async fn function_name(params): return_type {
    // 関数本体
}
```

**例：**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

async fn process_data(data: string) {
    print("Processing:", data);
    return null;
}
```

**動作：**
- `async fn`は非同期関数を宣言
- 同期的に呼び出し可能（現在のスレッドで実行）
- 並行タスクとしてスポーン可能（新しいスレッドで実行）
- スポーン時は独自のOSスレッドで実行

**注意：** `await`キーワードは将来の使用のために予約されていますが、現在は実装されていません。

---

## タスク管理

### spawn

新しい並行タスクを作成して開始します。

**シグネチャ：**
```hemlock
spawn(async_fn: function, ...args): task
```

**パラメータ：**
- `async_fn` - 実行する非同期関数
- `...args` - 関数に渡す引数

**戻り値：** タスクハンドル

**例：**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// 単一タスクをスポーン
let t = spawn(compute, 1000);
let result = join(t);
print(result);

// 複数タスクをスポーン（並列実行！）
let t1 = spawn(compute, 100);
let t2 = spawn(compute, 200);
let t3 = spawn(compute, 300);

// 3つすべてが同時に実行中
let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

**動作：**
- `pthread_create()`経由で新しいOSスレッドを作成
- すぐに関数の実行を開始
- 後で結合するためのタスクハンドルを返す
- タスクは別のCPUコアで並列実行

---

### join

タスクの完了を待ち、結果を取得します。

**シグネチャ：**
```hemlock
join(task: task): any
```

**パラメータ：**
- `task` - `spawn()`からのタスクハンドル

**戻り値：** タスクの戻り値

**例：**
```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

let t = spawn(factorial, 10);
let result = join(t);  // タスク完了までブロック
print(result);         // 3628800
```

**動作：**
- タスク完了まで現在のスレッドをブロック
- タスクの戻り値を返す
- タスクが投げた例外を伝播
- 戻り後にタスクリソースをクリーンアップ

**エラーハンドリング：**
```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task failed!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Caught:", e);  // "Caught: Task failed!"
}
```

---

### detach

タスクをデタッチします（ファイア・アンド・フォーゲット実行）。

**シグネチャ：**
```hemlock
detach(task: task): null
```

**パラメータ：**
- `task` - `spawn()`からのタスクハンドル

**戻り値：** `null`

**例：**
```hemlock
async fn background_work() {
    print("Working in background...");
    return null;
}

let t = spawn(background_work);
detach(t);  // タスクは独立して実行を継続

// デタッチされたタスクは結合できない
// join(t);  // エラー
```

**動作：**
- タスクは独立して実行を継続
- デタッチされたタスクは`join()`できない
- タスク完了時にタスクとスレッドは自動的にクリーンアップ

**使用ケース：**
- ファイア・アンド・フォーゲットのバックグラウンドタスク
- ロギング/モニタリングタスク
- 値を返す必要がないタスク

---

## チャネル

チャネルはタスク間のスレッドセーフな通信を提供します。

### channel

バッファ付きチャネルを作成します。

**シグネチャ：**
```hemlock
channel(capacity: i32): channel
```

**パラメータ：**
- `capacity` - バッファサイズ（値の数）

**戻り値：** チャネルオブジェクト

**例：**
```hemlock
let ch = channel(10);  // 容量10のバッファ付きチャネル
let ch2 = channel(1);  // 最小バッファ（同期的）
let ch3 = channel(100); // 大きなバッファ
```

**動作：**
- スレッドセーフなチャネルを作成
- 同期にpthreadミューテックスを使用
- 容量は作成時に固定

---

### チャネルメソッド

#### send

チャネルに値を送信します（満杯の場合ブロック）。

**シグネチャ：**
```hemlock
channel.send(value: any): null
```

**パラメータ：**
- `value` - 送信する値（任意の型）

**戻り値：** `null`

**例：**
```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let t = spawn(producer, ch, 5);
```

**動作：**
- チャネルに値を送信
- チャネルが満杯の場合ブロック
- スレッドセーフ（ミューテックス使用）
- 値が送信されると戻る

---

#### recv

チャネルから値を受信します（空の場合ブロック）。

**シグネチャ：**
```hemlock
channel.recv(): any
```

**戻り値：** チャネルからの値、またはチャネルがクローズされ空の場合`null`

**例：**
```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let t = spawn(consumer, ch, 5);
```

**動作：**
- チャネルから値を受信
- チャネルが空の場合ブロック
- チャネルがクローズされ空の場合`null`を返す
- スレッドセーフ（ミューテックス使用）

---

#### close

チャネルをクローズします（これ以上の送信は不可）。

**シグネチャ：**
```hemlock
channel.close(): null
```

**戻り値：** `null`

**例：**
```hemlock
async fn producer(ch) {
    ch.send(1);
    ch.send(2);
    ch.send(3);
    ch.close();  // これ以上値がないことを通知
    return null;
}

async fn consumer(ch) {
    while (true) {
        let val = ch.recv();
        if (val == null) {
            break;  // チャネルがクローズ
        }
        print(val);
    }
    return null;
}
```

**動作：**
- チャネルをクローズ
- これ以上の送信は不可
- チャネルが空の場合`recv()`は`null`を返す
- スレッドセーフ

---

## 完全な並行性の例

### プロデューサー・コンシューマーパターン

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        print("Producing:", i);
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        print("Consuming:", val);
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// チャネルを作成
let ch = channel(10);

// プロデューサーとコンシューマーをスポーン
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// 完了を待機
join(p);
let total = join(c);
print("Total:", total);  // 0+10+20+30+40 = 100
```

---

## 並列計算

### 複数タスクの例

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// 複数タスクをスポーン（並列実行！）
let t1 = spawn(factorial, 5);   // スレッド1
let t2 = spawn(factorial, 6);   // スレッド2
let t3 = spawn(factorial, 7);   // スレッド3
let t4 = spawn(factorial, 8);   // スレッド4

// 4つすべてが同時に計算中！

// 結果を待機
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
let f8 = join(t4);  // 40320

print(f5, f6, f7, f8);
```

---

## タスクライフサイクル

### 状態遷移

1. **作成済み** - タスクがスポーンされたがまだ実行されていない
2. **実行中** - タスクがOSスレッドで実行中
3. **完了** - タスクが終了（結果が利用可能）
4. **結合済み** - 結果が取得され、リソースがクリーンアップ
5. **デタッチ済み** - タスクは独立して継続

### ライフサイクルの例

```hemlock
async fn work(n: i32): i32 {
    return n * 2;
}

// 1. タスクを作成
let t = spawn(work, 21);  // 状態：実行中

// タスクは別スレッドで実行...

// 2. タスクを結合
let result = join(t);     // 状態：完了 → 結合済み
print(result);            // 42

// 結合後にタスクリソースがクリーンアップ
```

### デタッチのライフサイクル

```hemlock
async fn background() {
    print("Background task running");
    return null;
}

// 1. タスクを作成
let t = spawn(background);  // 状態：実行中

// 2. タスクをデタッチ
detach(t);                  // 状態：デタッチ済み

// タスクは独立して実行を継続
// 完了時にOSがリソースをクリーンアップ
```

---

## エラーハンドリング

### 例外の伝播

タスクで投げられた例外は結合時に伝播されます：

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task failed!";
    }
    return 42;
}

// 成功するタスク
let t1 = spawn(risky_operation, 0);
let result1 = join(t1);  // 42

// 失敗するタスク
let t2 = spawn(risky_operation, 1);
try {
    let result2 = join(t2);
} catch (e) {
    print("Caught:", e);  // "Caught: Task failed!"
}
```

### 複数タスクのハンドリング

```hemlock
async fn work(id: i32, should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task " + typeof(id) + " failed";
    }
    return id * 10;
}

let t1 = spawn(work, 1, 0);
let t2 = spawn(work, 2, 1);  // 失敗する
let t3 = spawn(work, 3, 0);

// エラーハンドリング付きで結合
try {
    let r1 = join(t1);  // OK
    print("Task 1:", r1);

    let r2 = join(t2);  // 投げる
    print("Task 2:", r2);  // 到達しない
} catch (e) {
    print("Error:", e);  // "Error: Task 2 failed"
}

// 残りのタスクはまだ結合可能
let r3 = join(t3);
print("Task 3:", r3);
```

---

## パフォーマンス特性

### 真の並列処理

```hemlock
async fn cpu_intensive(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// 順次実行
let start = get_time();
let r1 = cpu_intensive(10000000);
let r2 = cpu_intensive(10000000);
let sequential_time = get_time() - start;

// 並列実行
let start2 = get_time();
let t1 = spawn(cpu_intensive, 10000000);
let t2 = spawn(cpu_intensive, 10000000);
join(t1);
join(t2);
let parallel_time = get_time() - start2;

// マルチコアシステムではparallel_timeはsequential_timeの約50%になるはず
```

**実証された特性：**
- N個のタスクはN個のCPUコアを同時に使用可能
- ストレステストではウォール時間に対して8-9倍のCPU時間を示す（並列処理の証明）
- スレッドオーバーヘッド：タスクあたり約8KBスタック + pthreadオーバーヘッド
- 1つのタスクのブロッキング操作は他に影響しない

---

## 実装の詳細

### スレッディングモデル

- **1:1スレッディング** - 各タスク = 1 OSスレッド（`pthread`）
- **カーネルスケジュール** - OSカーネルがスレッドをコアに分散
- **プリエンプティブマルチタスキング** - OSがスレッドを中断して切り替え可能
- **GILなし** - グローバルインタプリタロックなし（Pythonとは異なる）

### 同期

- **ミューテックス** - チャネルは`pthread_mutex_t`を使用
- **条件変数** - ブロッキングsend/recvは`pthread_cond_t`を使用
- **ロックフリー操作** - タスク状態遷移はアトミック

### メモリとクリーンアップ

- **結合されたタスク** - `join()`後に自動クリーンアップ
- **デタッチされたタスク** - タスク完了時に自動クリーンアップ
- **チャネル** - 参照カウント、使用されなくなると解放

---

## 制限事項

- 複数チャネルの多重化のための`select()`なし
- ワークスティーリングスケジューラなし（タスクあたり1スレッド）
- 非同期I/O統合なし（ファイル/ネットワーク操作はブロック）
- チャネル容量は作成時に固定

---

## 完全なAPI要約

### 関数

| 関数 | シグネチャ | 戻り値 | 説明 |
|-----------|-----------------------------------|-----------|--------------------------------|
| `spawn`   | `(async_fn: function, ...args)`   | `task`    | 並行タスクを作成して開始 |
| `join`    | `(task: task)`                    | `any`     | タスクを待ち、結果を取得 |
| `detach`  | `(task: task)`                    | `null`    | タスクをデタッチ（ファイア・アンド・フォーゲット） |
| `channel` | `(capacity: i32)`                 | `channel` | スレッドセーフなチャネルを作成 |

### チャネルメソッド

| メソッド | シグネチャ | 戻り値 | 説明 |
|---------|-----------------|---------|----------------------------------|
| `send`  | `(value: any)`  | `null`  | 値を送信（満杯ならブロック） |
| `recv`  | `()`            | `any`   | 値を受信（空ならブロック） |
| `close` | `()`            | `null`  | チャネルをクローズ |

### 型

| 型 | 説明 |
|-----------|--------------------------------------|
| `task`    | 並行タスクのハンドル |
| `channel` | スレッドセーフな通信チャネル |

---

## ベストプラクティス

### すべきこと

- タスク間の通信にチャネルを使用
- 結合されたタスクからの例外をハンドル
- 送信完了時にチャネルをクローズ
- 結果の取得とクリーンアップに`join()`を使用
- 非同期関数のみをスポーン

### すべきでないこと

- 同期なしに可変状態を共有しない
- 同じタスクを2回結合しない
- クローズされたチャネルに送信しない
- 非async関数をスポーンしない
- タスクの結合を忘れない（デタッチしない限り）

---

## 関連項目

- [組み込み関数](#reference-builtins) - `spawn()`、`join()`、`detach()`、`channel()`
- [型システム](#reference-type-system) - タスクとチャネル型


--------------------------------------------------------------------------------
## 型システム
--------------------------------------------------------------------------------

# 型システムリファレンス

Hemlockの型システムの完全なリファレンスです。すべてのプリミティブ型と複合型を含みます。

---

## 概要

Hemlockは実行時型タグとオプションの型注釈を持つ**動的型システム**を使用します。すべての値は実行時型を持ち、型変換は明示的な昇格規則に従います。

**主な機能：**
- 実行時型チェック（インタプリタ）
- コンパイル時型チェック（hemlockc - デフォルトで有効）
- オプションの型注釈
- リテラルの自動型推論
- 明示的な型昇格規則
- 精度を失う暗黙的変換なし

---

## コンパイル時型チェック（hemlockc）

Hemlockコンパイラ（`hemlockc`）には、実行可能ファイル生成前にコードを検証するコンパイル時型チェッカーが含まれています。これにより、プログラムを実行せずに型エラーを早期に発見できます。

### デフォルトの動作

型チェックはhemloccで**デフォルトで有効**です：

```bash
# 型チェックは自動的に行われる
hemlockc program.hml -o program

# エラーはコンパイル前に報告される
hemlockc bad_types.hml
# 出力：1 type error found
```

### コンパイラフラグ

| フラグ | 説明 |
|------|-------------|
| `--check` | 型チェックのみ、コンパイルしない（検証後に終了） |
| `--no-type-check` | 型チェックを無効化（推奨されない） |
| `--strict-types` | より厳格な型警告を有効化 |

**例：**

```bash
# コンパイルせずに型のみ検証
hemlockc --check program.hml
# 出力：program.hml: no type errors

# 型チェックを無効化（注意して使用）
hemlockc --no-type-check dynamic_code.hml -o program

# 暗黙のany型に対する厳格な警告を有効化
hemlockc --strict-types program.hml -o program
```

### 型チェッカーが検証する内容

1. **型注釈** - 代入された値が宣言された型と一致することを保証
2. **関数呼び出し** - 引数の型がパラメータの型と一致することを検証
3. **戻り値の型** - return文が宣言された戻り値の型と一致することをチェック
4. **演算子の使用** - オペランドが互換性があることを検証
5. **プロパティアクセス** - 型付きオブジェクトのオブジェクトフィールドの型を検証

### 許容的な数値変換

型チェッカーはコンパイル時に数値型の変換を許可し、範囲の検証は実行時に行われます：

```hemlock
let x: i8 = 100;      // OK - 100はi8に収まる（実行時に検証）
let y: u8 = 255;      // OK - u8の範囲内
let z: f64 = 42;      // OK - i32からf64は安全
```

### 動的コードのサポート

型注釈のないコードは動的（`any`型）として扱われ、常に型チェッカーを通過します：

```hemlock
let x = get_value();  // 動的 - 注釈なし
process(x);           // OK - 動的な値はどこでも受け入れられる
```

---

## プリミティブ型

### 数値型

#### 符号付き整数

| 型 | サイズ | 範囲 | エイリアス |
|--------|---------|-------------------------------------------|-----------|
| `i8`   | 1バイト | -128から127 | - |
| `i16`  | 2バイト | -32,768から32,767 | - |
| `i32`  | 4バイト | -2,147,483,648から2,147,483,647 | `integer` |
| `i64`  | 8バイト | -9,223,372,036,854,775,808から9,223,372,036,854,775,807 | - |

**例：**
```hemlock
let a: i8 = 127;
let b: i16 = 32000;
let c: i32 = 1000000;
let d: i64 = 9223372036854775807;

// 型エイリアス
let x: integer = 42;  // i32と同じ
```

#### 符号なし整数

| 型 | サイズ | 範囲 | エイリアス |
|--------|---------|---------------------------|--------|
| `u8`   | 1バイト | 0から255 | `byte` |
| `u16`  | 2バイト | 0から65,535 | - |
| `u32`  | 4バイト | 0から4,294,967,295 | - |
| `u64`  | 8バイト | 0から18,446,744,073,709,551,615 | - |

**例：**
```hemlock
let a: u8 = 255;
let b: u16 = 65535;
let c: u32 = 4294967295;
let d: u64 = 18446744073709551615;

// 型エイリアス
let byte_val: byte = 65;  // u8と同じ
```

#### 浮動小数点

| 型 | サイズ | 精度 | エイリアス |
|--------|---------|----------------|----------|
| `f32`  | 4バイト | 約7桁 | - |
| `f64`  | 8バイト | 約15桁 | `number` |

**例：**
```hemlock
let pi: f32 = 3.14159;
let precise: f64 = 3.14159265359;

// 型エイリアス
let x: number = 2.718;  // f64と同じ
```

---

### 整数リテラルの推論

整数リテラルはその値に基づいて自動的に型付けされます：

**規則：**
- i32範囲（-2,147,483,648から2,147,483,647）内の値：`i32`として推論
- i32範囲外だがi64範囲内の値：`i64`として推論
- 他の型（i8、i16、u8、u16、u32、u64）には明示的な型注釈を使用

**例：**
```hemlock
let small = 42;                    // i32（i32に収まる）
let large = 5000000000;            // i64（> i32最大値）
let max_i64 = 9223372036854775807; // i64（INT64_MAX）
let explicit: u32 = 100;           // u32（型注釈で上書き）
```

---

### ブーリアン型

**型：** `bool`

**値：** `true`、`false`

**サイズ：** 1バイト（内部的に）

**例：**
```hemlock
let is_active: bool = true;
let done = false;

if (is_active && !done) {
    print("working");
}
```

---

### 文字型

#### Rune

**型：** `rune`

**説明：** Unicodeコードポイント（U+0000からU+10FFFF）

**サイズ：** 4バイト（32ビット値）

**範囲：** 0から0x10FFFF（1,114,111）

**リテラル構文：** シングルクォート `'x'`

**例：**
```hemlock
// ASCII
let a = 'A';
let digit = '0';

// マルチバイトUTF-8
let rocket = '🚀';      // U+1F680
let heart = '❤';        // U+2764
let chinese = '中';     // U+4E2D

// エスケープシーケンス
let newline = '\n';
let tab = '\t';
let backslash = '\\';
let quote = '\'';
let null = '\0';

// Unicodeエスケープ
let emoji = '\u{1F680}';   // 最大6桁の16進数
let max = '\u{10FFFF}';    // 最大コードポイント
```

**型変換：**
```hemlock
// 整数からrune
let code: rune = 65;        // 'A'
let r: rune = 128640;       // 🚀

// runeから整数
let value: i32 = 'Z';       // 90

// runeから文字列
let s: string = 'H';        // "H"

// u8からrune
let byte: u8 = 65;
let rune_val: rune = byte;  // 'A'
```

**関連項目：** 文字列 + rune連結については[文字列API](#reference-string-api)

---

### 文字列型

**型：** `string`

**説明：** UTF-8エンコード、可変、ヒープ割り当てのテキスト

**エンコーディング：** UTF-8（U+0000からU+10FFFF）

**可変性：** 可変（ほとんどの言語と異なる）

**プロパティ：**
- `.length` - コードポイント数（文字数）
- `.byte_length` - バイト数（UTF-8エンコーディングサイズ）

**リテラル構文：** ダブルクォート `"text"`

**例：**
```hemlock
let s = "hello";
s[0] = 'H';             // 変更（"Hello"になる）
print(s.length);        // 5（コードポイント数）
print(s.byte_length);   // 5（UTF-8バイト数）

let emoji = "🚀";
print(emoji.length);        // 1（1つのコードポイント）
print(emoji.byte_length);   // 4（4つのUTF-8バイト）
```

**インデックス：**
```hemlock
let s = "hello";
let ch = s[0];          // rune 'h'を返す
s[0] = 'H';             // runeで設定
```

**関連項目：** 完全なメソッドリファレンスは[文字列API](#reference-string-api)

---

### Null型

**型：** `null`

**説明：** null値（値の不在）

**サイズ：** 8バイト（内部的に）

**値：** `null`

**例：**
```hemlock
let x = null;
let y: i32 = null;  // エラー：型の不一致

if (x == null) {
    print("x is null");
}
```

---

## 複合型

### 配列型

**型：** `array`

**説明：** 動的、ヒープ割り当て、混合型の配列

**プロパティ：**
- `.length` - 要素数

**ゼロインデックス：** はい

**リテラル構文：** `[elem1, elem2, ...]`

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// 混合型
let mixed = [1, "hello", true, null];
```

**関連項目：** 完全なメソッドリファレンスは[配列API](#reference-array-api)

---

### オブジェクト型

**型：** `object`

**説明：** 動的フィールドを持つJavaScriptスタイルのオブジェクト

**リテラル構文：** `{ field: value, ... }`

**例：**
```hemlock
let person = { name: "Alice", age: 30 };
print(person.name);  // "Alice"

// フィールドを動的に追加
person.email = "alice@example.com";
```

**型定義：**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: bool,  // オプションフィールド
}

let p: Person = { name: "Bob", age: 25 };
print(typeof(p));  // "Person"
```

---

### ポインタ型

#### 生ポインタ（ptr）

**型：** `ptr`

**説明：** 生メモリアドレス（安全でない）

**サイズ：** 8バイト

**境界チェック：** なし

**例：**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

#### バッファ（buffer）

**型：** `buffer`

**説明：** 境界チェック付きの安全なポインタラッパー

**構造：** ポインタ + 長さ + 容量

**プロパティ：**
- `.length` - バッファサイズ
- `.capacity` - 割り当て容量

**例：**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // 境界チェックあり
print(b.length);        // 64
free(b);
```

**関連項目：** 割り当て関数は[メモリAPI](#reference-memory-api)

---

## 特殊型

### ファイル型

**型：** `file`

**説明：** I/O操作用のファイルハンドル

**プロパティ：**
- `.path` - ファイルパス（string）
- `.mode` - オープンモード（string）
- `.closed` - ファイルがクローズされているか（bool）

**関連項目：** [ファイルAPI](#reference-file-api)

---

### タスク型

**型：** `task`

**説明：** 並行タスクのハンドル

**関連項目：** [並行性API](#reference-concurrency-api)

---

### チャネル型

**型：** `channel`

**説明：** スレッドセーフな通信チャネル

**関連項目：** [並行性API](#reference-concurrency-api)

---

### 関数型

**型：** `function`

**説明：** ファーストクラスの関数値

**例：**
```hemlock
fn add(a, b) {
    return a + b;
}

let multiply = fn(x, y) {
    return x * y;
};

print(typeof(add));      // "function"
print(typeof(multiply)); // "function"
```

---

### Void型

**型：** `void`

**説明：** 戻り値の不在（内部使用）

---

## 型昇格規則

操作で型を混合する場合、Hemlockは「より高い」型に昇格します：

**昇格階層：**
```
f64（最高精度）
 ↑
f32
 ↑
u64
 ↑
i64
 ↑
u32
 ↑
i32
 ↑
u16
 ↑
i16
 ↑
u8
 ↑
i8（最低）
```

**規則：**
1. 浮動小数点は常に整数に勝つ
2. 同じカテゴリ（int/uint/float）内ではより大きいサイズが勝つ
3. 両方のオペランドが結果の型に昇格される
4. **精度保持：** i64/u64 + f32はf64に昇格（f32ではない）

**例：**
```hemlock
// サイズ昇格
u8 + i32    → i32    // より大きいサイズが勝つ
i32 + i64   → i64    // より大きいサイズが勝つ
u32 + u64   → u64    // より大きいサイズが勝つ

// 浮動小数点昇格
i32 + f32   → f32    // 浮動小数点が勝つ、f32はi32に十分
i64 + f32   → f64    // i64の精度を保持するためf64に昇格
i64 + f64   → f64    // 浮動小数点は常に勝つ
i8 + f64    → f64    // 浮動小数点 + 最大が勝つ
```

**なぜi64 + f32 → f64なのか？**

f32は24ビットの仮数しかなく、2^24（16,777,216）より大きい整数を正確に表現できません。i64は2^63までの値を保持できるため、i64とf32を混合すると深刻な精度損失が発生します。Hemlockは代わりにf64（53ビット仮数）に昇格します。

---

## 範囲チェック

型注釈は代入時に範囲チェックを強制します：

**有効な代入：**
```hemlock
let x: u8 = 255;             // OK
let y: i8 = 127;             // OK
let a: i64 = 2147483647;     // OK
let b: u64 = 4294967295;     // OK
```

**無効な代入（実行時エラー）：**
```hemlock
let x: u8 = 256;             // エラー：範囲外
let y: i8 = 128;             // エラー：最大は127
let z: u64 = -1;             // エラー：u64は負にできない
```

---

## 型イントロスペクション

### typeof(value)

値の型名を文字列として返します。

**シグネチャ：**
```hemlock
typeof(value: any): string
```

**戻り値：**
- プリミティブ型：`"i8"`、`"i16"`、`"i32"`、`"i64"`、`"u8"`、`"u16"`、`"u32"`、`"u64"`、`"f32"`、`"f64"`、`"bool"`、`"string"`、`"rune"`、`"null"`
- 複合型：`"array"`、`"object"`、`"ptr"`、`"buffer"`、`"function"`
- 特殊型：`"file"`、`"task"`、`"channel"`
- 型付きオブジェクト：カスタム型名（例：`"Person"`）

**例：**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"
```

**関連項目：** [組み込み関数](builtins.md#typeof)

---

## 型変換

### 暗黙的変換

Hemlockは型昇格規則に従って算術操作で暗黙的な型変換を行います。

**例：**
```hemlock
let a: u8 = 10;
let b: i32 = 20;
let result = a + b;     // resultはi32（昇格される）
```

### 明示的変換

明示的な変換には型注釈を使用します：

**例：**
```hemlock
// 整数から浮動小数点
let i: i32 = 42;
let f: f64 = i;         // 42.0

// 浮動小数点から整数（切り詰め）
let x: f64 = 3.14;
let y: i32 = x;         // 3

// 整数からrune
let code: rune = 65;    // 'A'

// runeから整数
let value: i32 = 'Z';   // 90

// runeから文字列
let s: string = 'H';    // "H"
```

---

## 型エイリアス

### 組み込みエイリアス

Hemlockは一般的な型の組み込み型エイリアスを提供します：

| エイリアス | 実際の型 | 用途 |
|-----------|-------------|--------------------------|
| `integer` | `i32`       | 汎用整数 |
| `number`  | `f64`       | 汎用浮動小数点 |
| `byte`    | `u8`        | バイト値 |

**例：**
```hemlock
let count: integer = 100;       // i32と同じ
let price: number = 19.99;      // f64と同じ
let b: byte = 255;              // u8と同じ
```

### カスタム型エイリアス

`type`キーワードを使用してカスタム型エイリアスを定義：

```hemlock
// シンプルなエイリアス
type Integer = i32;
type Text = string;

// 関数型エイリアス
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

// 複合型エイリアス
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// ジェネリック型エイリアス
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
```

**カスタムエイリアスの使用：**
```hemlock
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**注意：** 型エイリアスは透過的です - `typeof()`は基礎となる型名を返します。

---

## 関数型

関数型は関数値のシグネチャを指定します：

### 構文

```hemlock
fn(param_types): return_type
```

### 例

```hemlock
// 基本的な関数型
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// 関数パラメータ
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// 関数を返す高階関数
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// 非同期関数型
fn run_async(handler: async fn(): void) {
    spawn(handler);
}
```

---

## 複合型（交差型）

複合型は`&`を使用して複数の型制約を要求します：

```hemlock
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// オブジェクトはすべての型を満たす必要がある
let person: HasName & HasAge = { name: "Alice", age: 30 };

// 3つ以上の型
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

---

## 要約表

| 型 | サイズ | 可変 | ヒープ割り当て | 説明 |
|------------|----------|---------|----------------|--------------------------------|
| `i8`-`i64` | 1-8バイト | いいえ | いいえ | 符号付き整数 |
| `u8`-`u64` | 1-8バイト | いいえ | いいえ | 符号なし整数 |
| `f32`      | 4バイト | いいえ | いいえ | 単精度浮動小数点 |
| `f64`      | 8バイト | いいえ | いいえ | 倍精度浮動小数点 |
| `bool`     | 1バイト | いいえ | いいえ | ブーリアン |
| `rune`     | 4バイト | いいえ | いいえ | Unicodeコードポイント |
| `string`   | 可変 | はい | はい | UTF-8テキスト |
| `array`    | 可変 | はい | はい | 動的配列 |
| `object`   | 可変 | はい | はい | 動的オブジェクト |
| `ptr`      | 8バイト | いいえ | いいえ | 生ポインタ |
| `buffer`   | 可変 | はい | はい | 安全なポインタラッパー |
| `file`     | 不透明 | はい | はい | ファイルハンドル |
| `task`     | 不透明 | いいえ | はい | 並行タスクハンドル |
| `channel`  | 不透明 | はい | はい | スレッドセーフチャネル |
| `function` | 不透明 | いいえ | はい | 関数値 |
| `null`     | 8バイト | いいえ | いいえ | Null値 |

---

## 関連項目

- [演算子リファレンス](#reference-operators) - 操作での型の動作
- [組み込み関数](#reference-builtins) - 型イントロスペクションと変換
- [文字列API](#reference-string-api) - 文字列型メソッド
- [配列API](#reference-array-api) - 配列型メソッド
- [メモリAPI](#reference-memory-api) - ポインタとバッファ操作


--------------------------------------------------------------------------------
## 文字列API
--------------------------------------------------------------------------------

# 文字列APIリファレンス

Hemlockの文字列型と全19個の文字列メソッドの完全なリファレンスです。

---

## 概要

Hemlockの文字列は**UTF-8エンコード、可変、ヒープ割り当て**されるシーケンスであり、完全なUnicodeサポートを提供します。すべての操作は**コードポイント**（文字）で動作し、バイトではありません。

**主な機能：**
- UTF-8エンコーディング（U+0000からU+10FFFF）
- 可変（文字をその場で変更可能）
- コードポイントベースのインデックス
- 19個の組み込みメソッド
- `+`演算子での自動連結

---

## 文字列型

**型：** `string`

**プロパティ：**
- `.length` - コードポイント数（文字数）
- `.byte_length` - UTF-8バイト数

**リテラル構文：** ダブルクォート `"text"`

**例：**
```hemlock
let s = "hello";
print(s.length);        // 5（コードポイント）
print(s.byte_length);   // 5（バイト）

let emoji = "🚀";
print(emoji.length);        // 1（1つのコードポイント）
print(emoji.byte_length);   // 4（4つのUTF-8バイト）
```

---

## インデックス

文字列は`[]`を使用したコードポイントベースのインデックスをサポートします：

**読み取りアクセス：**
```hemlock
let s = "hello";
let ch = s[0];          // rune 'h'を返す
```

**書き込みアクセス：**
```hemlock
let s = "hello";
s[0] = 'H';             // runeで変更（"Hello"になる）
```

**UTF-8の例：**
```hemlock
let text = "Hi🚀!";
print(text[0]);         // 'H'
print(text[1]);         // 'i'
print(text[2]);         // '🚀'（1つのコードポイント）
print(text[3]);         // '!'
```

---

## 連結

`+`演算子を使用して文字列とruneを連結します：

**文字列 + 文字列：**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"
```

**文字列 + Rune：**
```hemlock
let greeting = "Hello" + '!';      // "Hello!"
let decorated = "Text" + '✓';      // "Text✓"
```

**Rune + 文字列：**
```hemlock
let prefix = '>' + " Message";     // "> Message"
let bullet = '•' + " Item";        // "• Item"
```

**複数の連結：**
```hemlock
let msg = "Hi " + '👋' + " World " + '🌍';  // "Hi 👋 World 🌍"
```

---

## 文字列プロパティ

### .length

Unicodeコードポイント（文字）の数を取得します。

**型：** `i32`

**例：**
```hemlock
let s = "hello";
print(s.length);        // 5

let emoji = "🚀";
print(emoji.length);    // 1（1つのコードポイント）

let text = "Hello 🌍!";
print(text.length);     // 8（7 ASCII + 1絵文字）
```

---

### .byte_length

UTF-8バイト数を取得します。

**型：** `i32`

**例：**
```hemlock
let s = "hello";
print(s.byte_length);   // 5（ASCII文字1つにつき1バイト）

let emoji = "🚀";
print(emoji.byte_length); // 4（絵文字は4 UTF-8バイト）

let text = "Hello 🌍!";
print(text.byte_length);  // 11（7 ASCII + 絵文字4）
```

---

## 文字列メソッド

### 部分文字列とスライス

#### substr

位置と長さで部分文字列を抽出します。

**シグネチャ：**
```hemlock
string.substr(start: i32, length: i32): string
```

**パラメータ：**
- `start` - 開始コードポイントインデックス（0ベース）
- `length` - 抽出するコードポイント数

**戻り値：** 新しい文字列

**例：**
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world"
let first = s.substr(0, 5);     // "hello"

// UTF-8の例
let text = "Hi🚀!";
let emoji = text.substr(2, 1);  // "🚀"
```

---

#### slice

範囲で部分文字列を抽出します（終了は含まない）。

**シグネチャ：**
```hemlock
string.slice(start: i32, end: i32): string
```

**パラメータ：**
- `start` - 開始コードポイントインデックス（0ベース）
- `end` - 終了コードポイントインデックス（含まない）

**戻り値：** 新しい文字列

**例：**
```hemlock
let s = "hello world";
let sub = s.slice(0, 5);        // "hello"
let world = s.slice(6, 11);     // "world"

// UTF-8の例
let text = "Hi🚀!";
let first_three = text.slice(0, 3);  // "Hi🚀"
```

---

### 検索と検出

#### find

部分文字列の最初の出現位置を見つけます。

**シグネチャ：**
```hemlock
string.find(needle: string): i32
```

**パラメータ：**
- `needle` - 検索する部分文字列

**戻り値：** 最初の出現のコードポイントインデックス、見つからない場合は`-1`

**例：**
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6
let pos2 = s.find("foo");       // -1（見つからない）
let pos3 = s.find("l");         // 2（最初の'l'）
```

---

#### contains

文字列が部分文字列を含むかチェックします。

**シグネチャ：**
```hemlock
string.contains(needle: string): bool
```

**パラメータ：**
- `needle` - 検索する部分文字列

**戻り値：** 見つかった場合は`true`、それ以外は`false`

**例：**
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

---

### 分割と結合

#### split

区切り文字で文字列を配列に分割します。

**シグネチャ：**
```hemlock
string.split(delimiter: string): array
```

**パラメータ：**
- `delimiter` - 分割する文字列

**戻り値：** 文字列の配列

**例：**
```hemlock
let csv = "a,b,c";
let parts = csv.split(",");     // ["a", "b", "c"]

let path = "/usr/local/bin";
let dirs = path.split("/");     // ["", "usr", "local", "bin"]

let text = "hello world foo";
let words = text.split(" ");    // ["hello", "world", "foo"]
```

---

#### trim

先頭と末尾の空白を削除します。

**シグネチャ：**
```hemlock
string.trim(): string
```

**戻り値：** 空白が削除された新しい文字列

**例：**
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let text = "\n\t  world  \n";
let clean2 = text.trim();       // "world"
```

---

### 大文字小文字変換

#### to_upper

文字列を大文字に変換します。

**シグネチャ：**
```hemlock
string.to_upper(): string
```

**戻り値：** 大文字の新しい文字列

**例：**
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

let mixed = "HeLLo";
let upper2 = mixed.to_upper();  // "HELLO"
```

---

#### to_lower

文字列を小文字に変換します。

**シグネチャ：**
```hemlock
string.to_lower(): string
```

**戻り値：** 小文字の新しい文字列

**例：**
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"

let mixed = "HeLLo";
let lower2 = mixed.to_lower();  // "hello"
```

---

### 接頭辞と接尾辞

#### starts_with

文字列が接頭辞で始まるかチェックします。

**シグネチャ：**
```hemlock
string.starts_with(prefix: string): bool
```

**パラメータ：**
- `prefix` - チェックする接頭辞

**戻り値：** 文字列が接頭辞で始まる場合は`true`、それ以外は`false`

**例：**
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

---

#### ends_with

文字列が接尾辞で終わるかチェックします。

**シグネチャ：**
```hemlock
string.ends_with(suffix: string): bool
```

**パラメータ：**
- `suffix` - チェックする接尾辞

**戻り値：** 文字列が接尾辞で終わる場合は`true`、それ以外は`false`

**例：**
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

---

### 置換

#### replace

部分文字列の最初の出現を置換します。

**シグネチャ：**
```hemlock
string.replace(old: string, new: string): string
```

**パラメータ：**
- `old` - 置換する部分文字列
- `new` - 置換文字列

**戻り値：** 最初の出現が置換された新しい文字列

**例：**
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");  // "hello there"

let text = "foo foo foo";
let text2 = text.replace("foo", "bar"); // "bar foo foo"（最初のみ）
```

---

#### replace_all

部分文字列のすべての出現を置換します。

**シグネチャ：**
```hemlock
string.replace_all(old: string, new: string): string
```

**パラメータ：**
- `old` - 置換する部分文字列
- `new` - 置換文字列

**戻り値：** すべての出現が置換された新しい文字列

**例：**
```hemlock
let text = "foo foo foo";
let text2 = text.replace_all("foo", "bar"); // "bar bar bar"

let s = "hello world hello";
let s2 = s.replace_all("hello", "hi");      // "hi world hi"
```

---

### 繰り返し

#### repeat

文字列をn回繰り返します。

**シグネチャ：**
```hemlock
string.repeat(count: i32): string
```

**パラメータ：**
- `count` - 繰り返し回数

**戻り値：** count回繰り返された新しい文字列

**例：**
```hemlock
let s = "ha";
let repeated = s.repeat(3);     // "hahaha"

let line = "-";
let separator = line.repeat(40); // "----------------------------------------"
```

---

### 文字アクセス

#### char_at

インデックスのUnicodeコードポイントを取得します。

**シグネチャ：**
```hemlock
string.char_at(index: i32): rune
```

**パラメータ：**
- `index` - コードポイントインデックス（0ベース）

**戻り値：** Rune（Unicodeコードポイント）

**例：**
```hemlock
let s = "hello";
let ch = s.char_at(0);          // 'h'
let ch2 = s.char_at(1);         // 'e'

// UTF-8の例
let emoji = "🚀";
let ch3 = emoji.char_at(0);     // U+1F680（ロケット）
```

---

#### chars

文字列をruneの配列に変換します。

**シグネチャ：**
```hemlock
string.chars(): array
```

**戻り値：** runeの配列（コードポイント）

**例：**
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']

// UTF-8の例
let text = "Hi🚀!";
let chars2 = text.chars();      // ['H', 'i', '🚀', '!']
```

---

### バイトアクセス

#### byte_at

インデックスのバイト値を取得します。

**シグネチャ：**
```hemlock
string.byte_at(index: i32): u8
```

**パラメータ：**
- `index` - バイトインデックス（0ベース、コードポイントインデックスではない）

**戻り値：** バイト値（u8）

**例：**
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104（ASCII 'h'）
let byte2 = s.byte_at(1);       // 101（ASCII 'e'）

// UTF-8の例
let emoji = "🚀";
let byte3 = emoji.byte_at(0);   // 240（最初のUTF-8バイト）
```

---

#### bytes

文字列をバイトの配列に変換します。

**シグネチャ：**
```hemlock
string.bytes(): array
```

**戻り値：** u8バイトの配列

**例：**
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111]

// UTF-8の例
let emoji = "🚀";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128]（4 UTF-8バイト）
```

---

#### to_bytes

文字列をバッファに変換します。

**シグネチャ：**
```hemlock
string.to_bytes(): buffer
```

**戻り値：** UTF-8バイトを含むバッファ

**例：**
```hemlock
let s = "hello";
let buf = s.to_bytes();
print(buf.length);              // 5

// UTF-8の例
let emoji = "🚀";
let buf2 = emoji.to_bytes();
print(buf2.length);             // 4
```

**注意：** これはレガシーメソッドです。ほとんどの場合は`.bytes()`を使用してください。

---

### JSONデシリアライズ

#### deserialize

JSON文字列を値にパースします。

**シグネチャ：**
```hemlock
string.deserialize(): any
```

**戻り値：** パースされた値（オブジェクト、配列、数値、文字列、bool、またはnull）

**例：**
```hemlock
let json = '{"x":10,"y":20}';
let obj = json.deserialize();
print(obj.x);                   // 10
print(obj.y);                   // 20

let arr_json = '[1,2,3]';
let arr = arr_json.deserialize();
print(arr[0]);                  // 1

let num_json = '42';
let num = num_json.deserialize();
print(num);                     // 42
```

**サポートされる型：**
- オブジェクト：`{"key": value}`
- 配列：`[1, 2, 3]`
- 数値：`42`、`3.14`
- 文字列：`"text"`
- ブーリアン：`true`、`false`
- Null：`null`

**関連項目：** オブジェクトの`.serialize()`メソッド

---

## メソッドチェーン

文字列メソッドは簡潔な操作のためにチェーンできます：

**例：**
```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ");                  // "foo | bar | baz"

let cleaned = "  HELLO  "
    .trim()
    .to_lower();                   // "hello"
```

---

## 完全なメソッド要約

| メソッド | シグネチャ | 戻り値 | 説明 |
|----------------|----------------------------------------------|-----------|---------------------------------------|
| `substr`       | `(start: i32, length: i32)`                  | `string`  | 位置/長さで部分文字列を抽出 |
| `slice`        | `(start: i32, end: i32)`                     | `string`  | 範囲で部分文字列を抽出 |
| `find`         | `(needle: string)`                           | `i32`     | 最初の出現を見つける（見つからない場合-1）|
| `contains`     | `(needle: string)`                           | `bool`    | 部分文字列を含むかチェック |
| `split`        | `(delimiter: string)`                        | `array`   | 配列に分割 |
| `trim`         | `()`                                         | `string`  | 空白を削除 |
| `to_upper`     | `()`                                         | `string`  | 大文字に変換 |
| `to_lower`     | `()`                                         | `string`  | 小文字に変換 |
| `starts_with`  | `(prefix: string)`                           | `bool`    | 接頭辞で始まるかチェック |
| `ends_with`    | `(suffix: string)`                           | `bool`    | 接尾辞で終わるかチェック |
| `replace`      | `(old: string, new: string)`                 | `string`  | 最初の出現を置換 |
| `replace_all`  | `(old: string, new: string)`                 | `string`  | すべての出現を置換 |
| `repeat`       | `(count: i32)`                               | `string`  | 文字列をn回繰り返す |
| `char_at`      | `(index: i32)`                               | `rune`    | インデックスのコードポイントを取得 |
| `byte_at`      | `(index: i32)`                               | `u8`      | インデックスのバイトを取得 |
| `chars`        | `()`                                         | `array`   | runeの配列に変換 |
| `bytes`        | `()`                                         | `array`   | バイトの配列に変換 |
| `to_bytes`     | `()`                                         | `buffer`  | バッファに変換（レガシー） |
| `deserialize`  | `()`                                         | `any`     | JSON文字列をパース |

---

## 関連項目

- [型システム](#reference-type-system) - 文字列型の詳細
- [配列API](#reference-array-api) - split()結果の配列メソッド
- [演算子](#reference-operators) - 文字列連結演算子


--------------------------------------------------------------------------------
## 演算子
--------------------------------------------------------------------------------

# 演算子リファレンス

Hemlockのすべての演算子の完全なリファレンスです。優先順位、結合性、動作を含みます。

---

## 概要

HemlockはCスタイルの演算子と明示的な優先順位規則を提供します。すべての演算子は厳密な型付け規則に従い、適用可能な場合は自動型昇格が行われます。

---

## 算術演算子

### 二項算術

| 演算子 | 名前 | 例 | 説明 |
|----------|----------------|------------|------------------------------|
| `+`      | 加算 | `a + b`    | 2つの値を加算 |
| `-`      | 減算 | `a - b`    | aからbを減算 |
| `*`      | 乗算 | `a * b`    | 2つの値を乗算 |
| `/`      | 除算 | `a / b`    | aをbで除算 |

**型昇格：**
結果は型昇格規則に従います（[型システム](type-system.md#型昇格規則)を参照）。

**例：**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// 浮動小数点除算
let e = 10.0 / 3.0;    // 3.333... (f64)

// 混合型
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, 昇格される)
```

**ゼロ除算：**
- 整数のゼロ除算：実行時エラー
- 浮動小数点のゼロ除算：`inf`または`-inf`を返す

---

### 単項算術

| 演算子 | 名前 | 例 | 説明 |
|----------|----------|---------|----------------------|
| `-`      | 否定 | `-a`    | 値を否定 |
| `+`      | プラス | `+a`    | 恒等（何もしない） |

**例：**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5（変更なし）

let x = -3.14;         // -3.14
```

---

## 比較演算子

| 演算子 | 名前 | 例 | 戻り値 |
|----------|-----------------------|------------|---------|
| `==`     | 等しい | `a == b`   | `bool`  |
| `!=`     | 等しくない | `a != b`   | `bool`  |
| `<`      | より小さい | `a < b`    | `bool`  |
| `>`      | より大きい | `a > b`    | `bool`  |
| `<=`     | 以下 | `a <= b`   | `bool`  |
| `>=`     | 以上 | `a >= b`   | `bool`  |

**型昇格：**
比較前にオペランドが昇格されます。

**例：**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// 文字列比較
print("hello" == "hello");  // true
print("abc" < "def");       // true（辞書順）

// 混合型
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true（i32に昇格）
```

---

## 論理演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|-------------|--------------|--------------------------|
| `&&`     | 論理AND | `a && b`     | 両方がtrueならtrue |
| `\|\|`   | 論理OR | `a \|\| b`   | どちらかがtrueならtrue |
| `!`      | 論理NOT | `!a`         | ブーリアンを否定 |

**短絡評価：**
- `&&` - 最初のfalse値で停止
- `||` - 最初のtrue値で停止

**例：**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// 短絡
if (x != 0 && (10 / x) > 2) {
    print("safe");
}

if (x == 0 || (10 / x) > 2) {
    print("safe");
}
```

---

## ビット演算子

**制限：** 整数型のみ（i8-i64、u8-u64）

### 二項ビット演算

| 演算子 | 名前 | 例 | 説明 |
|----------|--------------|------------|--------------------------|
| `&`      | ビットAND | `a & b`    | 各ビットをAND |
| `\|`     | ビットOR | `a \| b`   | 各ビットをOR |
| `^`      | ビットXOR | `a ^ b`    | 各ビットをXOR |
| `<<`     | 左シフト | `a << b`   | bビット左にシフト |
| `>>`     | 右シフト | `a >> b`   | bビット右にシフト |

**型保持：**
結果の型はオペランドの型に一致（型昇格あり）。

**例：**
```hemlock
let a = 12;  // 2進数で1100
let b = 10;  // 2進数で1010

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**符号なしの例：**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**右シフトの動作：**
- 符号付き型：算術シフト（符号拡張）
- 符号なし型：論理シフト（ゼロ埋め）

---

### 単項ビット演算

| 演算子 | 名前 | 例 | 説明 |
|----------|-------------|---------|--------------------------|
| `~`      | ビットNOT | `~a`    | すべてのビットを反転 |

**例：**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13（2の補数）

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## 文字列演算子

### 連結

| 演算子 | 名前 | 例 | 説明 |
|----------|----------------|------------|--------------------|
| `+`      | 連結 | `a + b`    | 文字列を結合 |

**例：**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"

// 文字列 + rune
let greeting = "Hello" + '!';      // "Hello!"

// rune + 文字列
let prefix = '>' + " Message";     // "> Message"
```

---

## 代入演算子

### 基本代入

| 演算子 | 名前 | 例 | 説明 |
|----------|------------|------------|--------------------------|
| `=`      | 代入 | `a = b`    | 変数に値を代入 |

**例：**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### 複合代入

#### 算術複合代入

| 演算子 | 名前 | 例 | 等価 |
|----------|-----------------|------------|--------------------|
| `+=`     | 加算代入 | `a += b`   | `a = a + b`        |
| `-=`     | 減算代入 | `a -= b`   | `a = a - b`        |
| `*=`     | 乗算代入 | `a *= b`   | `a = a * b`        |
| `/=`     | 除算代入 | `a /= b`   | `a = a / b`        |
| `%=`     | 剰余代入 | `a %= b`   | `a = a % b`        |

**例：**
```hemlock
let x = 10;
x += 5;      // xは15になる
x -= 3;      // xは12になる
x *= 2;      // xは24になる
x /= 4;      // xは6になる

let count = 0;
count += 1;  // 1ずつインクリメント
```

#### ビット複合代入

| 演算子 | 名前 | 例 | 等価 |
|----------|--------------------|-------------|---------------------|
| `&=`     | ビットAND代入 | `a &= b`    | `a = a & b`         |
| `\|=`    | ビットOR代入 | `a \|= b`   | `a = a \| b`        |
| `^=`     | ビットXOR代入 | `a ^= b`    | `a = a ^ b`         |
| `<<=`    | 左シフト代入 | `a <<= b`   | `a = a << b`        |
| `>>=`    | 右シフト代入 | `a >>= b`   | `a = a >> b`        |

**例：**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flagsは0b0011になる（上位ビットをマスク）
flags |= 0b1000;   // flagsは0b1011になる（ビットをセット）
flags ^= 0b0001;   // flagsは0b1010になる（ビットをトグル）

let x = 1;
x <<= 4;           // xは16になる（4ビット左シフト）
x >>= 2;           // xは4になる（2ビット右シフト）
```

### インクリメント/デクリメント

| 演算子 | 名前 | 例 | 説明 |
|----------|------------|---------|--------------------------|
| `++`     | インクリメント | `a++`   | 1ずつインクリメント（後置） |
| `--`     | デクリメント | `a--`   | 1ずつデクリメント（後置） |

**例：**
```hemlock
let i = 0;
i++;         // iは1になる
i++;         // iは2になる
i--;         // iは1になる

// ループでよく使用
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**注意：** `++`と`--`は両方とも後置演算子です（値はインクリメント/デクリメント前に返される）

---

## Null安全演算子

### Null合体（`??`）

左オペランドがnullでなければそれを返し、そうでなければ右オペランドを返します。

| 演算子 | 名前 | 例 | 説明 |
|----------|------------------|--------------|--------------------------------|
| `??`     | Null合体 | `a ?? b`     | aがnullでなければa、そうでなければb |

**例：**
```hemlock
let name = null;
let display = name ?? "Anonymous";  // "Anonymous"

let value = 42;
let result = value ?? 0;            // 42

// チェーン
let a = null;
let b = null;
let c = "found";
let result2 = a ?? b ?? c;          // "found"

// 関数呼び出しとともに
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### オプショナルチェーン（`?.`）

潜在的にnullの値のプロパティやメソッドに安全にアクセスします。

| 演算子 | 名前 | 例 | 説明 |
|----------|-------------------|----------------|----------------------------------|
| `?.`     | オプショナルチェーン | `a?.b`         | aがnullでなければa.b、そうでなければnull |
| `?.[`    | オプショナルインデックス | `a?.[0]`       | aがnullでなければa[0]、そうでなければnull |
| `?.(`    | オプショナル呼び出し | `a?.()`        | aがnullでなければa()を呼び出し、そうでなければnull |

**例：**
```hemlock
let user = null;
let name = user?.name;              // null（エラーなし）

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null（安全なナビゲーション）

// 配列とともに
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// メソッド呼び出しとともに
let obj = { greet: fn() { return "Hello"; } };
let greeting = obj?.greet?.();      // "Hello"

let empty = null;
let result = empty?.method?.();     // null
```

**動作：**
- 左オペランドがnullの場合、式全体がnullに短絡
- 左オペランドがnullでない場合、通常通りアクセス
- 深いプロパティアクセスのためにチェーン可能

---

## メンバーアクセス演算子

### ドット演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|------------------|--------------|-----------------------|
| `.`      | メンバーアクセス | `obj.field`  | オブジェクトフィールドにアクセス |
| `.`      | プロパティアクセス | `arr.length` | プロパティにアクセス |

**例：**
```hemlock
// オブジェクトフィールドアクセス
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// 配列プロパティ
let arr = [1, 2, 3];
print(arr.length);         // 3

// 文字列プロパティ
let s = "hello";
print(s.length);           // 5

// メソッド呼び出し
let result = s.to_upper(); // "HELLO"
```

---

### インデックス演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|---------|-----------|----------------------|
| `[]`     | インデックス | `arr[i]`  | 要素にアクセス |

**例：**
```hemlock
// 配列インデックス
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// 文字列インデックス（runeを返す）
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// バッファインデックス
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## 関数呼び出し演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|---------------|--------------|--------------------|
| `()`     | 関数呼び出し | `f(a, b)`    | 関数を呼び出し |

**例：**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// メソッド呼び出し
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// ビルトイン呼び出し
print("message");
```

---

## 演算子優先順位

演算子は高い優先順位から低い優先順位の順にリストされています：

| 優先順位 | 演算子 | 説明 | 結合性 |
|------------|----------------------------|--------------------------------|---------------|
| 1          | `()` `[]` `.` `?.`         | 呼び出し、インデックス、メンバーアクセス、オプショナルチェーン | 左から右 |
| 2          | `++` `--`                  | 後置インクリメント/デクリメント | 左から右 |
| 3          | `!` `~` `-`（単項）`+`（単項） | 論理NOT、ビットNOT、否定 | 右から左 |
| 4          | `*` `/` `%`                | 乗算、除算、剰余 | 左から右 |
| 5          | `+` `-`                    | 加算、減算 | 左から右 |
| 6          | `<<` `>>`                  | ビットシフト | 左から右 |
| 7          | `<` `<=` `>` `>=`          | 関係 | 左から右 |
| 8          | `==` `!=`                  | 等価 | 左から右 |
| 9          | `&`                        | ビットAND | 左から右 |
| 10         | `^`                        | ビットXOR | 左から右 |
| 11         | `\|`                       | ビットOR | 左から右 |
| 12         | `&&`                       | 論理AND | 左から右 |
| 13         | `\|\|`                     | 論理OR | 左から右 |
| 14         | `??`                       | Null合体 | 左から右 |
| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | 代入 | 右から左 |

---

## 優先順位の例

### 例1：算術と比較
```hemlock
let result = 5 + 3 * 2;
// 評価：5 + (3 * 2) = 11
// 乗算は加算より優先順位が高い

let cmp = 10 > 5 + 3;
// 評価：10 > (5 + 3) = true
// 加算は比較より優先順位が高い
```

### 例2：ビット演算子
```hemlock
let result1 = 12 | 10 & 8;
// 評価：12 | (10 & 8) = 12 | 8 = 12
// &は|より優先順位が高い

let result2 = 8 | 1 << 2;
// 評価：8 | (1 << 2) = 8 | 4 = 12
// シフトはビットORより優先順位が高い

// 明確にするために括弧を使用
let result3 = (5 & 3) | (2 << 1);
// 評価：1 | 4 = 5
```

### 例3：論理演算子
```hemlock
let result = true || false && false;
// 評価：true || (false && false) = true
// &&は||より優先順位が高い

let cmp = 5 < 10 && 10 < 20;
// 評価：(5 < 10) && (10 < 20) = true
// 比較は&&より優先順位が高い
```

### 例4：括弧の使用
```hemlock
// 括弧なし
let a = 2 + 3 * 4;        // 14

// 括弧あり
let b = (2 + 3) * 4;      // 20

// 複雑な式
let c = (a + b) * (a - b);
```

---

## 型固有の演算子動作

### 除算（常にFloat）

`/`演算子はオペランドの型に関係なく**常にfloat**（f64）を返します：

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

これは予期しない整数切り詰めの一般的なバグを防ぎます。

### フロア除算（div / divi）

フロア除算（他の言語の整数除算のような）には、`div()`と`divi()`関数を使用します：

```hemlock
// div(a, b) - floatを返すフロア除算
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- -無限大に向かって切り捨て

// divi(a, b) - 整数を返すフロア除算
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**整数を返す数学関数：**
整数を返す他の丸め操作：

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// 配列インデックスとして直接使用可能
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20（インデックス1）
```

### 文字列比較

文字列は辞書順で比較されます：

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Null比較

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### 型エラー

互換性のない型間の一部の操作は許可されません：

```hemlock
// エラー：floatにビット演算子は使用不可
let x = 3.14 & 2.71;

// エラー：文字列にビット演算子は使用不可
let y = "hello" & "world";

// OK：算術の型昇格
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32（昇格される）
```

---

## 関連項目

- [型システム](#reference-type-system) - 型昇格と変換規則
- [組み込み関数](#reference-builtins) - 組み込み操作
- [文字列API](#reference-string-api) - 文字列連結とメソッド


--------------------------------------------------------------------------------
## 組み込み関数
--------------------------------------------------------------------------------

# 組み込み関数リファレンス

Hemlockのすべての組み込み関数と定数の完全なリファレンスです。

---

## 概要

Hemlockは、I/O、型イントロスペクション、メモリ管理、並行処理、システムインタラクションのための組み込み関数セットを提供します。すべての組み込み関数はインポートなしでグローバルに利用可能です。

---

## I/O関数

### print

改行付きで値を標準出力に出力します。

**シグネチャ:**
```hemlock
print(...values): null
```

**パラメータ:**
- `...values` - 出力する任意の数の値

**戻り値:** `null`

**例:**
```hemlock
print("Hello, World!");
print(42);
print(3.14);
print(true);
print([1, 2, 3]);
print({ x: 10, y: 20 });

// 複数の値
print("x =", 10, "y =", 20);
```

**動作:**
- すべての値を文字列に変換
- 複数の値をスペースで区切る
- 末尾に改行を追加
- 標準出力をフラッシュ

---

### read_line

標準入力から1行のテキストを読み取ります（ユーザー入力）。

**シグネチャ:**
```hemlock
read_line(): string | null
```

**パラメータ:** なし

**戻り値:**
- `string` - 標準入力から読み取った行（改行は除去済み）
- `null` - EOF（ファイル/入力の終端）の場合

**例:**
```hemlock
// シンプルなプロンプト
print("What is your name?");
let name = read_line();
print("Hello, " + name + "!");

// 数値の読み取り（手動パースが必要）
print("Enter a number:");
let input = read_line();
let num = parse_int(input);  // parse_intについては以下を参照
print("Double:", num * 2);

// EOFの処理
let line = read_line();
if (line == null) {
    print("End of input");
}

// 複数行の読み取り
print("Enter lines (Ctrl+D to stop):");
while (true) {
    let line = read_line();
    if (line == null) {
        break;
    }
    print("You said:", line);
}
```

**動作:**
- ユーザーがEnterを押すまでブロック
- 末尾の改行（`\n`）とキャリッジリターン（`\r`）を除去
- EOF時に`null`を返す（Unixでは Ctrl+D、Windowsでは Ctrl+Z）
- 標準入力からのみ読み取り（ファイルからは読み取らない）

**ユーザー入力のパース:**

`read_line()`は常に文字列を返すため、数値入力は手動でパースする必要があります:

```hemlock
// シンプルな整数パーサー
fn parse_int(s: string): i32 {
    let result: i32 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// 使用例
print("Enter your age:");
let age = parse_int(read_line());
print("In 10 years you'll be", age + 10);
```

**関連項目:** ファイルからの読み取りについては[ファイルAPI](#reference-file-api)を参照

---

### eprint

改行付きで値を標準エラー出力に出力します。

**シグネチャ:**
```hemlock
eprint(value: any): null
```

**パラメータ:**
- `value` - 標準エラー出力に出力する単一の値

**戻り値:** `null`

**例:**
```hemlock
eprint("Error: file not found");
eprint(404);
eprint("Warning: " + message);

// 典型的なエラー処理パターン
fn load_config(path: string) {
    if (!exists(path)) {
        eprint("Error: config file not found: " + path);
        return null;
    }
    // ...
}
```

**動作:**
- 標準エラー出力（stderr）に出力
- 末尾に改行を追加
- 引数は1つのみ受け付け（`print`とは異なる）
- 通常の出力と混ざるべきでないエラーメッセージに有用

**printとの違い:**
- `print()` → stdout（通常出力、`>`でリダイレクト可能）
- `eprint()` → stderr（エラー出力、`2>`でリダイレクト可能）

```bash
# シェルの例: stdoutとstderrを分離
./hemlock script.hml > output.txt 2> errors.txt
```

---

## 型イントロスペクション

### typeof

値の型名を取得します。

**シグネチャ:**
```hemlock
typeof(value: any): string
```

**パラメータ:**
- `value` - 任意の値

**戻り値:** 型名を文字列として返す

**例:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof(null));            // "null"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

// 型付きオブジェクト
define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"

// その他の型
print(typeof(alloc(10)));       // "ptr"
print(typeof(buffer(10)));      // "buffer"
print(typeof(open("file.txt"))); // "file"
```

**型名:**
- プリミティブ: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- 複合型: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- 特殊型: `"file"`, `"task"`, `"channel"`
- カスタム型: `define`で定義されたユーザー定義の型名

**関連項目:** [型システム](#reference-type-system)

---

## コマンド実行

### exec

シェルコマンドを実行し、出力をキャプチャします。

**シグネチャ:**
```hemlock
exec(command: string): object
```

**パラメータ:**
- `command` - 実行するシェルコマンド

**戻り値:** 以下のフィールドを持つオブジェクト:
- `output` (string) - コマンドのstdout
- `exit_code` (i32) - 終了ステータスコード（0 = 成功）

**例:**
```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0

// 終了ステータスのチェック
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Found:", r.output);
} else {
    print("Pattern not found");
}

// 複数行の出力を処理
let r2 = exec("ls -la");
let lines = r2.output.split("\n");
```

**動作:**
- `/bin/sh`経由でコマンドを実行
- stdoutのみをキャプチャ（stderrはターミナルに出力）
- コマンドが完了するまでブロック
- 出力がない場合は空文字列を返す

**エラー処理:**
```hemlock
try {
    let r = exec("nonexistent_command");
} catch (e) {
    print("Failed to execute:", e);
}
```

**セキュリティ警告:** シェルインジェクションに脆弱です。ユーザー入力は常に検証/サニタイズしてください。

**制限事項:**
- stderrのキャプチャなし
- ストリーミングなし
- タイムアウトなし
- シグナル処理なし

---

### exec_argv

明示的な引数配列でコマンドを実行します（シェル解釈なし）。

**シグネチャ:**
```hemlock
exec_argv(argv: array): object
```

**パラメータ:**
- `argv` - 文字列の配列: `[command, arg1, arg2, ...]`

**戻り値:** 以下のフィールドを持つオブジェクト:
- `output` (string) - コマンドのstdout
- `exit_code` (i32) - 終了ステータスコード（0 = 成功）

**例:**
```hemlock
// シンプルなコマンド
let result = exec_argv(["ls", "-la"]);
print(result.output);

// スペースを含む引数のコマンド（安全！）
let r = exec_argv(["grep", "hello world", "file.txt"]);

// 引数付きでスクリプトを実行
let r2 = exec_argv(["python", "script.py", "--input", "data.json"]);
print(r2.exit_code);
```

**execとの違い:**
```hemlock
// exec()はシェルを使用 - ユーザー入力では安全でない
exec("ls " + user_input);  // シェルインジェクションのリスク！

// exec_argv()はシェルをバイパス - 安全
exec_argv(["ls", user_input]);  // インジェクション不可能
```

**使用するタイミング:**
- 引数にスペース、引用符、特殊文字が含まれる場合
- ユーザー入力を処理する場合（セキュリティ）
- 予測可能な引数パースが必要な場合

**関連項目:** シンプルなシェルコマンドには`exec()`を使用

---

## エラー処理

### throw

例外をスローします。

**シグネチャ:**
```hemlock
throw expression
```

**パラメータ:**
- `expression` - スローする値（任意の型）

**戻り値:** 戻りません（制御を移譲）

**例:**
```hemlock
throw "error message";
throw 404;
throw { code: 500, message: "Internal error" };
throw null;
```

**関連項目:** try/catch/finally文

---

### panic

エラーメッセージを出力してプログラムを即座に終了します（回復不能）。

**シグネチャ:**
```hemlock
panic(message?: any): never
```

**パラメータ:**
- `message`（省略可能） - 出力するエラーメッセージ

**戻り値:** 戻りません（プログラムが終了）

**例:**
```hemlock
panic();                          // デフォルト: "panic!"
panic("unreachable code reached");
panic(42);

// 一般的な使用例
fn process_state(state: i32): string {
    if (state == 1) { return "ready"; }
    if (state == 2) { return "running"; }
    panic("invalid state: " + typeof(state));
}
```

**動作:**
- stderrにエラーを出力: `panic: <message>`
- 終了コード1で終了
- try/catchで**キャッチ不可能**
- バグや回復不能なエラーに使用

**panicとthrowの違い:**
- `panic()` - 回復不能なエラー、即座に終了
- `throw` - 回復可能なエラー、キャッチ可能

---

### assert

条件が真であることをアサートするか、エラーメッセージで終了します。

**シグネチャ:**
```hemlock
assert(condition: any, message?: string): null
```

**パラメータ:**
- `condition` - 真偽をチェックする値
- `message`（省略可能） - アサーション失敗時のカスタムエラーメッセージ

**戻り値:** `null`（アサーションが成功した場合）

**例:**
```hemlock
// 基本的なアサーション
assert(x > 0);
assert(name != null);
assert(arr.length > 0, "Array must not be empty");

// カスタムメッセージ付き
fn divide(a: i32, b: i32): f64 {
    assert(b != 0, "Division by zero");
    return a / b;
}

// 関数引数の検証
fn process_data(data: array) {
    assert(data != null, "data cannot be null");
    assert(data.length > 0, "data cannot be empty");
    // ...
}
```

**動作:**
- 条件が真の場合: `null`を返し、実行を継続
- 条件が偽の場合: エラーを出力し、終了コード1で終了
- 偽の値: `false`, `0`, `0.0`, `null`, `""`（空文字列）
- 真の値: それ以外すべて

**失敗時の出力:**
```
Assertion failed: Array must not be empty
```

**使用するタイミング:**
- 関数の事前条件の検証
- 開発中の不変条件のチェック
- プログラマーエラーの早期検出

**assertとpanicの違い:**
- `assert(cond, msg)` - 条件をチェックし、偽の場合に失敗
- `panic(msg)` - 無条件で常に失敗

---

## シグナル処理

### signal

シグナルハンドラを登録またはリセットします。

**シグネチャ:**
```hemlock
signal(signum: i32, handler: function | null): function | null
```

**パラメータ:**
- `signum` - シグナル番号（`SIGINT`などの定数を使用）
- `handler` - シグナル受信時に呼び出す関数、またはデフォルトにリセットする場合は`null`

**戻り値:** 以前のハンドラ関数、または`null`

**例:**
```hemlock
fn handle_interrupt(sig) {
    print("Caught SIGINT!");
}

signal(SIGINT, handle_interrupt);

// デフォルトにリセット
signal(SIGINT, null);
```

**ハンドラのシグネチャ:**
```hemlock
fn handler(signum: i32) {
    // signumにはシグナル番号が含まれる
}
```

**関連項目:**
- [シグナル定数](#シグナル定数)
- `raise()`

---

### raise

現在のプロセスにシグナルを送信します。

**シグネチャ:**
```hemlock
raise(signum: i32): null
```

**パラメータ:**
- `signum` - 発生させるシグナル番号

**戻り値:** `null`

**例:**
```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

raise(SIGUSR1);
raise(SIGUSR1);
print(count);  // 2
```

---

## グローバル変数

### args

コマンドライン引数の配列です。

**型:** 文字列の`array`

**構造:**
- `args[0]` - スクリプトのファイル名
- `args[1..n]` - コマンドライン引数

**例:**
```bash
# コマンド: ./hemlock script.hml hello world
```

```hemlock
print(args[0]);        // "script.hml"
print(args.length);    // 3
print(args[1]);        // "hello"
print(args[2]);        // "world"

// 引数を反復処理
let i = 1;
while (i < args.length) {
    print("Argument", i, ":", args[i]);
    i = i + 1;
}
```

**REPLでの動作:** REPLでは、`args.length`は0（空の配列）

---

## シグナル定数

標準POSIXシグナル定数（i32値）:

### 割り込みと終了

| 定数       | 値    | 説明                                   |
|------------|-------|----------------------------------------|
| `SIGINT`   | 2     | キーボードからの割り込み（Ctrl+C）     |
| `SIGTERM`  | 15    | 終了要求                               |
| `SIGQUIT`  | 3     | キーボードからの終了（Ctrl+\）         |
| `SIGHUP`   | 1     | 制御端末でのハングアップ検出           |
| `SIGABRT`  | 6     | 中止シグナル                           |

### ユーザー定義

| 定数       | 値    | 説明                       |
|------------|-------|----------------------------|
| `SIGUSR1`  | 10    | ユーザー定義シグナル1      |
| `SIGUSR2`  | 12    | ユーザー定義シグナル2      |

### プロセス制御

| 定数       | 値    | 説明                            |
|------------|-------|---------------------------------|
| `SIGALRM`  | 14    | アラームクロックタイマー        |
| `SIGCHLD`  | 17    | 子プロセスのステータス変更      |
| `SIGCONT`  | 18    | 停止中の場合は続行              |
| `SIGSTOP`  | 19    | プロセス停止（キャッチ不可）    |
| `SIGTSTP`  | 20    | 端末停止（Ctrl+Z）              |

### I/O

| 定数       | 値    | 説明                               |
|------------|-------|------------------------------------|
| `SIGPIPE`  | 13    | 壊れたパイプ                       |
| `SIGTTIN`  | 21    | バックグラウンドでの端末読み取り   |
| `SIGTTOU`  | 22    | バックグラウンドでの端末書き込み   |

**例:**
```hemlock
fn handle_signal(sig) {
    if (sig == SIGINT) {
        print("Interrupt detected");
    }
    if (sig == SIGTERM) {
        print("Termination requested");
    }
}

signal(SIGINT, handle_signal);
signal(SIGTERM, handle_signal);
```

**注意:** `SIGKILL`（9）と`SIGSTOP`（19）はキャッチまたは無視できません。

---

## 数学/算術関数

### div

浮動小数点数を返す床除算です。

**シグネチャ:**
```hemlock
div(a: number, b: number): f64
```

**パラメータ:**
- `a` - 被除数
- `b` - 除数

**戻り値:** `a / b`の床を浮動小数点数（f64）として返す

**例:**
```hemlock
let result = div(7, 2);    // 3.0（3.5ではない）
let result2 = div(10, 3);  // 3.0
let result3 = div(-7, 2);  // -4.0（床は負の無限大方向に丸める）
```

**注意:** Hemlockでは、`/`演算子は常に浮動小数点数を返します。整数部分を浮動小数点数として必要な場合は`div()`を、整数結果が必要な場合は`divi()`を使用してください。

---

### divi

整数を返す床除算です。

**シグネチャ:**
```hemlock
divi(a: number, b: number): i64
```

**パラメータ:**
- `a` - 被除数
- `b` - 除数

**戻り値:** `a / b`の床を整数（i64）として返す

**例:**
```hemlock
let result = divi(7, 2);    // 3
let result2 = divi(10, 3);  // 3
let result3 = divi(-7, 2);  // -4（床は負の無限大方向に丸める）
```

**比較:**
```hemlock
print(7 / 2);      // 3.5（通常の除算、常に浮動小数点数）
print(div(7, 2));  // 3.0（床除算、浮動小数点数結果）
print(divi(7, 2)); // 3  （床除算、整数結果）
```

---

## メモリ管理関数

完全なリファレンスについては[メモリAPI](#reference-memory-api)を参照:
- `alloc(size)` - 生メモリを確保
- `free(ptr)` - メモリを解放
- `buffer(size)` - 安全なバッファを確保
- `memset(ptr, byte, size)` - メモリを埋める
- `memcpy(dest, src, size)` - メモリをコピー
- `realloc(ptr, new_size)` - 確保サイズを変更

### sizeof

型のバイト単位のサイズを取得します。

**シグネチャ:**
```hemlock
sizeof(type): i32
```

**パラメータ:**
- `type` - 型定数（`i32`, `f64`, `ptr`など）または型名の文字列

**戻り値:** バイト単位のサイズを`i32`として返す

**例:**
```hemlock
print(sizeof(i8));       // 1
print(sizeof(i16));      // 2
print(sizeof(i32));      // 4
print(sizeof(i64));      // 8
print(sizeof(f32));      // 4
print(sizeof(f64));      // 8
print(sizeof(ptr));      // 8
print(sizeof(rune));     // 4

// 型エイリアスの使用
print(sizeof(byte));     // 1（u8と同じ）
print(sizeof(integer));  // 4（i32と同じ）
print(sizeof(number));   // 8（f64と同じ）

// 文字列形式でも動作
print(sizeof("i32"));    // 4
```

**サポートされる型:**
| 型 | サイズ | エイリアス |
|------|------|---------|
| `i8` | 1 | - |
| `i16` | 2 | - |
| `i32` | 4 | `integer` |
| `i64` | 8 | - |
| `u8` | 1 | `byte` |
| `u16` | 2 | - |
| `u32` | 4 | - |
| `u64` | 8 | - |
| `f32` | 4 | - |
| `f64` | 8 | `number` |
| `ptr` | 8 | - |
| `rune` | 4 | - |
| `bool` | 1 | - |

**関連項目:** 型付き確保には`talloc()`を使用

---

### talloc

型付き配列用のメモリを確保します（型認識確保）。

**シグネチャ:**
```hemlock
talloc(type, count: i32): ptr
```

**パラメータ:**
- `type` - 型定数（`i32`, `f64`, `ptr`など）
- `count` - 確保する要素数

**戻り値:** 確保されたメモリへの`ptr`、失敗時は`null`

**例:**
```hemlock
// 10個のi32の配列を確保（40バイト）
let int_arr = talloc(i32, 10);
ptr_write_i32(int_arr, 42);
ptr_write_i32(ptr_offset(int_arr, 1, 4), 100);

// 5個のf64の配列を確保（40バイト）
let float_arr = talloc(f64, 5);

// 100バイトの配列を確保
let byte_arr = talloc(u8, 100);

// 解放を忘れずに！
free(int_arr);
free(float_arr);
free(byte_arr);
```

**allocとの比較:**
```hemlock
// これらは同等:
let p1 = talloc(i32, 10);      // 型認識: 10個のi32
let p2 = alloc(sizeof(i32) * 10);  // 手動計算

// tallocの方が明確でエラーが起きにくい
```

**エラー処理:**
- 確保に失敗した場合は`null`を返す
- countが正でない場合はエラーで終了
- サイズオーバーフロー（count * element_size）をチェック

**関連項目:** `alloc()`, `sizeof()`, `free()`

---

## FFIポインタヘルパー

これらの関数は、生メモリへの型付き値の読み書きを支援し、FFIや低レベルメモリ操作に有用です。

### ptr_null

ヌルポインタを作成します。

**シグネチャ:**
```hemlock
ptr_null(): ptr
```

**戻り値:** ヌルポインタ

**例:**
```hemlock
let p = ptr_null();
if (p == null) {
    print("Pointer is null");
}
```

---

### ptr_offset

ポインタオフセットを計算します（ポインタ演算）。

**シグネチャ:**
```hemlock
ptr_offset(ptr: ptr, index: i32, element_size: i32): ptr
```

**パラメータ:**
- `ptr` - ベースポインタ
- `index` - 要素インデックス
- `element_size` - 各要素のバイト単位のサイズ

**戻り値:** 指定されたインデックスの要素へのポインタ

**例:**
```hemlock
let arr = talloc(i32, 10);
ptr_write_i32(arr, 100);                      // arr[0] = 100
ptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200
ptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300

print(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200
free(arr);
```

---

### ポインタ読み取り関数

メモリから型付き値を読み取ります。

| 関数 | シグネチャ | 戻り値 | 説明 |
|----------|-----------|---------|-------------|
| `ptr_read_i8` | `(ptr)` | `i8` | 符号付き8ビット整数を読み取り |
| `ptr_read_i16` | `(ptr)` | `i16` | 符号付き16ビット整数を読み取り |
| `ptr_read_i32` | `(ptr)` | `i32` | 符号付き32ビット整数を読み取り |
| `ptr_read_i64` | `(ptr)` | `i64` | 符号付き64ビット整数を読み取り |
| `ptr_read_u8` | `(ptr)` | `u8` | 符号なし8ビット整数を読み取り |
| `ptr_read_u16` | `(ptr)` | `u16` | 符号なし16ビット整数を読み取り |
| `ptr_read_u32` | `(ptr)` | `u32` | 符号なし32ビット整数を読み取り |
| `ptr_read_u64` | `(ptr)` | `u64` | 符号なし64ビット整数を読み取り |
| `ptr_read_f32` | `(ptr)` | `f32` | 32ビット浮動小数点数を読み取り |
| `ptr_read_f64` | `(ptr)` | `f64` | 64ビット浮動小数点数を読み取り |
| `ptr_read_ptr` | `(ptr)` | `ptr` | ポインタ値を読み取り |

**例:**
```hemlock
let p = alloc(8);
ptr_write_f64(p, 3.14159);
let value = ptr_read_f64(p);
print(value);  // 3.14159
free(p);
```

---

### ポインタ書き込み関数

メモリに型付き値を書き込みます。

| 関数 | シグネチャ | 戻り値 | 説明 |
|----------|-----------|---------|-------------|
| `ptr_write_i8` | `(ptr, value)` | `null` | 符号付き8ビット整数を書き込み |
| `ptr_write_i16` | `(ptr, value)` | `null` | 符号付き16ビット整数を書き込み |
| `ptr_write_i32` | `(ptr, value)` | `null` | 符号付き32ビット整数を書き込み |
| `ptr_write_i64` | `(ptr, value)` | `null` | 符号付き64ビット整数を書き込み |
| `ptr_write_u8` | `(ptr, value)` | `null` | 符号なし8ビット整数を書き込み |
| `ptr_write_u16` | `(ptr, value)` | `null` | 符号なし16ビット整数を書き込み |
| `ptr_write_u32` | `(ptr, value)` | `null` | 符号なし32ビット整数を書き込み |
| `ptr_write_u64` | `(ptr, value)` | `null` | 符号なし64ビット整数を書き込み |
| `ptr_write_f32` | `(ptr, value)` | `null` | 32ビット浮動小数点数を書き込み |
| `ptr_write_f64` | `(ptr, value)` | `null` | 64ビット浮動小数点数を書き込み |
| `ptr_write_ptr` | `(ptr, value)` | `null` | ポインタ値を書き込み |

**例:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);
print(ptr_read_i32(p));  // 42
free(p);
```

---

### バッファ/ポインタ変換

#### buffer_ptr

バッファから生ポインタを取得します。

**シグネチャ:**
```hemlock
buffer_ptr(buf: buffer): ptr
```

**例:**
```hemlock
let buf = buffer(64);
let p = buffer_ptr(buf);
// pはbufと同じメモリを指す
```

#### ptr_to_buffer

生ポインタの周りにバッファラッパーを作成します。

**シグネチャ:**
```hemlock
ptr_to_buffer(ptr: ptr, size: i32): buffer
```

**例:**
```hemlock
let p = alloc(64);
let buf = ptr_to_buffer(p, 64);
buf[0] = 65;  // 境界チェック付きになる
// 注意: bufを解放すると基底のメモリも解放される
```

---

## ファイルI/O関数

完全なリファレンスについては[ファイルAPI](#reference-file-api)を参照:
- `open(path, mode?)` - ファイルを開く

---

## 並行処理関数

完全なリファレンスについては[並行処理API](#reference-concurrency-api)を参照:
- `spawn(fn, args...)` - タスクを生成
- `join(task)` - タスクを待機
- `detach(task)` - タスクを切り離す
- `channel(capacity)` - チャネルを作成

### apply

引数の配列で関数を動的に呼び出します。

**シグネチャ:**
```hemlock
apply(fn: function, args: array): any
```

**パラメータ:**
- `fn` - 呼び出す関数
- `args` - 関数に渡す引数の配列

**戻り値:** 呼び出された関数の戻り値

**例:**
```hemlock
fn add(a, b) {
    return a + b;
}

// 引数の配列で呼び出し
let result = apply(add, [2, 3]);
print(result);  // 5

// 動的ディスパッチ
let operations = {
    add: fn(a, b) { return a + b; },
    mul: fn(a, b) { return a * b; },
    sub: fn(a, b) { return a - b; }
};

fn calculate(op: string, args: array) {
    return apply(operations[op], args);
}

print(calculate("add", [10, 5]));  // 15
print(calculate("mul", [10, 5]));  // 50
print(calculate("sub", [10, 5]));  // 5

// 可変引数
fn sum(...nums) {
    let total = 0;
    for (n in nums) {
        total = total + n;
    }
    return total;
}

let numbers = [1, 2, 3, 4, 5];
print(apply(sum, numbers));  // 15
```

**ユースケース:**
- 実行時の値に基づく動的関数ディスパッチ
- 可変引数リストでの関数呼び出し
- 高階ユーティリティ（map、filterなど）の実装
- プラグイン/拡張システム

---

### select

複数のチャネルからのデータを待機し、いずれかがデータを持ったときに戻ります。

**シグネチャ:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**パラメータ:**
- `channels` - チャネル値の配列
- `timeout_ms`（省略可能） - ミリ秒単位のタイムアウト（-1または省略で無限）

**戻り値:**
- `{ channel, value }` - データを持つチャネルと受信した値を含むオブジェクト
- `null` - タイムアウト時

**例:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// プロデューサータスク
spawn(fn() {
    sleep(100);
    ch1.send("from channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("from channel 2");
});

// 最初のメッセージを待機
let result = select([ch1, ch2]);
print(result.value);  // "from channel 2"（最初に到着）

// タイムアウト付き
let result2 = select([ch1, ch2], 1000);  // 最大1秒待機
if (result2 == null) {
    print("Timeout - no data received");
} else {
    print("Received:", result2.value);
}

// 継続的なselectループ
while (true) {
    let msg = select([ch1, ch2], 5000);
    if (msg == null) {
        print("No activity for 5 seconds");
        break;
    }
    print("Got message:", msg.value);
}
```

**動作:**
- チャネルがデータを持つかタイムアウトになるまでブロック
- チャネルが既にデータを持っている場合は即座に戻る
- チャネルが閉じられて空の場合、`{ channel, value: null }`を返す
- チャネルを順番にポーリング（最初に準備完了したチャネルが勝つ）

**ユースケース:**
- 複数のプロデューサーの多重化
- チャネル操作でのタイムアウトの実装
- 複数のソースを持つイベントループの構築

---

## まとめ表

### 関数

| 関数       | カテゴリ        | 戻り値       | 説明                            |
|------------|-----------------|--------------|----------------------------------|
| `print`    | I/O             | `null`       | 標準出力に出力                   |
| `read_line`| I/O             | `string?`    | 標準入力から行を読み取り         |
| `eprint`   | I/O             | `null`       | 標準エラー出力に出力             |
| `typeof`   | 型              | `string`     | 型名を取得                       |
| `exec`     | コマンド        | `object`     | シェルコマンドを実行             |
| `exec_argv`| コマンド        | `object`     | 引数配列で実行                   |
| `assert`   | エラー          | `null`       | 条件をアサートまたは終了         |
| `panic`    | エラー          | `never`      | 回復不能エラー（終了）           |
| `signal`   | シグナル        | `function?`  | シグナルハンドラを登録           |
| `raise`    | シグナル        | `null`       | プロセスにシグナルを送信         |
| `alloc`    | メモリ          | `ptr`        | 生メモリを確保                   |
| `talloc`   | メモリ          | `ptr`        | 型付き確保                       |
| `sizeof`   | メモリ          | `i32`        | 型サイズをバイトで取得           |
| `free`     | メモリ          | `null`       | メモリを解放                     |
| `buffer`   | メモリ          | `buffer`     | 安全なバッファを確保             |
| `memset`   | メモリ          | `null`       | メモリを埋める                   |
| `memcpy`   | メモリ          | `null`       | メモリをコピー                   |
| `realloc`  | メモリ          | `ptr`        | 確保サイズを変更                 |
| `open`     | ファイルI/O     | `file`       | ファイルを開く                   |
| `spawn`    | 並行処理        | `task`       | 並行タスクを生成                 |
| `join`     | 並行処理        | `any`        | タスク結果を待機                 |
| `detach`   | 並行処理        | `null`       | タスクを切り離す                 |
| `channel`  | 並行処理        | `channel`    | 通信チャネルを作成               |
| `select`   | 並行処理        | `object?`    | 複数チャネルで待機               |
| `apply`    | 関数            | `any`        | 引数配列で関数を呼び出し         |

### グローバル変数

| 変数       | 型       | 説明                              |
|------------|----------|-----------------------------------|
| `args`     | `array`  | コマンドライン引数                |

### 定数

| 定数       | 型    | カテゴリ | 値    | 説明                      |
|------------|-------|----------|-------|---------------------------|
| `SIGINT`   | `i32` | シグナル | 2     | キーボード割り込み        |
| `SIGTERM`  | `i32` | シグナル | 15    | 終了要求                  |
| `SIGQUIT`  | `i32` | シグナル | 3     | キーボード終了            |
| `SIGHUP`   | `i32` | シグナル | 1     | ハングアップ              |
| `SIGABRT`  | `i32` | シグナル | 6     | 中止                      |
| `SIGUSR1`  | `i32` | シグナル | 10    | ユーザー定義1             |
| `SIGUSR2`  | `i32` | シグナル | 12    | ユーザー定義2             |
| `SIGALRM`  | `i32` | シグナル | 14    | アラームタイマー          |
| `SIGCHLD`  | `i32` | シグナル | 17    | 子ステータス変更          |
| `SIGCONT`  | `i32` | シグナル | 18    | 続行                      |
| `SIGSTOP`  | `i32` | シグナル | 19    | 停止（キャッチ不可）      |
| `SIGTSTP`  | `i32` | シグナル | 20    | 端末停止                  |
| `SIGPIPE`  | `i32` | シグナル | 13    | 壊れたパイプ              |
| `SIGTTIN`  | `i32` | シグナル | 21    | バックグラウンド端末読取  |
| `SIGTTOU`  | `i32` | シグナル | 22    | バックグラウンド端末書込  |

---

## 関連項目

- [型システム](#reference-type-system) - 型と変換
- [メモリAPI](#reference-memory-api) - メモリ確保関数
- [ファイルAPI](#reference-file-api) - ファイルI/O関数
- [並行処理API](#reference-concurrency-api) - 非同期/並行処理関数
- [文字列API](#reference-string-api) - 文字列メソッド
- [配列API](#reference-array-api) - 配列メソッド


--------------------------------------------------------------------------------
## 配列API
--------------------------------------------------------------------------------

# 配列APIリファレンス

Hemlockの配列型と全18個の配列メソッドの完全なリファレンスです。

---

## 概要

Hemlockの配列は**動的でヒープ割り当て**されるシーケンスであり、混合型を保持できます。データ操作と処理のための包括的なメソッドを提供します。

**主な機能：**
- 動的サイズ（自動拡張）
- ゼロインデックス
- 混合型を許可
- 18個の組み込みメソッド
- 容量追跡付きヒープ割り当て

---

## 配列型

**型：** `array`

**プロパティ：**
- `.length` - 要素数（i32）

**リテラル構文：** 角括弧 `[elem1, elem2, ...]`

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// 混合型
let mixed = [1, "hello", true, null];
print(mixed.length);   // 4

// 空配列
let empty = [];
print(empty.length);   // 0
```

---

## インデックス

配列は`[]`を使用したゼロベースのインデックスをサポートします：

**読み取りアクセス：**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**書き込みアクセス：**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**注意：** 直接インデックスには境界チェックがありません。安全のためにはメソッドを使用してください。

---

## 配列プロパティ

### .length

配列の要素数を取得します。

**型：** `i32`

**例：**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let empty = [];
print(empty.length);   // 0

// 長さは動的に変化
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## 配列メソッド

### スタック操作

#### push

配列の末尾に要素を追加します。

**シグネチャ：**
```hemlock
array.push(value: any): null
```

**パラメータ：**
- `value` - 追加する要素

**戻り値：** `null`

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("hello");     // [1, 2, 3, 4, 5, "hello"]
```

---

#### pop

最後の要素を削除して返します。

**シグネチャ：**
```hemlock
array.pop(): any
```

**戻り値：** 最後の要素（配列から削除される）

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [1, 2, 3];
let last = arr.pop();  // 3
print(arr);            // [1, 2]

let last2 = arr.pop(); // 2
print(arr);            // [1]
```

**エラー：** 配列が空の場合は実行時エラー。

---

### キュー操作

#### shift

最初の要素を削除して返します。

**シグネチャ：**
```hemlock
array.shift(): any
```

**戻り値：** 最初の要素（配列から削除される）

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();  // 1
print(arr);               // [2, 3]

let first2 = arr.shift(); // 2
print(arr);               // [3]
```

**エラー：** 配列が空の場合は実行時エラー。

---

#### unshift

配列の先頭に要素を追加します。

**シグネチャ：**
```hemlock
array.unshift(value: any): null
```

**パラメータ：**
- `value` - 追加する要素

**戻り値：** `null`

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### 挿入と削除

#### insert

特定のインデックスに要素を挿入します。

**シグネチャ：**
```hemlock
array.insert(index: i32, value: any): null
```

**パラメータ：**
- `index` - 挿入する位置（0ベース）
- `value` - 挿入する要素

**戻り値：** `null`

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// 末尾に挿入
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**動作：** インデックス以降の要素を右にシフトします。

---

#### remove

インデックスの要素を削除して返します。

**シグネチャ：**
```hemlock
array.remove(index: i32): any
```

**パラメータ：**
- `index` - 削除する位置（0ベース）

**戻り値：** 削除された要素

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let removed2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**動作：** インデックス以降の要素を左にシフトします。

**エラー：** インデックスが範囲外の場合は実行時エラー。

---

### 検索と検出

#### find

値の最初の出現位置を見つけます。

**シグネチャ：**
```hemlock
array.find(value: any): i32
```

**パラメータ：**
- `value` - 検索する値

**戻り値：** 最初の出現のインデックス、見つからない場合は`-1`

**例：**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1（見つからない）

// 最初の重複を見つける
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1（最初の出現）
```

**比較：** プリミティブと文字列には値の等価性を使用します。

---

#### contains

配列が値を含むかチェックします。

**シグネチャ：**
```hemlock
array.contains(value: any): bool
```

**パラメータ：**
- `value` - 検索する値

**戻り値：** 見つかった場合は`true`、それ以外は`false`

**例：**
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false

// 文字列でも動作
let words = ["hello", "world"];
let has3 = words.contains("hello");  // true
```

---

### スライスと抽出

#### slice

範囲で部分配列を抽出します（終了は含まない）。

**シグネチャ：**
```hemlock
array.slice(start: i32, end: i32): array
```

**パラメータ：**
- `start` - 開始インデックス（0ベース、含む）
- `end` - 終了インデックス（含まない）

**戻り値：** [start, end)の要素を含む新しい配列

**変更：** なし（新しい配列を返す）

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]
let first_three = arr.slice(0, 3);  // [1, 2, 3]
let last_two = arr.slice(3, 5);     // [4, 5]

// 空のスライス
let empty = arr.slice(2, 2); // []
```

---

#### first

最初の要素を削除せずに取得します。

**シグネチャ：**
```hemlock
array.first(): any
```

**戻り値：** 最初の要素

**変更：** なし

**例：**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3]（変更なし）
```

**エラー：** 配列が空の場合は実行時エラー。

---

#### last

最後の要素を削除せずに取得します。

**シグネチャ：**
```hemlock
array.last(): any
```

**戻り値：** 最後の要素

**変更：** なし

**例：**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3]（変更なし）
```

**エラー：** 配列が空の場合は実行時エラー。

---

### 配列操作

#### reverse

配列をその場で反転します。

**シグネチャ：**
```hemlock
array.reverse(): null
```

**戻り値：** `null`

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let words = ["hello", "world"];
words.reverse();             // ["world", "hello"]
```

---

#### clear

配列からすべての要素を削除します。

**シグネチャ：**
```hemlock
array.clear(): null
```

**戻り値：** `null`

**変更：** はい（配列をその場で変更）

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### 配列結合

#### concat

別の配列と連結します。

**シグネチャ：**
```hemlock
array.concat(other: array): array
```

**パラメータ：**
- `other` - 連結する配列

**戻り値：** 両方の配列の要素を含む新しい配列

**変更：** なし（新しい配列を返す）

**例：**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                    // [1, 2, 3]（変更なし）
print(b);                    // [4, 5, 6]（変更なし）

// 連結のチェーン
let c = [7, 8];
let all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### 関数型操作

#### map

コールバック関数を使用して各要素を変換します。

**シグネチャ：**
```hemlock
array.map(callback: fn): array
```

**パラメータ：**
- `callback` - 要素を受け取り変換された値を返す関数

**戻り値：** 変換された要素を含む新しい配列

**変更：** なし（新しい配列を返す）

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
let doubled = arr.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

let names = ["alice", "bob"];
let upper = names.map(fn(s) { return s.to_upper(); });
print(upper);  // ["ALICE", "BOB"]
```

---

#### filter

述語に一致する要素を選択します。

**シグネチャ：**
```hemlock
array.filter(predicate: fn): array
```

**パラメータ：**
- `predicate` - 要素を受け取りboolを返す関数

**戻り値：** 述語がtrueを返した要素を含む新しい配列

**変更：** なし（新しい配列を返す）

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let evens = arr.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4, 6]

let words = ["hello", "hi", "hey", "goodbye"];
let short = words.filter(fn(s) { return s.length < 4; });
print(short);  // ["hi", "hey"]
```

---

#### reduce

アキュムレータを使用して配列を単一の値に削減します。

**シグネチャ：**
```hemlock
array.reduce(callback: fn, initial: any): any
```

**パラメータ：**
- `callback` - (アキュムレータ, 要素)を受け取り新しいアキュムレータを返す関数
- `initial` - アキュムレータの初期値

**戻り値：** 最終的な累積値

**変更：** なし

**例：**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

let product = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(product);  // 120

// 最大値を見つける
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### 文字列変換

#### join

区切り文字で要素を文字列に結合します。

**シグネチャ：**
```hemlock
array.join(delimiter: string): string
```

**パラメータ：**
- `delimiter` - 要素間に配置する文字列

**戻り値：** すべての要素を結合した文字列

**例：**
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// 混合型でも動作
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"

// 空の区切り文字
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**動作：** すべての要素を自動的に文字列に変換します。

---

## メソッドチェーン

配列メソッドは簡潔な操作のためにチェーンできます：

**例：**
```hemlock
// sliceとjoinをチェーン
let result = ["apple", "banana", "cherry", "date"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

// concatとsliceをチェーン
let combined = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// 複雑なチェーン
let words = ["hello", "world", "foo", "bar"];
let result2 = words
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "hello-world-foo-baz"
```

---

## 完全なメソッド要約

### 変更メソッド

配列をその場で変更するメソッド：

| メソッド | シグネチャ | 戻り値 | 説明 |
|----------|--------------------------|-----------|--------------------------------|
| `push`     | `(value: any)`             | `null`    | 末尾に追加 |
| `pop`      | `()`                       | `any`     | 末尾から削除 |
| `shift`    | `()`                       | `any`     | 先頭から削除 |
| `unshift`  | `(value: any)`             | `null`    | 先頭に追加 |
| `insert`   | `(index: i32, value: any)` | `null`    | インデックスに挿入 |
| `remove`   | `(index: i32)`             | `any`     | インデックスから削除 |
| `reverse`  | `()`                       | `null`    | その場で反転 |
| `clear`    | `()`                       | `null`    | すべての要素を削除 |

### 非変更メソッド

元の配列を変更せずに新しい値を返すメソッド：

| メソッド | シグネチャ | 戻り値 | 説明 |
|----------|--------------------------|-----------|--------------------------------|
| `find`     | `(value: any)`             | `i32`     | 最初の出現を見つける |
| `contains` | `(value: any)`             | `bool`    | 値を含むかチェック |
| `slice`    | `(start: i32, end: i32)`   | `array`   | 部分配列を抽出 |
| `first`    | `()`                       | `any`     | 最初の要素を取得 |
| `last`     | `()`                       | `any`     | 最後の要素を取得 |
| `concat`   | `(other: array)`           | `array`   | 配列を連結 |
| `join`     | `(delimiter: string)`      | `string`  | 要素を文字列に結合 |
| `map`      | `(callback: fn)`           | `array`   | 各要素を変換 |
| `filter`   | `(predicate: fn)`          | `array`   | 一致する要素を選択 |
| `reduce`   | `(callback: fn, initial: any)` | `any` | 単一の値に削減 |

---

## 使用パターン

### スタック使用

```hemlock
let stack = [];

// 要素をプッシュ
stack.push(1);
stack.push(2);
stack.push(3);

// 要素をポップ
while (stack.length > 0) {
    let item = stack.pop();
    print(item);  // 3, 2, 1
}
```

### キュー使用

```hemlock
let queue = [];

// エンキュー
queue.push(1);
queue.push(2);
queue.push(3);

// デキュー
while (queue.length > 0) {
    let item = queue.shift();
    print(item);  // 1, 2, 3
}
```

### 配列変換

```hemlock
// フィルタ（手動）
let numbers = [1, 2, 3, 4, 5, 6];
let evens = [];
let i = 0;
while (i < numbers.length) {
    if (numbers[i] % 2 == 0) {
        evens.push(numbers[i]);
    }
    i = i + 1;
}

// マップ（手動）
let numbers2 = [1, 2, 3, 4, 5];
let doubled = [];
let j = 0;
while (j < numbers2.length) {
    doubled.push(numbers2[j] * 2);
    j = j + 1;
}
```

### 配列の構築

```hemlock
let arr = [];

// ループで配列を構築
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## 実装の詳細

**容量管理：**
- 配列は必要に応じて自動的に拡張
- 容量は超過時に2倍になる
- 手動の容量制御なし

**値の比較：**
- `find()`と`contains()`は値の等価性を使用
- プリミティブと文字列で正しく動作
- オブジェクト/配列は参照で比較

**メモリ：**
- ヒープ割り当て
- 自動解放なし（手動メモリ管理）
- 直接インデックスアクセスには境界チェックなし

---

## 関連項目

- [型システム](#reference-type-system) - 配列型の詳細
- [文字列API](#reference-string-api) - 文字列join()の結果
- [演算子](#reference-operators) - 配列インデックス演算子



################################################################################
# 設計と思想
################################################################################

--------------------------------------------------------------------------------
## シグネチャ構文
--------------------------------------------------------------------------------

# シグネチャ構文設計

> Hemlockの型システムを関数型、nullable修飾子、型エイリアス、constパラメータ、メソッドシグネチャで拡張する。

**ステータス:** 実装済み (v1.7.0)
**バージョン:** 1.0
**著者:** Claude

---

## 概要

このドキュメントでは、Hemlockの既存インフラストラクチャに基づいて構築する5つの相互接続された型システム拡張を提案します:

1. **関数型注釈** - ファーストクラスの関数型
2. **Nullable型修飾子** - 明示的なnull処理（既存の`nullable`フラグを拡張）
3. **型エイリアス** - 名前付き型の省略形
4. **Constパラメータ** - 不変性契約
5. **Defineでのメソッドシグネチャ** - インターフェースのような動作

これらの機能は以下の哲学を共有します: **暗黙より明示、オプションだが使用時は強制**。

---

## 1. 関数型注釈

### 動機

現在、関数のシグネチャを型として表現する方法がありません:

```hemlock
// 現在: callbackには型情報がない
fn map(arr: array, callback) { ... }

// 提案: 明示的な関数型
fn map(arr: array, callback: fn(any, i32): any): array { ... }
```

### 構文

```hemlock
// 基本的な関数型
fn(i32, i32): i32

// パラメータ名付き（ドキュメント用のみ、強制されない）
fn(a: i32, b: i32): i32

// 戻り値なし (void)
fn(string): void
fn(string)              // 省略形: `: void`を省略

// Nullable戻り値
fn(i32): string?

// オプションパラメータ
fn(name: string, age?: i32): void

// 残余パラメータ
fn(...args: array): i32

// パラメータなし
fn(): bool

// 高階: 関数を返す関数
fn(i32): fn(i32): i32

// 非同期関数型
async fn(i32): i32
```

### 使用例

```hemlock
// 関数型を持つ変数
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// 関数パラメータ
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// 戻り値型が関数
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// 関数の配列
let ops: array<fn(i32, i32): i32> = [add, subtract, multiply];

// オブジェクトフィールド
define EventHandler {
    name: string;
    callback: fn(Event): void;
}
```

### AST変更

```c
// TypeKind列挙型 (include/ast.h)
typedef enum {
    // ... 既存の型 ...
    TYPE_FUNCTION,      // 新規: 関数型
} TypeKind;

// Type構造体 (include/ast.h)
struct Type {
    TypeKind kind;
    // ... 既存のフィールド ...

    // TYPE_FUNCTION用:
    struct Type **param_types;      // パラメータ型
    char **param_names;             // オプションのパラメータ名（ドキュメント用）
    int *param_optional;            // どのパラメータがオプションか
    int num_params;
    char *rest_param_name;          // 残余パラメータ名またはNULL
    struct Type *rest_param_type;   // 残余パラメータ型
    struct Type *return_type;       // 戻り値型（NULL = void）
    int is_async;                   // 非同期関数型
};
```

### パース

関数型は`fn`（または`async fn`）の後にパラメータリストで始まります:

```
function_type := ["async"] "fn" "(" [param_type_list] ")" [":" type]
param_type_list := param_type ("," param_type)*
param_type := [identifier ":"] ["?"] type | "..." [identifier] [":" type]
```

**曖昧さの解消:** 型をパース中に`fn`に遭遇した場合:
- `(`が続く場合、関数型
- そうでなければ、構文エラー（単独の`fn`は有効な型ではない）

### 型互換性

```hemlock
// 関数型には厳密な一致が必要
let f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK

// パラメータの反変性（より広い型を受け入れるのはOK）
let g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// 戻り値の共変性（より狭い型を返すのはOK）
let h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// アリティは一致する必要がある
let bad: fn(i32): i32 = fn(a, b) { return a; };       // エラー: アリティ不一致

// オプションパラメータは必須と互換
let opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK
```

---

## 2. Nullable型修飾子

### 動機

`?`サフィックスにより、シグネチャでのnull受け入れを明示的にします:

```hemlock
// 現在: nullが有効かどうか不明
fn find(arr: array, val: any): i32 { ... }

// 提案: 明示的なnullable戻り値
fn find(arr: array, val: any): i32? { ... }
```

### 構文

```hemlock
// ?サフィックス付きNullable型
string?           // stringまたはnull
i32?              // i32またはnull
User?             // Userまたはnull
array<i32>?       // arrayまたはnull
fn(i32): i32?     // i32またはnullを返す関数

// 関数型との組み合わせ
fn(string?): i32          // stringまたはnullを受け入れる
fn(string): i32?          // i32またはnullを返す
fn(string?): i32?         // 両方nullable

// defineでの使用
define Result {
    value: any?;
    error: string?;
}
```

### 実装上の注意

**既に存在:** `Type.nullable`フラグは既にASTにあります。この機能は主に以下が必要:
1. 任意の型での`?`サフィックスのパーサーサポート（検証/拡張）
2. 関数型との適切な組み合わせ
3. ランタイム強制

### 型互換性

```hemlock
// 非nullableはnullableに代入可能
let x: i32? = 42;           // OK
let y: i32? = null;         // OK

// nullableは非nullableに代入不可
let z: i32 = x;             // エラー: xはnullかもしれない

// null合体でアンラップ
let z: i32 = x ?? 0;        // OK: ??がデフォルトを提供

// セーフナビゲーションはnullableを返す
let name: string? = user?.name;
```

---

## 3. 型エイリアス

### 動機

複雑な型は名前付きの省略形から恩恵を受けます:

```hemlock
// 現在: 繰り返しの複合型
fn process(entity: HasName & HasId & HasTimestamp) { ... }
fn validate(entity: HasName & HasId & HasTimestamp) { ... }

// 提案: 名前付きエイリアス
type Entity = HasName & HasId & HasTimestamp;
fn process(entity: Entity) { ... }
fn validate(entity: Entity) { ... }
```

### 構文

```hemlock
// 基本エイリアス
type Integer = i32;
type Text = string;

// 複合型エイリアス
type Entity = HasName & HasId;
type Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;

// 関数型エイリアス
type Callback = fn(Event): void;
type Predicate = fn(any): bool;
type Reducer = fn(acc: any, val: any): any;
type AsyncTask = async fn(): any;

// Nullableエイリアス
type OptionalString = string?;

// ジェネリックエイリアス（ジェネリック型エイリアスをサポートする場合）
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// 配列型エイリアス
type IntArray = array<i32>;
type Matrix = array<array<f64>>;
```

### スコープと可視性

```hemlock
// デフォルトでモジュールスコープ
type Callback = fn(Event): void;

// エクスポート可能
export type Handler = fn(Request): Response;

// 別のファイルで
import { Handler } from "./handlers.hml";
fn register(h: Handler) { ... }
```

### AST変更

```c
// 新しい文の種類
typedef enum {
    // ... 既存の文 ...
    STMT_TYPE_ALIAS,    // 新規
} StmtKind;

// Stmtユニオン内
struct {
    char *name;                 // エイリアス名
    char **type_params;         // ジェネリックパラメータ: <T, U>
    int num_type_params;
    Type *aliased_type;         // 実際の型
} type_alias;
```

### パース

```
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"
```

**注:** `type`は新しいキーワードです。既存の識別子との競合をチェックしてください。

### 解決

型エイリアスは以下のタイミングで解決されます:
- **パース時:** エイリアスが型環境に記録される
- **チェック時:** エイリアスが基礎となる型に展開される
- **ランタイム:** エイリアスは透過的（基礎型と同じ）

```hemlock
type MyInt = i32;
let x: MyInt = 42;
typeof(x);           // "i32"（"MyInt"ではない）
```

---

## 4. Constパラメータ

### 動機

関数シグネチャで不変性の意図を示します:

```hemlock
// 現在: 配列が変更されるかどうか不明
fn print_all(items: array) { ... }

// 提案: 明示的な不変性契約
fn print_all(const items: array) { ... }
```

### 構文

```hemlock
// Constパラメータ
fn process(const data: buffer) {
    // data[0] = 0;        // エラー: constを変更できない
    let x = data[0];       // OK: 読み取りは許可
    return x;
}

// 複数のconstパラメータ
fn compare(const a: array, const b: array): bool { ... }

// constとmutableの混在
fn update(const source: array, target: array) {
    for (item in source) {
        target.push(item);   // OK: targetは変更可能
    }
}

// 型推論付きconst
fn log(const msg) {
    print(msg);
}

// 関数型でのconst
type Reader = fn(const buffer): i32;
```

### Constが防ぐもの

```hemlock
fn bad(const arr: array) {
    arr.push(1);         // エラー: 変更メソッド
    arr.pop();           // エラー: 変更メソッド
    arr[0] = 5;          // エラー: インデックス代入
    arr.clear();         // エラー: 変更メソッド
}

fn ok(const arr: array) {
    let x = arr[0];      // OK: 読み取り
    let len = len(arr);  // OK: 長さチェック
    let copy = arr.slice(0, 10);  // OK: 新しい配列を作成
    for (item in arr) {  // OK: イテレーション
        print(item);
    }
}
```

### 変更 vs 非変更メソッド

| 型 | 変更（constでブロック） | 非変更（許可） |
|------|----------------------------|------------------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |
| string | インデックス代入 (`s[0] = 'x'`) | すべてのメソッド（新しい文字列を返す） |
| buffer | インデックス代入, memset, memcpy (to) | インデックス読み取り, slice |
| object | フィールド代入 | フィールド読み取り |

### AST変更

```c
// 関数式内 (include/ast.h)
struct {
    // ... 既存のフィールド ...
    int *param_is_const;    // 新規: constなら1、そうでなければ0
} function;

// 関数型用のType構造体内
struct Type {
    // ... 既存のフィールド ...
    int *param_is_const;    // TYPE_FUNCTION用
};
```

### 強制

**インタプリタ:**
- 変数バインディングでconst性を追跡
- 変更操作前にチェック
- const違反でランタイムエラー

**コンパイラ:**
- 有益な場合はconstで修飾されたC変数を生成
- const違反の静的解析
- コンパイル時の警告/エラー

---

## 5. Defineでのメソッドシグネチャ

### 動機

`define`ブロックでデータフィールドだけでなく、期待されるメソッドを指定できるようにします:

```hemlock
// 現在: データフィールドのみ
define User {
    name: string;
    age: i32;
}

// 提案: メソッドシグネチャ
define Comparable {
    fn compare(other: Self): i32;
}

define Serializable {
    fn serialize(): string;
    fn deserialize(data: string): Self;  // 静的メソッド
}
```

### 構文

```hemlock
// メソッドシグネチャ（本体なし）
define Hashable {
    fn hash(): i32;
}

// 複数のメソッド
define Collection {
    fn size(): i32;
    fn is_empty(): bool;
    fn contains(item: any): bool;
}

// フィールドとメソッドの混在
define Entity {
    id: i32;
    name: string;
    fn validate(): bool;
    fn serialize(): string;
}

// Self型の使用
define Cloneable {
    fn clone(): Self;
}

define Comparable {
    fn compare(other: Self): i32;
    fn equals(other: Self): bool;
}

// オプションメソッド
define Printable {
    fn to_string(): string;
    fn debug_string?(): string;  // オプションメソッド（存在しない可能性あり）
}

// デフォルト実装付きメソッド
define Ordered {
    fn compare(other: Self): i32;  // 必須

    // デフォルト実装（オーバーライドされなければ継承）
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
}
```

### `Self`型

`Self`はインターフェースを実装する具象型を参照します:

```hemlock
define Addable {
    fn add(other: Self): Self;
}

// 使用時:
let a: Addable = {
    value: 10,
    add: fn(other) {
        return { value: self.value + other.value, add: self.add };
    }
};
```

### 構造的型付け（ダックタイピング）

メソッドシグネチャはフィールドと同じダックタイピングを使用します:

```hemlock
define Stringifiable {
    fn to_string(): string;
}

// to_string()メソッドを持つ任意のオブジェクトはStringifiableを満たす
let x: Stringifiable = {
    name: "test",
    to_string: fn() { return self.name; }
};

// メソッド付き複合型
define Named { name: string; }
define Printable { fn to_string(): string; }

type NamedPrintable = Named & Printable;

let y: NamedPrintable = {
    name: "Alice",
    to_string: fn() { return "Name: " + self.name; }
};
```

### AST変更

```c
// Stmtユニオン内のdefine_objectを拡張
struct {
    char *name;
    char **type_params;
    int num_type_params;

    // フィールド（既存）
    char **field_names;
    Type **field_types;
    int *field_optional;
    Expr **field_defaults;
    int num_fields;

    // メソッド（新規）
    char **method_names;
    Type **method_types;        // TYPE_FUNCTION
    int *method_optional;       // オプションメソッド (fn name?(): type)
    Expr **method_defaults;     // デフォルト実装（シグネチャのみの場合NULL）
    int num_methods;
} define_object;
```

### 型チェック

`value: InterfaceType`をチェックする際:
1. すべての必須フィールドが互換型で存在するかチェック
2. すべての必須メソッドが互換シグネチャで存在するかチェック
3. オプションフィールド/メソッドは不在でも可

```hemlock
define Sortable {
    fn compare(other: Self): i32;
}

// 有効: compareメソッドを持つ
let valid: Sortable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// 無効: compareがない
let invalid: Sortable = { value: 10 };  // エラー: メソッド 'compare' がない

// 無効: 間違ったシグネチャ
let wrong: Sortable = {
    compare: fn() { return 0; }  // エラー: (Self): i32が期待される
};
```

---

## 相互作用の例

### すべての機能を組み合わせる

```hemlock
// 複雑な関数型の型エイリアス
type EventCallback = fn(event: Event, context: Context?): bool;

// 複合インターフェースの型エイリアス
type Entity = HasId & HasName & Serializable;

// メソッドシグネチャ付きdefine
define Repository<T> {
    fn find(id: i32): T?;
    fn save(const entity: T): bool;
    fn delete(id: i32): bool;
    fn find_all(predicate: fn(T): bool): array<T>;
}

// すべてを一緒に使用
fn create_user_repo(): Repository<User> {
    let users: array<User> = [];

    return {
        find: fn(id) {
            for (u in users) {
                if (u.id == id) { return u; }
            }
            return null;
        },
        save: fn(const entity) {
            users.push(entity);
            return true;
        },
        delete: fn(id) {
            // ...
            return true;
        },
        find_all: fn(predicate) {
            return users.filter(predicate);
        }
    };
}
```

### 明示的な型を持つコールバック

```hemlock
type ClickHandler = fn(event: MouseEvent): void;
type KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;

define Widget {
    x: i32;
    y: i32;
    on_click: ClickHandler?;
    on_key: KeyHandler?;
}

fn create_button(label: string, handler: ClickHandler): Widget {
    return {
        x: 0, y: 0,
        on_click: handler,
        on_key: null
    };
}
```

### Nullable関数型

```hemlock
// オプションのコールバック
fn fetch(url: string, on_complete: fn(Response): void?): void {
    let response = http_get(url);
    if (on_complete != null) {
        on_complete(response);
    }
}

// 関数型からのnullable戻り値
type Parser = fn(input: string): AST?;

fn try_parse(parsers: array<Parser>, input: string): AST? {
    for (p in parsers) {
        let result = p(input);
        if (result != null) {
            return result;
        }
    }
    return null;
}
```

---

## 実装ロードマップ

### フェーズ1: コアインフラストラクチャ
1. TypeKind列挙型に`TYPE_FUNCTION`を追加
2. Type構造体に関数型フィールドを拡張
3. コンパイラ型チェッカーに`CHECKED_FUNCTION`を追加
4. `Self`型サポートを追加 (TYPE_SELF)

### フェーズ2: パース
1. パーサーに`parse_function_type()`を実装
2. 型位置で`fn(...)`を処理
3. `type`キーワードと`STMT_TYPE_ALIAS`パースを追加
4. `const`パラメータ修飾子パースを追加
5. メソッドシグネチャ用にdefineパースを拡張

### フェーズ3: 型チェック
1. 関数型互換性ルール
2. 型エイリアス解決と展開
3. Constパラメータ変更チェック
4. define型でのメソッドシグネチャ検証
5. Self型解決

### フェーズ4: ランタイム
1. 呼び出しサイトでの関数型検証
2. Const違反検出
3. 型エイリアス透過性

### フェーズ5: パリティテスト
1. 関数型注釈テスト
2. Nullable組み合わせテスト
3. 型エイリアステスト
4. Constパラメータテスト
5. メソッドシグネチャテスト

---

## 設計上の決定

### 1. ジェネリック型エイリアス: **YES**

型エイリアスはジェネリックパラメータをサポート:

```hemlock
// ジェネリック型エイリアス
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
type Mapper<T, U> = fn(T): U;
type AsyncResult<T> = async fn(): T?;

// 使用
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
let result: Result<User, string> = { value: user, error: null };
let transform: Mapper<i32, string> = fn(n) { return n.to_string(); };
```

### 2. Const伝播: **DEEP**

Constパラメータは完全に不変 - どのパスを通しても変更不可:

```hemlock
fn process(const arr: array<object>) {
    arr.push({});        // エラー: const配列を変更できない
    arr[0] = {};         // エラー: const配列を変更できない
    arr[0].x = 5;        // エラー: constを通して変更できない（DEEP）

    let x = arr[0].x;    // OK: 読み取りは問題ない
    let copy = arr[0];   // OK: コピーを作成
    copy.x = 5;          // OK: コピーはconstではない
}

fn nested(const obj: object) {
    obj.user.name = "x"; // エラー: ディープconstはネストされた変更を防ぐ
    obj.items[0] = 1;    // エラー: ディープconstはネストされた変更を防ぐ
}
```

**根拠:** ディープconstはより強い保証を提供し、データの整合性を確保するのにより有用です。
ネストされたデータを変更する必要がある場合は、まずコピーを作成してください。

### 3. スタンドアロン型エイリアスでのSelf: **NO**

`Self`は明確な意味を持つ`define`ブロック内でのみ有効:

```hemlock
// 有効: Selfは定義された型を参照
define Comparable {
    fn compare(other: Self): i32;
}

// 無効: ここではSelfに意味がない
type Cloner = fn(Self): Self;  // エラー: defineコンテキスト外のSelf

// 代わりに、ジェネリックを使用:
type Cloner<T> = fn(T): T;
```

### 4. メソッドのデフォルト実装: **YES (シンプルなものに限る)**

シンプル/ユーティリティメソッドにデフォルト実装を許可:

```hemlock
define Comparable {
    // 必須: 実装が必要
    fn compare(other: Self): i32;

    // デフォルト実装（シンプルな便利メソッド）
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
}

define Printable {
    fn to_string(): string;

    // デフォルト: 必須メソッドに委譲
    fn print() {
        print(self.to_string());
    }
    fn println() {
        print(self.to_string() + "\n");
    }
}

// オブジェクトは必須メソッドのみ実装すればよい
let item: Comparable = {
    value: 42,
    compare: fn(other) { return self.value - other.value; }
    // equals, less_than, greater_thanはデフォルトから継承
};

item.less_than({ value: 50, compare: item.compare });  // true
```

**デフォルトのガイドライン:**
- シンプルに保つ（1-3行）
- 必須メソッドに委譲すべき
- 複雑なロジックや副作用なし
- プリミティブと単純な合成のみ

### 5. 変性: **推論（明示的注釈なし）**

変性は型パラメータの使用方法から推論されます:

```hemlock
// 変性は位置に基づいて自動
type Producer<T> = fn(): T;           // 戻り値のT = 共変
type Consumer<T> = fn(T): void;       // パラメータのT = 反変
type Transformer<T> = fn(T): T;       // 両方のT = 不変

// 例: Dog <: Animal（DogはAnimalのサブタイプ）
let dog_producer: Producer<Dog> = fn() { return new_dog(); };
let animal_producer: Producer<Animal> = dog_producer;  // OK: 共変

let animal_consumer: Consumer<Animal> = fn(a) { print(a); };
let dog_consumer: Consumer<Dog> = animal_consumer;     // OK: 反変
```

**なぜ推論？**
- ボイラープレートが少ない（`<out T>` / `<in T>`はノイズを加える）
- 「暗黙より明示」に従う - 位置は明示的
- ほとんどの言語が関数型の変性を処理する方法に一致
- 変性ルールに違反した場合のエラーは明確

---

## 付録: 文法変更

```ebnf
(* 型 *)
type := simple_type | compound_type | function_type
simple_type := base_type ["?"] | identifier ["<" type_args ">"] ["?"]
compound_type := simple_type ("&" simple_type)+
function_type := ["async"] "fn" "(" [param_types] ")" [":" type]

base_type := "i8" | "i16" | "i32" | "i64"
           | "u8" | "u16" | "u32" | "u64"
           | "f32" | "f64" | "bool" | "string" | "rune"
           | "ptr" | "buffer" | "void" | "null"
           | "array" ["<" type ">"]
           | "object"
           | "Self"

param_types := param_type ("," param_type)*
param_type := ["const"] [identifier ":"] ["?"] type
            | "..." [identifier] [":" type]

type_args := type ("," type)*

(* 文 *)
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"

define_stmt := "define" identifier ["<" type_params ">"] "{" define_members "}"
define_members := (field_def | method_def)*
field_def := identifier (":" type ["=" expr] | "?:" (type | expr)) ";"?
method_def := "fn" identifier ["?"] "(" [param_types] ")" [":" type] (block | ";")
            (* "?" はオプションメソッドを示し、block はデフォルト実装を提供 *)

(* パラメータ *)
param := ["const"] ["ref"] identifier [":" type] ["?:" expr]
       | "..." identifier [":" type]
```


--------------------------------------------------------------------------------
## 実装の詳細
--------------------------------------------------------------------------------

# Hemlock 実装詳細

このドキュメントでは、Hemlock言語の技術的な実装について説明します。プロジェクト構造、コンパイルパイプライン、ランタイムアーキテクチャ、および設計上の決定事項を含みます。

---

## 目次

- [プロジェクト構造](#プロジェクト構造)
- [コンパイルパイプライン](#コンパイルパイプライン)
- [モジュラーインタプリタ設計](#モジュラーインタプリタ設計)
- [ランタイムアーキテクチャ](#ランタイムアーキテクチャ)
- [値の表現](#値の表現)
- [型システムの実装](#型システムの実装)
- [メモリ管理](#メモリ管理)
- [並行処理モデル](#並行処理モデル)
- [将来の計画](#将来の計画)

---

## プロジェクト構造

```
hemlock/
├── src/
│   ├── frontend/              # 共有: 字句解析器、構文解析器、AST
│   │   ├── lexer.c            # トークン化
│   │   ├── parser/            # 再帰下降パーサー
│   │   ├── ast.c              # ASTノード管理
│   │   └── module.c           # モジュール解決
│   ├── backends/
│   │   ├── interpreter/       # hemlock: ツリーウォーキングインタプリタ
│   │   │   ├── main.c         # CLIエントリポイント
│   │   │   ├── runtime.c      # 式/文の評価
│   │   │   ├── builtins.c     # 組み込み関数
│   │   │   └── ...
│   │   └── compiler/          # hemlockc: Cコードジェネレータ
│   │       ├── main.c         # CLI、オーケストレーション
│   │       ├── type_check.c   # コンパイル時型チェック
│   │       ├── codegen.c      # コード生成コンテキスト
│   │       ├── codegen_expr.c # 式のコード生成
│   │       ├── codegen_stmt.c # 文のコード生成
│   │       └── ...
│   ├── tools/
│   │   ├── lsp/               # 言語サーバープロトコル
│   │   └── bundler/           # バンドル/パッケージツール
├── runtime/                   # libhemlock_runtime.a（コンパイル済みプログラム用）
├── stdlib/                    # 標準ライブラリ（39モジュール）
│   └── docs/                  # モジュールドキュメント
├── tests/
│   ├── parity/                # 両バックエンドで合格必須のテスト
│   ├── interpreter/           # インタプリタ固有のテスト
│   └── compiler/              # コンパイラ固有のテスト
├── examples/                  # サンプルプログラム
└── docs/                      # ドキュメント
```

### ディレクトリ構成

**`include/`** - コンポーネント間のインターフェースを定義するパブリックAPIヘッダー:
- 字句解析器、構文解析器、AST、インタプリタ間の明確な分離
- 依存関係を最小化するための前方宣言
- 他のプログラムにHemlockを埋め込むためのパブリックAPI

**`src/`** - 実装ファイル:
- トップレベルファイルは字句解析、構文解析、AST管理を処理
- `main.c`はCLIとREPLを提供
- インタプリタは別々のサブシステムにモジュール化

**`src/interpreter/`** - モジュラーインタプリタ実装:
- 各モジュールは単一の明確な責務を持つ
- モジュール間通信用の内部APIは`internal.h`で定義
- モジュールは独立してコンパイル可能で、より高速なビルドを実現

**`tests/`** - 包括的なテストスイート:
- 機能領域ごとに整理
- 各ディレクトリには焦点を絞ったテストケースを含む
- `run_tests.sh`がテスト実行を調整

---

## コンパイルパイプライン

Hemlockは、明確なフェーズを持つ従来のコンパイルパイプラインを使用します:

### フェーズ1: 字句解析（レキサー）

**入力:** ソースコードテキスト
**出力:** トークンストリーム
**実装:** `src/lexer.c`

```
ソース: "let x = 42;"
   ↓
トークン: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**主な特徴:**
- キーワード、識別子、リテラル、演算子、句読点を認識
- UTF-8文字列リテラルとルーンリテラルを処理
- エラーメッセージ用に行番号を報告
- シングルパス、バックトラックなし

### フェーズ2: 構文解析（パーサー）

**入力:** トークンストリーム
**出力:** 抽象構文木（AST）
**実装:** `src/parser.c`

```
トークン: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   ↓
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**主な特徴:**
- 再帰下降パーサー
- プログラム構造のツリー表現を構築
- 演算子の優先順位を処理
- 構文を検証（括弧、セミコロンなど）
- 意味解析はまだ行わない（実行時に行う）

**演算子の優先順位（低い順）:**
1. 代入: `=`
2. 論理OR: `||`
3. 論理AND: `&&`
4. ビット単位OR: `|`
5. ビット単位XOR: `^`
6. ビット単位AND: `&`
7. 等価: `==`, `!=`
8. 比較: `<`, `>`, `<=`, `>=`
9. ビットシフト: `<<`, `>>`
10. 加算/減算: `+`, `-`
11. 乗算/除算/剰余: `*`, `/`, `%`
12. 単項: `!`, `-`, `~`
13. 呼び出し/インデックス/メンバー: `()`, `[]`, `.`

### フェーズ3a: インタープリテーション（ツリーウォーキング）

**入力:** AST
**出力:** プログラム実行
**実装:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   ↓
実行: ASTノードを再帰的に評価
   ↓
結果: 変数xが値42で作成される
```

**主な特徴:**
- 直接的なAST走査（ツリーウォーキングインタプリタ）
- 実行時の動的型チェック
- 環境ベースの変数ストレージ

### フェーズ3b: コンパイル（hemlockc）

**入力:** AST
**出力:** Cコード生成によるネイティブ実行可能ファイル
**実装:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   ↓
型チェック: コンパイル時に型を検証
   ↓
Cコード生成: 同等のCコードを生成
   ↓
GCC: Cをネイティブバイナリにコンパイル
   ↓
結果: スタンドアロン実行可能ファイル
```

**主な特徴:**
- コンパイル時型チェック（デフォルトで有効）
- 移植性のためのCコード生成
- `libhemlock_runtime.a`にリンク
- インタプリタよりも大幅に高速な実行

---

## コンパイラバックエンド（hemlockc）

HemlockコンパイラはASTからCコードを生成し、GCCを使用してネイティブ実行可能ファイルにコンパイルします。

### コンパイラアーキテクチャ

```
src/backends/compiler/
├── main.c              # CLI、引数解析、オーケストレーション
├── codegen.c           # コアコード生成コンテキスト
├── codegen_expr.c      # 式のコード生成
├── codegen_stmt.c      # 文のコード生成
├── codegen_call.c      # 関数呼び出し生成
├── codegen_closure.c   # クロージャ実装
├── codegen_program.c   # トップレベルプログラム生成
├── codegen_module.c    # モジュール/インポート処理
├── type_check.c        # コンパイル時型チェック
└── type_check.h        # 型チェッカーAPI
```

### 型チェック

コンパイラには統一された型チェックシステムが含まれており、以下を行います:

1. **コンパイル時に型を検証** - 実行前に型エラーをキャッチ
2. **動的コードをサポート** - 型なしコードは`any`として扱われる（常に有効）
3. **最適化ヒントを提供** - アンボックス可能な変数を識別

**型チェックフラグ:**

| フラグ | 説明 |
|------|-------------|
| (デフォルト) | 型チェック有効 |
| `--check` | 型チェックのみ、コンパイルしない |
| `--no-type-check` | 型チェックを無効化 |
| `--strict-types` | 暗黙の`any`型で警告 |

**型チェッカー実装:**

```c
// type_check.h - 主要な構造体
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // 最適化ヒント
    // ... 型環境、定義など
} TypeCheckContext;

// メインエントリポイント
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### コード生成

codegen フェーズはASTノードをCコードに変換します:

**式のマッピング:**
```
Hemlock                 →  生成されるC
----------------------------------------
let x = 42;            →  HmlValue x = hml_val_i32(42);
x + y                  →  hml_add(x, y)
arr[i]                 →  hml_array_get(arr, i)
obj.field              →  hml_object_get_field(obj, "field")
fn(a, b) { ... }       →  環境キャプチャ付きクロージャ
```

**ランタイム統合:**

生成されたCコードは`libhemlock_runtime.a`にリンクし、以下を提供します:
- `HmlValue`タグ付きユニオン型
- メモリ管理（参照カウント）
- 組み込み関数（print、typeofなど）
- 並行処理プリミティブ（タスク、チャネル）
- FFIサポート

### アンボックス最適化

型チェッカーは、ボックス化された`HmlValue`の代わりにネイティブC型を使用できる変数を識別します:

**アンボックス可能なパターン:**
- 既知の整数型を持つループカウンター
- ループ内のアキュムレータ変数
- 明示的な型注釈を持つ変数（i32、i64、f64、bool）

```hemlock
// ループカウンター 'i' はネイティブint32_tにアンボックス可能
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## モジュラーインタプリタ設計

インタプリタは、保守性とスケーラビリティのために、焦点を絞ったモジュールに分割されています。

### モジュールの責務

#### 1. 環境（`environment.c`）- 121行

**目的:** 変数スコープと名前解決

**主要関数:**
- `env_create()` - オプションの親を持つ新しい環境を作成
- `env_define()` - 現在のスコープに新しい変数を定義
- `env_get()` - 現在または親スコープで変数を検索
- `env_set()` - 既存の変数値を更新
- `env_free()` - 環境とすべての変数を解放

**設計:**
- リンクされたスコープ（各環境は親へのポインタを持つ）
- 高速な変数検索のためのHashMap
- クロージャのレキシカルスコープをサポート

#### 2. 値（`values.c`）- 394行

**目的:** 値コンストラクタとデータ構造管理

**主要関数:**
- `value_create_*()` - 各値型のコンストラクタ
- `value_copy()` - ディープ/シャローコピーロジック
- `value_free()` - クリーンアップとメモリ解放
- `value_to_string()` - 印刷用の文字列表現

**データ構造:**
- オブジェクト（動的フィールド配列）
- 配列（動的リサイズ）
- バッファ（ptr + length + capacity）
- クロージャ（関数 + キャプチャされた環境）
- タスクとチャネル（並行処理プリミティブ）

#### 3. 型（`types.c`）- 440行

**目的:** 型システム、変換、ダックタイピング

**主要関数:**
- `type_check()` - ランタイム型検証
- `type_convert()` - 暗黙の型変換/プロモーション
- `duck_type_check()` - オブジェクトの構造的型チェック
- `type_name()` - 印刷可能な型名を取得

**機能:**
- 型プロモーション階層（i8 → i16 → i32 → i64 → f32 → f64、i64/u64 + f32 → f64）
- 数値型の範囲チェック
- オブジェクト型定義のダックタイピング
- オプションフィールドのデフォルト値

#### 4. 組み込み関数（`builtins.c`）- 955行

**目的:** 組み込み関数とグローバル登録

**主要関数:**
- `register_builtins()` - すべての組み込み関数と定数を登録
- 組み込み関数の実装（print、typeof、alloc、freeなど）
- シグナル処理関数
- コマンド実行（exec）

**組み込み関数のカテゴリ:**
- I/O: print、open、read_file、write_file
- メモリ: alloc、free、memset、memcpy、realloc
- 型: typeof、assert
- 並行処理: spawn、join、detach、channel
- システム: exec、signal、raise、panic
- FFI: dlopen、dlsym、dlcall、dlclose

#### 5. I/O（`io.c`）- 449行

**目的:** ファイルI/OとJSONシリアライゼーション

**主要関数:**
- ファイルオブジェクトメソッド（read、write、seek、tell、close）
- JSONシリアライゼーション/デシリアライゼーション
- 循環参照検出

**機能:**
- プロパティを持つファイルオブジェクト（path、mode、closed）
- UTF-8対応テキストI/O
- バイナリI/Oサポート
- オブジェクトと配列のJSONラウンドトリップ

#### 6. FFI（`ffi.c`）- 外部関数インターフェース

**目的:** 共有ライブラリからC関数を呼び出す

**主要関数:**
- `dlopen()` - 共有ライブラリをロード
- `dlsym()` - 名前で関数ポインタを取得
- `dlcall()` - 型変換付きでC関数を呼び出す
- `dlclose()` - ライブラリをアンロード

**機能:**
- 動的関数呼び出しのためのlibffi統合
- 自動型変換（Hemlock ↔ C型）
- すべてのプリミティブ型をサポート
- ポインタとバッファのサポート

#### 7. ランタイム（`runtime.c`）- 865行

**目的:** 式の評価と文の実行

**主要関数:**
- `eval_expr()` - 式を評価（再帰的）
- `eval_stmt()` - 文を実行
- 制御フロー処理（if、while、for、switchなど）
- 例外処理（try/catch/finally/throw）

**機能:**
- 再帰的な式評価
- ブール演算の短絡評価
- メソッド呼び出し検出と`self`バインディング
- 例外伝播
- break/continue/return処理

### モジュラー設計の利点

**1. 関心の分離**
- 各モジュールは1つの明確な責務を持つ
- 機能がどこに実装されているか見つけやすい
- 変更時の認知負荷を軽減

**2. より高速なインクリメンタルビルド**
- 変更されたモジュールのみ再コンパイルが必要
- 並列コンパイルが可能
- 開発中のイテレーション時間を短縮

**3. より簡単なテストとデバッグ**
- モジュールを単独でテスト可能
- バグは特定のサブシステムに限定
- テスト用のモック実装が可能

**4. スケーラビリティ**
- 新機能を適切なモジュールに追加可能
- モジュールを独立してリファクタリング可能
- ファイルごとのコードサイズが管理可能

**5. コード構成**
- 関連機能の論理的なグルーピング
- 明確な依存関係グラフ
- 新しい貢献者のオンボーディングが容易

---

## ランタイムアーキテクチャ

### 値の表現

Hemlockのすべての値は、タグ付きユニオンを使用する`Value`構造体で表現されます:

```c
typedef struct Value {
    ValueType type;  // ランタイム型タグ
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**設計上の決定:**
- 柔軟性を維持しながら型安全性を確保する**タグ付きユニオン**
- 動的型付けと型チェックを可能にする**ランタイム型タグ**
- プリミティブ用の**直接値ストレージ**（ボックス化なし）
- ヒープ割り当て型用の**ポインタストレージ**（文字列、オブジェクト、配列）

### メモリレイアウト例

**整数（i32）:**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- 合計サイズ: 約16バイト（8バイトタグ + 8バイトユニオン）
- スタック割り当て
- ヒープ割り当て不要

**文字列:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // ヒープへのポインタ
}

ヒープ: "hello\0"（6バイト、null終端UTF-8）
```
- 値はスタック上で16バイト
- 文字列データはヒープ割り当て
- 手動で解放が必要

**オブジェクト:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // ヒープへのポインタ
}

ヒープ: Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- オブジェクト構造はヒープ上
- フィールドは動的配列に格納
- フィールド値は埋め込まれたValue構造体

### 環境の実装

変数は環境チェーンに格納されます:

```c
typedef struct Environment {
    HashMap *bindings;           // name → Value
    struct Environment *parent;  // レキシカル親スコープ
} Environment;
```

**スコープチェーンの例:**
```
グローバルスコープ: { print: <builtin>, args: <array> }
    ↑
関数スコープ: { x: 10, y: 20 }
    ↑
ブロックスコープ: { i: 0 }
```

**検索アルゴリズム:**
1. 現在の環境のハッシュマップをチェック
2. 見つからない場合、親環境をチェック
3. 見つかるかグローバルスコープに達するまで繰り返す
4. どのスコープでも見つからない場合はエラー

---

## 型システムの実装

### 型チェック戦略

Hemlockは**オプションの型注釈**付きの**ランタイム型チェック**を使用します:

```hemlock
let x = 42;           // 型チェックなし、i32を推論
let y: u8 = 255;      // ランタイムチェック: 値はu8に収まる必要あり
let z: i32 = x + y;   // ランタイムチェック + 型プロモーション
```

**実装フロー:**
1. **リテラル推論** - レキサー/パーサーがリテラルから初期型を決定
2. **型注釈チェック** - 注釈がある場合、代入時に検証
3. **プロモーション** - 二項演算は共通型にプロモート
4. **変換** - 明示的な変換はオンデマンドで発生

### 型プロモーションの実装

型プロモーションは、精度を保持する固定階層に従います:

```c
// 簡略化されたプロモーションロジック
ValueType promote_types(ValueType a, ValueType b) {
    // f64は常に勝つ
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32とi64/u64はf64にプロモート（精度保持）
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // 大きい整数型が勝つ
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**型ランク:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### ダックタイピングの実装

オブジェクトの型チェックは構造的比較を使用します:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // すべての必須フィールドをチェック
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // フィールドが見つからない
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // 型が違う
        }
    }

    return true;  // すべての必須フィールドが存在し、正しい型
}
```

**ダックタイピングで許可されること:**
- オブジェクトの余分なフィールド（無視される）
- 部分構造型付け（オブジェクトは必要以上のものを持てる）
- 検証後の型名の割り当て

---

## メモリ管理

### 割り当て戦略

Hemlockは2つの割り当てプリミティブを持つ**手動メモリ管理**を使用します:

**1. 生ポインタ（`ptr`）:**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return ptr;
}
```
- 直接malloc/free
- トラッキングなし
- ユーザーの責任で解放

**2. バッファ（`buffer`）:**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- サイズと容量を追跡
- アクセス時の境界チェック
- それでも手動freeが必要

### ヒープ割り当て型

**文字列:**
- ヒープ上のUTF-8バイト配列
- Cとの相互運用のためnull終端
- 変更可能（その場で変更可能）
- 参照カウント（スコープ終了時に自動解放）

**オブジェクト:**
- 動的フィールド配列
- フィールド名と値はヒープ上
- 参照カウント（スコープ終了時に自動解放）
- 循環参照の可能性あり（訪問済みセットトラッキングで処理）

**配列:**
- 動的な容量倍増成長
- 要素は埋め込まれたValue構造体
- 成長時の自動再割り当て
- 参照カウント（スコープ終了時に自動解放）

**クロージャ:**
- 参照によって環境をキャプチャ
- 環境はヒープ割り当て
- クロージャ環境は参照されなくなると適切に解放

---

## 並行処理モデル

### スレッディングアーキテクチャ

Hemlockは**1:1スレッディング**とPOSIXスレッド（pthreads）を使用します:

```
ユーザータスク        OSスレッド           CPUコア
---------          ---------          --------
spawn(f1) ------>  pthread_create --> コア0
spawn(f2) ------>  pthread_create --> コア1
spawn(f3) ------>  pthread_create --> コア2
```

**主な特徴:**
- 各`spawn()`は新しいpthreadを作成
- カーネルがスレッドをコア間でスケジュール
- 真の並列実行（GILなし）
- プリエンプティブマルチタスキング

### タスクの実装

```c
typedef struct Task {
    pthread_t thread;        // OSスレッドハンドル
    Value result;            // 戻り値
    char *error;             // 例外メッセージ（スローされた場合）
    pthread_mutex_t lock;    // 状態を保護
    TaskState state;         // RUNNING、FINISHED、ERROR
} Task;
```

**タスクのライフサイクル:**
1. `spawn(func, args)` → タスクを作成、pthreadを開始
2. スレッドが引数付きで関数を実行
3. 戻り時: 結果を格納、状態をFINISHEDに設定
4. 例外時: エラーメッセージを格納、状態をERRORに設定
5. `join(task)` → スレッドを待機、結果を返すか例外をスロー

### チャネルの実装

```c
typedef struct Channel {
    void **buffer;           // Value*の循環バッファ
    size_t capacity;         // 最大バッファアイテム数
    size_t count;            // バッファ内の現在のアイテム数
    size_t read_index;       // 次の読み取り位置
    size_t write_index;      // 次の書き込み位置
    bool closed;             // チャネルクローズフラグ
    pthread_mutex_t lock;    // バッファを保護
    pthread_cond_t not_full; // スペースが利用可能時のシグナル
    pthread_cond_t not_empty;// データが利用可能時のシグナル
} Channel;
```

**送信操作:**
1. mutexをロック
2. バッファがフルなら待機（not_fullでcond_wait）
3. buffer[write_index]に値を書き込み
4. write_indexをインクリメント（循環）
5. not_emptyをシグナル
6. mutexをアンロック

**受信操作:**
1. mutexをロック
2. バッファが空なら待機（not_emptyでcond_wait）
3. buffer[read_index]から値を読み取り
4. read_indexをインクリメント（循環）
5. not_fullをシグナル
6. mutexをアンロック

**同期保証:**
- スレッドセーフなsend/recv（mutexで保護）
- ブロッキングセマンティクス（プロデューサーはフルで待機、コンシューマーは空で待機）
- 順序付き配信（チャネル内でFIFO）

---

## 将来の計画

### 完了: コンパイラバックエンド ✓

コンパイラバックエンド（`hemlockc`）は以下で実装済み:
- ASTからのCコード生成
- コンパイル時型チェック（デフォルトで有効）
- ランタイムライブラリ（`libhemlock_runtime.a`）
- インタプリタとの完全なパリティ（98%のテスト合格率）
- アンボックス最適化フレームワーク

### 現在のフォーカス: 型システムの強化

**最近の改善:**
- 統一された型チェックと型推論システム
- コンパイル時型チェックがデフォルトで有効
- 型のみの検証用`--check`フラグ
- 最適化ヒント用のコード生成への型コンテキスト渡し

### 将来の強化

**潜在的な追加:**
- ジェネリクス/テンプレート
- パターンマッチング
- 型認識IDEサポートのためのLSP統合
- より積極的なアンボックス最適化
- スタック割り当てのためのエスケープ解析

### 長期的な最適化

**可能な改善:**
- メソッド呼び出しのインラインキャッシング
- ホットコードパスのJITコンパイル
- より良い並行処理のためのワークスティーリングスケジューラ
- プロファイルガイド最適化

---

## 実装ガイドライン

### 新機能の追加

新機能を実装する際は、以下のガイドラインに従ってください:

**1. 適切なモジュールを選択:**
- 新しい値型 → `values.c`
- 型変換 → `types.c`
- 組み込み関数 → `builtins.c`
- I/O操作 → `io.c`
- 制御フロー → `runtime.c`

**2. すべてのレイヤーを更新:**
- 必要に応じてASTノード型を追加（`ast.h`、`ast.c`）
- 必要に応じてレキサートークンを追加（`lexer.c`）
- パーサールールを追加（`parser.c`）
- ランタイム動作を実装（`runtime.c`または適切なモジュール）
- テストを追加（`tests/`）

**3. 一貫性を維持:**
- 既存のコードスタイルに従う
- 一貫した命名規則を使用
- ヘッダーでパブリックAPIをドキュメント化
- エラーメッセージを明確で一貫性のあるものにする

**4. 徹底的にテスト:**
- 実装前にテストケースを追加
- 成功とエラーのパスをテスト
- エッジケースをテスト
- メモリリークがないことを確認（valgrind）

### パフォーマンスの考慮事項

**現在のボトルネック:**
- 変数アクセスのHashMap検索
- 再帰関数呼び出し（TCOなし）
- 文字列連結（毎回新しい文字列を割り当て）
- すべての操作での型チェックオーバーヘッド

**最適化の機会:**
- 変数位置のキャッシュ（インラインキャッシング）
- 末尾呼び出し最適化
- 連結用文字列ビルダー
- ランタイムチェックをスキップする型推論

### デバッグのヒント

**便利なツール:**
- `valgrind` - メモリリーク検出
- `gdb` - クラッシュのデバッグ
- `-g`フラグ - デバッグシンボル
- `printf`デバッグ - シンプルだが効果的

**よくある問題:**
- セグフォルト → NULLポインタ参照（戻り値をチェック）
- メモリリーク → free()呼び出しの欠落（value_freeパスをチェック）
- 型エラー → type_convert()とtype_check()ロジックをチェック
- スレッドでのクラッシュ → 競合状態（mutex使用をチェック）

---

## 結論

Hemlockの実装は以下を優先しています:
- **モジュール性** - 関心の明確な分離
- **シンプルさ** - 直接的な実装
- **明示性** - 隠された魔法なし
- **保守性** - 理解と変更が容易

現在のツリーウォーキングインタプリタは、迅速な機能開発と実験を容易にするために意図的にシンプルにしています。将来のコンパイラバックエンドは、同じセマンティクスを維持しながらパフォーマンスを向上させます。


--------------------------------------------------------------------------------
## 設計思想
--------------------------------------------------------------------------------

# Hemlock言語設計哲学

> 「安全でないものを安全に書くための、小さな安全でない言語。」

このドキュメントは、Hemlockの核となる設計原則と哲学を説明します。言語に変更や追加を行う前に、まずこれをお読みください。

---

## 目次

- [コアアイデンティティ](#コアアイデンティティ)
- [設計原則](#設計原則)
- [安全性に関する哲学](#安全性に関する哲学)
- [追加すべきでないもの](#追加すべきでないもの)
- [将来の検討事項](#将来の検討事項)
- [最終的な考え](#最終的な考え)

---

## コアアイデンティティ

Hemlockは、手動メモリ管理と明示的な制御を採用した**システムスクリプト言語**です。以下を求めるプログラマー向けに設計されています:

- Cの力
- 現代的なスクリプト言語の人間工学
- 組み込みの構造化非同期並行処理
- 隠された動作や魔法なし

### HemlockでないもNOT

- **メモリセーフ**（ダングリングポインタはあなたの責任）
- **Rust、Go、Luaの代替**
- **複雑さを隠す言語**

### Hemlockであるもの

- **常に暗黙より明示**
- **教育的かつ実験的**
- **システム作業のための「Cスクリプト層」**
- **トレードオフについて正直**

---

## 設計原則

### 1. 暗黙より明示

Hemlockはすべての言語構文で明示性を重視します。驚き、魔法、隠された動作があってはなりません。

**悪い例（暗黙）:**
```hemlock
let x = 5  // セミコロンがない - エラーになるべき
```

**良い例（明示）:**
```hemlock
let x = 5;
free(ptr);  // あなたが割り当てたなら、あなたが解放する
```

**重要な側面:**
- セミコロンは必須（自動セミコロン挿入なし）
- ガベージコレクションなし
- 手動メモリ管理（alloc/free）
- 型注釈はオプションだが、実行時にチェックされる
- 自動リソースクリーンアップなし（RAIIなし）、ただし`defer`が明示的なクリーンアップを提供

### 2. デフォルトで動的、選択で型付き

すべての値はランタイム型タグを持ちますが、システムは柔軟でありながらエラーをキャッチするように設計されています。

**型推論:**
- 小さい整数（i32に収まる）: `42` → `i32`
- 大きい整数（> i32範囲）: `9223372036854775807` → `i64`
- 浮動小数点: `3.14` → `f64`

**必要に応じた明示的な型付け:**
```hemlock
let x = 42;              // i32推論（小さい値）
let y: u8 = 255;         // 明示的なu8
let z = x + y;           // i32にプロモート
let big = 5000000000;    // i64推論（> i32最大値）
```

**型プロモーション規則**は、最小から最大への明確な階層に従い、浮動小数点は常に整数に勝ちます。

### 3. 安全でないことは機能であり、バグではない

Hemlockはすべてのエラーを防ごうとはしません。代わりに、安全であるためのツールを提供しながら、必要に応じて安全でない動作を選択できるようにします。

**意図的な安全でなさの例:**
- ポインタ算術はオーバーフローする可能性がある（ユーザーの責任）
- 生の`ptr`に境界チェックなし（安全性が必要なら`buffer`を使用）
- ダブルフリーによるクラッシュは許可（手動メモリ管理）
- 型システムは事故を防ぐが、必要に応じて危険な操作も許可

```hemlock
let p = alloc(10);
let q = p + 100;  // 割り当てを大きく超えている - 許可されるが危険
```

**哲学:** 型システムは*事故*を防ぐべきだが、*意図的な*安全でない操作は許可すべき。

### 4. 構造化並行処理がファーストクラス

並行処理はHemlockにおいて後付けではありません。最初から言語に組み込まれています。

**主な機能:**
- `async`/`await`が言語に組み込み
- 通信用チャネル
- タスク管理のための`spawn`/`join`/`detach`
- 生スレッドなし、ロックなし - 構造化のみ
- POSIXスレッドを使用した真のマルチスレッド並列処理

**イベントループやグリーンスレッドではない** - Hemlockは複数のCPUコアにわたる真の並列処理のために実際のOSスレッドを使用します。

### 5. C風の構文、低セレモニー

Hemlockはシステムプログラマーにとって馴染みやすく、ボイラープレートを減らします。

**設計上の選択:**
- 常に`{}`ブロック、オプションの括弧なし
- 演算子はCと一致: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- 型構文はRust/TypeScriptと一致: `let x: type = value;`
- 関数はファーストクラスの値
- 最小限のキーワードと特殊形式

---

## 安全性に関する哲学

**Hemlockの安全性に対する見解:**

> 「安全であるためのツール（`buffer`、型注釈、境界チェック）を提供しますが、それらを使うことを強制しません（`ptr`、手動メモリ、安全でない操作）。
>
> デフォルトは安全に導くべきですが、エスケープハッチは常に利用可能であるべきです。」

### 提供される安全ツール

**1. 安全なbuffer型:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // 境界チェック付き
print(b.length);        // 64
free(b);                // それでも手動
```

**2. 安全でない生ポインタ:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // 解放を覚えておく必要がある
```

**3. 型注釈:**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // エラー: 範囲外
```

**4. ランタイム型チェック:**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // 整数として安全に使用できる
}
```

### 指針

1. **ドキュメントでは安全なパターンをデフォルトに** - `ptr`より先に`buffer`を示し、型注釈を推奨
2. **安全でない操作を明確に** - 生ポインタ算術は意図的に見えるべき
3. **エスケープハッチを提供** - 経験豊富なユーザーが低レベルの作業をすることを妨げない
4. **トレードオフについて正直に** - 何が問題になる可能性があるかをドキュメント化

### 安全 vs 安全でないの例

| 安全なパターン | 安全でないパターン | 安全でないを使うとき |
|-------------|----------------|-------------------|
| `buffer`型 | `ptr`型 | FFI、パフォーマンス重視のコード |
| 型注釈 | 注釈なし | 外部インターフェース、検証 |
| 境界チェック付きアクセス | ポインタ算術 | 低レベルメモリ操作 |
| 例外処理 | null/エラーコードを返す | 例外が重すぎる場合 |

---

## 追加すべきでないもの

何を追加し**ない**かを理解することは、何を追加するかを知ることと同じくらい重要です。

### ❌ 暗黙の動作を追加しない

**悪い例:**

```hemlock
// 悪い: 自動セミコロン挿入
let x = 5
let y = 10

// 悪い: 精度を失う暗黙の型変換
let x: i32 = 3.14  // 切り捨てるべき？エラーにすべき？
```

**理由:** 暗黙の動作は驚きを生み、コードの推論を難しくします。

### ❌ 複雑さを隠さない

**悪い例:**

```hemlock
// 悪い: 裏での魔法の最適化
let arr = [1, 2, 3]  // これはスタック？ヒープ？ユーザーは知るべき！（ヒープ、参照カウント）

// 悪い: 生ポインタの自動解放
let p = alloc(100)  // これは自動解放される？いいえ！生ptrは常にfree()が必要
```

**参照カウントについての注記:** Hemlockは文字列、配列、オブジェクト、バッファに内部参照カウントを使用しています - これらはスコープ終了時に自動解放されます。これは明示的で予測可能です（参照が0になると決定論的クリーンアップ、GCポーズなし）。生ポインタ（`alloc()`からの`ptr`）は参照カウントされず、常に手動`free()`が必要です。

**理由:** 隠された複雑さはパフォーマンスの予測と問題のデバッグを不可能にします。

### ❌ 既存のセマンティクスを壊さない

**これらの核となる決定を変更しない:**
- セミコロンは必須 - オプションにしない
- 手動メモリ管理 - GCを追加しない
- 変更可能な文字列 - 不変にしない
- ランタイム型チェック - 削除しない

**理由:** 一貫性と安定性は流行の機能より重要です。

### ❌ 明示性を減らす「便利な」機能を追加しない

**避けるべき機能の例:**
- 演算子オーバーロード（ユーザー型には可能かもしれないが、慎重に）
- 情報を失う暗黙の型強制
- 自動リソースクリーンアップ（RAII）
- 複雑さを隠すメソッドチェーン
- DSLと魔法の構文

**例外:** 便利な機能は、単純な操作の**明示的なシンタックスシュガー**であればOK:
- `else if`は問題ない（ネストされたif文にすぎない）
- 文字列補間は明確にシンタックスシュガーならOKかもしれない
- オブジェクトのメソッド構文は問題ない（何をするか明示的）

---

## 将来の検討事項

### 追加するかもしれない（検討中）

これらの機能はHemlockの哲学に沿っていますが、慎重な設計が必要です:

**1. パターンマッチング**
```hemlock
match (value) {
    case i32: print("integer");
    case string: print("text");
    case _: print("other");
}
```
- 明示的な型チェック
- 隠れたコストなし
- コンパイル時の網羅性チェックが可能

**2. エラー型（`Result<T, E>`）**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("division by zero");
    }
    return Ok(a / b);
}
```
- 明示的なエラー処理
- ユーザーにエラーについて考えさせる
- 例外の代替

**3. 配列/スライス型**
- 動的配列は既にある
- スタック割り当て用の固定サイズ配列を追加できる
- スタック vs ヒープについて明示的である必要がある

**4. 改善されたメモリ安全ツール**
- オプションの境界チェックフラグ
- デバッグビルドでのメモリリーク検出
- サニタイザ統合

### おそらく追加しない

これらの機能は核となる原則に違反します:

**1. ガベージコレクション**
- メモリ管理の複雑さを隠す
- 予測不可能なパフォーマンス
- 明示的制御の原則に反する

**2. 自動メモリ管理**
- GCと同じ理由
- 参照カウントは明示的ならOKかもしれない

**3. データを失う暗黙の型変換**
- 「暗黙より明示」に反する
- 微妙なバグの原因

**4. マクロ（複雑なもの）**
- 力が強すぎ、複雑すぎ
- シンプルなマクロシステムならOKかもしれない
- コード生成や関数を推奨

**5. 継承を持つクラスベースOOP**
- 暗黙の動作が多すぎる
- ダックタイピングとオブジェクトで十分
- 継承より合成

**6. 複雑な解決を持つモジュールシステム**
- インポートはシンプルで明示的に
- 魔法の検索パスなし
- バージョン解決なし（OSパッケージマネージャを使用）

---

## 最終的な考え

### 信頼と責任

Hemlockは**信頼と責任**についてです。プログラマーが以下を行うことを信頼します:

- メモリを正しく管理する
- 型を適切に使用する
- エラーを適切に処理する
- トレードオフを理解する

見返りに、Hemlockは以下を提供します:

- 隠れたコストなし
- 驚きの動作なし
- 必要な時の完全な制御
- 望むときの安全ツール

### 指針となる質問

**新機能を検討するとき、尋ねてください:**

> 「これはプログラマーにより明示的な制御を与えるか、それとも何かを隠すか？」

- **明示的な制御を追加する**なら → おそらくHemlockに適している
- **複雑さを隠す**なら → おそらく属さない
- 明確にドキュメント化された**オプショナルシュガー**なら → OKかもしれない

### 良い追加の例

✅ **Switch文** - 明示的な制御フロー、魔法なし、明確なセマンティクス

✅ **pthreadsを使ったAsync/await** - 明示的な並行処理、真の並列処理、ユーザーがスポーンを制御

✅ **ptrと並ぶBuffer型** - 安全と安全でないの選択を与える

✅ **オプションの型注釈** - 厳密さを強制せずにバグをキャッチ

✅ **Try/catch/finally** - 明確な制御フローを持つ明示的なエラー処理

### 悪い追加の例

❌ **自動セミコロン挿入** - 構文エラーを隠し、コードを曖昧にする

❌ **RAII/デストラクタ** - 自動クリーンアップはリソースがいつ解放されるか隠す

❌ **暗黙のnull合体** - nullチェックを隠し、コードの推論を難しくする

❌ **自動成長文字列** - メモリ割り当てを隠し、予測不可能なパフォーマンス

---

## 結論

Hemlockは最も安全な言語、最速の言語、最も機能豊富な言語になろうとしていません。

**Hemlockは最も*正直な*言語になろうとしています。**

正確に何をしているかを伝え、必要なときに制御を与え、鋭い角を隠しません。低レベルでコードを理解したいが、現代的な人間工学も楽しみたい人のための言語です。

機能がHemlockに属するかどうかわからない場合は、覚えておいてください:

> **常に暗黙より明示。**
> **安全でないことは機能であり、バグではない。**
> **ユーザーに責任がある、それでOK。**



################################################################################
# コントリビューション
################################################################################

--------------------------------------------------------------------------------
## ガイドライン
--------------------------------------------------------------------------------

# Hemlockへの貢献

Hemlockへの貢献にご興味をお持ちいただき、ありがとうございます！このガイドでは、言語の設計哲学とコード品質を維持しながら効果的に貢献する方法を説明します。

---

## 目次

- [始める前に](#始める前に)
- [貢献ワークフロー](#貢献ワークフロー)
- [コードスタイルガイドライン](#コードスタイルガイドライン)
- [貢献すべきもの](#貢献すべきもの)
- [貢献すべきでないもの](#貢献すべきでないもの)
- [共通パターン](#共通パターン)
- [新機能の追加](#新機能の追加)
- [コードレビュープロセス](#コードレビュープロセス)

---

## 始める前に

### 必読ドキュメント

貢献する前に、以下のドキュメントを順番にお読みください:

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Hemlockの核となる原則を理解する
2. **`/home/user/hemlock/docs/design/implementation.md`** - コードベースの構造を学ぶ
3. **`/home/user/hemlock/docs/contributing/testing.md`** - テスト要件を理解する
4. **このドキュメント** - 貢献ガイドラインを学ぶ

### 前提条件

**必要な知識:**
- Cプログラミング（ポインタ、メモリ管理、構造体）
- コンパイラ/インタプリタの基礎（字句解析、構文解析、AST）
- GitとGitHubワークフロー
- Unix/Linuxコマンドライン

**必要なツール:**
- GCCまたはClangコンパイラ
- Makeビルドシステム
- Gitバージョン管理
- Valgrind（メモリリーク検出用）
- 基本的なテキストエディタまたはIDE

### コミュニケーションチャネル

**質問する場所:**
- GitHub Issues - バグ報告と機能リクエスト
- GitHub Discussions - 一般的な質問と設計の議論
- Pull Requestコメント - 具体的なコードフィードバック

---

## 貢献ワークフロー

### 1. Issueを見つけるか作成する

**コードを書く前に:**
- あなたの貢献に関するIssueが存在するか確認
- なければ、何をしたいか説明するIssueを作成
- 大きな変更を始める前にメンテナーのフィードバックを待つ
- 小さなバグ修正はこのステップをスキップ可能

**良いIssue説明には以下を含む:**
- 問題の説明（何が壊れているか、何が欠けているか）
- 提案する解決策（どのように修正するか）
- 例（問題を示すコードスニペット）
- 根拠（この変更がHemlockの哲学に沿う理由）

### 2. フォークとクローン

```bash
# まずGitHub上でリポジトリをフォークし、その後:
git clone https://github.com/YOUR_USERNAME/hemlock.git
cd hemlock
git checkout -b feature/your-feature-name
```

### 3. 変更を行う

以下のガイドラインに従ってください:
- 最初にテストを書く（TDDアプローチ）
- 機能を実装する
- すべてのテストが合格することを確認
- メモリリークをチェック
- ドキュメントを更新

### 4. 変更をテストする

```bash
# 完全なテストスイートを実行
make test

# 特定のテストカテゴリを実行
./tests/run_tests.sh tests/category/

# メモリリークをチェック
valgrind ./hemlock tests/your_test.hml

# ビルドとテスト
make clean && make && make test
```

### 5. 変更をコミットする

**良いコミットメッセージ:**
```
整数型にビット演算子を追加

- &, |, ^, <<, >>, ~ 演算子を実装
- 整数のみの演算を保証する型チェックを追加
- 演算子優先順位テーブルを更新
- すべての演算子に対する包括的なテストを追加

Closes #42
```

**コミットメッセージの形式:**
- 1行目: 簡潔な要約（最大50文字）
- 空行
- 詳細な説明（72文字で折り返し）
- Issue番号を参照

### 6. Pull Requestを提出する

**提出前に:**
- 最新のmainブランチにリベース
- すべてのテストが合格することを確認
- valgrindを実行してリークをチェック
- ユーザー向け機能を追加する場合はCLAUDE.mdを更新

**Pull Request説明には以下を含める:**
- これが解決する問題
- どのように解決するか
- 破壊的変更（ある場合）
- 新しい構文や動作の例
- テストカバレッジの要約

---

## コードスタイルガイドライン

### Cコードスタイル

**フォーマット:**
```c
// 4スペースでインデント（タブなし）
// 関数はK&R括弧スタイル
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // 制御構造では同じ行に括弧
        do_something();
    }
}

// 行の長さ: 最大100文字
// 演算子の周りにスペース
int result = (a + b) * c;

// ポインタのアスタリスクは型と一緒
char *string;   // 良い
char* string;   // 避ける
char * string;  // 避ける
```

**命名規則:**
```c
// 関数: lowercase_with_underscores
void eval_expression(ASTNode *node);

// 型: PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// 定数: UPPERCASE_WITH_UNDERSCORES
#define MAX_BUFFER_SIZE 4096

// 変数: lowercase_with_underscores
int item_count;
Value *current_value;

// 列挙型: TYPE_PREFIX_NAME
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**コメント:**
```c
// 簡潔な説明には単一行コメント
// 適切な大文字で完全な文を使用

/*
 * 長い説明には複数行コメント
 * 読みやすさのためにアスタリスクを揃える
 */

/**
 * 関数のドキュメントコメント
 * @param node - 評価するASTノード
 * @return 評価された値
 */
Value eval_expr(ASTNode *node);
```

**エラー処理:**
```c
// すべてのmalloc呼び出しをチェック
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Error: Out of memory\n");
    exit(1);
}

// エラーメッセージにコンテキストを提供
if (file == NULL) {
    fprintf(stderr, "Error: Failed to open '%s': %s\n",
            filename, strerror(errno));
    exit(1);
}

// 意味のあるエラーメッセージを使用
// 悪い: "Error: Invalid value"
// 良い: "Error: Expected integer, got string"
```

**メモリ管理:**
```c
// 割り当てたものは常に解放
Value *val = value_create_i32(42);
// ... valを使用
value_free(val);

// 解放後にポインタをNULLに設定（ダブルフリー防止）
free(ptr);
ptr = NULL;

// コメントで所有権をドキュメント化
// この関数は 'value' の所有権を取得し、解放します
void store_value(Value *value);

// この関数は所有権を取得しません（呼び出し側が解放）
Value *get_value(void);
```

### コード構成

**ファイル構造:**
```c
// 1. インクルード（システムヘッダーが先、次にローカル）
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. 定数とマクロ
#define INITIAL_CAPACITY 16

// 3. 型定義
typedef struct Foo Foo;

// 4. 静的関数宣言（内部ヘルパー）
static void helper_function(void);

// 5. パブリック関数の実装
void public_api_function(void)
{
    // 実装
}

// 6. 静的関数の実装
static void helper_function(void)
{
    // 実装
}
```

**ヘッダーファイル:**
```c
// ヘッダーガードを使用
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// 前方宣言
typedef struct Value Value;

// ヘッダーにはパブリックAPIのみ
void public_function(Value *val);

// パラメータと戻り値をドキュメント化
/**
 * 式ASTノードを評価する
 * @param node - 評価するASTノード
 * @param env - 現在の環境
 * @return 結果値
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## 貢献すべきもの

### ✅ 推奨される貢献

**バグ修正:**
- メモリリーク
- セグメンテーションフォルト
- 不正確な動作
- エラーメッセージの改善

**ドキュメント:**
- コードコメント
- APIドキュメント
- ユーザーガイドとチュートリアル
- サンプルプログラム
- テストケースドキュメント

**テスト:**
- 既存機能の追加テストケース
- エッジケースカバレッジ
- 修正されたバグの回帰テスト
- パフォーマンスベンチマーク

**小規模な機能追加:**
- 新しい組み込み関数（哲学に合う場合）
- 文字列/配列メソッド
- ユーティリティ関数
- エラー処理の改善

**パフォーマンス改善:**
- より高速なアルゴリズム（セマンティクスを変更せずに）
- メモリ使用量の削減
- ベンチマークスイート
- プロファイリングツール

**ツーリング:**
- エディタの構文ハイライト
- 言語サーバープロトコル（LSP）
- デバッガ統合
- ビルドシステムの改善

### 🤔 まず議論すること

**主要な機能:**
- 新しい言語構文
- 型システムの変更
- 構文の追加
- 並行処理プリミティブ

**議論の方法:**
1. GitHub IssueまたはDiscussionを開く
2. 機能と根拠を説明
3. サンプルコードを示す
4. Hemlockの哲学にどう合うか説明
5. メンテナーのフィードバックを待つ
6. 実装前に設計を反復

---

## 貢献すべきでないもの

### ❌ 推奨されない貢献

**以下のような機能を追加しない:**
- ユーザーから複雑さを隠す
- 動作を暗黙的または魔法的にする
- 既存のセマンティクスや構文を壊す
- ガベージコレクションや自動メモリ管理を追加
- 「暗黙より明示」の原則に違反

**却下される貢献の例:**

**1. 自動セミコロン挿入**
```hemlock
// 悪い: これは却下されます
let x = 5  // セミコロンなし
let y = 10 // セミコロンなし
```
理由: 構文を曖昧にし、エラーを隠す

**2. RAII/デストラクタ**
```hemlock
// 悪い: これは却下されます
let f = open("file.txt");
// スコープ終了時にファイルが自動的にクローズ
```
理由: リソースがいつ解放されるか隠す、明示的ではない

**3. データを失う暗黙の型強制**
```hemlock
// 悪い: これは却下されます
let x: i32 = 3.14;  // 黙って3に切り捨て
```
理由: データ損失は暗黙ではなく明示的であるべき

**4. ガベージコレクション**
```c
// 悪い: これは却下されます
void *gc_malloc(size_t size) {
    // 自動クリーンアップのために割り当てを追跡
}
```
理由: メモリ管理を隠す、予測不可能なパフォーマンス

**5. 複雑なマクロシステム**
```hemlock
// 悪い: これは却下されます
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
理由: 魔法が多すぎ、コードの推論が難しくなる

### 一般的な却下理由

**「これは暗黙的すぎる」**
- 解決策: 動作を明示的にしてドキュメント化

**「これは複雑さを隠す」**
- 解決策: 複雑さを露出させつつ人間工学的にする

**「これは既存のコードを壊す」**
- 解決策: 破壊的でない代替案を見つけるか、バージョニングを議論

**「これはHemlockの哲学に合わない」**
- 解決策: philosophy.mdを再読し、アプローチを再検討

---

## 共通パターン

### エラー処理パターン

```c
// Hemlockコードでの回復可能なエラーにはこのパターンを使用
Value *divide(Value *a, Value *b)
{
    // 前提条件をチェック
    if (b->type != TYPE_I32) {
        // エラー値を返すか例外をスロー
        return create_error("Expected integer divisor");
    }

    if (b->i32_value == 0) {
        return create_error("Division by zero");
    }

    // 操作を実行
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### メモリ管理パターン

```c
// パターン: 割り当て、使用、解放
void process_data(void)
{
    // 割り当て
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // 使用
    if (buf && str) {
        // ... 作業を行う
    }

    // 解放（割り当ての逆順で）
    free(str);
    free_buffer(buf);
}
```

### 値作成パターン

```c
// コンストラクタを使用して値を作成
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### 型チェックパターン

```c
// 操作前に型をチェック
Value *add_values(Value *a, Value *b)
{
    // 型チェック
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("Type mismatch");
    }

    // 安全に進行
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### 文字列構築パターン

```c
// 効率的に文字列を構築
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Error: %s (line %d)", detail, line_number);
}
```

---

## 新機能の追加

### 機能追加チェックリスト

新機能を追加する際は、以下のステップに従ってください:

#### 1. 設計フェーズ

- [ ] philosophy.mdを読んで整合性を確認
- [ ] 機能を説明するGitHub Issueを作成
- [ ] 設計のメンテナー承認を取得
- [ ] 仕様を書く（構文、セマンティクス、例）
- [ ] エッジケースとエラー条件を検討

#### 2. 実装フェーズ

**言語構文を追加する場合:**

- [ ] `lexer.h`にトークン型を追加（必要に応じて）
- [ ] `lexer.c`にレキサールールを追加（必要に応じて）
- [ ] `ast.h`にASTノード型を追加
- [ ] `ast.c`にASTコンストラクタを追加
- [ ] `parser.c`にパーサールールを追加
- [ ] `runtime.c`または適切なモジュールにランタイム動作を追加
- [ ] ASTフリー関数でクリーンアップを処理

**組み込み関数を追加する場合:**

- [ ] `builtins.c`に関数実装を追加
- [ ] `register_builtins()`で関数を登録
- [ ] すべてのパラメータ型の組み合わせを処理
- [ ] 適切なエラー値を返す
- [ ] パラメータと戻り値型をドキュメント化

**値型を追加する場合:**

- [ ] `values.h`に型列挙型を追加
- [ ] Valueユニオンにフィールドを追加
- [ ] `values.c`にコンストラクタを追加
- [ ] クリーンアップ用に`value_free()`に追加
- [ ] コピー用に`value_copy()`に追加
- [ ] 印刷用に`value_to_string()`に追加
- [ ] 数値の場合は型プロモーションルールを追加

#### 3. テストフェーズ

- [ ] テストケースを書く（testing.mdを参照）
- [ ] 成功ケースをテスト
- [ ] エラーケースをテスト
- [ ] エッジケースをテスト
- [ ] 完全なテストスイートを実行（`make test`）
- [ ] valgrindでメモリリークをチェック
- [ ] 可能であれば複数のプラットフォームでテスト

#### 4. ドキュメントフェーズ

- [ ] ユーザー向けドキュメントでCLAUDE.mdを更新
- [ ] 実装を説明するコードコメントを追加
- [ ] `examples/`に例を作成
- [ ] 関連するdocs/ファイルを更新
- [ ] 破壊的変更をドキュメント化

#### 5. 提出フェーズ

- [ ] デバッグコードとコメントをクリーンアップ
- [ ] コードスタイル準拠を確認
- [ ] 最新のmainにリベース
- [ ] 詳細な説明付きでPull Requestを作成
- [ ] コードレビューフィードバックに対応

### 例: 新しい演算子の追加

例として剰余演算子`%`の追加を見てみましょう:

**1. レキサー (lexer.c):**
```c
// get_next_token()のswitch文に追加
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. レキサーヘッダー (lexer.h):**
```c
typedef enum {
    // ... 既存のトークン
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h):**
```c
typedef enum {
    // ... 既存の演算子
    OP_MOD,
    // ...
} BinaryOp;
```

**4. パーサー (parser.c):**
```c
// parse_multiplicative()または適切な優先順位レベルに追加
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. ランタイム (runtime.c):**
```c
// eval_binary_op()に追加
case OP_MOD:
    // 型チェック
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Error: Modulo by zero\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... 他の型の組み合わせを処理
    break;
```

**6. テスト (tests/operators/modulo.hml):**
```hemlock
// 基本的な剰余
print(10 % 3);  // 期待: 2

// 負の剰余
print(-10 % 3); // 期待: -1

// エラーケース（失敗するはず）
// print(10 % 0);  // ゼロ除算
```

**7. ドキュメント (CLAUDE.md):**
```markdown
### 算術演算子
- `+` - 加算
- `-` - 減算
- `*` - 乗算
- `/` - 除算
- `%` - 剰余（余り）
```

---

## コードレビュープロセス

### レビュアーが確認すること

**1. 正確性**
- コードは主張通りに動作するか？
- エッジケースは処理されているか？
- メモリリークはないか？
- エラーは適切に処理されているか？

**2. 哲学との整合性**
- これはHemlockの設計原則に合っているか？
- 明示的か暗黙的か？
- 複雑さを隠していないか？

**3. コード品質**
- コードは読みやすく保守可能か？
- 変数名は説明的か？
- 関数は適切なサイズか？
- 十分なドキュメントがあるか？

**4. テスト**
- 十分なテストケースがあるか？
- テストは成功と失敗のパスをカバーしているか？
- エッジケースはテストされているか？

**5. ドキュメント**
- ユーザー向けドキュメントは更新されているか？
- コードコメントは明確か？
- 例は提供されているか？

### フィードバックへの対応

**すべきこと:**
- レビュアーの時間に感謝する
- 理解できない場合は明確化の質問をする
- 同意しない場合は理由を説明する
- 要求された変更を迅速に行う
- スコープが変更された場合はPR説明を更新

**すべきでないこと:**
- 批判を個人的に受け取る
- 防御的に議論する
- フィードバックを無視する
- レビューコメントの上に強制プッシュする（リベースを除く）
- PRに無関係な変更を追加する

### PRをマージしてもらう

**マージの要件:**
- [ ] すべてのテストが合格
- [ ] メモリリークなし（valgrindクリーン）
- [ ] メンテナーからのコードレビュー承認
- [ ] ドキュメント更新済み
- [ ] コードスタイルガイドラインに従っている
- [ ] Hemlockの哲学に沿っている

**タイムライン:**
- 小さなPR（バグ修正）: 通常数日以内にレビュー
- 中程度のPR（新機能）: 1-2週間かかる可能性あり
- 大きなPR（主要な変更）: 広範な議論が必要

---

## 追加リソース

### 学習リソース

**インタプリタの理解:**
- "Crafting Interpreters" by Robert Nystrom
- "Writing An Interpreter In Go" by Thorsten Ball
- "Modern Compiler Implementation in C" by Andrew Appel

**Cプログラミング:**
- "The C Programming Language" by K&R
- "Expert C Programming" by Peter van der Linden
- "C Interfaces and Implementations" by David Hanson

**メモリ管理:**
- Valgrindドキュメント
- "Understanding and Using C Pointers" by Richard Reese

### 便利なコマンド

```bash
# デバッグシンボル付きでビルド
make clean && make CFLAGS="-g -O0"

# valgrindで実行
valgrind --leak-check=full ./hemlock script.hml

# 特定のテストカテゴリを実行
./tests/run_tests.sh tests/strings/

# コードナビゲーション用のタグファイルを生成
ctags -R .

# すべてのTODOとFIXMEを見つける
grep -rn "TODO\|FIXME" src/ include/
```

---

## 質問?

貢献について質問がある場合:

1. `docs/`のドキュメントを確認
2. 既存のGitHub Issueを検索
3. GitHub Discussionsで質問
4. 質問を含む新しいIssueを開く

**Hemlockへの貢献ありがとうございます！**


--------------------------------------------------------------------------------
## テスト
--------------------------------------------------------------------------------

# Hemlockテストガイド

このガイドでは、Hemlockのテスト哲学、テストの書き方、テストスイートの実行方法を説明します。

---

## 目次

- [テスト哲学](#テスト哲学)
- [テストスイートの構造](#テストスイートの構造)
- [テストの実行](#テストの実行)
- [テストの作成](#テストの作成)
- [テストカテゴリ](#テストカテゴリ)
- [メモリリークテスト](#メモリリークテスト)
- [継続的インテグレーション](#継続的インテグレーション)
- [ベストプラクティス](#ベストプラクティス)

---

## テスト哲学

### 核となる原則

**1. テスト駆動開発（TDD）**

機能を実装する**前に**テストを書く:

```
1. 失敗するテストを書く
2. 機能を実装する
3. テストを実行する（合格するはず）
4. 必要に応じてリファクタリング
5. 繰り返す
```

**利点:**
- 機能が実際に動作することを確認
- 回帰を防ぐ
- 期待される動作をドキュメント化
- リファクタリングを安全にする

**2. 包括的なカバレッジ**

成功と失敗の両方のケースをテスト:

```hemlock
// 成功ケース
let x: u8 = 255;  // 動作するはず

// 失敗ケース
let y: u8 = 256;  // エラーになるはず
```

**3. 早期かつ頻繁にテスト**

以下のタイミングでテストを実行:
- コードをコミットする前
- 変更を加えた後
- プルリクエストを提出する前
- コードレビュー中

**ルール:** マージ前にすべてのテストが合格する必要があります。

### テストすべきもの

**常にテストすべきもの:**
- ✅ 基本機能（ハッピーパス）
- ✅ エラー条件（サッドパス）
- ✅ エッジケース（境界条件）
- ✅ 型チェックと変換
- ✅ メモリ管理（リークなし）
- ✅ 並行処理と競合状態

**テストカバレッジの例:**
```hemlock
// 機能: String.substr(start, length)

// ハッピーパス
print("hello".substr(0, 5));  // "hello"

// エッジケース
print("hello".substr(0, 0));  // ""（空）
print("hello".substr(5, 0));  // ""（末尾で）
print("hello".substr(2, 100)); // "llo"（末尾を超える）

// エラーケース
// "hello".substr(-1, 5);  // エラー: 負のインデックス
// "hello".substr(0, -1);  // エラー: 負の長さ
```

---

## テストスイートの構造

### ディレクトリ構成

```
tests/
├── run_tests.sh          # メインのテストランナースクリプト
├── primitives/           # 型システムテスト
│   ├── integers.hml
│   ├── floats.hml
│   ├── booleans.hml
│   ├── i64.hml
│   └── u64.hml
├── conversions/          # 型変換テスト
│   ├── int_to_float.hml
│   ├── promotion.hml
│   └── rune_conversions.hml
├── memory/               # ポインタ/バッファテスト
│   ├── alloc.hml
│   ├── buffer.hml
│   └── memcpy.hml
├── strings/              # 文字列操作テスト
│   ├── concat.hml
│   ├── methods.hml
│   ├── utf8.hml
│   └── runes.hml
├── control/              # 制御フローテスト
│   ├── if.hml
│   ├── switch.hml
│   └── while.hml
├── functions/            # 関数とクロージャテスト
│   ├── basics.hml
│   ├── closures.hml
│   └── recursion.hml
├── objects/              # オブジェクトテスト
│   ├── literals.hml
│   ├── methods.hml
│   ├── duck_typing.hml
│   └── serialization.hml
├── arrays/               # 配列操作テスト
│   ├── basics.hml
│   ├── methods.hml
│   └── slicing.hml
├── loops/                # ループテスト
│   ├── for.hml
│   ├── while.hml
│   ├── break.hml
│   └── continue.hml
├── exceptions/           # エラー処理テスト
│   ├── try_catch.hml
│   ├── finally.hml
│   └── throw.hml
├── io/                   # ファイルI/Oテスト
│   ├── file_object.hml
│   ├── read_write.hml
│   └── seek.hml
├── async/                # 並行処理テスト
│   ├── spawn_join.hml
│   ├── channels.hml
│   └── exceptions.hml
├── ffi/                  # FFIテスト
│   ├── basic_call.hml
│   ├── types.hml
│   └── dlopen.hml
├── signals/              # シグナル処理テスト
│   ├── basic.hml
│   ├── handlers.hml
│   └── raise.hml
└── args/                 # コマンドライン引数テスト
    └── basic.hml
```

### テストファイルの命名

**規則:**
- 説明的な名前を使用: `method_chaining.hml`ではなく`test1.hml`
- 関連テストをグループ化: `string_substr.hml`、`string_slice.hml`
- 1ファイルに1つの機能領域
- ファイルを焦点を絞った小さなものに保つ

---

## テストの実行

### すべてのテストを実行

```bash
# hemlockルートディレクトリから
make test

# または直接
./tests/run_tests.sh
```

**出力:**
```
Running tests in tests/primitives/...
  ✓ integers.hml
  ✓ floats.hml
  ✓ booleans.hml

Running tests in tests/strings/...
  ✓ concat.hml
  ✓ methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### 特定のカテゴリを実行

```bash
# 文字列テストのみ実行
./tests/run_tests.sh tests/strings/

# 1つのテストファイルのみ実行
./tests/run_tests.sh tests/strings/concat.hml

# 複数のカテゴリを実行
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### Valgrindで実行（メモリリークチェック）

```bash
# 単一テストのリークをチェック
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# すべてのテストをチェック（遅い！）
for test in tests/**/*.hml; do
    echo "Testing $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### 失敗したテストのデバッグ

```bash
# 詳細出力で実行
./hemlock tests/failing_test.hml

# gdbで実行
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # クラッシュした場合
```

---

## テストの作成

### テストファイルの形式

テストファイルは期待出力を持つHemlockプログラムです:

**例: tests/primitives/integers.hml**
```hemlock
// 基本的な整数リテラルをテスト
let x = 42;
print(x);  // 期待: 42

let y: i32 = 100;
print(y);  // 期待: 100

// 算術をテスト
let sum = x + y;
print(sum);  // 期待: 142

// 型推論をテスト
let small = 10;
print(typeof(small));  // 期待: i32

let large = 5000000000;
print(typeof(large));  // 期待: i64
```

**テストの動作:**
1. テストランナーが.hmlファイルを実行
2. stdout出力をキャプチャ
3. 期待出力と比較（コメントまたは別の.outファイルから）
4. 合格/不合格を報告

### 期待出力の方法

**方法1: インラインコメント（シンプルなテストに推奨）**

```hemlock
print("hello");  // 期待: hello
print(42);       // 期待: 42
```

テストランナーは`// 期待: ...`コメントをパースします。

**方法2: 別の.outファイル**

期待出力で`test_name.hml.out`を作成:

**test_name.hml:**
```hemlock
print("line 1");
print("line 2");
print("line 3");
```

**test_name.hml.out:**
```
line 1
line 2
line 3
```

### エラーケースのテスト

エラーテストは非ゼロステータスでプログラムを終了させるべき:

**例: tests/primitives/range_error.hml**
```hemlock
// これは型エラーで失敗するはず
let x: u8 = 256;  // u8の範囲外
```

**期待される動作:**
- プログラムは非ゼロステータスで終了
- stderrにエラーメッセージを出力

**テストランナーの処理:**
- エラーを期待するテストは別ファイルにすべき
- 命名規則を使用: `*_error.hml`または`*_fail.hml`
- 期待されるエラーをコメントでドキュメント化

### 成功ケースのテスト

**例: tests/strings/methods.hml**
```hemlock
// substrをテスト
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // 期待: world

// findをテスト
let pos = s.find("world");
print(pos);  // 期待: 6

// containsをテスト
let has = s.contains("lo");
print(has);  // 期待: true

// trimをテスト
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // 期待: hello
```

### エッジケースのテスト

**例: tests/arrays/edge_cases.hml**
```hemlock
// 空の配列
let empty = [];
print(empty.length);  // 期待: 0

// 単一要素
let single = [42];
print(single[0]);  // 期待: 42

// 負のインデックス（別のテストファイルでエラーになるはず）
// print(single[-1]);  // エラー

// 末尾を超えるインデックス（エラーになるはず）
// print(single[100]);  // エラー

// 境界条件
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // 期待: []（空）
print(arr.slice(3, 3));  // 期待: []（空）
print(arr.slice(1, 2));  // 期待: [2]
```

### 型システムのテスト

**例: tests/conversions/promotion.hml**
```hemlock
// 二項演算での型プロモーションをテスト

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // 期待: i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // 期待: f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // 期待: i32
```

### 並行処理のテスト

**例: tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// タスクをスポーン
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// 結果をジョインして出力
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // 期待: 45
print(r2);  // 期待: 190
```

### 例外のテスト

**例: tests/exceptions/try_catch.hml**
```hemlock
// 基本的なtry/catchをテスト
try {
    throw "error message";
} catch (e) {
    print("Caught: " + e);  // 期待: Caught: error message
}

// finallyをテスト
let executed = false;
try {
    print("try");  // 期待: try
} finally {
    executed = true;
    print("finally");  // 期待: finally
}

// 例外伝播をテスト
fn risky(): i32 {
    throw "failure";
}

try {
    risky();
} catch (e) {
    print(e);  // 期待: failure
}
```

---

## テストカテゴリ

### プリミティブテスト

**テストすべきもの:**
- 整数型（i8、i16、i32、i64、u8、u16、u32、u64）
- 浮動小数点型（f32、f64）
- ブール型
- 文字列型
- ルーン型
- Null型

**テスト領域の例:**
- リテラル構文
- 型推論
- 範囲チェック
- オーバーフロー動作
- 型注釈

### 変換テスト

**テストすべきもの:**
- 暗黙の型プロモーション
- 明示的な型変換
- 損失のある変換（エラーになるべき）
- 操作での型プロモーション
- 異なる型間の比較

### メモリテスト

**テストすべきもの:**
- alloc/freeの正確性
- バッファの作成とアクセス
- バッファの境界チェック
- memset、memcpy、realloc
- メモリリーク検出（valgrind）

### 文字列テスト

**テストすべきもの:**
- 連結
- 全18の文字列メソッド
- UTF-8処理
- ルーンインデックス
- 文字列 + ルーン連結
- エッジケース（空文字列、単一文字など）

### 制御フローテスト

**テストすべきもの:**
- if/else/else if
- whileループ
- forループ
- switch文
- break/continue
- return文

### 関数テスト

**テストすべきもの:**
- 関数定義と呼び出し
- パラメータ渡し
- 戻り値
- 再帰
- クロージャとキャプチャ
- ファーストクラス関数
- 無名関数

### オブジェクトテスト

**テストすべきもの:**
- オブジェクトリテラル
- フィールドアクセスと代入
- メソッドとselfバインディング
- ダックタイピング
- オプションフィールド
- JSONシリアライゼーション/デシリアライゼーション
- 循環参照検出

### 配列テスト

**テストすべきもの:**
- 配列作成
- インデックスと代入
- 全15の配列メソッド
- 混合型
- 動的リサイズ
- エッジケース（空、単一要素）

### 例外テスト

**テストすべきもの:**
- try/catch/finally
- throw文
- 例外伝播
- ネストされたtry/catch
- try/catch/finally内でのreturn
- キャッチされない例外

### I/Oテスト

**テストすべきもの:**
- ファイルオープンモード
- 読み書き操作
- seek/tell
- ファイルプロパティ
- エラー処理（ファイルがないなど）
- リソースクリーンアップ

### 非同期テスト

**テストすべきもの:**
- spawn/join/detach
- チャネルsend/recv
- タスク内での例外伝播
- 複数の並行タスク
- チャネルのブロッキング動作

### FFIテスト

**テストすべきもの:**
- dlopen/dlclose
- dlsym
- 様々な型でのdlcall
- 型変換
- エラー処理

---

## メモリリークテスト

### Valgrindの使用

**基本的な使い方:**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**出力例（リークなし）:**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**出力例（リークあり）:**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### 一般的なリークの原因

**1. free()呼び出しの欠落:**
```c
// 悪い
char *str = malloc(100);
// ... strを使用
// 解放を忘れた！

// 良い
char *str = malloc(100);
// ... strを使用
free(str);
```

**2. ポインタの消失:**
```c
// 悪い
char *ptr = malloc(100);
ptr = malloc(200);  // 最初の割り当てへの参照を失った！

// 良い
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. 例外パス:**
```c
// 悪い
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // リーク！
    }
    free(data);
}

// 良い
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### 既知の許容可能なリーク

いくつかの小さな「リーク」は意図的な起動時割り当てです:

**グローバルビルトイン:**
```hemlock
// 組み込み関数、FFI型、定数は起動時に割り当てられ
// 終了時に解放されない（通常〜200バイト）
```

これらは真のリークではなく - プログラムの寿命中持続し、終了時にOSによってクリーンアップされる一度限りの割り当てです。

---

## 継続的インテグレーション

### GitHub Actions（将来）

CIがセットアップされると、すべてのテストは以下で自動的に実行されます:
- mainブランチへのプッシュ
- プルリクエストの作成/更新
- スケジュールされた毎日の実行

**CIワークフロー:**
1. Hemlockをビルド
2. テストスイートを実行
3. メモリリークをチェック（valgrind）
4. 結果をPRに報告

### コミット前チェック

コミット前に実行:

```bash
# 新規ビルド
make clean && make

# すべてのテストを実行
make test

# いくつかのテストでリークをチェック
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## ベストプラクティス

### すべきこと

✅ **最初にテストを書く（TDD）**
```bash
1. tests/feature/new_feature.hmlを作成
2. src/に機能を実装
3. テストが合格するまで実行
```

✅ **成功と失敗の両方をテスト**
```hemlock
// 成功: tests/feature/success.hml
let result = do_thing();
print(result);  // 期待: expected value

// 失敗: tests/feature/failure.hml
do_invalid_thing();  // エラーになるはず
```

✅ **説明的なテスト名を使用**
```
良い: tests/strings/substr_utf8_boundary.hml
悪い: tests/test1.hml
```

✅ **テストを焦点を絞ったものに保つ**
- 1ファイルに1つの機能領域
- 明確なセットアップとアサーション
- 最小限のコード

✅ **難しいテストを説明するコメントを追加**
```hemlock
// クロージャが外部変数を参照でキャプチャすることをテスト
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // クロージャ作成後に変更
    return f();  // 10ではなく20を返すはず
}
```

✅ **エッジケースをテスト**
- 空の入力
- Null値
- 境界値（最小/最大）
- 大きな入力
- 負の値

### すべきでないこと

❌ **テストをスキップしない**
- マージ前にすべてのテストが合格する必要がある
- 失敗するテストをコメントアウトしない
- バグを修正するか機能を削除する

❌ **互いに依存するテストを書かない**
```hemlock
// 悪い: test2.hmlがtest1.hmlの出力に依存
// テストは独立しているべき
```

❌ **テストでランダム値を使用しない**
```hemlock
// 悪い: 非決定論的
let x = random();
print(x);  // 出力を予測できない

// 良い: 決定論的
let x = 42;
print(x);  // 期待: 42
```

❌ **実装の詳細をテストしない**
```hemlock
// 悪い: 内部構造をテスト
let obj = { x: 10 };
// 内部フィールド順序、容量などをチェックしない

// 良い: 動作をテスト
print(obj.x);  // 期待: 10
```

❌ **メモリリークを無視しない**
- すべてのテストはvalgrindクリーンであるべき
- 既知/許容可能なリークをドキュメント化
- マージ前にリークを修正

### テストの保守

**テストを更新すべきとき:**
- 機能の動作が変更された
- バグ修正に新しいテストケースが必要
- エッジケースが発見された
- パフォーマンス改善

**テストを削除すべきとき:**
- 機能が言語から削除された
- テストが既存のカバレッジと重複
- テストが不正確だった

**テストのリファクタリング:**
- 関連テストをグループ化
- 共通のセットアップコードを抽出
- 一貫した命名を使用
- テストをシンプルで読みやすく保つ

---

## テストセッションの例

機能をテストと共に追加する完全な例を示します:

### 機能: `array.first()`メソッドの追加

**1. まずテストを書く:**

```bash
# テストファイルを作成
cat > tests/arrays/first_method.hml << 'EOF'
// array.first()メソッドをテスト

// 基本ケース
let arr = [1, 2, 3];
print(arr.first());  // 期待: 1

// 単一要素
let single = [42];
print(single.first());  // 期待: 42

// 空の配列（エラーになるべき - 別のテストファイル）
// let empty = [];
// print(empty.first());  // エラー
EOF
```

**2. テストを実行（失敗するはず）:**

```bash
./hemlock tests/arrays/first_method.hml
# エラー: Method 'first' not found on array
```

**3. 機能を実装:**

`src/interpreter/builtins.c`を編集:

```c
// array_firstメソッドを追加
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Error: Cannot get first element of empty array\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// 配列メソッドテーブルに登録
// ... 配列メソッド登録に追加
```

**4. テストを実行（合格するはず）:**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# 成功！
```

**5. メモリリークをチェック:**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. 完全なテストスイートを実行:**

```bash
make test
# Total: 252 tests (251 + 新しいもの)
# Passed: 252
# Failed: 0
```

**7. コミット:**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "array.first()メソッドをテストと共に追加"
```

---

## まとめ

**覚えておいてください:**
- 最初にテストを書く（TDD）
- 成功と失敗のケースをテスト
- コミット前にすべてのテストを実行
- メモリリークをチェック
- 既知の問題をドキュメント化
- テストをシンプルで焦点を絞ったものに保つ

**テスト品質はコード品質と同じくらい重要です！**



################################################################################
# HPM: はじめに
################################################################################

--------------------------------------------------------------------------------
## インストール
--------------------------------------------------------------------------------

# インストール

このガイドでは、システムにhpmをインストールする方法を説明します。

## クイックインストール（推奨）

1つのコマンドで最新リリースをインストール:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

これは自動的に:
- オペレーティングシステムを検出（Linux、macOS）
- アーキテクチャを検出（x86_64、arm64）
- 適切なビルド済みバイナリをダウンロード
- `/usr/local/bin`にインストール（必要に応じてsudoを使用）

### インストールオプション

```bash
# カスタム場所にインストール（sudoが不要）
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local

# 特定のバージョンをインストール
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5

# オプションの組み合わせ
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5
```

### サポートされるプラットフォーム

| プラットフォーム | アーキテクチャ | ステータス |
|----------|--------------|--------|
| Linux    | x86_64       | ✓ サポート |
| macOS    | x86_64       | ✓ サポート |
| macOS    | arm64 (M1/M2/M3) | ✓ サポート |
| Linux    | arm64        | ソースからビルド |

## ソースからビルド

ソースからビルドしたい場合、またはビルド済みバイナリでカバーされていないプラットフォームが必要な場合は、以下の手順に従ってください。

### 前提条件

hpmは最初に[Hemlock](https://github.com/hemlang/hemlock)がインストールされている必要があります。続行する前にHemlockのインストール手順に従ってください。

Hemlockがインストールされていることを確認:

```bash
hemlock --version
```

## インストール方法

### 方法1: Make Install

ソースからビルドしてインストール。

```bash
# リポジトリをクローン
git clone https://github.com/hemlang/hpm.git
cd hpm

# /usr/local/binにインストール（sudoが必要）
sudo make install
```

インストール後、動作を確認:

```bash
hpm --version
```

### 方法2: カスタム場所

カスタムディレクトリにインストール（sudoが不要）:

```bash
# リポジトリをクローン
git clone https://github.com/hemlang/hpm.git
cd hpm

# ~/.local/binにインストール
make install PREFIX=$HOME/.local

# または任意のカスタム場所
make install PREFIX=/opt/hemlock
```

カスタムbinディレクトリがPATHに含まれていることを確認:

```bash
# ~/.bashrcまたは~/.zshrcに追加
export PATH="$HOME/.local/bin:$PATH"
```

### 方法3: インストールせずに実行

hpmをインストールせずに直接実行できます:

```bash
# リポジトリをクローン
git clone https://github.com/hemlang/hpm.git
cd hpm

# ローカルラッパースクリプトを作成
make

# hpmディレクトリから実行
./hpm --help

# またはhemlockで直接実行
hemlock src/main.hml --help
```

### 方法4: 手動インストール

独自のラッパースクリプトを作成:

```bash
# 永続的な場所にクローン
git clone https://github.com/hemlang/hpm.git ~/.hpm-source

# ラッパースクリプトを作成
cat > ~/.local/bin/hpm << 'EOF'
#!/bin/sh
exec hemlock "$HOME/.hpm-source/src/main.hml" "$@"
EOF

chmod +x ~/.local/bin/hpm
```

## インストール変数

Makefileは以下の変数をサポート:

| 変数 | デフォルト | 説明 |
|----------|---------|-------------|
| `PREFIX` | `/usr/local` | インストールプレフィックス |
| `BINDIR` | `$(PREFIX)/bin` | バイナリディレクトリ |
| `HEMLOCK` | `hemlock` | hemlockインタプリタへのパス |

カスタム変数を使用した例:

```bash
make install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock
```

## 仕組み

インストーラはhpmソースコードでHemlockインタプリタを呼び出すシェルラッパースクリプトを作成します:

```bash
#!/bin/sh
exec hemlock "/path/to/hpm/src/main.hml" "$@"
```

このアプローチ:
- コンパイルが不要
- 常に最新のソースコードを実行
- すべてのプラットフォームで確実に動作

## hpmの更新

hpmを最新バージョンに更新するには:

```bash
cd /path/to/hpm
git pull origin main

# パスが変更された場合は再インストール
sudo make install
```

## アンインストール

システムからhpmを削除:

```bash
cd /path/to/hpm
sudo make uninstall
```

または手動で削除:

```bash
sudo rm /usr/local/bin/hpm
```

## インストールの確認

インストール後、すべてが動作することを確認:

```bash
# バージョンを確認
hpm --version

# ヘルプを表示
hpm --help

# 初期化をテスト（空のディレクトリで）
mkdir test-project && cd test-project
hpm init --yes
cat package.json
```

## トラブルシューティング

### "hemlock: command not found"

HemlockがインストールされていないかPATHにありません。まずHemlockをインストール:

```bash
# hemlockが存在するか確認
which hemlock

# 見つからない場合、https://github.com/hemlang/hemlockからHemlockをインストール
```

### "Permission denied"

システム全体へのインストールにはsudoを使用するか、ユーザーディレクトリにインストール:

```bash
# オプション1: sudoを使用
sudo make install

# オプション2: ユーザーディレクトリにインストール
make install PREFIX=$HOME/.local
```

### インストール後に"hpm: command not found"

PATHにインストールディレクトリが含まれていない可能性があります:

```bash
# hpmがどこにインストールされたか確認
ls -la /usr/local/bin/hpm

# カスタム場所を使用している場合はPATHに追加
export PATH="$HOME/.local/bin:$PATH"
```

## プラットフォーム固有の注意事項

### Linux

標準インストールはすべてのLinuxディストリビューションで動作します。一部のディストリビューションでは以下が必要な場合があります:

```bash
# Debian/Ubuntu: ビルド必須パッケージを確認
sudo apt-get install build-essential git

# Fedora/RHEL
sudo dnf install make git
```

### macOS

標準インストールが動作します。Homebrewを使用している場合:

```bash
# Xcodeコマンドラインツールを確認
xcode-select --install
```

### Windows (WSL)

hpmはWindows Subsystem for Linuxで動作します:

```bash
# WSLターミナルで
git clone https://github.com/hemlang/hpm.git
cd hpm
make install PREFIX=$HOME/.local
```

## 次のステップ

インストール後:

1. [クイックスタート](#hpm-installation-quick-start) - 最初のプロジェクトを作成
2. [コマンドリファレンス](#hpm-installation-commands) - すべてのコマンドを学ぶ
3. [設定](#hpm-installation-configuration) - hpmを設定


--------------------------------------------------------------------------------
## クイックスタート
--------------------------------------------------------------------------------

# クイックスタート

hpmを5分で使い始めましょう。

## hpmのインストール

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

その他のインストールオプションについては、[インストールガイド](#hpm-quick-start-installation)を参照してください。

## 新しいプロジェクトの作成

新しいディレクトリを作成してパッケージを初期化:

```bash
mkdir my-project
cd my-project
hpm init
```

プロジェクトの詳細を入力:

```
Package name (owner/repo): myname/my-project
Version (1.0.0):
Description: My awesome Hemlock project
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

`--yes`を使用してすべてのデフォルトを受け入れる:

```bash
hpm init --yes
```

## プロジェクト構造

基本的なプロジェクト構造を作成:

```
my-project/
├── package.json        # プロジェクトマニフェスト
├── src/
│   └── index.hml      # メインエントリポイント
└── test/
    └── test.hml       # テスト
```

メインファイルを作成:

```bash
mkdir -p src test
```

**src/index.hml:**
```hemlock
// メインエントリポイント
export fn greet(name: string): string {
    return "Hello, " + name + "!";
}

export fn main() {
    print(greet("World"));
}
```

## 依存関係のインストール

GitHub上でパッケージを検索（パッケージは`owner/repo`形式を使用）:

```bash
# パッケージをインストール
hpm install hemlang/sprout

# バージョン制約付きでインストール
hpm install hemlang/json@^1.0.0

# 開発依存関係としてインストール
hpm install hemlang/test-utils --dev
```

インストール後、プロジェクト構造に`hem_modules/`が追加されます:

```
my-project/
├── package.json
├── package-lock.json   # ロックファイル（自動生成）
├── hem_modules/        # インストールされたパッケージ
│   └── hemlang/
│       └── sprout/
├── src/
│   └── index.hml
└── test/
    └── test.hml
```

## インストールしたパッケージの使用

GitHubパスを使用してパッケージをインポート:

```hemlock
// インストールしたパッケージからインポート
import { app, router } from "hemlang/sprout";
import { parse, stringify } from "hemlang/json";

// サブパスからインポート
import { middleware } from "hemlang/sprout/middleware";

// 標準ライブラリ（組み込み）
import { HashMap } from "@stdlib/collections";
import { readFile } from "@stdlib/fs";
```

## スクリプトの追加

`package.json`にスクリプトを追加:

```json
{
  "name": "myname/my-project",
  "version": "1.0.0",
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/test.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

`hpm run`でスクリプトを実行:

```bash
hpm run start
hpm run build

# testの短縮形
hpm test
```

## 一般的なワークフロー

### すべての依存関係をインストール

`package.json`を持つプロジェクトをクローンした場合:

```bash
git clone https://github.com/someone/project.git
cd project
hpm install
```

### 依存関係の更新

すべてのパッケージを制約内で最新バージョンに更新:

```bash
hpm update
```

特定のパッケージを更新:

```bash
hpm update hemlang/sprout
```

### インストールされたパッケージの表示

すべてのインストール済みパッケージをリスト:

```bash
hpm list
```

出力に依存関係ツリーが表示されます:

```
my-project@1.0.0
├── hemlang/sprout@2.1.0
│   └── hemlang/router@1.5.0
└── hemlang/json@1.2.3
```

### 更新の確認

新しいバージョンがあるパッケージを確認:

```bash
hpm outdated
```

### パッケージの削除

```bash
hpm uninstall hemlang/sprout
```

## 例: Webアプリケーション

Webフレームワークを使用した完全な例:

**package.json:**
```json
{
  "name": "myname/my-web-app",
  "version": "1.0.0",
  "description": "A web application",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/sprout": "^2.0.0"
  },
  "scripts": {
    "start": "hemlock src/index.hml",
    "dev": "hemlock --watch src/index.hml"
  }
}
```

**src/index.hml:**
```hemlock
import { App, Router } from "hemlang/sprout";

fn main() {
    let app = App.new();
    let router = Router.new();

    router.get("/", fn(req, res) {
        res.send("Hello, World!");
    });

    router.get("/api/status", fn(req, res) {
        res.json({ status: "ok" });
    });

    app.use(router);
    app.listen(3000);

    print("Server running on http://localhost:3000");
}
```

アプリケーションを実行:

```bash
hpm install
hpm run start
```

## 次のステップ

- [コマンドリファレンス](#hpm-quick-start-commands) - すべてのhpmコマンドを学ぶ
- [パッケージの作成](#hpm-quick-start-creating-packages) - 独自のパッケージを公開
- [設定](#hpm-quick-start-configuration) - hpmとGitHubトークンを設定
- [プロジェクトセットアップ](#hpm-quick-start-project-setup) - 詳細なプロジェクト設定


--------------------------------------------------------------------------------
## プロジェクトセットアップ
--------------------------------------------------------------------------------

# プロジェクトセットアップ

hpmを使ったHemlockプロジェクトのセットアップ完全ガイド。

## 新しいプロジェクトの開始

### 基本セットアップ

ゼロから新しいプロジェクトを作成:

```bash
# プロジェクトディレクトリを作成
mkdir my-project
cd my-project

# package.jsonを初期化
hpm init

# ディレクトリ構造を作成
mkdir -p src test
```

### プロジェクトテンプレート

以下は異なる用途に応じた一般的なプロジェクト構造です:

#### ライブラリパッケージ

再利用可能なライブラリ用:

```
my-library/
├── package.json
├── README.md
├── LICENSE
├── src/
│   ├── index.hml          # メインエントリ、パブリックAPIをエクスポート
│   ├── core.hml           # コア機能
│   ├── utils.hml          # ユーティリティ関数
│   └── types.hml          # 型定義
└── test/
    ├── framework.hml      # テストフレームワーク
    ├── run.hml            # テストランナー
    └── test_core.hml      # テスト
```

**package.json:**

```json
{
  "name": "yourusername/my-library",
  "version": "1.0.0",
  "description": "A reusable Hemlock library",
  "main": "src/index.hml",
  "scripts": {
    "test": "hemlock test/run.hml"
  },
  "dependencies": {},
  "devDependencies": {}
}
```

#### アプリケーション

スタンドアロンアプリケーション用:

```
my-app/
├── package.json
├── README.md
├── src/
│   ├── main.hml           # アプリケーションエントリポイント
│   ├── config.hml         # 設定
│   ├── commands/          # CLIコマンド
│   │   ├── index.hml
│   │   └── run.hml
│   └── lib/               # 内部ライブラリ
│       └── utils.hml
├── test/
│   └── run.hml
└── data/                  # データファイル
```

**package.json:**

```json
{
  "name": "yourusername/my-app",
  "version": "1.0.0",
  "description": "A Hemlock application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {}
}
```

#### Webアプリケーション

Webサーバー用:

```
my-web-app/
├── package.json
├── README.md
├── src/
│   ├── main.hml           # サーバーエントリポイント
│   ├── routes/            # ルートハンドラ
│   │   ├── index.hml
│   │   ├── api.hml
│   │   └── auth.hml
│   ├── middleware/        # ミドルウェア
│   │   ├── index.hml
│   │   └── auth.hml
│   ├── models/            # データモデル
│   │   └── user.hml
│   └── services/          # ビジネスロジック
│       └── user.hml
├── test/
│   └── run.hml
├── static/                # 静的ファイル
│   ├── css/
│   └── js/
└── views/                 # テンプレート
    └── index.hml
```

**package.json:**

```json
{
  "name": "yourusername/my-web-app",
  "version": "1.0.0",
  "description": "A Hemlock web application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml"
  },
  "dependencies": {
    "hemlang/sprout": "^2.0.0",
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  }
}
```

## package.jsonファイル

### 必須フィールド

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

### すべてのフィールド

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "Package description",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "homepage": "https://yourusername.github.io/my-package",
  "bugs": "https://github.com/yourusername/my-package/issues",
  "main": "src/index.hml",
  "keywords": ["utility", "parser"],
  "dependencies": {
    "owner/package": "^1.0.0"
  },
  "devDependencies": {
    "owner/test-lib": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

### フィールドリファレンス

| フィールド | 型 | 説明 |
|-------|------|-------------|
| `name` | string | owner/repo形式のパッケージ名（必須） |
| `version` | string | セマンティックバージョン（必須） |
| `description` | string | 短い説明 |
| `author` | string | 作者名とメール |
| `license` | string | ライセンス識別子（MIT、Apache-2.0など） |
| `repository` | string | リポジトリURL |
| `homepage` | string | プロジェクトホームページ |
| `bugs` | string | イシュートラッカーURL |
| `main` | string | エントリポイントファイル（デフォルト: src/index.hml） |
| `keywords` | array | 検索キーワード |
| `dependencies` | object | ランタイム依存関係 |
| `devDependencies` | object | 開発依存関係 |
| `scripts` | object | 名前付きスクリプト |
| `files` | array | 公開時に含めるファイル |
| `native` | object | ネイティブライブラリ要件 |

## package-lock.jsonファイル

ロックファイルは自動生成され、バージョン管理にコミットする必要があります。再現可能なインストールを保証します。

```json
{
  "lockVersion": 1,
  "hemlock": "1.0.0",
  "dependencies": {
    "hemlang/sprout": {
      "version": "2.1.0",
      "resolved": "https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz",
      "integrity": "sha256-abc123...",
      "dependencies": {
        "hemlang/router": "^1.5.0"
      }
    },
    "hemlang/router": {
      "version": "1.5.0",
      "resolved": "https://github.com/hemlang/router/archive/v1.5.0.tar.gz",
      "integrity": "sha256-def456...",
      "dependencies": {}
    }
  }
}
```

### ロックファイルのベストプラクティス

- package-lock.jsonをバージョン管理に**コミット**
- 手動で**編集しない** - 自動生成される
- 変更をプルした後に**`hpm install`を実行**
- 破損した場合は**削除して再生成**:
  ```bash
  rm package-lock.json
  hpm install
  ```

## hem_modulesディレクトリ

インストールされたパッケージは`hem_modules/`に保存されます:

```
hem_modules/
├── hemlang/
│   ├── sprout/
│   │   ├── package.json
│   │   └── src/
│   └── router/
│       ├── package.json
│       └── src/
└── alice/
    └── http-client/
        ├── package.json
        └── src/
```

### hem_modulesのベストプラクティス

- **.gitignoreに追加** - 依存関係をコミットしない
- **変更しない** - 変更は上書きされる
- **新しくインストールするには削除**:
  ```bash
  rm -rf hem_modules
  hpm install
  ```

## .gitignore

Hemlockプロジェクトの推奨.gitignore:

```gitignore
# 依存関係
hem_modules/

# ビルド出力
dist/
*.hmlc

# IDEファイル
.idea/
.vscode/
*.swp
*.swo

# OSファイル
.DS_Store
Thumbs.db

# ログ
*.log
logs/

# 環境
.env
.env.local

# テストカバレッジ
coverage/
```

## 依存関係の操作

### 依存関係の追加

```bash
# ランタイム依存関係を追加
hpm install hemlang/json

# バージョン制約付きで追加
hpm install hemlang/sprout@^2.0.0

# 開発依存関係を追加
hpm install hemlang/test-utils --dev
```

### 依存関係のインポート

```hemlock
// パッケージからインポート（"main"エントリを使用）
import { parse, stringify } from "hemlang/json";

// サブパスからインポート
import { Router } from "hemlang/sprout/router";

// 標準ライブラリをインポート
import { HashMap } from "@stdlib/collections";
import { readFile, writeFile } from "@stdlib/fs";
```

### インポート解決

hpmは以下の順序でインポートを解決:

1. **標準ライブラリ**: `@stdlib/*`は組み込みモジュールをインポート
2. **パッケージルート**: `owner/repo`は`main`フィールドを使用
3. **サブパス**: `owner/repo/path`は以下をチェック:
   - `hem_modules/owner/repo/path.hml`
   - `hem_modules/owner/repo/path/index.hml`
   - `hem_modules/owner/repo/src/path.hml`
   - `hem_modules/owner/repo/src/path/index.hml`

## スクリプト

### スクリプトの定義

package.jsonにスクリプトを追加:

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

### スクリプトの実行

```bash
hpm run start
hpm run dev
hpm run build

# testの短縮形
hpm test

# 引数を渡す
hpm run test -- --verbose --filter=unit
```

### スクリプトの命名規則

| スクリプト | 目的 |
|--------|---------|
| `start` | アプリケーションを実行 |
| `dev` | 開発モードで実行 |
| `test` | すべてのテストを実行 |
| `build` | 本番用にビルド |
| `clean` | 生成ファイルを削除 |
| `lint` | コードスタイルをチェック |
| `format` | コードをフォーマット |

## 開発ワークフロー

### 初期セットアップ

```bash
# プロジェクトをクローン
git clone https://github.com/yourusername/my-project.git
cd my-project

# 依存関係をインストール
hpm install

# テストを実行
hpm test

# 開発を開始
hpm run dev
```

### 日常のワークフロー

```bash
# 最新の変更をプル
git pull

# 新しい依存関係をインストール
hpm install

# 変更を加える...

# テストを実行
hpm test

# コミット
git add .
git commit -m "Add feature"
git push
```

### 新機能の追加

```bash
# フィーチャーブランチを作成
git checkout -b feature/new-feature

# 必要に応じて新しい依存関係を追加
hpm install hemlang/new-lib

# 機能を実装...

# テスト
hpm test

# コミットとプッシュ
git add .
git commit -m "Add new feature"
git push -u origin feature/new-feature
```

## 環境別設定

### 環境変数の使用

```hemlock
import { getenv } from "@stdlib/env";

let db_host = getenv("DATABASE_HOST") ?? "localhost";
let api_key = getenv("API_KEY") ?? "";

if api_key == "" {
    print("Warning: API_KEY not set");
}
```

### 設定ファイル

**config.hml:**

```hemlock
import { getenv } from "@stdlib/env";

export let config = {
    environment: getenv("HEMLOCK_ENV") ?? "development",
    database: {
        host: getenv("DB_HOST") ?? "localhost",
        port: int(getenv("DB_PORT") ?? "5432"),
        name: getenv("DB_NAME") ?? "myapp"
    },
    server: {
        port: int(getenv("PORT") ?? "3000"),
        host: getenv("HOST") ?? "0.0.0.0"
    }
};

export fn is_production(): bool {
    return config.environment == "production";
}
```

## 参照

- [クイックスタート](#hpm-project-setup-quick-start) - すぐに始める
- [コマンド](#hpm-project-setup-commands) - コマンドリファレンス
- [パッケージの作成](#hpm-project-setup-creating-packages) - パッケージの公開
- [設定](#hpm-project-setup-configuration) - hpmの設定



################################################################################
# HPM: ユーザーガイド
################################################################################

--------------------------------------------------------------------------------
## コマンド
--------------------------------------------------------------------------------

# コマンドリファレンス

すべてのhpmコマンドの完全なリファレンス。

## グローバルオプション

これらのオプションはどのコマンドでも使用できます:

| オプション | 説明 |
|--------|-------------|
| `--help`, `-h` | ヘルプメッセージを表示 |
| `--version`, `-v` | hpmのバージョンを表示 |
| `--verbose` | 詳細な出力を表示 |

## コマンド

### hpm init

新しい`package.json`ファイルを作成します。

```bash
hpm init        # インタラクティブモード
hpm init --yes  # すべてのデフォルトを受け入れる
hpm init -y     # 短縮形
```

**オプション:**

| オプション | 説明 |
|--------|-------------|
| `--yes`, `-y` | すべてのプロンプトでデフォルト値を受け入れる |

**インタラクティブプロンプト:**
- パッケージ名（owner/repo形式）
- バージョン（デフォルト: 1.0.0）
- 説明
- 作者
- ライセンス（デフォルト: MIT）
- メインファイル（デフォルト: src/index.hml）

**例:**

```bash
$ hpm init
Package name (owner/repo): alice/my-lib
Version (1.0.0):
Description: A utility library
Author: Alice <alice@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

---

### hpm install

依存関係をインストールするか、新しいパッケージを追加します。

```bash
hpm install                           # package.jsonからすべてをインストール
hpm install owner/repo                # パッケージを追加してインストール
hpm install owner/repo@^1.0.0        # バージョン制約付きで
hpm install owner/repo --dev         # 開発依存関係として
hpm i owner/repo                      # 短縮形
```

**オプション:**

| オプション | 説明 |
|--------|-------------|
| `--dev`, `-D` | devDependenciesに追加 |
| `--verbose` | 詳細な進捗を表示 |
| `--dry-run` | インストールせずにプレビュー |
| `--offline` | キャッシュのみからインストール（ネットワークなし） |
| `--parallel` | 並列ダウンロードを有効化（実験的） |

**バージョン制約の構文:**

| 構文 | 例 | 意味 |
|--------|---------|---------|
| (なし) | `owner/repo` | 最新バージョン |
| 固定 | `owner/repo@1.2.3` | 正確に1.2.3 |
| キャレット | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |
| チルダ | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |
| 範囲 | `owner/repo@>=1.0.0` | 1.0.0以上 |

**例:**

```bash
# すべての依存関係をインストール
hpm install

# 特定のパッケージをインストール
hpm install hemlang/json

# バージョン制約付きでインストール
hpm install hemlang/sprout@^2.0.0

# 開発依存関係としてインストール
hpm install hemlang/test-utils --dev

# インストール内容をプレビュー
hpm install hemlang/sprout --dry-run

# 詳細出力
hpm install --verbose

# キャッシュのみからインストール（オフライン）
hpm install --offline
```

**出力:**

```
Installing dependencies...
  + hemlang/sprout@2.1.0
  + hemlang/router@1.5.0 (dependency of hemlang/sprout)

Installed 2 packages in 1.2s
```

---

### hpm uninstall

パッケージを削除します。

```bash
hpm uninstall owner/repo
hpm rm owner/repo          # 短縮形
hpm remove owner/repo      # 別名
```

**例:**

```bash
hpm uninstall hemlang/sprout
```

**出力:**

```
Removed hemlang/sprout@2.1.0
Updated package.json
Updated package-lock.json
```

---

### hpm update

制約内で最新バージョンにパッケージを更新します。

```bash
hpm update              # すべてのパッケージを更新
hpm update owner/repo   # 特定のパッケージを更新
hpm up owner/repo       # 短縮形
```

**オプション:**

| オプション | 説明 |
|--------|-------------|
| `--verbose` | 詳細な進捗を表示 |
| `--dry-run` | 更新せずにプレビュー |

**例:**

```bash
# すべてのパッケージを更新
hpm update

# 特定のパッケージを更新
hpm update hemlang/sprout

# 更新をプレビュー
hpm update --dry-run
```

**出力:**

```
Updating dependencies...
  hemlang/sprout: 2.0.0 → 2.1.0
  hemlang/router: 1.4.0 → 1.5.0

Updated 2 packages
```

---

### hpm list

インストールされているパッケージを表示します。

```bash
hpm list              # 完全な依存関係ツリーを表示
hpm list --depth=0    # 直接依存関係のみ
hpm list --depth=1    # 1レベルの推移的依存関係
hpm ls                # 短縮形
```

**オプション:**

| オプション | 説明 |
|--------|-------------|
| `--depth=N` | ツリーの深さを制限（デフォルト: すべて） |

**例:**

```bash
$ hpm list
my-project@1.0.0
├── hemlang/sprout@2.1.0
│   ├── hemlang/router@1.5.0
│   └── hemlang/middleware@1.2.0
├── hemlang/json@1.2.3
└── hemlang/test-utils@1.0.0 (dev)

$ hpm list --depth=0
my-project@1.0.0
├── hemlang/sprout@2.1.0
├── hemlang/json@1.2.3
└── hemlang/test-utils@1.0.0 (dev)
```

---

### hpm outdated

新しいバージョンが利用可能なパッケージを表示します。

```bash
hpm outdated
```

**出力:**

```
Package            Current  Wanted  Latest
hemlang/sprout     2.0.0    2.0.5   2.1.0
hemlang/router     1.4.0    1.4.2   1.5.0
```

- **Current**: インストールされているバージョン
- **Wanted**: 制約に一致する最高バージョン
- **Latest**: 最新の利用可能なバージョン

---

### hpm run

package.jsonからスクリプトを実行します。

```bash
hpm run <script>
hpm run <script> -- <args>
```

**例:**

このpackage.jsonの場合:

```json
{
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

スクリプトを実行:

```bash
hpm run start
hpm run test
hpm run build

# スクリプトに引数を渡す
hpm run test -- --verbose
```

---

### hpm test

`hpm run test`の短縮形。

```bash
hpm test
hpm test -- --verbose
```

以下と同等:

```bash
hpm run test
```

---

### hpm why

パッケージがインストールされている理由を説明します（依存関係チェーンを表示）。

```bash
hpm why owner/repo
```

**例:**

```bash
$ hpm why hemlang/router

hemlang/router@1.5.0 is installed because:

my-project@1.0.0
└── hemlang/sprout@2.1.0
    └── hemlang/router@1.5.0
```

---

### hpm cache

グローバルパッケージキャッシュを管理します。

```bash
hpm cache list    # キャッシュされたパッケージをリスト
hpm cache clean   # すべてのキャッシュされたパッケージをクリア
```

**サブコマンド:**

| サブコマンド | 説明 |
|------------|-------------|
| `list` | すべてのキャッシュされたパッケージとサイズを表示 |
| `clean` | すべてのキャッシュされたパッケージを削除 |

**例:**

```bash
$ hpm cache list
Cached packages in ~/.hpm/cache:

hemlang/sprout
  2.0.0 (1.2 MB)
  2.1.0 (1.3 MB)
hemlang/router
  1.5.0 (450 KB)

Total: 2.95 MB

$ hpm cache clean
Cleared cache (2.95 MB freed)
```

---

## コマンドショートカット

便宜上、いくつかのコマンドには短いエイリアスがあります:

| コマンド | ショートカット |
|---------|-----------|
| `install` | `i` |
| `uninstall` | `rm`, `remove` |
| `list` | `ls` |
| `update` | `up` |

**例:**

```bash
hpm i hemlang/sprout        # hpm install hemlang/sprout
hpm rm hemlang/sprout       # hpm uninstall hemlang/sprout
hpm ls                      # hpm list
hpm up                      # hpm update
```

---

## 終了コード

hpmは異なるエラー条件を示すために特定の終了コードを使用します:

| コード | 意味 |
|------|---------|
| 0 | 成功 |
| 1 | 依存関係の競合 |
| 2 | パッケージが見つからない |
| 3 | バージョンが見つからない |
| 4 | ネットワークエラー |
| 5 | 無効なpackage.json |
| 6 | 整合性チェック失敗 |
| 7 | GitHubレート制限超過 |
| 8 | 循環依存 |

スクリプトでの終了コードの使用:

```bash
hpm install
if [ $? -ne 0 ]; then
    echo "Installation failed"
    exit 1
fi
```

---

## 環境変数

hpmは以下の環境変数を尊重します:

| 変数 | 説明 |
|----------|-------------|
| `GITHUB_TOKEN` | 認証用のGitHub APIトークン |
| `HPM_CACHE_DIR` | キャッシュディレクトリの場所を上書き |
| `HOME` | ユーザーホームディレクトリ（設定/キャッシュ用） |

**例:**

```bash
# より高いレート制限のためにGitHubトークンを使用
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# カスタムキャッシュディレクトリを使用
export HPM_CACHE_DIR=/tmp/hpm-cache
hpm install
```

---

## 参照

- [設定](#hpm-commands-configuration) - 設定ファイル
- [パッケージ仕様](#hpm-commands-package-spec) - package.jsonの形式
- [トラブルシューティング](#hpm-commands-troubleshooting) - よくある問題


--------------------------------------------------------------------------------
## トラブルシューティング
--------------------------------------------------------------------------------

# トラブルシューティング

hpmの一般的な問題と解決策。

## インストールの問題

### "hemlock: command not found"

**原因:** HemlockがインストールされていないかPATHにない。

**解決策:**

```bash
# hemlockが存在するか確認
which hemlock

# 見つからない場合、まずHemlockをインストール
# https://github.com/hemlang/hemlock を参照

# インストール後に確認
hemlock --version
```

### "hpm: command not found"

**原因:** hpmがインストールされていないかPATHにない。

**解決策:**

```bash
# hpmがどこにインストールされているか確認
ls -la /usr/local/bin/hpm
ls -la ~/.local/bin/hpm

# カスタム場所を使用している場合、PATHに追加
export PATH="$HOME/.local/bin:$PATH"

# 永続化のため~/.bashrcまたは~/.zshrcに追加
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# 必要に応じて再インストール
cd /path/to/hpm
sudo make install
```

### インストール時の"Permission denied"

**原因:** インストールディレクトリへの書き込み権限がない。

**解決策:**

```bash
# オプション1: システム全体のインストールにsudoを使用
sudo make install

# オプション2: ユーザーディレクトリにインストール（sudoが不要）
make install PREFIX=$HOME/.local
```

## 依存関係の問題

### "Package not found"（終了コード2）

**原因:** パッケージがGitHubに存在しない。

**解決策:**

```bash
# パッケージが存在するか確認
# https://github.com/owner/repo をチェック

# スペルを確認
hpm install hemlang/sprout  # 正しい
hpm install hemlan/sprout   # 間違ったowner
hpm install hemlang/spout   # 間違ったrepo

# package.jsonのタイプミスを確認
cat package.json | grep -A 5 dependencies
```

### "Version not found"（終了コード3）

**原因:** バージョン制約に一致するリリースがない。

**解決策:**

```bash
# 利用可能なバージョンをリスト（GitHubのリリース/タグを確認）
# タグは'v'で始まる必要あり（例: v1.0.0）

# 有効なバージョン制約を使用
hpm install owner/repo@^1.0.0

# 最新バージョンを試す
hpm install owner/repo

# GitHubで利用可能なタグを確認
# https://github.com/owner/repo/tags
```

### "Dependency conflict"（終了コード1）

**原因:** 2つのパッケージが依存関係の互換性のないバージョンを要求。

**解決策:**

```bash
# 競合を確認
hpm install --verbose

# 何がその依存関係を要求しているか確認
hpm why conflicting/package

# 解決策:
# 1. 競合しているパッケージを更新
hpm update problem/package

# 2. package.jsonでバージョン制約を変更
# 互換性のあるバージョンを許可するように編集

# 3. 競合しているパッケージの1つを削除
hpm uninstall one/package
```

### "Circular dependency"（終了コード8）

**原因:** パッケージAがBに依存し、BがAに依存。

**解決策:**

```bash
# サイクルを特定
hpm install --verbose

# これは通常パッケージ自体のバグ
# パッケージメンテナーに連絡

# 回避策: 循環しているパッケージの1つの使用を避ける
```

## ネットワークの問題

### "Network error"（終了コード4）

**原因:** GitHub APIに接続できない。

**解決策:**

```bash
# インターネット接続を確認
ping github.com

# GitHub APIにアクセスできるか確認
curl -I https://api.github.com

# 再試行（hpmは自動的にリトライ）
hpm install

# パッケージがキャッシュされている場合はオフラインモードを使用
hpm install --offline

# ファイアウォールの背後にいる場合はプロキシ設定を確認
export HTTPS_PROXY=http://proxy:8080
hpm install
```

### "GitHub rate limit exceeded"（終了コード7）

**原因:** 認証なしでAPIリクエストが多すぎる。

**解決策:**

```bash
# オプション1: GitHubトークンで認証（推奨）
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# トークンを作成: GitHub → Settings → Developer settings → Personal access tokens

# オプション2: トークンを設定ファイルに保存
mkdir -p ~/.hpm
echo '{"github_token": "ghp_xxxxxxxxxxxx"}' > ~/.hpm/config.json

# オプション3: レート制限のリセットを待つ（毎時リセット）

# オプション4: オフラインモードを使用
hpm install --offline
```

### 接続タイムアウト

**原因:** ネットワークが遅いかGitHub APIの問題。

**解決策:**

```bash
# hpmは指数バックオフで自動的にリトライ

# GitHubに問題がないか確認
# https://www.githubstatus.com を参照

# 後で再試行
hpm install

# キャッシュされたパッケージを使用
hpm install --offline
```

## Package.jsonの問題

### "Invalid package.json"（終了コード5）

**原因:** 不正な形式または必須フィールドの欠落。

**解決策:**

```bash
# JSON構文を検証
cat package.json | python -m json.tool

# 必須フィールドを確認
cat package.json

# 必須フィールド:
# - "name": "owner/repo"形式
# - "version": "X.Y.Z"形式

# 必要に応じて再生成
rm package.json
hpm init
```

### "name"形式エラー

**原因:** パッケージ名が`owner/repo`形式でない。

**解決策:**

```json
// 間違い
{
  "name": "my-package"
}

// 正しい
{
  "name": "yourusername/my-package"
}
```

### "version"形式エラー

**原因:** バージョンがsemver形式でない。

**解決策:**

```json
// 間違い
{
  "version": "1.0"
}

// 正しい
{
  "version": "1.0.0"
}
```

## ロックファイルの問題

### ロックファイルの同期が取れていない

**原因:** package.jsonがinstallを実行せずに変更された。

**解決策:**

```bash
# ロックファイルを再生成
rm package-lock.json
hpm install
```

### 破損したロックファイル

**原因:** 無効なJSONまたは手動編集。

**解決策:**

```bash
# JSONの有効性を確認
cat package-lock.json | python -m json.tool

# 再生成
rm package-lock.json
hpm install
```

## hem_modulesの問題

### パッケージがインストールされない

**原因:** 様々な問題の可能性。

**解決策:**

```bash
# クリーンにして再インストール
rm -rf hem_modules
hpm install

# 詳細出力を確認
hpm install --verbose
```

### インポートが機能しない

**原因:** パッケージが正しくインストールされていないか、インポートパスが間違っている。

**解決策:**

```bash
# パッケージがインストールされているか確認
ls hem_modules/owner/repo/

# package.jsonのmainフィールドを確認
cat hem_modules/owner/repo/package.json

# 正しいインポート形式
import { x } from "owner/repo";          # mainエントリを使用
import { y } from "owner/repo/subpath";  # サブパスインポート
```

### "Module not found"エラー

**原因:** インポートパスがファイルに解決されない。

**解決策:**

```bash
# インポートパスを確認
ls hem_modules/owner/repo/src/

# index.hmlを確認
ls hem_modules/owner/repo/src/index.hml

# package.jsonのmainフィールドを確認
cat hem_modules/owner/repo/package.json | grep main
```

## キャッシュの問題

### キャッシュの容量が大きすぎる

**解決策:**

```bash
# キャッシュサイズを表示
hpm cache list

# キャッシュをクリア
hpm cache clean
```

### キャッシュの権限

**解決策:**

```bash
# 権限を修正
chmod -R u+rw ~/.hpm/cache

# または削除して再インストール
rm -rf ~/.hpm/cache
hpm install
```

### 間違ったキャッシュを使用

**解決策:**

```bash
# キャッシュの場所を確認
echo $HPM_CACHE_DIR
ls ~/.hpm/cache

# 間違っている場合は環境変数をクリア
unset HPM_CACHE_DIR
```

## スクリプトの問題

### "Script not found"

**原因:** スクリプト名がpackage.jsonに存在しない。

**解決策:**

```bash
# 利用可能なスクリプトをリスト
cat package.json | grep -A 20 scripts

# スペルを確認
hpm run test    # 正しい
hpm run tests   # スクリプト名が"test"の場合は間違い
```

### スクリプトが失敗

**原因:** スクリプトコマンドにエラー。

**解決策:**

```bash
# コマンドを直接実行してエラーを確認
hemlock test/run.hml

# スクリプト定義を確認
cat package.json | grep test
```

## デバッグ

### 詳細出力を有効化

```bash
hpm install --verbose
```

### hpmバージョンを確認

```bash
hpm --version
```

### hemlockバージョンを確認

```bash
hemlock --version
```

### ドライラン

変更を加えずにプレビュー:

```bash
hpm install --dry-run
```

### クリーンスレート

最初から始める:

```bash
rm -rf hem_modules package-lock.json
hpm install
```

## ヘルプを得る

### コマンドヘルプ

```bash
hpm --help
hpm install --help
```

### 問題を報告

バグに遭遇した場合:

1. 既存のIssueを確認: https://github.com/hemlang/hpm/issues
2. 以下を含む新しいIssueを作成:
   - hpmバージョン（`hpm --version`）
   - Hemlockバージョン（`hemlock --version`）
   - オペレーティングシステム
   - 再現手順
   - エラーメッセージ（`--verbose`を使用）

## 終了コードリファレンス

| コード | 意味 | 一般的な解決策 |
|------|---------|-----------------|
| 0 | 成功 | - |
| 1 | 依存関係の競合 | 更新または制約を変更 |
| 2 | パッケージが見つからない | スペルを確認、リポジトリの存在を確認 |
| 3 | バージョンが見つからない | GitHubで利用可能なバージョンを確認 |
| 4 | ネットワークエラー | 接続を確認、リトライ |
| 5 | 無効なpackage.json | JSON構文と必須フィールドを修正 |
| 6 | 整合性チェック失敗 | キャッシュをクリアして再インストール |
| 7 | GitHubレート制限 | GITHUB_TOKENを追加 |
| 8 | 循環依存 | パッケージメンテナーに連絡 |

## 参照

- [インストール](#hpm-troubleshooting-installation) - インストールガイド
- [設定](#hpm-troubleshooting-configuration) - 設定オプション
- [コマンド](#hpm-troubleshooting-commands) - コマンドリファレンス


--------------------------------------------------------------------------------
## 設定
--------------------------------------------------------------------------------

# 設定

このガイドでは、hpmのすべての設定オプションについて説明します。

## 概要

hpmは以下の方法で設定できます:

1. **環境変数** - ランタイム設定用
2. **グローバル設定ファイル** - `~/.hpm/config.json`
3. **プロジェクトファイル** - `package.json`と`package-lock.json`

## 環境変数

### GITHUB_TOKEN

認証用のGitHub APIトークン。

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
```

**認証の利点:**
- より高いAPIレート制限（60ではなく5000リクエスト/時間）
- プライベートリポジトリへのアクセス
- より高速な依存関係解決

**トークンの作成:**

1. GitHub → Settings → Developer settings → Personal access tokensに移動
2. "Generate new token (classic)"をクリック
3. スコープを選択:
   - `repo` - プライベートリポジトリへのアクセス用
   - `read:packages` - GitHub Packages用（使用する場合）
4. 生成してトークンをコピー

### HPM_CACHE_DIR

デフォルトのキャッシュディレクトリを上書きします。

```bash
export HPM_CACHE_DIR=/custom/cache/path
```

デフォルト: `~/.hpm/cache`

**使用例:**
- カスタムキャッシュ場所を持つCI/CDシステム
- プロジェクト間での共有キャッシュ
- 分離されたビルド用の一時キャッシュ

### HOME

ユーザーホームディレクトリ。以下の場所を特定するために使用:
- 設定ディレクトリ: `$HOME/.hpm/`
- キャッシュディレクトリ: `$HOME/.hpm/cache/`

通常はシステムによって設定されます。必要な場合のみ上書きしてください。

### .bashrc / .zshrcの例

```bash
# GitHub認証（推奨）
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx

# カスタムキャッシュ場所（オプション）
# export HPM_CACHE_DIR=/path/to/cache

# hpmをPATHに追加（カスタムインストール場所を使用する場合）
export PATH="$HOME/.local/bin:$PATH"
```

## グローバル設定ファイル

### 場所

`~/.hpm/config.json`

### 形式

```json
{
  "github_token": "ghp_xxxxxxxxxxxxxxxxxxxx"
}
```

### 設定ファイルの作成

```bash
# 設定ディレクトリを作成
mkdir -p ~/.hpm

# 設定ファイルを作成
cat > ~/.hpm/config.json << 'EOF'
{
  "github_token": "ghp_your_token_here"
}
EOF

# ファイルを保護（推奨）
chmod 600 ~/.hpm/config.json
```

### トークンの優先順位

両方が設定されている場合、環境変数が優先されます:

1. `GITHUB_TOKEN`環境変数（最高）
2. `~/.hpm/config.json`の`github_token`フィールド
3. 認証なし（デフォルト）

## ディレクトリ構造

### グローバルディレクトリ

```
~/.hpm/
├── config.json          # グローバル設定
└── cache/               # パッケージキャッシュ
    └── owner/
        └── repo/
            └── 1.0.0.tar.gz
```

### プロジェクトディレクトリ

```
my-project/
├── package.json         # プロジェクトマニフェスト
├── package-lock.json    # 依存関係ロックファイル
├── hem_modules/         # インストールされたパッケージ
│   └── owner/
│       └── repo/
│           ├── package.json
│           └── src/
├── src/                 # ソースコード
└── test/                # テスト
```

## パッケージキャッシュ

### 場所

デフォルト: `~/.hpm/cache/`

上書き: `HPM_CACHE_DIR`環境変数

### 構造

```
~/.hpm/cache/
├── hemlang/
│   ├── sprout/
│   │   ├── 2.0.0.tar.gz
│   │   └── 2.1.0.tar.gz
│   └── router/
│       └── 1.5.0.tar.gz
└── alice/
    └── http-client/
        └── 1.0.0.tar.gz
```

### キャッシュの管理

```bash
# キャッシュされたパッケージを表示
hpm cache list

# キャッシュ全体をクリア
hpm cache clean
```

### キャッシュの動作

- パッケージは最初のダウンロード後にキャッシュされる
- 以降のインストールはキャッシュされたバージョンを使用
- キャッシュのみからインストールするには`--offline`を使用
- キャッシュはすべてのプロジェクト間で共有

## GitHub APIレート制限

### 認証なし

- IPアドレスあたり**60リクエスト/時間**
- 同じIP上のすべての非認証ユーザーで共有
- CI/CDや多くの依存関係がある場合、すぐに枯渇

### 認証あり

- 認証ユーザーあたり**5000リクエスト/時間**
- 個人のレート制限、共有なし

### レート制限の処理

hpmは自動的に:
- 指数バックオフでリトライ（1秒、2秒、4秒、8秒）
- 終了コード7でレート制限エラーを報告
- レート制限された場合に認証を提案

**レート制限時の解決策:**

```bash
# オプション1: GitHubトークンで認証（推奨）
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# オプション2: レート制限のリセットを待つ
# （制限は毎時リセット）

# オプション3: オフラインモードを使用（パッケージがキャッシュされている場合）
hpm install --offline
```

## オフラインモード

ネットワークアクセスなしでパッケージをインストール:

```bash
hpm install --offline
```

**要件:**
- すべてのパッケージがキャッシュにある必要あり
- 正確なバージョンを持つロックファイルが存在する必要あり

**使用例:**
- エアギャップ環境
- CI/CDビルドの高速化（ウォームキャッシュ時）
- レート制限の回避

## CI/CD設定

### GitHub Actions

```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Hemlock
      run: |
        # Hemlockをインストール（セットアップに応じて調整）
        curl -sSL https://hemlock.dev/install.sh | sh

    - name: Cache hpm packages
      uses: actions/cache@v3
      with:
        path: ~/.hpm/cache
        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-hpm-

    - name: Install dependencies
      run: hpm install
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Run tests
      run: hpm test
```

### GitLab CI

```yaml
stages:
  - build
  - test

variables:
  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache

cache:
  paths:
    - .hpm-cache/
  key: $CI_COMMIT_REF_SLUG

build:
  stage: build
  script:
    - hpm install
  artifacts:
    paths:
      - hem_modules/

test:
  stage: test
  script:
    - hpm test
```

### Docker

**Dockerfile:**

```dockerfile
FROM hemlock:latest

WORKDIR /app

# パッケージファイルを最初にコピー（レイヤーキャッシュ用）
COPY package.json package-lock.json ./

# 依存関係をインストール
RUN hpm install

# ソースコードをコピー
COPY . .

# アプリケーションを実行
CMD ["hemlock", "src/main.hml"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - hpm-cache:/root/.hpm/cache

volumes:
  hpm-cache:
```

## プロキシ設定

プロキシの背後にある環境では、システムレベルで設定:

```bash
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080
export NO_PROXY=localhost,127.0.0.1

hpm install
```

## セキュリティのベストプラクティス

### トークンのセキュリティ

1. **トークンをバージョン管理にコミットしない**
2. **CI/CDでは環境変数を使用**
3. **トークンスコープを最小限に制限**
4. **定期的にトークンをローテーション**
5. **設定ファイルを保護**:
   ```bash
   chmod 600 ~/.hpm/config.json
   ```

### プライベートリポジトリ

プライベートパッケージにアクセスするには:

1. `repo`スコープを持つトークンを作成
2. 認証を設定（環境変数または設定ファイル）
3. トークンがリポジトリへのアクセス権を持っていることを確認

```bash
# アクセスをテスト
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install yourorg/private-package
```

## 設定のトラブルシューティング

### 設定の確認

```bash
# トークンが設定されているかチェック
echo $GITHUB_TOKEN | head -c 10

# 設定ファイルをチェック
cat ~/.hpm/config.json

# キャッシュディレクトリをチェック
ls -la ~/.hpm/cache/

# 詳細出力でテスト
hpm install --verbose
```

### よくある問題

**"GitHub rate limit exceeded"**
- `GITHUB_TOKEN`で認証を設定
- レート制限のリセットを待つ
- パッケージがキャッシュされている場合は`--offline`を使用

**キャッシュの"Permission denied"**
```bash
# キャッシュの権限を修正
chmod -R u+rw ~/.hpm/cache
```

**"Config file not found"**
```bash
# 設定ディレクトリを作成
mkdir -p ~/.hpm
touch ~/.hpm/config.json
```

## 参照

- [インストール](#hpm-configuration-installation) - hpmのインストール
- [トラブルシューティング](#hpm-configuration-troubleshooting) - よくある問題
- [コマンド](#hpm-configuration-commands) - コマンドリファレンス



################################################################################
# HPM: パッケージ開発
################################################################################

--------------------------------------------------------------------------------
## バージョニング
--------------------------------------------------------------------------------

# バージョニング

hpmにおけるセマンティックバージョニングの完全ガイド。

## セマンティックバージョニング

hpmはパッケージバージョンに[セマンティックバージョニング2.0.0](https://semver.org/)（semver）を使用します。

### バージョン形式

```
MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
```

**例:**
```
1.0.0           # リリースバージョン
2.1.3           # リリースバージョン
1.0.0-alpha     # プレリリース
1.0.0-beta.1    # 番号付きプレリリース
1.0.0-rc.1      # リリース候補
1.0.0+20231201  # ビルドメタデータ付き
1.0.0-beta+exp  # プレリリース＋ビルドメタデータ
```

### バージョンコンポーネント

| コンポーネント | 説明 | 例 |
|-----------|-------------|---------|
| MAJOR | 破壊的変更 | `1.0.0` → `2.0.0` |
| MINOR | 新機能（後方互換） | `1.0.0` → `1.1.0` |
| PATCH | バグ修正（後方互換） | `1.0.0` → `1.0.1` |
| PRERELEASE | プレリリース識別子 | `1.0.0-alpha` |
| BUILD | ビルドメタデータ（比較で無視） | `1.0.0+build123` |

### いつインクリメントするか

| 変更タイプ | インクリメント | 例 |
|-------------|-----------|---------|
| 破壊的なAPI変更 | MAJOR | 関数の削除 |
| パブリック関数の名前変更 | MAJOR | `parse()` → `decode()` |
| 関数シグネチャの変更 | MAJOR | 必須パラメータの追加 |
| 新しい関数の追加 | MINOR | `validate()`の追加 |
| オプションパラメータの追加 | MINOR | 新しいオプション`options`引数 |
| バグ修正 | PATCH | nullポインタの修正 |
| パフォーマンス改善 | PATCH | より高速なアルゴリズム |
| 内部リファクタリング | PATCH | API変更なし |

## バージョン制約

### 制約の構文

| 構文 | 意味 | 解決範囲 |
|--------|---------|-------------|
| `1.2.3` | 正確なバージョン | 1.2.3のみ |
| `^1.2.3` | キャレット（互換） | ≥1.2.3 かつ <2.0.0 |
| `~1.2.3` | チルダ（パッチ更新） | ≥1.2.3 かつ <1.3.0 |
| `>=1.0.0` | 以上 | 1.0.0以上 |
| `>1.0.0` | より大きい | 1.0.0より上 |
| `<2.0.0` | 未満 | 2.0.0未満 |
| `<=2.0.0` | 以下 | 2.0.0以下 |
| `>=1.0.0 <2.0.0` | 範囲 | 1.0.0と2.0.0の間 |
| `*` | 任意 | 任意のバージョン |

### キャレット範囲（^）

キャレット（`^`）は最左の非ゼロ桁を変更しない変更を許可:

```
^1.2.3  →  >=1.2.3 <2.0.0   # 1.x.xを許可
^0.2.3  →  >=0.2.3 <0.3.0   # 0.2.xを許可
^0.0.3  →  >=0.0.3 <0.0.4   # 0.0.3のみを許可
```

**使用場面:** メジャーバージョン内で互換性のある更新が必要な場合。

**最も一般的な制約** - ほとんどの依存関係に推奨。

### チルダ範囲（~）

チルダ（`~`）はパッチレベルの変更のみを許可:

```
~1.2.3  →  >=1.2.3 <1.3.0   # 1.2.xを許可
~1.2    →  >=1.2.0 <1.3.0   # 1.2.xを許可
~1      →  >=1.0.0 <2.0.0   # 1.x.xを許可
```

**使用場面:** バグ修正のみが必要で、新機能は不要な場合。

### 比較範囲

比較演算子を組み合わせて正確に制御:

```json
{
  "dependencies": {
    "owner/pkg": ">=1.0.0 <2.0.0",
    "owner/other": ">1.5.0 <=2.1.0"
  }
}
```

### 任意のバージョン（*）

任意のバージョンに一致:

```json
{
  "dependencies": {
    "owner/pkg": "*"
  }
}
```

**警告:** 本番環境には推奨しません。常に最新バージョンを取得します。

## プレリリースバージョン

### プレリリース識別子

プレリリースはリリースより優先順位が低い:

```
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0
```

### 一般的なプレリリースタグ

| タグ | 意味 | ステージ |
|-----|---------|-------|
| `alpha` | 初期開発 | 非常に不安定 |
| `beta` | 機能完了 | テスト中 |
| `rc` | リリース候補 | 最終テスト |
| `dev` | 開発スナップショット | 不安定 |

### 制約でのプレリリース

制約はデフォルトでプレリリースに一致しない:

```
^1.0.0    # 1.1.0-betaに一致しない
>=1.0.0   # 2.0.0-alphaに一致しない
```

プレリリースを含めるには、明示的に参照:

```
>=1.0.0-alpha <2.0.0   # すべての1.xプレリリースを含む
```

## バージョン比較

### 比較ルール

1. MAJOR、MINOR、PATCHを数値比較
2. 同じバージョンではリリース > プレリリース
3. プレリリースは英数字順で比較
4. ビルドメタデータは無視

### 例

```
1.0.0 < 1.0.1 < 1.1.0 < 2.0.0

1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0

1.0.0 = 1.0.0+build123  # ビルドメタデータは無視
```

### ソート

バージョンは昇順でソート:

```
1.0.0
1.0.1
1.1.0
1.1.1
2.0.0-alpha
2.0.0-beta
2.0.0
```

## バージョン解決

### 解決アルゴリズム

複数のパッケージが同じ依存関係を要求する場合:

1. すべての制約を収集
2. すべての範囲の共通部分を見つける
3. 共通部分内で最高バージョンを選択
4. すべてを満たすバージョンがない場合はエラー

### 解決例

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)

共通部分: >=1.2.0 <1.3.0
利用可能: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]
解決: 1.2.5（共通部分内で最高）
```

### 競合検出

すべての制約を満たすバージョンがない場合に競合が発生:

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)

共通部分: （空）
結果: 競合 - 両方を満たすバージョンがない
```

## ベストプラクティス

### パッケージ利用者向け

1. **ほとんどの依存関係にキャレット範囲を使用**:
   ```json
   "hemlang/json": "^1.2.0"
   ```

2. **重要な依存関係にはチルダ範囲を使用**:
   ```json
   "critical/lib": "~1.2.0"
   ```

3. **必要な場合のみバージョンを固定**:
   ```json
   "unstable/pkg": "1.2.3"
   ```

4. **再現可能なビルドのためにロックファイルをコミット**

5. **セキュリティ修正を得るために定期的に更新**:
   ```bash
   hpm update
   hpm outdated
   ```

### パッケージ作成者向け

1. **初期開発は0.1.0から開始**:
   - APIは頻繁に変更される可能性
   - ユーザーは不安定さを期待

2. **APIが安定したら1.0.0に移行**:
   - 安定性へのパブリックコミットメント
   - 破壊的変更にはメジャーバンプが必要

3. **semverを厳密に守る**:
   - 破壊的変更 = MAJOR
   - 新機能 = MINOR
   - バグ修正 = PATCH

4. **テストにはプレリリースを使用**:
   ```bash
   git tag v2.0.0-beta.1
   git push --tags
   ```

5. **破壊的変更をCHANGELOGにドキュメント化**

## バージョンの公開

### リリースの作成

```bash
# package.jsonのバージョンを更新
# package.jsonを編集: "version": "1.1.0"

# バージョン変更をコミット
git add package.json
git commit -m "Bump version to 1.1.0"

# タグを作成してプッシュ
git tag v1.1.0
git push origin main --tags
```

### タグ形式

タグは`v`で始まる**必要あり**:

```
v1.0.0      ✓ 正しい
v1.0.0-beta ✓ 正しい
1.0.0       ✗ 認識されない
```

### リリースワークフロー

```bash
# 1. テストが合格することを確認
hpm test

# 2. package.jsonのバージョンを更新
# 3. CHANGELOG.mdを更新
# 4. 変更をコミット
git add -A
git commit -m "Release v1.2.0"

# 5. タグを作成
git tag v1.2.0

# 6. すべてをプッシュ
git push origin main --tags
```

## バージョンの確認

### インストールされたバージョンをリスト

```bash
hpm list
```

### 更新を確認

```bash
hpm outdated
```

出力:
```
Package         Current  Wanted  Latest
hemlang/json    1.0.0    1.0.5   1.2.0
hemlang/sprout  2.0.0    2.0.3   2.1.0
```

- **Current**: インストールされているバージョン
- **Wanted**: 制約に一致する最高バージョン
- **Latest**: 最新の利用可能バージョン

### パッケージの更新

```bash
# すべてを更新
hpm update

# 特定のパッケージを更新
hpm update hemlang/json
```

## 参照

- [パッケージの作成](#hpm-versioning-creating-packages) - 公開ガイド
- [パッケージ仕様](#hpm-versioning-package-spec) - package.jsonの形式
- [コマンド](#hpm-versioning-commands) - CLIリファレンス


--------------------------------------------------------------------------------
## パッケージの作成
--------------------------------------------------------------------------------

# パッケージの作成

このガイドでは、Hemlockパッケージの作成、構造化、公開方法について説明します。

## 概要

hpmはGitHubをパッケージレジストリとして使用します。パッケージはGitHubの`owner/repo`パスで識別され、バージョンはGitタグです。公開は単にタグ付きリリースをプッシュするだけです。

## 新しいパッケージの作成

### 1. パッケージの初期化

新しいディレクトリを作成して初期化:

```bash
mkdir my-package
cd my-package
hpm init
```

プロンプトに答えます:

```
Package name (owner/repo): yourusername/my-package
Version (1.0.0):
Description: A useful Hemlock package
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

### 2. プロジェクト構造の作成

パッケージの推奨構造:

```
my-package/
├── package.json          # パッケージマニフェスト
├── README.md             # ドキュメント
├── LICENSE               # ライセンスファイル
├── src/
│   ├── index.hml         # メインエントリポイント（パブリックAPIをエクスポート）
│   ├── utils.hml         # 内部ユーティリティ
│   └── types.hml         # 型定義
└── test/
    ├── framework.hml     # テストフレームワーク
    └── test_utils.hml    # テスト
```

### 3. パブリックAPIの定義

**src/index.hml** - メインエントリポイント:

```hemlock
// パブリックAPIを再エクスポート
export { parse, stringify } from "./parser.hml";
export { Config, Options } from "./types.hml";
export { process } from "./processor.hml";

// 直接エクスポート
export fn create(options: Options): Config {
    // 実装
}

export fn validate(config: Config): bool {
    // 実装
}
```

### 4. package.jsonの記述

完全なpackage.jsonの例:

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "A useful Hemlock package",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/bundle.hmlc"
  },
  "keywords": ["utility", "parser", "config"],
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ]
}
```

## パッケージの命名

### 要件

- `owner/repo`形式である必要あり
- `owner`はGitHubユーザー名または組織である必要あり
- `repo`はリポジトリ名である必要あり
- 複数単語の名前には小文字とハイフンを使用

### 良い名前

```
hemlang/sprout
alice/http-client
myorg/json-utils
bob/date-formatter
```

### 避けるべき名前

```
my-package          # ownerがない
alice/MyPackage     # PascalCase
alice/my_package    # アンダースコア
```

## パッケージ構造のベストプラクティス

### エントリポイント

package.jsonの`main`フィールドがエントリポイントを指定:

```json
{
  "main": "src/index.hml"
}
```

このファイルでパブリックAPIをエクスポート:

```hemlock
// ユーザーが必要とするすべてをエクスポート
export { Parser, parse } from "./parser.hml";
export { Formatter, format } from "./formatter.hml";

// 型
export type { Config, Options } from "./types.hml";
```

### 内部 vs パブリック

内部実装の詳細をプライベートに保つ:

```
src/
├── index.hml          # パブリック: エクスポートされるAPI
├── parser.hml         # パブリック: index.hmlで使用
├── formatter.hml      # パブリック: index.hmlで使用
└── internal/
    ├── helpers.hml    # プライベート: 内部使用のみ
    └── constants.hml  # プライベート: 内部使用のみ
```

ユーザーはパッケージルートからインポート:

```hemlock
// 良い - パブリックAPIからインポート
import { parse, Parser } from "yourusername/my-package";

// 可能 - サブパスインポート
import { validate } from "yourusername/my-package/validator";

// 非推奨 - 内部へのアクセス
import { helper } from "yourusername/my-package/internal/helpers";
```

### サブパスエクスポート

サブパスからのインポートをサポート:

```
src/
├── index.hml              # メインエントリ
├── parser/
│   └── index.hml          # yourusername/pkg/parser
├── formatter/
│   └── index.hml          # yourusername/pkg/formatter
└── utils/
    └── index.hml          # yourusername/pkg/utils
```

ユーザーは以下のようにインポート可能:

```hemlock
import { parse } from "yourusername/my-package";           // メイン
import { Parser } from "yourusername/my-package/parser";   // サブパス
import { format } from "yourusername/my-package/formatter";
```

## 依存関係

### 依存関係の追加

```bash
# ランタイム依存関係
hpm install hemlang/json

# 開発依存関係
hpm install hemlang/test-utils --dev
```

### 依存関係のベストプラクティス

1. **ほとんどの依存関係にキャレット範囲を使用**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     }
   }
   ```

2. **必要な場合のみバージョンを固定**（APIが不安定な場合）:
   ```json
   {
     "dependencies": {
       "unstable/lib": "1.2.3"
     }
   }
   ```

3. **過度に制限的な範囲を避ける**:
   ```json
   // 悪い: 制限しすぎ
   "hemlang/json": ">=1.2.3 <1.2.5"

   // 良い: 互換性のある更新を許可
   "hemlang/json": "^1.2.3"
   ```

4. **開発依存関係を分離**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     },
     "devDependencies": {
       "hemlang/test-utils": "^1.0.0"
     }
   }
   ```

## パッケージのテスト

### テストの作成

**test/run.hml:**

```hemlock
import { suite, test, assert_eq } from "./framework.hml";
import { parse, stringify } from "../src/index.hml";

fn run_tests() {
    suite("Parser", fn() {
        test("parses valid input", fn() {
            let result = parse("hello");
            assert_eq(result.value, "hello");
        });

        test("handles empty input", fn() {
            let result = parse("");
            assert_eq(result.value, "");
        });
    });

    suite("Stringify", fn() {
        test("stringifies object", fn() {
            let obj = { name: "test" };
            let result = stringify(obj);
            assert_eq(result, '{"name":"test"}');
        });
    });
}

run_tests();
```

### テストの実行

テストスクリプトを追加:

```json
{
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

以下で実行:

```bash
hpm test
```

## 公開

### 前提条件

1. パッケージ名に一致するGitHubリポジトリを作成
2. `package.json`が完全で有効であることを確認
3. すべてのテストが合格

### 公開プロセス

公開は単にGitタグをプッシュするだけ:

```bash
# 1. すべてがコミットされていることを確認
git add .
git commit -m "Prepare v1.0.0 release"

# 2. バージョンタグを作成（'v'で始まる必要あり）
git tag v1.0.0

# 3. コードとタグをプッシュ
git push origin main
git push origin v1.0.0
# または一度にすべてのタグをプッシュ
git push origin main --tags
```

### バージョンタグ

タグは`vX.Y.Z`形式に従う必要あり:

```bash
git tag v1.0.0      # リリース
git tag v1.0.1      # パッチ
git tag v1.1.0      # マイナー
git tag v2.0.0      # メジャー
git tag v1.0.0-beta.1  # プレリリース
```

### リリースチェックリスト

新しいバージョンを公開する前に:

1. package.jsonの**バージョンを更新**
2. **テストを実行**: `hpm test`
3. **CHANGELOG**を更新（ある場合）
4. APIが変更された場合は**README**を更新
5. **変更をコミット**
6. **タグを作成**
7. **GitHubにプッシュ**

### 自動化の例

リリーススクリプトを作成:

```bash
#!/bin/bash
# release.sh - 新しいバージョンをリリース

VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Usage: ./release.sh 1.0.0"
    exit 1
fi

# テストを実行
hpm test || exit 1

# package.jsonのバージョンを更新
sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

# コミットとタグ
git add package.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# プッシュ
git push origin main --tags

echo "Released v$VERSION"
```

## ユーザーによるパッケージのインストール

公開後、ユーザーは以下でインストール可能:

```bash
# 最新バージョン
hpm install yourusername/my-package

# 特定のバージョン
hpm install yourusername/my-package@1.0.0

# バージョン制約
hpm install yourusername/my-package@^1.0.0
```

そしてインポート:

```hemlock
import { parse, stringify } from "yourusername/my-package";
```

## ドキュメント

### README.md

すべてのパッケージにはREADMEが必要:

```markdown
# my-package

このパッケージが何をするかの簡単な説明。

## インストール

\`\`\`bash
hpm install yourusername/my-package
\`\`\`

## 使用方法

\`\`\`hemlock
import { parse } from "yourusername/my-package";

let result = parse("input");
\`\`\`

## API

### parse(input: string): Result

入力文字列を解析します。

### stringify(obj: any): string

オブジェクトを文字列に変換します。

## ライセンス

MIT
```

### APIドキュメント

すべてのパブリックエクスポートをドキュメント化:

```hemlock
/// 入力文字列を構造化されたResultに解析します。
///
/// # 引数
/// * `input` - 解析する文字列
///
/// # 戻り値
/// 解析されたデータまたはエラーを含むResult
///
/// # 例
/// ```
/// let result = parse("hello world");
/// print(result.value);
/// ```
export fn parse(input: string): Result {
    // 実装
}
```

## バージョニングガイドライン

[セマンティックバージョニング](https://semver.org/)に従う:

- **MAJOR**（1.0.0 → 2.0.0）: 破壊的変更
- **MINOR**（1.0.0 → 1.1.0）: 新機能、後方互換
- **PATCH**（1.0.0 → 1.0.1）: バグ修正、後方互換

### いつバンプするか

| 変更タイプ | バージョンバンプ |
|-------------|--------------|
| 破壊的なAPI変更 | MAJOR |
| 関数/型の削除 | MAJOR |
| 関数シグネチャの変更 | MAJOR |
| 新しい関数の追加 | MINOR |
| 新しい機能の追加 | MINOR |
| バグ修正 | PATCH |
| ドキュメント更新 | PATCH |
| 内部リファクタリング | PATCH |

## 参照

- [パッケージ仕様](#hpm-creating-packages-package-spec) - 完全なpackage.jsonリファレンス
- [バージョニング](#hpm-creating-packages-versioning) - セマンティックバージョニングの詳細
- [設定](#hpm-creating-packages-configuration) - GitHub認証


--------------------------------------------------------------------------------
## パッケージ仕様
--------------------------------------------------------------------------------

# パッケージ仕様

`package.json`ファイル形式の完全なリファレンス。

## 概要

すべてのhpmパッケージにはプロジェクトルートに`package.json`ファイルが必要です。このファイルはパッケージのメタデータ、依存関係、スクリプトを定義します。

## 最小限の例

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

## 完全な例

```json
{
  "name": "hemlang/example-package",
  "version": "1.2.3",
  "description": "An example Hemlock package",
  "author": "Hemlock Team <team@hemlock.dev>",
  "license": "MIT",
  "repository": "https://github.com/hemlang/example-package",
  "homepage": "https://hemlang.github.io/example-package",
  "bugs": "https://github.com/hemlang/example-package/issues",
  "main": "src/index.hml",
  "keywords": ["example", "utility", "hemlock"],
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "^2.1.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/bundle.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

## フィールドリファレンス

### name（必須）

`owner/repo`形式のパッケージ名。

```json
{
  "name": "hemlang/sprout"
}
```

**要件:**
- `owner/repo`形式である必要あり
- `owner`はGitHubユーザー名または組織である必要あり
- `repo`はリポジトリ名である必要あり
- 小文字、数字、ハイフンを使用
- 合計最大214文字

**有効な名前:**
```
hemlang/sprout
alice/http-client
myorg/json-utils
bob123/my-lib
```

**無効な名前:**
```
my-package          # ownerがない
hemlang/My_Package  # 大文字とアンダースコア
hemlang             # repoがない
```

### version（必須）

[セマンティックバージョニング](https://semver.org/)に従うパッケージバージョン。

```json
{
  "version": "1.2.3"
}
```

**形式:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`

**有効なバージョン:**
```
1.0.0
2.1.3
1.0.0-alpha
1.0.0-beta.1
1.0.0-rc.1+build.123
0.1.0
```

### description

パッケージの短い説明。

```json
{
  "description": "A fast JSON parser for Hemlock"
}
```

- 200文字以下に保つ
- パッケージが何をするかを説明、どのようにではなく

### author

パッケージ作者情報。

```json
{
  "author": "Your Name <email@example.com>"
}
```

**受け入れられる形式:**
```json
"author": "Your Name"
"author": "Your Name <email@example.com>"
"author": "Your Name <email@example.com> (https://website.com)"
```

### license

ライセンス識別子。

```json
{
  "license": "MIT"
}
```

**一般的なライセンス:**
- `MIT` - MITライセンス
- `Apache-2.0` - Apache License 2.0
- `GPL-3.0` - GNU General Public License v3.0
- `BSD-3-Clause` - BSD 3条項ライセンス
- `ISC` - ISCライセンス
- `UNLICENSED` - プロプライエタリ/プライベート

可能な限り[SPDX識別子](https://spdx.org/licenses/)を使用してください。

### repository

ソースリポジトリへのリンク。

```json
{
  "repository": "https://github.com/hemlang/sprout"
}
```

### homepage

プロジェクトホームページURL。

```json
{
  "homepage": "https://sprout.hemlock.dev"
}
```

### bugs

イシュートラッカーURL。

```json
{
  "bugs": "https://github.com/hemlang/sprout/issues"
}
```

### main

パッケージのエントリポイントファイル。

```json
{
  "main": "src/index.hml"
}
```

**デフォルト:** `src/index.hml`

ユーザーがパッケージをインポートするとき:
```hemlock
import { x } from "owner/repo";
```

hpmは`main`で指定されたファイルをロードします。

**インポートの解決順序:**
1. 正確なパス: `src/index.hml`
2. .hml拡張子付き: `src/index` → `src/index.hml`
3. indexファイル: `src/index/` → `src/index/index.hml`

### keywords

発見性のためのキーワード配列。

```json
{
  "keywords": ["json", "parser", "utility", "hemlock"]
}
```

- 小文字を使用
- 具体的で関連性のあるものに
- 適切な場合は言語（"hemlock"）を含める

### dependencies

パッケージが動作するために必要なランタイム依存関係。

```json
{
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "~2.1.0",
    "alice/logger": ">=1.0.0 <2.0.0"
  }
}
```

**キー:** パッケージ名（`owner/repo`）
**値:** バージョン制約

**バージョン制約の構文:**

| 制約 | 意味 |
|------------|---------|
| `1.2.3` | 正確なバージョン |
| `^1.2.3` | >=1.2.3 <2.0.0 |
| `~1.2.3` | >=1.2.3 <1.3.0 |
| `>=1.0.0` | 1.0.0以上 |
| `>=1.0.0 <2.0.0` | 範囲 |
| `*` | 任意のバージョン |

### devDependencies

開発専用の依存関係（テスト、ビルドなど）。

```json
{
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0",
    "hemlang/linter": "^2.0.0"
  }
}
```

開発依存関係は:
- 開発中にインストールされる
- パッケージが依存関係として使用されるときはインストールされない
- テスト、ビルド、リンティングなどに使用

### scripts

`hpm run`で実行できる名前付きコマンド。

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

**スクリプトの実行:**
```bash
hpm run start
hpm run build
hpm test        # 'hpm run test'の短縮形
```

**引数の渡し方:**
```bash
hpm run test -- --verbose --filter=unit
```

**一般的なスクリプト:**

| スクリプト | 目的 |
|--------|---------|
| `start` | アプリケーションを起動 |
| `dev` | ホットリロード付き開発モード |
| `test` | テストを実行 |
| `build` | 本番用にビルド |
| `clean` | ビルド成果物を削除 |
| `lint` | コードスタイルをチェック |
| `format` | コードをフォーマット |

### files

パッケージがインストールされるときに含めるファイルとディレクトリ。

```json
{
  "files": [
    "src/",
    "lib/",
    "LICENSE",
    "README.md"
  ]
}
```

**デフォルト動作:** 指定されていない場合、以下を含む:
- リポジトリ内のすべてのファイル
- `.git/`、`node_modules/`、`hem_modules/`を除外

**用途:**
- パッケージサイズを削減
- 配布からテストファイルを除外
- 必要なファイルのみを含める

### native

ネイティブライブラリの要件。

```json
{
  "native": {
    "requires": ["libcurl", "openssl", "sqlite3"]
  }
}
```

システムにインストールが必要なネイティブ依存関係をドキュメント化します。

## 検証

hpmは様々な操作でpackage.jsonを検証します。一般的な検証エラー:

### 必須フィールドの欠落

```
Error: package.json missing required field: name
```

**修正:** 必須フィールドを追加。

### 無効なname形式

```
Error: Invalid package name. Must be in owner/repo format.
```

**修正:** `owner/repo`形式を使用。

### 無効なversion

```
Error: Invalid version "1.0". Must be semver format (X.Y.Z).
```

**修正:** 完全なsemver形式（`1.0.0`）を使用。

### 無効なJSON

```
Error: package.json is not valid JSON
```

**修正:** JSON構文を確認（カンマ、クォート、括弧）。

## package.jsonの作成

### インタラクティブ

```bash
hpm init
```

各フィールドをインタラクティブにプロンプト。

### デフォルト値で

```bash
hpm init --yes
```

デフォルト値で作成:
```json
{
  "name": "directory-name/directory-name",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "license": "MIT",
  "main": "src/index.hml",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

### 手動

ファイルを手動で作成:

```bash
cat > package.json << 'EOF'
{
  "name": "yourname/your-package",
  "version": "1.0.0",
  "description": "Your package description",
  "main": "src/index.hml",
  "dependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
EOF
```

## ベストプラクティス

1. **常にmainを指定** - デフォルトに頼らない
2. **キャレット範囲を使用** - ほとんどの依存関係には`^1.0.0`
3. **開発依存関係を分離** - テスト/ビルド依存関係はdevDependenciesに
4. **キーワードを含める** - ユーザーがパッケージを見つけやすくする
5. **スクリプトをドキュメント化** - スクリプトに明確な名前を付ける
6. **ライセンスを指定** - オープンソースには必須
7. **説明を追加** - ユーザーが目的を理解しやすくする

## 参照

- [パッケージの作成](#hpm-package-spec-creating-packages) - 公開ガイド
- [バージョニング](#hpm-package-spec-versioning) - バージョン制約
- [プロジェクトセットアップ](#hpm-package-spec-project-setup) - プロジェクト構造



################################################################################
# HPM: リファレンス
################################################################################

--------------------------------------------------------------------------------
## アーキテクチャ
--------------------------------------------------------------------------------

# アーキテクチャ

hpmの内部アーキテクチャと設計。このドキュメントは、貢献者およびhpmの動作に興味のある方向けです。

## 概要

hpmはHemlockで書かれており、パッケージ管理の様々な側面を処理するいくつかのモジュールで構成されています:

```
src/
├── main.hml        # CLIエントリポイントとコマンドルーティング
├── manifest.hml    # package.jsonの処理
├── lockfile.hml    # package-lock.jsonの処理
├── semver.hml      # セマンティックバージョニング
├── resolver.hml    # 依存関係解決
├── github.hml      # GitHub APIクライアント
├── installer.hml   # パッケージのダウンロードと展開
└── cache.hml       # グローバルキャッシュ管理
```

## モジュールの責務

### main.hml

CLIアプリケーションのエントリポイント。

**責務:**
- コマンドライン引数の解析
- 適切なハンドラへのコマンドルーティング
- ヘルプとバージョン情報の表示
- グローバルフラグの処理（--verbose、--dry-runなど）
- 適切なコードでの終了

**主要関数:**
- `main()` - エントリポイント、引数を解析してコマンドをディスパッチ
- `cmd_init()` - `hpm init`を処理
- `cmd_install()` - `hpm install`を処理
- `cmd_uninstall()` - `hpm uninstall`を処理
- `cmd_update()` - `hpm update`を処理
- `cmd_list()` - `hpm list`を処理
- `cmd_outdated()` - `hpm outdated`を処理
- `cmd_run()` - `hpm run`を処理
- `cmd_why()` - `hpm why`を処理
- `cmd_cache()` - `hpm cache`を処理

**コマンドショートカット:**
```hemlock
let shortcuts = {
    "i": "install",
    "rm": "uninstall",
    "remove": "uninstall",
    "ls": "list",
    "up": "update"
};
```

### manifest.hml

`package.json`ファイルの読み書きを処理。

**責務:**
- package.jsonの読み書き
- パッケージ構造の検証
- 依存関係の管理
- パッケージ指定子（owner/repo@version）の解析

**主要関数:**
```hemlock
create_default(): Manifest           // 空のマニフェストを作成
read_manifest(): Manifest            // ファイルから読み込み
write_manifest(m: Manifest)          // ファイルに書き込み
validate(m: Manifest): bool          // 構造を検証
get_all_dependencies(m): Map         // deps + devDepsを取得
add_dependency(m, pkg, ver, dev)     // 依存関係を追加
remove_dependency(m, pkg)            // 依存関係を削除
parse_specifier(spec): (name, ver)   // "owner/repo@^1.0.0"を解析
split_name(name): (owner, repo)      // "owner/repo"を解析
```

**マニフェスト構造:**
```hemlock
type Manifest = {
    name: string,
    version: string,
    description: string?,
    author: string?,
    license: string?,
    repository: string?,
    main: string?,
    dependencies: Map<string, string>,
    devDependencies: Map<string, string>,
    scripts: Map<string, string>
};
```

### lockfile.hml

再現可能なインストールのための`package-lock.json`ファイルを管理。

**責務:**
- ロックファイルの作成/読み取り/書き込み
- 解決された正確なバージョンの追跡
- ダウンロードURLと整合性ハッシュの保存
- 孤立した依存関係の削除

**主要関数:**
```hemlock
create_empty(): Lockfile              // 空のロックファイルを作成
read_lockfile(): Lockfile             // ファイルから読み込み
write_lockfile(l: Lockfile)           // ファイルに書き込み
create_entry(ver, url, hash, deps)    // ロックエントリを作成
get_locked(l, pkg): LockEntry?        // ロックされたバージョンを取得
set_locked(l, pkg, entry)             // ロックされたバージョンを設定
remove_locked(l, pkg)                 // エントリを削除
prune(l, keep: Set)                   // 孤立を削除
needs_update(l, m): bool              // 同期が取れているかチェック
```

**ロックファイル構造:**
```hemlock
type Lockfile = {
    lockVersion: int,
    hemlock: string,
    dependencies: Map<string, LockEntry>
};

type LockEntry = {
    version: string,
    resolved: string,     // ダウンロードURL
    integrity: string,    // SHA256ハッシュ
    dependencies: Map<string, string>
};
```

### semver.hml

セマンティックバージョニング2.0.0の完全な実装。

**責務:**
- バージョン文字列の解析
- バージョンの比較
- バージョン制約の解析と評価
- 制約を満たすバージョンの検索

**主要関数:**
```hemlock
// 解析
parse(s: string): Version             // "1.2.3-beta+build" → Version
stringify(v: Version): string         // Version → "1.2.3-beta+build"

// 比較
compare(a, b: Version): int           // -1、0、または1
gt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool

// 制約
parse_constraint(s: string): Constraint    // "^1.2.3" → Constraint
satisfies(v: Version, c: Constraint): bool // vがcに一致するかチェック
max_satisfying(versions, c): Version?      // 最高の一致を見つける
sort(versions): [Version]                  // 昇順ソート

// ユーティリティ
constraints_overlap(a, b: Constraint): bool  // 互換性をチェック
```

**バージョン構造:**
```hemlock
type Version = {
    major: int,
    minor: int,
    patch: int,
    prerelease: [string]?,  // 例: ["beta", "1"]
    build: string?          // 例: "20230101"
};
```

**制約の種類:**
```hemlock
type Constraint =
    | Exact(Version)           // "1.2.3"
    | Caret(Version)           // "^1.2.3" → >=1.2.3 <2.0.0
    | Tilde(Version)           // "~1.2.3" → >=1.2.3 <1.3.0
    | Range(op, Version)       // ">=1.0.0"、"<2.0.0"
    | And(Constraint, Constraint)  // 結合された範囲
    | Any;                     // "*"
```

### resolver.hml

npmスタイルの依存関係解決を実装。

**責務:**
- 依存関係ツリーの解決
- バージョン競合の検出
- 循環依存の検出
- 可視化ツリーの構築

**主要関数:**
```hemlock
resolve(manifest, lockfile): ResolveResult
    // メインリゾルバ: 解決されたバージョンを持つすべての依存関係のフラットマップを返す

resolve_version(pkg, constraints: [string]): ResolvedPackage?
    // すべての制約を満たすバージョンを見つける

detect_cycles(deps: Map): [Cycle]?
    // DFSを使用して循環依存を見つける

build_tree(lockfile): Tree
    // 表示用のツリー構造を作成

find_why(pkg, lockfile): [Chain]
    // パッケージがインストールされている理由を説明する依存関係チェーンを見つける
```

**解決アルゴリズム:**

1. **制約を収集**: マニフェストと推移的依存関係を走査
2. **各パッケージを解決**: 各パッケージについて:
   - 依存元からのすべてのバージョン制約を取得
   - GitHubから利用可能なバージョンを取得
   - すべての制約を満たす最高バージョンを見つける
   - 満たすバージョンがない場合: 競合
3. **循環を検出**: DFSを実行して循環依存を見つける
4. **フラットマップを返す**: パッケージ名 → 解決されたバージョン情報

**ResolveResult構造:**
```hemlock
type ResolveResult = {
    packages: Map<string, ResolvedPackage>,
    conflicts: [Conflict]?,
    cycles: [Cycle]?
};

type ResolvedPackage = {
    name: string,
    version: Version,
    url: string,
    dependencies: Map<string, string>
};
```

### github.hml

パッケージ発見とダウンロード用のGitHub APIクライアント。

**責務:**
- 利用可能なバージョン（タグ）の取得
- リポジトリからのpackage.jsonのダウンロード
- リリースtarballのダウンロード
- 認証とレート制限の処理

**主要関数:**
```hemlock
get_token(): string?
    // 環境変数または設定からトークンを取得

github_request(url, headers?): Response
    // リトライ付きでAPIリクエストを実行

get_tags(owner, repo): [string]
    // バージョンタグを取得（v1.0.0、v1.1.0など）

get_package_json(owner, repo, ref): Manifest
    // 特定のタグ/コミットでpackage.jsonを取得

download_tarball(owner, repo, tag): bytes
    // リリースアーカイブをダウンロード

repo_exists(owner, repo): bool
    // リポジトリが存在するかチェック

get_repo_info(owner, repo): RepoInfo
    // リポジトリメタデータを取得
```

**リトライロジック:**
- 指数バックオフ: 1秒、2秒、4秒、8秒
- 以下でリトライ: 403（レート制限）、5xx（サーバーエラー）、ネットワークエラー
- 最大4回リトライ
- レート制限エラーを明確に報告

**使用するAPIエンドポイント:**
```
GET /repos/{owner}/{repo}/tags
GET /repos/{owner}/{repo}/contents/package.json?ref={tag}
GET /repos/{owner}/{repo}/tarball/{tag}
GET /repos/{owner}/{repo}
```

### installer.hml

パッケージのダウンロードと展開を処理。

**責務:**
- GitHubからパッケージをダウンロード
- hem_modulesにtarballを展開
- キャッシュされたパッケージのチェック/使用
- パッケージのインストール/アンインストール

**主要関数:**
```hemlock
install_package(pkg: ResolvedPackage): bool
    // 単一パッケージをダウンロードしてインストール

install_all(packages: Map, options): InstallResult
    // 解決されたすべてのパッケージをインストール

uninstall_package(name: string): bool
    // hem_modulesからパッケージを削除

get_installed(): Map<string, string>
    // 現在インストールされているパッケージをリスト

verify_integrity(pkg): bool
    // パッケージの整合性を検証

prefetch_packages(packages: Map): void
    // キャッシュへの並列ダウンロード（実験的）
```

**インストールプロセス:**

1. 正しいバージョンで既にインストールされているかチェック
2. キャッシュにtarballがあるかチェック
3. キャッシュにない場合、GitHubからダウンロード
4. 将来の使用のためにキャッシュに保存
5. `hem_modules/owner/repo/`に展開
6. インストールを検証

**作成されるディレクトリ構造:**
```
hem_modules/
└── owner/
    └── repo/
        ├── package.json
        ├── src/
        └── ...
```

### cache.hml

グローバルパッケージキャッシュを管理。

**責務:**
- ダウンロードしたtarballの保存
- キャッシュされたパッケージの取得
- キャッシュされたパッケージのリスト
- キャッシュのクリア
- 設定の管理

**主要関数:**
```hemlock
get_cache_dir(): string
    // キャッシュディレクトリを取得（HPM_CACHE_DIRを尊重）

get_config_dir(): string
    // 設定ディレクトリを取得（~/.hpm）

is_cached(owner, repo, version): bool
    // tarballがキャッシュされているかチェック

get_cached_path(owner, repo, version): string
    // キャッシュされたtarballへのパスを取得

store_tarball_file(owner, repo, version, data): void
    // tarballをキャッシュに保存

list_cached(): [CachedPackage]
    // すべてのキャッシュされたパッケージをリスト

clear_cache(): int
    // すべてのキャッシュされたパッケージを削除、解放バイト数を返す

get_cache_size(): int
    // 合計キャッシュサイズを計算

read_config(): Config
    // ~/.hpm/config.jsonを読み込み

write_config(c: Config): void
    // 設定ファイルを書き込み
```

**キャッシュ構造:**
```
~/.hpm/
├── config.json
└── cache/
    └── owner/
        └── repo/
            ├── 1.0.0.tar.gz
            └── 1.1.0.tar.gz
```

## データフロー

### インストールコマンドフロー

```
hpm install owner/repo@^1.0.0
         │
         ▼
    ┌─────────┐
    │ main.hml │ 引数を解析、cmd_installを呼び出し
    └────┬────┘
         │
         ▼
    ┌──────────┐
    │manifest.hml│ package.jsonを読み込み、依存関係を追加
    └────┬─────┘
         │
         ▼
    ┌──────────┐
    │resolver.hml│ すべての依存関係を解決
    └────┬─────┘
         │
         ├───────────────┐
         ▼               ▼
    ┌──────────┐    ┌─────────┐
    │ github.hml│    │ semver.hml│ バージョンを取得、満たすものを見つける
    └────┬─────┘    └─────────┘
         │
         ▼
    ┌───────────┐
    │installer.hml│ パッケージをダウンロードして展開
    └────┬──────┘
         │
         ├───────────────┐
         ▼               ▼
    ┌──────────┐    ┌─────────┐
    │ github.hml│    │ cache.hml│ ダウンロードまたはキャッシュを使用
    └──────────┘    └─────────┘
         │
         ▼
    ┌──────────┐
    │lockfile.hml│ package-lock.jsonを更新
    └──────────┘
```

### 解決アルゴリズムの詳細

```
入力: manifest.dependencies、manifest.devDependencies、既存のロックファイル

1. 初期化:
   - constraints = {} // Map<string, [Constraint]>
   - resolved = {}    // Map<string, ResolvedPackage>
   - queue = [直接依存関係]

2. キューが空でない間:
   a. pkg = queue.pop()
   b. pkgが既に解決済みならスキップ
   c. 依存元からpkgのすべての制約を取得
   d. GitHubから利用可能なバージョンを取得（キャッシュ）
   e. すべての制約を満たす最大バージョンを見つける
   f. 見つからない場合: 競合
   g. resolved[pkg] = {version, url, deps}
   h. pkgの依存関係をキューに追加

3. 解決されたグラフで循環を検出
   - 循環が見つかった場合: エラー

4. 解決されたマップを返す
```

## エラー処理

### 終了コード

main.hmlで定義:

```hemlock
let EXIT_SUCCESS = 0;
let EXIT_CONFLICT = 1;
let EXIT_NOT_FOUND = 2;
let EXIT_VERSION_NOT_FOUND = 3;
let EXIT_NETWORK = 4;
let EXIT_INVALID_MANIFEST = 5;
let EXIT_INTEGRITY = 6;
let EXIT_RATE_LIMIT = 7;
let EXIT_CIRCULAR = 8;
```

### エラー伝播

エラーは戻り値を通じてバブルアップ:

```hemlock
fn resolve_version(pkg): Result<Version, ResolveError> {
    let versions = github.get_tags(owner, repo)?;  // ?が伝播
    // ...
}
```

## テスト

### テストフレームワーク

`test/framework.hml`のカスタムテストフレームワーク:

```hemlock
fn suite(name: string, tests: fn()) {
    print("Suite: " + name);
    tests();
}

fn test(name: string, body: fn()) {
    try {
        body();
        print("  ✓ " + name);
    } catch e {
        print("  ✗ " + name + ": " + e);
        failed += 1;
    }
}

fn assert_eq<T>(actual: T, expected: T) {
    if actual != expected {
        throw "Expected " + expected + ", got " + actual;
    }
}
```

### テストファイル

- `test/test_semver.hml` - バージョン解析、比較、制約
- `test/test_manifest.hml` - マニフェストの読み書き、検証
- `test/test_lockfile.hml` - ロックファイル操作
- `test/test_cache.hml` - キャッシュ管理

### テストの実行

```bash
# すべてのテスト
make test

# 特定のテスト
make test-semver
make test-manifest
make test-lockfile
make test-cache
```

## 将来の改善

### 計画された機能

1. **整合性検証** - 完全なSHA256ハッシュチェック
2. **ワークスペース** - モノレポサポート
3. **プラグインシステム** - 拡張可能なコマンド
4. **監査** - セキュリティ脆弱性チェック
5. **プライベートレジストリ** - セルフホストパッケージホスティング

### 既知の制限

1. **バンドラーバグ** - スタンドアロン実行可能ファイルを作成できない
2. **並列ダウンロード** - 実験的、競合状態の可能性あり
3. **整合性** - SHA256が完全に実装されていない

## 貢献

### コードスタイル

- 4スペースインデント
- 関数は1つのことを行うべき
- 複雑なロジックにコメント
- 新機能にはテストを書く

### コマンドの追加

1. `main.hml`にハンドラを追加:
   ```hemlock
   fn cmd_newcmd(args: [string]) {
       // 実装
   }
   ```

2. コマンドディスパッチに追加:
   ```hemlock
   match command {
       "newcmd" => cmd_newcmd(args),
       // ...
   }
   ```

3. ヘルプテキストを更新

### モジュールの追加

1. `src/newmodule.hml`を作成
2. パブリックインターフェースをエクスポート
3. 必要なモジュールでインポート
4. `test/test_newmodule.hml`にテストを追加

## 参照

- [コマンド](#hpm-architecture-commands) - CLIリファレンス
- [パッケージの作成](#hpm-architecture-creating-packages) - パッケージ開発
- [バージョニング](#hpm-architecture-versioning) - セマンティックバージョニング


--------------------------------------------------------------------------------
## 終了コード
--------------------------------------------------------------------------------

# 終了コード

hpmの終了コードとその意味のリファレンス。

## 終了コード一覧

| コード | 名前 | 説明 |
|------|------|-------------|
| 0 | SUCCESS | コマンドが正常に完了 |
| 1 | CONFLICT | 依存関係のバージョン競合 |
| 2 | NOT_FOUND | パッケージが見つからない |
| 3 | VERSION_NOT_FOUND | 要求されたバージョンが見つからない |
| 4 | NETWORK | ネットワークエラー |
| 5 | INVALID_MANIFEST | 無効なpackage.json |
| 6 | INTEGRITY | 整合性チェック失敗 |
| 7 | RATE_LIMIT | GitHub APIレート制限超過 |
| 8 | CIRCULAR | 循環依存を検出 |

## 詳細な説明

### 終了コード0: SUCCESS

コマンドが正常に完了しました。

```bash
$ hpm install
Installed 5 packages
$ echo $?
0
```

### 終了コード1: CONFLICT

2つ以上のパッケージが依存関係の互換性のないバージョンを要求しています。

**例:**
```
Error: Dependency conflict for hemlang/json

  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)
  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)

No version satisfies all constraints.
```

**解決策:**
1. どのパッケージが競合しているか確認:
   ```bash
   hpm why hemlang/json
   ```
2. 競合しているパッケージを更新:
   ```bash
   hpm update package-a
   ```
3. package.jsonのバージョン制約を緩和
4. 競合しているパッケージの1つを削除

### 終了コード2: NOT_FOUND

指定されたパッケージがGitHubに存在しません。

**例:**
```
Error: Package not found: hemlang/nonexistent

The repository hemlang/nonexistent does not exist on GitHub.
```

**解決策:**
1. パッケージ名のスペルを確認
2. リポジトリが存在するか確認: `https://github.com/owner/repo`
3. アクセス権を確認（プライベートリポジトリの場合、GITHUB_TOKENを設定）

### 終了コード3: VERSION_NOT_FOUND

指定された制約に一致するバージョンがありません。

**例:**
```
Error: No version of hemlang/json matches constraint ^5.0.0

Available versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0
```

**解決策:**
1. GitHubのリリース/タグで利用可能なバージョンを確認
2. 有効なバージョン制約を使用
3. バージョンタグは`v`で始まる必要あり（例: `v1.0.0`）

### 終了コード4: NETWORK

ネットワーク関連のエラーが発生しました。

**例:**
```
Error: Network error: could not connect to api.github.com

Please check your internet connection and try again.
```

**解決策:**
1. インターネット接続を確認
2. GitHubにアクセスできるか確認
3. ファイアウォールの背後にいる場合はプロキシ設定を確認
4. パッケージがキャッシュされている場合は`--offline`を使用:
   ```bash
   hpm install --offline
   ```
5. 待ってからリトライ（hpmは自動的にリトライ）

### 終了コード5: INVALID_MANIFEST

package.jsonファイルが無効または不正な形式です。

**例:**
```
Error: Invalid package.json

  - Missing required field: name
  - Invalid version format: "1.0"
```

**解決策:**
1. JSON構文を確認（JSONバリデータを使用）
2. 必須フィールドが存在することを確認（`name`、`version`）
3. フィールド形式を確認:
   - name: `owner/repo`形式
   - version: `X.Y.Z` semver形式
4. 再生成:
   ```bash
   rm package.json
   hpm init
   ```

### 終了コード6: INTEGRITY

パッケージの整合性検証が失敗しました。

**例:**
```
Error: Integrity check failed for hemlang/json@1.0.0

Expected: sha256-abc123...
Actual:   sha256-def456...

The downloaded package may be corrupted.
```

**解決策:**
1. キャッシュをクリアして再インストール:
   ```bash
   hpm cache clean
   hpm install
   ```
2. ネットワーク問題を確認（部分的なダウンロード）
3. パッケージが改ざんされていないか確認

### 終了コード7: RATE_LIMIT

GitHub APIのレート制限を超過しました。

**例:**
```
Error: GitHub API rate limit exceeded

Unauthenticated rate limit: 60 requests/hour
Current usage: 60/60

Rate limit resets at: 2024-01-15 10:30:00 UTC
```

**解決策:**
1. **GitHubで認証**（推奨）:
   ```bash
   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
   hpm install
   ```
2. レート制限がリセットされるのを待つ（毎時リセット）
3. パッケージがキャッシュされている場合はオフラインモードを使用:
   ```bash
   hpm install --offline
   ```

### 終了コード8: CIRCULAR

依存関係グラフで循環依存が検出されました。

**例:**
```
Error: Circular dependency detected

  package-a@1.0.0
  └── package-b@1.0.0
      └── package-a@1.0.0  (circular!)

Cannot resolve dependency tree.
```

**解決策:**
1. これは通常パッケージ自体のバグ
2. パッケージメンテナーに連絡
3. 循環しているパッケージの1つの使用を避ける

## スクリプトでの終了コードの使用

### Bash

```bash
#!/bin/bash

hpm install
exit_code=$?

case $exit_code in
  0)
    echo "Installation successful"
    ;;
  1)
    echo "Dependency conflict - check version constraints"
    exit 1
    ;;
  2)
    echo "Package not found - check package name"
    exit 1
    ;;
  4)
    echo "Network error - check connection"
    exit 1
    ;;
  7)
    echo "Rate limited - set GITHUB_TOKEN"
    exit 1
    ;;
  *)
    echo "Unknown error: $exit_code"
    exit 1
    ;;
esac
```

### CI/CD

```yaml
# GitHub Actions
- name: Install dependencies
  run: |
    hpm install
    if [ $? -eq 7 ]; then
      echo "::error::GitHub rate limit exceeded. Add GITHUB_TOKEN."
      exit 1
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Make

```makefile
install:
	@hpm install || (echo "Installation failed with code $$?"; exit 1)

test: install
	@hpm test
```

## 終了コードによるトラブルシューティング

### クイックリファレンス

| コード | 最初に確認すること |
|------|---------------------|
| 1 | `hpm why <package>`を実行して競合を確認 |
| 2 | GitHubでパッケージ名を確認 |
| 3 | GitHubタグで利用可能なバージョンを確認 |
| 4 | インターネット接続を確認 |
| 5 | package.jsonの構文を検証 |
| 6 | `hpm cache clean && hpm install`を実行 |
| 7 | `GITHUB_TOKEN`環境変数を設定 |
| 8 | パッケージメンテナーに連絡 |

## 参照

- [トラブルシューティング](#hpm-exit-codes-troubleshooting) - 詳細な解決策
- [コマンド](#hpm-exit-codes-commands) - コマンドリファレンス
- [設定](#hpm-exit-codes-configuration) - GitHubトークンの設定



================================================================================
END OF DOCUMENTATION
================================================================================