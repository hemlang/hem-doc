<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hemlock Language Manual</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        @media (max-width: 768px) {
            .header h1 {
                display: none;
            }
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            margin-right: 0.5rem;
        }

        @media (max-width: 1023px) {
            .menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 768px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 768px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 769px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 0.5rem;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            margin-left: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <button class="menu-toggle" id="menuToggle" aria-label="Toggle navigation menu" aria-expanded="false">&#9776;</button>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA/4AAAEWCAYAAADfFEwLAAAALHRFWHRDcmVhdGlvbiBUaW1lAE1vbiAxMyBPY3QgMjAyNSAxMDo0NjoyOSAtMDUwMDkKRCAAAAAHdElNRQfpCg0VFSBTc4fRAAAACXBIWXMAAB7BAAAewQHDaVRTAAAABGdBTUEAALGPC/xhBQACWDJJREFUeNrsvQeU5NZ5JvoDqBy6qnMOM50ncEiKwxFFiaRE0xIpK5O0ktder99697x97+07Z3fPezo6x/I+rbO9luRsSbZkeW1RsmRJliVRkUGkGGc4sbunc86pcgDw7r1VqL6FAlCoZndPT8//kRhUowDcCxRw7/3u///fD4BAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIxL5AuNEVQCAQCERl+MlPflJR2/3AAw+oN7rOCAQCgUAgEIgbByT+CMQugeQLcRAweM52224XPX/4PCIQCAQCgUDcOkDij0BUCB0Rs/MOIeFCVASLZ6zSZ49C1a2LPuPziEAgEAgEAnH0gcQfgbABEyJWjoQZES22RrKF0KPMM2a2BpO/zZ491WAbAz6TCAQCgUAgEEcXSPwRiDLgCBm/NvqshxnhQrKFKMCA8Js9b4LFPkbQP3OqybbCvvg8IhAIBAKBQBxNIPFHIExgQfj1C+g+mxEuJFuIAkyeL21tZzE6lsLO82f6XOLziEAgEAgEAnH0gMQfgTCAjpQZLSKYkzEKjUgpJp+RbN2iqGBCSf+cGT1z/Hl4GD1nCuw8g/o1Po8IBAKBQCAQRxiOG12BmwXprCq4HAIOhg8Au7nXe/X7mJAyPfniF/57HjzR0hZ+O/tcW1cvrq2uKIC4JVDBhJJo8Vn/zFkRf57g6xc5fyz/fLJjaT2R/CMQCAQCgUAcHaDF3yaQ+B9u7MXvY0HK9GRfMtgmcqfiSZfMrbXPhYUQf9CI/2EjWvjM7x0srPx6cm+06J83/WQUf17ezZ8n/UbPof6Z1HsAHLpnEoFAIBAIxI1BpWmseeB44nAAib9NHAYStMs60N/4UL5sh+GeatCT/kAgKEajEZ6QSdyaLg4wJmQUPNmiS1a31k8AHEqidZh+n5sZFUwoGT1nksF2K08TCr1rf7lnkX8mkfwjEAgEAoEwIvrl/uaBKYQPIdDV3yb2mgARUiWSc1bk4r3LOhzaF+ygSOXHPv4b4m998jdN77UBMeNJP0/AHLpF28YTf40w8URLzK/1UMFYlO2wkO5DO2l0M8DAym8WMiIZLA7dmp8EEKE03l+DPqafJ/bZ/Dn4Z1LfaStg8kwiEAgEAoE4+rCZXlj/mYc2vi0ZQ5BzszVOANwYoMXfJvY67vx73/+x461vfUCu5Jy7mSw4zNgtuaXH0bXdY7Vy9OVZWWL9fr8jFovRzzzhd3JrJ/e3Rsg00N8om18ytAq6tfadHE8kwef10G2MrGkNodW9OSSTArbu+Y2ux42CDSs/b8HnSb7RYuVhos8mwS+8Sz//POqXwvMIxt4o2EEjEAgEAnGEYYPsW2Ui4qEarDGt9SEBEv/XiZuV4JjV+2a9nkpQJt5ab4Xlyb5LEAS3qqr0bxfskH9tXwqNcGkkKwU5wp/iPvOESyNmhYbxRjWCdn97fgJqv5+Xm/F5NPIggVLSryf8ZpNK+gkAo9ASDUYK/ry1nyf7aW7hyb82AVAUhoIdMwKBQCAQRw8WhN8sbXW5zEJGJN8wgxCgceHAgcR/H3EzkpajDD3hn52bl9paWzR3JI1I8W7VGgFzcYubWzTyzxN/ZTgy3XJ9e6YHBCnxSPu5J0VZiJDtSW7hyb8+vrosycLn6vAi/4zpXfv1E0o8mXfqFheYk3+e+Jdz8dcTf43c84Q/pftbmxwwivnHjhmBQCAQiCMCA8Jv5alotE1/nAb9eKRcCmEk/wcIjPHfRyA5M8dBkleTxk0gpJ/+zZMzfSw/T/g9kCP7Hu4zXTRyJqYg6/3GxNNvn04sP+KWXA4VFPXzw6u3/1rPL/wPKFVX5z9rdcLn5SYGR/r1naNG2DXyrj0zGsl3GSxm4STseXW73Z76hsbuQLCqw+P2tDqcjnpJclSLouAXBNGbL1tWFCUiy9m5ZDJ5eWVp6YeLi/OjUBoaYKbqry34bCIQCAQCcURg4JnIfzbSI9J/rlRgWFuMUgizYzCN8MEAif/rRJlY7EMbk3+jrcY3gPTbSaPGu11rhMzDLV7dWrP6Oy6sXx/8yeL5x0ASa5wOJ6H8Kjm5IKynIg+CJPwFyOoKlKqp0/L4xtAWwcIJpcMFk3h+Myu/mRcJ703CW/4L4n5VoXBtc3PLXYTs30aI/zHY8TIxgySKYlgUXWGn03UyGKx6vKWt/Zmx0eE/3trcXALjjlnO1xknpBAIBAKBOEKwGBPbTS+8G4FhvdCwdox+AgDJ/wEAXf1fJ240gb6V6l1Jnc2s/FA+5tqI9Hvzi49bM+KfgmzgX6affcdUdPmsSGiWyyFBfVUVRBNJiJAlnc2o7+p48//ZH2y7TPaPkiWeXzSXf83F2ra7/14LTe7idzi0E1oHjTKkX+9BwhN+t27hJ5IKpF8QBGd7R9eZuvr6+zweby/sQZutKMryxNj1/3tpaXEcdsJP9BoUWrw/xvojEIhDCSQJCIR9WIgOG5F9fWphu2mFjcINsyZro7TWOM7YZ6DF/3XiMJDnXZK6m86StwvSbyXeZ0X6eTKmEX26+LnP3tHI3PEfLLz8zpSaqRcEEQbaWqC7uQG8bhe8MDTKiL8kSjAbXQwT4k/PpxF9I6E2zcJ66C3+SPpzsCD9vGu/kZVfHzbCh46wfURRdHV2HT9bX9/wkMPprN/LepNzN3Qd7/md7cj2rybi8Wy+jlqqP6uZfAQCgThQGOQR1yDovi/pF5FAIBC7HhPrRYj1i5nQsD6VMJ9RiE9tLXCfi4T+cEJvf4HEXwc+VZz+M79N264/lt/G76s/D7dPifXUqlz9OfRllKsnd6xqVT+z78zOWe54/XH57wVeHb6S+250r+nfY+OT4sz0pBaXLNTW1UuE3EA8HhNcLpeUTqdZYyc5HA5QVQfZUVJkmbpEMyuroiiUoHlkWfBKkuoRBIGRfVVVNeLvp9uenHvxLZc3J+4VRUmibv09LU3wxsEeSGeyrOVyOnKvFtlXUAS1BnSWXMg3nKQekpzNym6PR0wlkyqpr1BHFnI9Spl7p90HTWBFtfitwWqb/rkxe+6Mni+j59Ds/GbPg/55Nnu24BDBRLnfKCOEfjKJJ/xeMCD+zS2t/a1tHe8hz2sTVEa8yWOqZrLZzHQ2k11WyZ9Op7PR6XSVhAVIktTe33/iVy+cf/nTUNqRGyn2Hqr7j0Agji5MVMb1n/UomQDQ8oVTIJFA3IqwkVrYSIeIFxR2GmwzGjNQ6F38+WxCdP80lE4SAHeM6SQeYu+A1hybuBld429W7NaV/blnn9L+tMqdrne/NnLBpoSfkn3N2k8Jf4Cut7Kxhq9PPf3ujUy0QxREUGQFbu/ugtt7OkGWc1ydEC54cWQMRueWWKz/uYaBv35Tzanvka+284vm8p+QJEdalrN6d3/lTW++/4aT3T0ODzgy748N0s+LQ2qkXyP3WthICfH3en3VvX0D7wkEg2egsrZZSaWSl9fX1n44NztzIZ1OpbjvhKqqULjrePf7AoHgQ/x5yfMdv3Tx/PuikcgqlM86wTpmHDwjEIj9goFlkv9sljqMh2q1xvYLcSvBhv4QP2YxSi1stObJv1GGIb213yqTkBZWiJmEDhBo8UccOlRKEGnjlif9dqywRmnUikh/fqFk3ws7pD8wF19p/5e55z6QUrJVjPQrMtwz2Ad9HS3kswqCKLAmi3B99ncOZLskNkKxtb9g8Sek3zAnKrmeG97g7SVRv0VIPz9DrhF+I60IfmGkv7Wt43Rbe8cHJEkKVFAdNZFIvDQ3M/3E8vLiJOx0mnz9hO3trbWLF179XP/Aicnauvr/Lb+deqN429u77r929dLXoTReT7+guj8CgdgXWLgiW33WQ583vKTN0jwAkFAgjjpMxir6DFb6MTFvsODHx/yYWTtGOw//ThpZ+x3c/nrPALMFxxr7CCT+tyiOggW2jICfUQNnlkatxAWbd+0HSvqT611fm3r6vYrI/gaVEPvbj3dBf3vLDsnPryRRgHgyZ3TNZjNKl7vpKuw0nuVcpY5kg3fEnjcrET+9OCRv5ecFIhnpJ0TfTwj5O8PVNfeAfSu/ms1kpufnZz8/OzNNRSN5IT4VSp9/Vs/hoatP3nnX3ac9Hu892nX4/P67yPobYE76EQgEYl9QRmHcagFufyPCb7aw/TCGGHGUwaUWprASszYzgvGhqfxEgKHF3+lyuWtr69oCgWCz2+2pczgdQbI9m0mn59fWVn+2tLhglUZYn+rvSI6BDxOQ+NvEzUpajgLhMoJ+wBAKhcWtrU3tb6sUffp4a72QH13zYn7+qJJs/ObMM++VBdWvFXqysw3u6OkCWWFp+0Clt7hA/CXYiMboVgi6/cvN3toNGm4NxjnZD62Q2lF9dnaDCkg/P5nEP08lWSEI6a4fGDz1YY/H02G3HqqqZslz/jVC4r8qZ7MJ2CH9dNE6VKO6sWduaXHxG51dxzTiDw6How+sB9YasDNGIBB7ApuEXzRZG7n861OI8cSi4DrM74/kH3EUwZF+KyOYWWph3hCmnwAojF8FQXA0NDR21dTV3+b3+/ucTlc72VaaXpiMoMPVNR9pbW1/eujalU/F47E1KE3tJ8FOGmHe4s88dPAd3Xsg8d9HHGbidFjrVQ5mVn5ChuzEWxtZ93nCz1tl2ULIfui7cy+8MyVnqKgfJV7Q29IId/V1E9K/E9PPO1grqgKxZAockgQdnsYxsskpO4WwqEAcZLXI1R/MLRp7ms7vRuNmqy+PCkm/9nzpJ5EK2SDoUltX39Xd0/cRQrxDduuRzWbnp6cmPr24MD8EO7FyGunX4vBBVzcn7HSm0vzc7HBHZ1eUPMsspEAUxSbdtZl9RrVdBALxumEjpZiZ2riRVxKFnvSbWRIxZzjiSMOA9JsZwYzGxEZLEemvqgo1tLS1v5Gsz5KxSxjsGasEj9d7/8nTZ+pfO//Kf02nU7yxgtZDI//8u4rYRyDx30ccBrJzGOqwVyiTksQu6TeLtda7YjOi9tPli+fmYisNGunvqK+Fe070MXK/g2Kevh6JsUB/uv+avNX9qWtPfCyWSnqqXL7r/+nEo/+FbC+nog6EGNLt8o2830fp2dktbJB+vScJP5nkM1g8La3tpwn5foyQbrfNaqiJePz5a1cv/0UymdiAnAAfJf6aMI7ezZ9PJaiBXYeqKiqdQHA6nX1soyC4fD6/Nx6PJfn9DD4jEAjErrGL/ttobUX89bnD+YVHEfm/0fcFgdgLWJB+Myu/UaYhXoi4YO2vq6vvbG3reNAfCJwCXYYguyBjjhP9gyc+cum183+Vr4Om9G/0XqOH4T5CfP2nOBqgVlSzlGPa95We80v/oO7qBTFK0celbTPaX/rYx1WRru3W93Vda3aHEGj7Wp7PgEBYXY8RaJq+9o4uU2VSp9PliMcTBfVRSZKMLPx6lf4gIT41/zLz3Du/OPH9//cL49/5D0vJjU6yPcQWQQgPbc30Qp701wT9cP9tg0y8rxjFGxZWN0BySJRUwUY62qQKos/v8YlxJd2j5sTbzKwYoK3XVldKUyLu/G14r62e4b3anv9OSn+89Pejv6nd94R/bso9i7t59/YCFZB+/aQSrw9RyAhBt3cdO/6mzq5jH6qA9Mvra6v/6/yrL/0hIf1UfT8GuYwQ2kLd/TU1/hTseALwkwJFGSPIsxzlCyAdMk4AIxCIfYNNrymjcCn9ZKrZhCqvnaK3Vuq97IpIhs6LEIG46WCD9JcbqwTyS5D7HAiFqzvP3PGGf9c3cOI/E9J/BnZJ+jUEAsH3kCUMpTpXRuNgfC/3CTjgy6OcdXM31s/HHwP1ox96/XXJ/21Z/m99UlB+65Ovr762j3Xs1EXb1+oYl3HdbdePNmoz05O8aFkJ+c9k0pLP5y00JrIs8+5MhqSMujt/fvRff2UzHb2LBi2phKh/derHTf+m5+Eng5IXLm+Nd8cyCR8haawelPSXbYtILTcTcRb3z4IAVDppoIAokaoIqhiXE34fOC1Jf36tcukJ8/e9cI8N753lb1Dh81D2fSDPm8Exil2Sbue52U299wplBqr6QSo/OOUHon7us6e3b+DB+obGt4HNDk1RlPjC/OynpyYnXoBSgs+ngNTc/LV68sr+Wr21GLoSZAluxD1GIBBHGyZWfjMLvz6tGL+YCeLybv6akri2ZKCY5OtRyIKCLv+ImxVlSL/RWMVoMq0otbDD4fT39PY9VF1T+2YyNHbuVV3Jufxt7R1vHrp25Z/BntYVWv73AUj89xGUCB1QURWXc6PduO2WX0EeUv1gQS/kx1sKmAX2BwuvPLSVjt1FiL2g5puXDKjBf5392bkPdr1taHhr5jgl/bSipzs7IOj1Glj7NdBIf4Ep+m9FY7m4f7J4HA6oDoRgZTsCqqyqHsmdgqwiQfEAaE9mN61i/82+2+vn4EY/V3uBXcT0661Rfm7tpZ3dwODJR0gneo/dOsiyvDoxPvp7y0uLI5Cz7Ce5hbfo83GrAuzMyNPPMhjEulL3fq4oJZlM0HPqla8BsMNFIBC7hEUsf7m+2yx3OD8BwPeZvHu/Rvh5N2J9/8oLiPHhAgjETYUKSD/v1q8XHS5KLdzQ2NTb2XX8UafTWVdhdVQqPpxJpxeyshx1Ohxhp8vVDLqxrc/vv4OsvgXmpB8t/fsMJP5HAHtNtg6heFwlgwZ9ahKemBVcr5NKpuHSxvjPC6IgUDLfGA7C0sY2I+xT0YWWqJpaX0ysVTFCr6hw8lgbc/enbv+gGk1C5toqSRRhMxZnX7+htxt6WhvhJxeugKLKEHD5FiVZTanmjd3ravQO6jcj5dxQ7YH9xOtw79eeryJLvyiK/sGTp98XCoXvsFuHTCYzMzJ09be3tjZnIWfp5639aSi29utj+7XPvFhOUUorUqcqrSxVUbZlAigl/IbeJWgVQyAQ5WBjwt5IYVwfg+zULeWIv0b6tTaS96ajwHzhiCMDA6HrSvWtikJkyLjA29M38FBtbd39hgr95lBTqeTE2urKs/Nzs1fS6XRK297Reex0W3vHvwUuRMDpcB4n5xdVVbUyfmGc/z4Cif8+4qAI9F6X83rOZRUvVylpsGjYjGY09QMGvVsTb+0PPL1w4W7C4X3sep0S3N3fA09fGoLteIJcv1t8eXWoI53NgCBJcLy5gYoG5GqhkX4q3icIXEuVU/ZPZzLQXlcDZ8n5XA4HXJ2ahS1yTqoFeLyufVFRFBpVwF+LEem3bPQqteq/3t9Uj499/DfE3/rkbxp6mRzCSSPbeB2Wfr1rP1tLkhQ4ceq2x4PBqhN260D6zJGrVy79TjwWW4Ed0k8Xffw+T/p5sg9gQvhhh/gXZvIVVVk22Y9H2VAjBAKBoNDlEC/noceH5BmlFitJJQY7lvxcAQLrb2RCJDTSr+3LE3+9+B+mDkPctNCNVfjQGf7dMkstXKKL4fF6awYGT37Q5/P3VFANlZD8aUL2vz4/NzPMbS/UbXpq4tWamtozPr//rPalKEn1DofTkcmkzca+JdeK7+XeAon/EQAhWhUfs5cEzYTsG73Ahc9UqK/7eJedEAWzfKRWeUiNYpl4wbXAUnr9hFbFEx2tEPL74C2n++Fbz78KgijAxbWxMHXzVxSVfb+D/C0ThJJqZhWZufqf7e9mpJ9ifn0dEuk0O2ygqTsgZNlxou56LBu+/fztdlPOJz7xCYEQ//0u/kCxR6S/YOmnafpOnj7zi35/oM9mFdRUMnn58qXXfi+VSlLlfkr2eRd/TcWfDmy1uH7exZ+vt6kWRCgcDpGBsk/7W5blaSjNfw2AZB+BQFQAG679RkJ++v7brVvz5L+QQ7y+obGzpqbuhNfn7SQkolYUBRfpqxOETExtbW4+MzU5/pySS7drleJPAbQsIm4ymJB+3oNG75VoJYrpDVfXdPT2DXzU6XTW2K2DqqrptbXVfx4dGf6+osjU00Y1qBObnIvFokM88aehj06nw5kn/sAdZ3sMjHh9QFV/Dpp6vqZOrv1NLZxGomWcMrmo27dIYd/smLwSPztWK4Mvx0DdX+LrxpVtdU0iVdU3KEOwPIavF1mM6kMbILowEr8VcZB1Uex6KBQWG5uaebe8AsmNx2PCwuKyRBeq2L+6tuHgr80gdokd7/F6C+I/GUfWnc1mPYIgkkXg3a0DuqVIqZS6Oq+noo1AOK0iK9DZWMfE+Kr9ATjX38Nc+xXyH50ACPu9UBcKFq5Zf9O0Oy+TQYZIPQAEkboyse2b8SjzIKDnPt7YoS4tL70COuuHmFMOJPdDEglZFF0uF7vX5L6J2j02/I3yVeGf2TK/aZGKvp1sDJT065/9j+WehbKDpNwxauG5yx9n+rzly+Gfb9N3aB9h5pJqJ6a/YO13OJ2hU7fd/uFKSH8ikXj14mvnf4eQ/nXIEX6q3s+7+WsWfy1+lXf111z19WS95HGtrq7t5DdkMpkJMPcQACgNAUAgEIgiWLj2m6n2W7WjfL9d6LsJeWjuHzjx3rPn7vnvPb39/62mtvZdXq/vNkJYWiXJUU/WHT6f/y3NLa0fu/Ouu/9HVVWoEUrV/S1T6aLCP+Iwo0wIDT9WMcpmpX/H/I2NzYPknfq1Skg/GTPMjY4M/X8jQ1e/RUg/zRBklGGoEJJIsK07heB0uWnd+MkCxAECb/g+Yq8ts3t5vtd7LhO1XqO1HmqZNeiO189omimU8qqkRkthcJFSs42fuvrEB90Ot+B2OODR+86B5rQvSgL8y89ehfVIjJV6pqsDTh/voHME+QrSPVWaEy33F031ByxWmn3OefHntABeGhqFazPz4JAkqPOHoh9oe+CTLlWaJztskmWLLLRB1AgeL9omBwJBNRqNMEJ31N2cbnR4gIlATrnBqj5lH/vbSUn/6ds/4vX5jtksXo3H4y9cvnj+U/kOUutE9Qr+PNnnY/K1Ouvj+vh3Q7OaOU6dPvN4VSj861rZKyvL//n68LWnYGdiIQk7ngX68pSj/iwiEIjKYIOMmFn53VCaS1y/zUna0upjx7ofDIXD9wiC7TSolKCMXLzwyn9JpVLaZCrfrurb1MLEJ7ZxiMMK3VjFTH9Ir9pvNFbxtbS23dbReewxURRdNosnY5XYS0NXL/91MpmkYxVeYFg/Dil4IBzv7rm7qbn1P/EnunLptfdsbW0uwI5nIx/KmIVi4WJ8J/cY6Op/E+GwxE4bdPT8ZyuXHSOyXyKyU1tXL9A89mA9iNAGD3zj5o15lftfmr9yNp1ITt7XdGbII7oU0AmarGcidRJh+FTIz+d2MWIuyzmvaUVW4U2DffDNF16l+dTgWFMDCEVifmqhwqLm7q+qoKX80y57aWMLplfW2ESA3+lRu72tPyKkPw2l8Y6GIn+E9B9URogbjkNK+vWxckaz50Wp+3ZF+mOxZy9dPP+nsixrpJ+38muz5pqVnyfhhdhUKH7PLAUj3R5PP1/+yvLSVSh2feVd/k1F/hAIBMIiRKqctV9P9j2gI/6SJHmPd/feT8YDD1LhsUrrRtrjvt6+wUcvX7rwN1CaFcCo78U2DnFoUYb0G71fRqSfEf/WtvYzlPTTsBmbxSubGxvfuHb10ldUVS0yUkGxuDA9n5Jf5zWFJL3npprJZFJQOr7A9++AgMTfJnZjlTwsRH0v62YRx2ek0GlE/M2WwveE9AOUxsFri9EggjVwiiBU/f3Fb783Jid7yNXdd2VzInpv423fv7t2YAI48i8Jol8j7T5PqQGhOuiHhlAAtuJJ9jlDRc+5qQnq1i9xRJ+q/QtczD/9/srkNMRTaTY5EHIFZu+uGbgMxQ21CMUDENN8wyhusj8oQ/r5Z6yctZ+691edPH2mItIfjUZ+cvnihb9QFCUC5S39RTPg3HmsBDBLXFmdTtdt2s6yLI9tbqxvQGkcLHbCCATCEhYCY2biu0baO/qFuebXNzR205Rirlw6sF0jEAz+gsfjeSKZTKagjJs/AnFYYRb6CvZCEYvCEZtb2k4T0v+oXdJPRTOXlxc/N3Z95EdQrDekecsAVxfeYMXeK8nh8OrOl8xms/R4KzFhxD4CiT/CNixc+vSEw4z868m+lYURwNyCYOh6/YO5Fx8kpL9bFETmkU8ODj6zfPF9i/HVS+9uf/Nr+X09QYdXZWRdzKXfU1VdO6MKhPiHoDEUhkx2J3Mdy+ZH1ik5Cz7OO4pa+wsXSc55eWwaFja28vp/gnxP3cmXodiKbEX69Qs2gvsAGxkjrIT8ilT8HQ5H1alTZz7s8/ntk/5I5IeXLp7/S/Ls0VAPo3h+I3d7M9Kvn3QzJP8trW3HyLNaiOVLp1MvwI5GgGUmgBv9eyEQiMMDnXK/kaq4XmSMb0v1IXgF0k+t/D19Az9fU1N7fwXWSFPQ9o4QndsmxkefBmvSj/0t4lDCxKvGyCtR84A1MlCwMUtDY1NfZxcj/U47ZauqEp+dmfnMzPTki1CqNcSHHGr1AChuDwSnwxkoPqe6IcslxN90rIFGr70HEv99xI2OXd7LutnIy2tEZkXuGCPSb+ZiDLqyrNwGC43campzgJB+gRL5Kp8XthMJkMjfY7GF2/5x4vt1v3js5y4JpB0i+3gYWVehEKvPd/nUmb+toRYCHk/RPaC7KKoCWRoWYNBs0sNnl9ZgdH6RTSbQc99Z2z1e7wln4nK6Jq6mXEHRK7gFxzaUDkLMrP44GNljGFiqjMRxzGbQi1zmyEA1ePLUmcd9fn+3zeLVSGT7ycsXL3yWPCOaMI6e9BvF9Ost8Ubu/WZhJOw9rK2tP8fXY3t7+1mw5+bP9scOGIFAmFgf+QntclZ+rS0tsvSHQuHmnr7+X3S7PZ0VVagMAsHgKbJ6Fswn17G/RRxKlAml0XslGpH+gqGiurqm49jxng+Ssa8tnQxFUbanJsb/YGFhjnqrat6IBdE+2LH2C7Dj2s+P1+n3gsPpKBIOlGV5hSx6QWJ85w4QSPx10Agxr2SeJ8imHYKVMrpVOfz5DcqzfbzVMXm1d9XOvlbnn5meYkr8eTf8EsIkORwOOZvVW7WZaj2XVqeI9BPStEM6BEERdtY0BoiP8S+QfnI6JyFMBUJGPheIWTyTaqCnp1b8d5w9A+dHJ2FkdoFUQoDF9HbLlyd/6PzFYw9NuAWn5HN45XgmKaXSGeaOT9P28agNBovc9zUsR6PQFKwq2c4uSlXgwsQkJDJZts3v9sBIZLbrxeUrPTmvAJGUBWpHsPnJR7se/KySSUf5+0TKYwv9KEqSmEwkDOP8zZ6dcr+r2XNq8exYKv6XK0urG7+2Kkf/Htgpp1KUUZ8upzxd1JGS38l/4tRtH/AHAv02i1cj29vfu3zpwuc40m/XvZ+fFDOL6RfBnPwLPp/vvkJFVHWDdOrnodjab0b+sVNGIBBm4VFGYXj6NpRvR0tIf0fnsbtaWtveU0EsPx0jrMWikeFkMkmJREKUREd1de2dHo+naBLW5XJ1cHW1CkVEIA4NXsdYhSf9bB0IBBt7+wY+TMbcPjtlK7K8OT4++jvLS4vDsGOc0I9PeGu/Vs+SkEGHw9nAnzubzU6BcWghehoeEJD4c+DJiQHhKCFY2v52iFM6S9OZfYIeqxid3845+H30++uJFSX8tCytPD3018Afoz9XvgHShPccVHjP5XZLqqKKqqpI5EWWCOnXGiJ+oaSfV71jpIJ07nRNJ/00YiODzrLpdrsF8r1Kzs2IvyhKpIFTneR8RhZ/ms7Pl1WzNbTpqfJ7wO1wwj2DvVBfFYSXRsYhS0j5Ymqz/p+nnnK+r/O+xRqHPxXPJn2JVNqQ4NPJgh0PgHyrS/6JpVIgVAkl4QF0/xevTsBmNMH2lcn32wnaXoJTFCQWPpDP3CdMRZbe/rmxb9z3YOPdv97hrr1CN+YnR7Ti2Jo01qLb41F8Pj/9bUx/f93vbjoJUAmJLucRontuBLPnmV8bPKMl74/Rc11p3W1gN2n7ijpS+rwNnjj1nmCw6pTNMs1Iv9ah8p0qL+RnFnNvNgA38roRmppb2iWHo5BeMJVK/SibzWTAOLc1ivohEIgiWJB+M10ULWbfa7CwftvpdAb6Bk68OxQKnwWbRJz0lcmV5aVvT4yP/kzhOk6g+kChlasnT535GO/KTMYOtdy5zVz8cRIAcRhR6VhFH47odbs91f2DJz/scDrDdgokpH9rfOz6by8vL41AcdYpo9h+jRtoBroSIu9wOFr486dTyetgTfp54PhjH4DEn4MVudgNkSomNL9JHvLf3NM6We1nRvit62g8KZEHa4DyavtiOpXiZx+dBguvoKt1quxFJ321Rmqy3JpPq6MQYqJw5UrkEGbth+KBRVGjF8nEAm6nBxrCoVxrQch3d0sTNFaH4AfnL0M0mYLJxFL4ueXLSou/UZ5NrEE8nTa8Lyy9n7BTAXq+1WgE/G43s+xDIQGgyjwGXrw2Clenp6GjoR6aasLMY6A6GKBXC1kmBijA+MIynB+botUSthJx35WNsWMdTTniD8UDEYZoNEIF4NQ1WFG7j3ft6jnYLSp7tnf9jJY9bi8Jf4WquGYCOexz/8CJh0Ph6jttFk1J/5MmpJ+39NN3wIz06639VlZ+3uuG7dfY1Pzz3LHqxvrqt6F0wg0t/QgEogQ2SL++bzay8hcRf0L2W3r6Bj7kdrtbbFZDJeOCibHRkb/b3FhfBoPMJttbW8uZTHrG5XIf1w4SRcEL9toydPNHHApYjFXKeSUWEX9JkqoGT556nLxjTXbKpULDExNjv8uRfn0KTG2crr0n2hjDUKibjJHC5P3jXWTVra2tS1DsXYjGhgMGEn8Ohzkm/5CgnMsRU+TlFo38FwgHFFv4NaKT1S18Y6DNJDpIo6QXCuJjB32qqojULF/j9xeqS+P1A14v/MIb74TvvfwabMRi8OLqteq3tN6RIPtDOqNAMp0pVumH0ul/iZx3fmsbeurrC5SflUC2XxyfYQd88K33gs/jgYIRgp1IYpUFJTcJwYg/vchsWm3x1s2DubVhV+EjB/H8ap4h+13OXsKmKq5VDtzCDHpPb//9NbV199gsmsb0/4CQ/s+WIf1mMf1G97mc2E+RtZ/Gjni9voe0gxVFnpwYH7sIxtZ+PqSg0JljfD8CcWuiDOk3IyJGZKRg6W9t67itvaPjA6Joz/WYtJ3y1ubmd4eHrnxTlmVNGAx0dWLtYjqdnuWJPwJxM2GPFPypV6J/4MSpd/t89vSHyHg4OT01+UdLiwvXYIf086mFtTEKb5Rjh4KxRyJU19R0sUFwoQx1a3lpYRKswwvNzonYIyDx30ccsYkEI0E0viHSC/i4JEnykE6a75R54q+Rfv3Ckx+9Yqie9BfiBBVRqCInFmVZgepQoIQ1Owixf+Ts7fCN51+hafaEV9eGfU6Hk/xGGYjE4xAOBEoulMdqPMq+CLjcO4KA9GIIoT99vB20TaqssokBlY8ToP+IArw2MpWbFBAECHv8Q3dU94wXeyqWWv3BwAph9kzZdc3fA9xUz7SJgr+R+nTRRJLB4u3oOna2obHpQbA3MUM9Nn58+eKFv86r91dC+vUE3Cq2Vu/mX0T+j3f3niXcX4uzU+Px+LegeAKOV/Y3EtlEIBC3ICog/fxEPE9EeELiEQTR19vX/2BtXf3bqJ6NnTqQMcTm3OzMZ2dnpmhmHo14qAb1YeMMRVaiRSdQC/HI6MmEONQoo+CvvW9mKYaLxio9vf1vC4XCZ+yUS1P2zc3N/sn83Ax9x6w8EvmxAS/graHIkBUIBPv5vzOZzHA6nU6BeXghvp8HACT++4ijQPp1aXvMOn/evY91+i9tjLzhuYUL/9Xr8CxWOwMXzzWeernD17AEuZdcs+xrKcu0tZ4EaaxY5Mrh8/0Wlu1ULEQV/alsQC0l8QW6zFvnRXj43O3wT0+/CPF0klnrqZv+dixZRPz1oPssbUeg2usrIv35kxbS/BX5KfEbyD5jc0twbWaWxhvS7cn7mt7wl7r4xMIZD/L33c2EwAFOMLxuWCj486q4VjPoBWt/c3PridbW9l+A0s7OCGosFn2WkP6/zFv6+Vg5Xh3XDunnYeVuqyf97NrD1dXv5KqVIQPob4E56ccOGIFA7Ib0m7kcs21Op7Nq8MTpRwPB4GmbVVDTqdTIyMjQn25vbdKxgxYGVRQGyNUn712oZvmTKLlJV3QnRhxq2FDwL9G2ApP3raPz2Nn6hsa32CxaWVle+pvpyYnnoNjSzwv6GY3JeRiJZ4LH4z3B75RKJs/DzhjHSNm/aOyBnob7A1szrojdKfcfZuzieozS9+gt/qwhEkUx+NLS5V8XHFIooWb659Mbj31l8kf//YeLrzxCyHY12YcuYW6p4pYgWSgLL8o/CqXCQEXKwCuJ9aCDkGpC/sHldBS69Zztfcd53y054VxfzvOJCvRRF//NWMzywrdSSYhnM1DtK/VKFPIF7aR92BlbCPl/1rej8NNrw0zcT1Wy6Tc2Df5Zn7913OD+gsk2QWe13jPshqR/7OO/YdpuHCbSz8Ho2a0kVs5bU1vX2XmM5b+1M1lKreovXr742p/SmDmoLGWfWTo97Tr46zGL7S9Yv2pr6+pdLnchLCGdzjy1vra2BqWk33T2HTtfBOLWgomXlJEmip7087nDC4vfH2i87cydv1YJ6Y9GIj+8cOGVTxLSPws7hERviSwRRRV0ar2KIm+C8YSm0d8IxIGjAgV/o/eNN1B4Gxqbelvb2h4BmwaKjY31r41eH34SrMcpvJu/XnOIJ/0F8u/xeulkX5+urOfBeNyBwn4HCCT+eRQr8KtCubRi2vd2CLT+3Pm1aPS92f5262vnWP159IvF8eyFdjgcRjl7GXmiaufj0fnuuJxuo5ZwRrvJB4focL+2Mfbo34//4D+MxRaoErqe/NMlBLoJAHI+ui7ELIGJOnBWybJQepX8TMVWeaEoJp+ip7WJ/J5SwShP4/7N7Ox089L2NgsVqHJ72Da1ZA8o3a6y4GpYWNuAb7/4KtBkfuQ+JO9rvP3z58InzhsUo18LPp9fCIXCbFt7R1fFz4T+2TD77a32Nzr2tz75myq/r91JJKOyir4zONfrmXDbpZhficscTYXT09v/IVGUPHbKTSYTF69cuvBpWc5qpF8/WNU8XKxIPw/e64bvYPVkv0TRv7W9412w49mlbqyvfQWKRf2MXPzR2o9A3KIw8JLSuxwbhUbpSUhh4j4crm4/ceq2f+/2eNrtlE/djldXlv/20sXzf5XNZLbAmPTzbSlPTLKknXbx55NlmQoBlptURfKPuNGoRMFfC0csSjNcVRVqOXa8+zFBEJ02yqOhiE8NXb38BBi/Y5pXYpHwNhS/I2ZhhwL1kCRj9sKYSVGUlcWFuXHAFMI3HOjqn0elKuUWaf9snZsXR7NSO7cTz23ns526GX2nc/WnELJZ5klnOPtPOm33dHSxzeV0MgL+c2dOAZ0nePX6BKxGIuJKenPwm9PP9B8PtLzyCx33/kBShdgr68PH4nJCua/hjlcoOQYubYi6kzdPJB+1wYae/LslUXSyHIGKCpmsvJOiT+Wt8ZoVXoCuxjq4PrfEti1tboNTlCBDkw3o7kaabIukUlDt9ZKWifcdMABXCPXif+7KCCljASRBpEdm3t5695cHg51XuL2N3KMKp4/HY4UGcGZ6clfPhN1MFWb7mxxv+9k3Opd+XZRG06KOlcCGQI6+M+WfpwLxd7lc4f7BEx9yOBwhO+WmU6nhK5de+8NMbsBqNFDVd6blSD8PO5b+AvkndXf6ff6Cmz8ZAF8fGx15BUpJv1kGAex8EYhbCCak30gPxWzClPfS89XV1R/v7u3/qCRJQTvlk34zOjc782nS370MpVZHzTVYqxs/fi2ENunLymYyVETXKl84AnHDUKGYH69BxJN+r9vtru4bGPxFSXL47ZSbSiavXr1y6bN5/SEjS7+Vi7/ZOKQwng2FwncDH9+fTr9CuEO5FML4Ph4AkPjvI/Y63ll/Piv3731wzzUTFitpnNaS2x10v6ycheqqAPicLnj43B1wdWIGXrw+DqIkieOxhbOfH/nWsdO1Pa89t3DpbVTmZ3J78bZ/0/PwP+bJv15MROvo9Q0fs/orqupiFXJIsLS+xVLqaUy8ID1K8+iJzPIOjeEQTCyuQkaWIZlKk3WWTQjosRKJsM0hQvxBNSf9rCSVpQ6CiYVleObyENtIST85Xn5Lw+3fJaR/DEqtKPz9NJsIuCGN4UHF6+91GTbdVI3c+4tIvyiKVBX3A263p9lOuYTsT1+7eun3U6nUBuxOyK8ors0kxtbK2l8U39/d0/egIIo1+erR2f0vQynhN5t4wBg7BOIWgoW7sVE/b5b5pEBE6hsa+7p7ej9iV7lfzmaXJ8ZHfz+fSox35TdSE9eUwrW6yfnPguSQavjzJpKJKTBOHYYTnIgbCptifnoDhV40k4bXBgYGT73f5XI32CmXEPD5oWtX/jhbaqDgw2d40q9/V4zqW+AFInWP9Hrv5suMRLefBnsphHHssc9A4m8Th0G0bGZ6isZ685tMiX++QSmq7x69SEazkkVW/6yq+Jmbv0obGBlUl8rU7gc72qC5thqefPUipDJZiKuZuueXrzwoORzsbGuZ6N1fn3468972t9Ac4/pZfq0s1gBuZePN35t74YHlxMbxrkDTzB31A1spOQNeyQHTK2t54l98uSJ3R1rqaqC+ahkWNrfY35uxOIT8Pi4sIKfOvxKLMeJf6/OXCPux0wmcfz7Z8dWRCbg0OQ2iJLLrz8gZ9b7GM8/cWd07BuXJmiX5p7/pzdoY3oD3x+w5LSfmV+hMe/sHfz6vSlsWspxdGRm+9ruxWIy6lWqkX2/pr5T0G12PkYJ/ibgfVcyuCoUfyx8DqqKsjV4f/lcw7njLxdohEIgjDAthsUrUxAvW/rr6hu5KSH8mk5kcGb76u1ubm3NgrCaut/ZDfl3UbhHCIUiSo5E7tULOOQnlST+2eYgDRZmJNrN3Tv/esbFLHxmr+AOBXjvlUt2h8bHrfxSLRalgpl7Ij59o06v4m3kl6MckYlt7xyB5F+u1MlVVjc/NzLwM1imE+XcQ38d9BBL/fcReER2tgfD5fEZkwApCbV09rK2uaGSi8MVzzz5lt3i99bScNcApke43t7MAMidcT+Pvqwi5/sCbz8FTl67C7Oo6E+PLfckM7sJYZP7en65c2ry3/jSNg9er+GrEzfWd2effvpjc6KFljMUW+q5vz4Hb6WHke3ZtDe6V+pg1n4da8AAQmKhfU3WIEP9N9jkaSzDiz++7nogx5/5aLyX9CmhSfjtTA1q9SZmra3B1ag6WNrdyIn4qc61W39R46sLddYPTUDyAkgzWejX2khALOODG8EZPdO0GJnH95dzmSkh/Z9exs7W1dffYKZO6p46Pjf7B1uYGFaEqR/qN4uWsZrit0viZTSJRa/9ZSZIKuazjifgTqWQyAebx/SXLzTrJhEAgdoVyeii8iK+RmB9rP0m7eZy0Px+1SfrVVCo1RD2l4rHYCuy0nRoJ4QkIQDHBKGmzQuHqasL9Cyl6SNu8ur21uQbFscRmCv/Y3iEOGnZDEc00iHxkrHJ3TW3dOTuFEQKenZ+b/fPVleVRKHXvNzJQ6OP5rYwPhfErqc99UJTGL/1yLBaNgLnFH939DxBI/A85+FnB1dUVttb+1q21z0UvTZ708yHufKhAYT+jQb7BjCToytJbU1mj5XI4ZNqEUEKcVZSdAvOu8jSt3oO3n4KXh8fhyvQss6grisr2J2RFeHl96Oduq+5eCjp81Bxv5O5P4/ndrEL5eQNR2qkqdd0XDJzktT+p5Z6S/9aGWrg4OQOymtMF4CHRFH6RCNu/xu/LTxcUS/nRSYvtRBzOj07CwvompKm2AOQEDbOyor6l8fTY3bWDs1DckOsXfjJAb/1XuPt8UzeGBzGJYEMZVy9KZeTi76XWqpbWtofBRmpFlv92dvrTK8tLw7C/pL8c4S+Kr6upqf2wVn+aTnByYtxM1A9j7BCIWxg20vbpJ0tLUp1qS3VNbWdP3wCN6bcTZ6wmk4nXrly++EepZHIddqyPRi7+/PhFI/0lqK6u6SK7FYTNstnsmC5vOMb4I244TN65SoWHffVkrNLc0vYOsJcGWl1fX/vy9NTEzyD3nhmFIurHKRrM6loyBnG7PQTeolSC0UjkR2Bu6cfxxwEDVf11qFSpXH+c9rmS48y+0xOZbCZDLfjs5fJ4vRJ5v3jCaGhBDgarnPn9HT6fv0AsQ6FwkWWZlqV3L+aV5MnxRgIkho1B2B1KUBJP3d2TyZThq0yJ/p19x6CvrQlkWYGHz94O3S2Nmvie52crV+8kn0I/W71896euffX/+MrUj9+lCEz1n1kXmjw1C4zdk3O319WymH0KWZbB53ZR4g2C7taquTQD+ckHgSq3QUN1kHzOpfwTcsr7bN9oJgXJTIaJ/gVc7vzxOz8GqT5cHJ+CH716GaaX1xjpZ/vk9wi4PMpWJuZ7cXWoayy+0BpX07UgirTx1ly3eOJfaDhpbJTuvho9M6JZJgY7z6jd4/T77fbdsItK62cCu7Fyhi5zPr+fqlE9Kgiiy0ZZ6urK8hdmpqeoCxs/e27m3m/o2qYn/RYDcTvWfrHrWPdph9N5RjsfGVz/09bmxiaUEn+jOgFg54tA3BKwSfqL0vWCsYK/j4wp2nr7Bn6JkP6AjaLVRCL+yqXXLvw+If3UIs9rovD5w/Xtp2XWk0AweJL/gnD+K1BeTAzjihEHBhvvnD51n6EGkd8fqD/W3fsBMma0peAfi0afGRm6+g3YIf1Wln6rtH2WosIdnV3nSJ2qCgWraoSMkX4K5Y0OhUPwPdxfoMWfQ5k4ZEpEDNP60W1GCulf+ocnpI9+6HHZokhTS6iR9XJra1PbJiUTicJ2OgmQJSQ1m83qY2TUSGSbnYPsr71cbNZ8YXFRbKivl6PRiKIrlxF+qiKfV5JnZeaPB4fDQVX9SxouQqQl8oKzxqDG5d+mrvE0hd12IgmtJVr4auE1PzfQC9NLqxD0eeBNJ/pgammFhQdc25o8cbqme/3ZpUtvcThc0lxi9dRXJ37ofrzrQTpb6ThbP7Dy4spl1ePyCc3VYehrawaHJDJX+7mVNZDz5fM3IyVnGbl3OXK6QORaoKuhARbXt7XbwuYS6KelrW02OVDn9zGSn4vnz8UjbMXi8MroBCxvbEFallk5bA5CzesDknVKyUhXt6dayJ8t8qpCxQNVSRTkgNO/7REc836Hb/KO5oFL8UwqU+8LTzUJVVRtXVQUhY/xBzAm/6rRc0MnBPhsEXaebatn3krhfzfnyxN5QaujRuytMhDY1Qao0GplKOhHB6z9Aycetangr25vb3139Prw98B89lxv6ddc5+wONK2sAvrQkYKbXX1Dwy9D4blRE9OTE18CY20Bs0EwDoARiCOOCq2OlpZHQrib+gZO/BJpO6tsFK0m4vGXLl+68Me67Cc84dcTEH2fqBc8Zd95PN4zfEFkfPMaWFsZi+p1o38TxNFGhcLDpqGI5D0L9OXGKnbeN0in02PXrl7WFPzL6Q9p74lWR31d9fUtGn+EwtVv546jk2/PGbj5W4n7IfYZSPxtwoxQWZGSxx97TPnohyovy8JlWf/ysb+5SQAeWr30Lxb7OxwO0U5RO0fRS0cIPxiUz87PTS4UfZe3lOdyhwca45lsmtwbN6xHY4xAq/q7xNX2jYT8OySJWdtPdrYzcTwVVPfXp5+5T5IcUlt9NSysbcBcYr3n1Y3hjTur++cCkldt8NZEtuRE1eLmBvMcoFb+mmAAQj4vK08VhYKZnvkGks9UANDj9OVIOtnW2lADoWkvuJxSoWI0PGEjmWDf1/kD+ZupMoK/uL4Jr46Mwzoh/7nRSD7uP0/6acgALZaQSKYdkKGpD1U6YeSkEgaOpJypSUKqZiMTOzU9tvROqgfgkVxL/7H3Pe/MT5yU3HPuMxP4s3jmbKXus/v8mqGSyQKD78qmJay0fjbi+vUq/nrLFcsM0dc/+Hav19dp5x4kk8nL165c/jsqWgOlHanVDHphwGkRXmM1iaHvcHXW/uOnnE7XXYV6JpJfW1tjMUJ2rf0IBOKIowwB4S39ejXxEku/z+evGxg89UtOp7PaRtHU0v8yIf2f4kg/337yor56F3+trkZeUEJdXX2TwyEV2m9KclaWWAhWOUs/Eg7EQaJSF3/9WMVHxiqPeL3edjuFKbK8OXZ9+FOEgNNsQ+W8EvXvHV/fsqGG9Q2NbS6X8xRXvLq5sfFdsB53oKjwAQOJ//7i9cRmW7n6Sro1r3SroYTsA/eyKdTXfscCadQhmmkIGBHSoomJsMsXdUlO2qC4FglhlyQRslktXD13O1hqPc1Vv6GOWfnpt5TAvzY+lSPNSsbplBzwpsE+WN3chh9euCK8sHz1BCH+NB5Q6gt1Lr64PlRFXe0BdvT4HZIjVw4328DU90l5KULE+R/E43DCHd2d4Pd5tJrBwvYW2zfkdoODet6T81Br/+LGFpwfm4Q1qvQPQuFyFEWGhlAIjjc3QEdjHQRZ6r/8LSTHxZJpWCHHrm1HIZpOQSyRhO14AhKZjEA1AzfiW+G8x4Spe78dWJHkw5CVYj9gMIA1ius3UqPmO1Jve0fnHdU1tXfbKZOmnRoeuvIZWc7SWWyjVDhm6v12SL/Rtdgi/cCs/U3/DnZi++NTk+N/C9akXy9yhW52CMQRhs6wYGbF49P28eSjSMjP7fZUD5449VGXy1Vvo+hcTP+l1yjpp6FHRpOm+rh+gOKxjZG4GGv7Ghqb79HF949EItvbgHnDEYcAuxAeNsw21Nl1/Fy4uuYOO2VSDaLZ2Zk/29hYn4FSMb80GMf1Wwn68fUtIf7NLa3vILsXeCXhGXNkDPIylKYRRjf/Gwgk/vuLih/gMvG9ZoN/3gOAL5sn+/wiq7ncdCKUn30zskAClJL/wmdVVtWgwxeNyMma7UQCUuksI/I86Vfzcwsa+Rfzanwelwtaa6sZyaYmdL/bBV6yra2+Fjoa6mB6edU/Eplt7gu2bd5V07/xyupQVhbAMbmwDF3NDWA8X5ErWhJEJuxH1f6dolSoS20oyJT4c6r9KqzGYuyAWn9gJ+Y/mWKp+nKkX2QTAdTa39/WBD1tzVAT8IOs5PZlQoGcnKLb6WRCgq3kGuj5RFFgwobXZufZTgGXf5I0kIYeJXrstlE8iqSfw25m0AukPxQKt7a2tb8T7In5paamJj4Ti7JUOPzsOW+tMhPyY9iFe78dUT+xu6fvDU6nszAgIIPsJ3TWfiutgaP8fCAQCLAtgKpNlBqp9xdIiMPprDpx8vSH3B5Pi52yU6nUtSuXL/7PdDrNk35ezE+fuk+rp7bWt4OFtpGmLw0EA/cVl5d8CXaIRtm84QjEfsHCk8/MQGFI+mvr6rsJuX4IbIr5bayv/dPsDNMg4g0URmJ++neDP78VBym4+nu8Xur98za+AvF47LvZbJaWY5VGGN/DAwaK+x0ilMndbWrBJH2eUS5dveIuc2fWFlnO6kXmnGA+oWCUZs5qgZC7apORbUKoqXs8aBZydlUCJDM5F/icZTxv/acgfx9vaijs29VQz7wBKGG+/XgXJdzC+fUR6uLkcktOoTfYtkFd6y9Nz7BwAe2mGbUgTvK9IqtMtI+/xbSOVKGfHrfCQpFyqv4hr4fOWJL90/DTy8OE9EfZmd1OCQZamuGDD9wDd/V3Q9jnY5kBisAJAbLJgzytF0hlJxaWYWxhkf0tK7LS4q/5WvFRJShqFHcjereXgnyHZRLB5gy6UQqqwkJj5Lp7+98vipLHRpFUzO9LiwvzVDAqAaVxqVZuc5bW9Apd/PmF7UNFIcmg4N/DjrV/a3xs9AtQSvr19bJVPwQCcXPDgPSXszoaifkV9FBOnDj9KBnqH7NTdiaTnrh29dIfcEJ+Vi7H+slSM40T3tLY43A4u7kiCelZ1wTFbMX3Y9uH2A+YhNWYCQ+bhSJ6CWqPd/e+z6aYHyHd8RdHhq99HUqFh8vpD+nralbnonews/PYW0jdOH0kNbMwP/cdwNj+Qwck/hzKuEof5L2yK1LGGgRVVTQXvEB+CXKfA7DjnueHnQZFa2DcUKoyXy63vKnwnAKK85nlC6fbwk0iU8onRHd+fSMXBJ/nnjnbvwqJbAaMBHq7muuZpZ/OBTTXhgvf1FT5odrnh7nESvVacoteo+PepttWSRHKRiQGE4vLrEa56Urjn5Km/YulU4WJBloPSXIw8k+3LUeibHsDs/YLkJYz8MLQGKxuR8DpcEB7fQ28+dQAnB3sYV4CBaV/TdiPAyX8NGOBkvdwYN4EG9vkfKOQkZmQoOoV3S882vHWJ6ECS8RhId43EmVc/Pl3RS+SU9SZ9vYNPuTxeJrtlBmLRX/KifmZucwZEn4oT/qNrsWWij9d+gZOvM3hcPRrJ4nHYn+7tbmxAaXeB0Z1QyAQtwbKKYkbaaEUkX7ST/r6B0++KxAMDtopMJvNLo4MXfs90iZR7yPe0m8lLqYn/ZYpTBsam96e/5tBluWJhfnZUSh1LUaLP+JGYDfCw4WYfjLWpGJ+73E6nWE7hWUymbnhoSt/pSgKdV+1k21I/y5YeVGWCPtRhMLV7wJe1C+V/unK8tI8VBBqiJNvBwMk/lCaRsxkN9Uo3VglKdFsHse2+3x+0eV2S04a5U4gSZIzP9OnT62jJ/x0oUqfVaSDDuU/a9sLEwHkuwBwkwDk3B5ShhuKyT+v2MnWZB9Rg8BBq/w/TPzw519ev/5zU7GFLhbHT7ZRQk6t8RoZp//SVHrb8Xgu5l73qlPre10oyCz09eFQPnpfYCkAT3e1gyQ4hBfXrzXS+lU5fPLJqq51mjrwuWsjee2Awm0s/gHpxRGSn0ingWYdyO2V1wYgB20m4sy7QCF7NlSF2EVPLK7C9MoaBNweONnRCm8c6IOmmjCoilp0XrZw17ERjzEPgawik+1KbqIjlYbnh0Zy28hWl+C8/JHuh/6I1LnEAkszDjidLpqxoXBOPr1ipc+b9p3R/vrvzJ5Po33sprE0219T+rc6xuJyrQaxZnH9haWlte10dU3NXWAD2SzpSK9d/VxezM+qIzVy8bfToZVz79db+gsDX/KMeMPh6l/T7iPp7BdGRq79I5Ra+S3d7LDTRSCOJspkPaGLkaux3ouQLb19Az9H2ps32ClXkeWt8bHrv7+1tTkHxer9lVr69bHFhbFJVShU7fX6itz8E/H497PZLC8SiCFOiANHhXH9ZpNt3u7e/gf8/kCPnTLJeDM+NTH2afIOaBNt5bINGYX3amsjo0PJGKSj89gdZMzKe/+o6+trX4VSrwKzNH74Hh4gMMYf7FtQd2Np3aV1VojHY4XPsPMC8oSGt9jzhL2g1K+qqvaCZXVLhop+5I+h6wwhC9n8Z/oi80SBbwxEWZb1RK1o5jwtp8MiqcL85nI+bp60OOkMbEVjEPB6ilzgfW43LEW2oT1cDfwcFHWvD3l9kPSnmSVeVnfC37tbG+GZqyNwPTJT86By17pLdKj3Nd25ObQ5HU6rWcf3X74I7zh7e15DoFSl0Od0wnpMhRgh/wGXe+eGky9pXei61uNjmgPpbBbmVtfB7ZDg3lN90FCdJ/yclV/lCqGTBiuRCKzFo6QcF7SEw0wckJ6TZgp4/sowbMZptgBBdYI4Qkl/UPRGwaAxzObUEJVMpijbwp6o4Bvtb5SO0urcRvvYUPSvqK5lUl0aZbvgB7F6a38R+ac5cNs7Oh8BG5OfLK5/cuLPkskEFZW0Grjyg1dbSrU2XfyNhHQKFv++/sHHybvWpFV3e3vrM6TTpx1+JaJ+CATiCMLCxd8srt/QvZ8ux45331NX33CfnXLJ8CM5PT31P1dXlqnl3Yr0822TBjMX45JwxI6OrrcLguDfKVdNzs/P2lUSZ4fgpCdir2FTeNjIK7HgkUiXpubWwbq6+jfZLFZZXl76IllGoLyBwmgsoNXZyOPQ0PBAl7r6+vdyx1IB5NGpyfELYBxqaBhmeKN/r1sJaPE/JNARAADjhoJ3X2YNxE9XLt37L3PPv+vZ1YsPjMYXbiPbKIumlv5w/jO/Due/M/IC4LUANPd/PgyAf9n19Sx0oNWu4FxRzD4wPyBYXNvUvdkCVHlyafeWYlHd3RDA53UToh1iZLq4aRCglVrcBUE6vzZMr0tyEJr+1uY3rFNSvrS9DU++epEJ6O2Q/p26eAkhp14BUc7dn4LG/UdSaeZV0FhVlXPPJ18PtrfAvSf6mWo/I/1cU85aLurOT9qv+c1NuLq0ACuxHOmv9ftzgoVkycgK/ODVS7CwscXKDkrea7/c/fCf5km/VdwTADaIRahAnMosD66Xuqr29PW/W5IcARtFqutrq08sLS5cg+KYfqv8t0W/4etw8TeL7S90umQQ3uj3Bz6UPxZkOXvx2pVL2qCXn+zT10+xU0cEAnHzwgbpN4svLrH2Uw8pQkKKcnSbQ80uLiz85fzcDB38l7P0m7n3lyX9Xp8vEAhWPcKXnE6nn1ldWV4A44lPdPNHHCSsJvPLpe6jD3djZ1fXu2jWJxtlqdFI5Knx0es/hPIGCquQPytNjRKPm9a29l6Xy307X5Ht7a0nZFk2Cn809brBMcjBAS3+hxOG1kyHw+nOZjOFGcJnVy/f+8LqlY+7RJcoR2TIypepjT9V4wlONfhqxt9QM3C5xVtL1ccLln7YiUemSwqKSQy/6BsIDfo0ghrYC3y8qnV8Irb4oEjaKUp8cy71Asytb8Dx1qaSA6ga/vzmFoQ8XvA6djRLQgEftNbVsImBHD/P0XhGzMMhpvp/aWsifK7+ZCyjZKXBcGfq/NpIaiW77V5Y34RnLw/Dm0/1Qy5rIdeekHP5XS6IJkh7WBUqTCbQCQOHKDCPADo5QL0OHILI3Pqp1V7lK62dimoCbG3CElP6pxZqiRB+HzveTUMbyPcb5LsXr16HdbKmcwntnvoXHu9+2z+R81uSfofTKWQzGWwIjWFG+q2sV4WFWq0IWe62U1AykXjt+sjQt8FeR1riNrcHLv5WM+1CV9fx/51OZOTPJS8vLf2hqqr6Opl1ugA48EUgjiTKTJJa6aCUWPpr6+qPd3Qeex9pa+yMGdW1tbUvT4yPPgXFIqhmpF+biDQzepiFOonHjve8XRTFWq5seXVl6QmwdjHGvOGIfYWJi78Z6TdU8Zckyd/bN/AemwYKyKTTU8NDV/7GRjiiVTo9s5AE01DDxqaW9wOnr0FDDcfHR78P9jwO8R28AUDiv4/YAxG2opeQkH76d8E9aDq6eJckOkUlL1DncbmFRDLliSrp/lhsqX94c/YddZ6q8dure352R23fCHVZhlLSn9Stte8yUBp7x9dJT/7ZS3xbuHv8qYULm2TncJXfC2d7u2F1axuy2Vysu0DItGaKpwcG3R5ClOMwRwh0X10DKPlA+SqvlxFu6k+v7kTiM1Ayfn58CrbSMddUfCn4D6NP1tR5w8oD7XclvznxtFsSJBhdXGIhAvedHmTlaWn56OeAxwvriQTE02k22aCSS1uLxxhRb6wK5XUCctZ6h84pRqsNtezPbW6yi3CKIrSGwuB2OFj9aUYAmdyANXJNV6ZnYSsRZ94Cg9Vdlx5uuftJ0jDyM6FWDSHfebC7RjoU9sWtODtqEqfKE2SjVFQ8+feEq2vaGhqbH7BTniLLm6PXhzWBHL4T1b8fhrPnVr/RLlX8i0h/T2//OZfbXXC7TaXI4z8+ehGMLf0VeyQgEIibHpUq+OtJvzcYrGrq7umj4URuG+Wpkcj290eGrv4zlBfy08YWRn1e2TbQ5/MHq6pC7+ELz2TSr0xPTdKsK3YmPVl9sf1D7CXK6GnYzZzhIf37g16fr9NOmXSMQvr+P0mlUjSFlp70G41VyqXttrL2c6S/ucPjcd/D1yUWjfxTKplMgH2PQ3wHDxhI/G8QqGiZxcSA3pXecLZQZQSS0FZylt7mBmiuzmXSWN2OwvjiMiWwwrYc7/7xyvnun61e3f7AiYderc/6np1Nrla9vDZ8+t6G00/VO6uo6iZtINyw01C4wJr8W1n95Tc2nPzxM0uX3rsRiTHafrKrPfelmou8F4Q8gVZz7vhNVVVwfXUFlqIRqPfnJjdzpH/nBhQ+kAPqw1Xsg0NywERmudrt8ogxOS3+aPblwO21/YnLG6NempxvcnGFEftzJ3oJEd8h/kG3m5H1bdI2+YIuWIpEmKAgtdiHvd7c5IOqZR/YAfVgWIvTSYotyMhZVp2WqjA0BoM7sf5Mto/cNFmGeDIFq1vRvKo/wIXVkdOTkfn2c00nv3Z7sPvHYE76BZZSoLQhLlRHmwCguBUazTJu8Xy8nJFQDltoCqrj3T3vIgNYl40ilcXFhS9sb29Rl1GjgatRR2pLzM8kvY8dMT8+Z663rr7h/8ofQ9+tzYnxsT8B41l2jO1HIG4hWFgczRT89eSDufi73e7qvoETH6RpT+2US8b7F65duUStjpqauB09FABromRo7Sdt+SM6a7+6trr6d3n9IiNhU3TzR+wrLPp2uy7+bGluaT1ZU1t3t81ileXlxS+urq6MQfE7ZyfFMA+7KYQL72BLa/vj5LCCqy7hJOsTE2PfAmOPQytPA8QBAom/DmXU9tUKjymXIrBw3Mz0FBX0E1LJpBjN55IH3SwcjfMhnVqh8ahy+FdXMxFVURXBTUhwR2MdI9M0Nv6Oni6YXV6Dl69PQCyVgpSarfry5e+e++CJd6h/f/17b3a73M7x7bl7W721z7674y3f9YouOlPIZglJOYUQAPI5S8osWKjzgoG82KDe6q+crR24dj06e3olsdnzk9euwNtuPwUNVJ1f0CLuCzn3GGjda3w+WCYEnBJvJ8sAoLul3N0XSJHVAT9EEim4tjohifnzJuU0xNJxoS/QlhyJzXroOa7NzEOY7NvT2lQ4Cd2/yuOBTEZmn2m5dDsl8IpOrZ+C7rOdSsLsxkY+BSFAtdcHHdXVbMJA5XdmkxkqC3Forq2G/ngSUuSYSDIJK5vbQlLJVD81f+Gj1W2+4U5/82Y+IwJ1L6DFsIaWbJIJSZXyAn/amQsDpFAoDA6nkwxyVtTaunphbHxH9K/7eJcCBtjNM2p2TDlPFu64onem0nIMjrHj4m9I+unfx7t77/N4vK1gA7Fo9KdTk+M0D3Q5l7mK0uOZuN/a7XALYjoDAyd/hQx6tWtRI9tbn14no14onWW3VLO+FSaNEIhbCRbeRHrPKEslcTpROnDi1KOE/DfaKTeTyUwPXb38GdJvbYOxpZ8X8+NJvwYjS6NhG0iV/INVVTprf+aVyYmxV6FYUMyOZx0CsZcoZ+03Eh0uvHc54eGud9qM6wfCF56eGBulhiT9RBtvvDMyAOjry9e1bJhNY2NTu9freTNfl1gs9pVoJLIJpe8fpvA7REDiD4x4iIRgKNraZDeV269grbey3OfTkWmW2iJyoy+Hs+CyfV0ul6AoikA6UcgfK+Td1QuNyFtb7xy9OvQ1xevwSF6ns5BOzuN0sSPaGmqho6kezo9MwsWpKaqy5/325LNvdUlORqwlUXItpTbe9rnhb3X/cs87/ibo9DPVcqqKC7nGw5UPD9DU/7OEbKgKDYDPTUQw0T+yT4nl/91tb37qi9e/05hVlOAPz1+Cc/29hHw3Qk4UX+Ws+dTRXmBWf6p4P0G4S39DY2mvzG2gpLq2KghbhFTLcqZwc+l6bHvO8/7O+7ajmYQ4n153SZIAl6amob+jZUcokMDvdpHfR2Yu/oqac9+v8/lBKSpYgJScJoR/C7ZSCVYGzQTQTgg/u99aqTvOBMybgZ6L/QZOFe7o7WITHllZhu++/Bqpc4K6ZbmSatbDjtmJQRDy2Q+17AkKzeJICL4ok4PJ4Esl51Ez2YyytbVZeHYI+Yc1WCncpYXFZSkej6vtHZ38bRHMnmuzZ5TuX27Sin7Pr/PHqdxxarljdPsblSPOTE/RjAbae2BGkK1m0T21tXXH6urtKePKcnbl+sjQF/Kxckak38raX0lcv5FyrmXqPrqQQcGAz+9/TPu9SBvx6tUrl7/B1cksjV+RtQs7XATiaMGGxdHIM8rIxd/f13/iYbspxGhY1NjoyB/FcynE+Lh+XkPIaLIUYMd4wLv4W8YVdx3rflQQxBBXBRrb/3nSt5rprmAKU8S+ooLUfXohzYKSPxlf07j+d5Oxn724/kxmZmTo2hc4Dxs96bdj6QcwN0AYvX85Ub/2jg/qrP2bExOjXwNr0o+Tb4cAqOoPRSS8HNFR8vuXtWLmIWgEKr8uLOXqlE6naUo3K2unGHT44n7JvUG5I1WVp9bnAtQcAaWx5XcS8vnAqUHSOSuwkdgGUcqlmKMLJbqKJHT+7dh3/2NEjrdAaQYAumjq/37SsRbSCJJynWTRGoUiy39A8iQfab/npzSeXSZlvDAyBi8MjUI0mQROTD8fMQ/MU6ElFIIkTaG3tVU4ldHNpduoBoCWss/rcsIDpweYZV4gRP8nyxd899SfTilyll1fPJmGuZX1wsQIRdDlYcr7NP0erXhDMJD7Pl83qpsws7EGVxeXIJJOspCB3vp6NinhceQnWVS1qIKCbs18E0SRCQlSVf/NWJztT+7+8olQ1wSUWjiKBjrk93ckEwkxk0lTLxAhEtkW6N/AkUBuYbdxeOiqStP+PffsU8A/e1bWe6Nn1OrZ/NjHf0PUpwHUCLwd671RCkEzkOtQuTSGRp2TmYp/YaGdaNfx7neSgaKdiU5lYX7+b+LxGLWem7n4m3aku4jr1w92LQe9Lpfb3dLa9t/y102LTi7Mz/62oshavcxE/fQprBAIxBGCDTE/q/RhRdb+Y909b6quqbnLTrnUODA7O/2Z9bVV2qeZWR2N1MR5lLM0FtrH+vqGVr8/8A7+YDJeem5ygqUPs9I3QcKB2BfYSN1nlIq7yNJPF+qV6PP7j9kpkxropifH/5xLM6wZKYwMFPr3zmxMZRVis+Pi39LW7fGUWPufiGxvb0Ip6TcbL+F7eIOAxH8f8cRXvmIj7U0J7FgL2ZrG8Df66yeoRXlmZa2IUPOgFu32pjp4+OwduZR0+W33nuiF27s72AkJ0W38u9Hv/WpcSVGfeD3x19L/MfIPeSsqlKb642fuocvftPb+Y/ef90juLHUSGJ5bgGcvDcH1uUVIy3KRkAFF2OsDn8sFy7EIRFKJ/I0ovR3US4AKB2rH0pj/ltoauI1pCQiwltom9VGEZm99lrndk62TSyuEhHPnIDeL1iGWTjOS3xisylvsBViNReHi/BysJ+KsjNZQCE42NUPA5S2ID5b9qYTcPf7Z0HX42rMvwXokJx6oqkr63sYzX5ZlOh1Sks+VnxF26bZp97kk3hsMJgBoFfjOaA+EJgv4xCc+YXqu3ZRjNVmwczctXfz16aiKBP1IZ/qA2+2x5a5K3eampyZegp1O1CxWbjdx/XrdDqvBrv73Zmk0B0+e+iVJkgoZCUhn+7mZ6alRMHbxN82Zi5YuBOJI4vWK+fmamltONDW1PAi20vaBsrqy/PezM9PUxd5Iwd9KBFWrr13Swfq39s6uj5C+1LNTBTW9uDD3WS62X+/5hNZ+xEGgXPYMSwNFfUNjD1nutVkWDfX88tLS4hCUkn6jcEQzbQu72YSKPG6aW9s+Qg4tGFLI+H5lfOz6V6F4HGIVZoOhhjcQSPw5WJGW3cQnV4IyL4Cp2nujKzQrkp+Rkv6JhZWdb3WH09o3EoL8psG+HPknr2F7fR2c7GyH/tZmlrM+IygNX5986r2wY/Wvfnl96A1fnvzx+4e2p06CMfmnjVgJ+V9PbQX+duxfH/rK2I/vTshJR4FUR6PwyugEPH91GObW1nPx8OxflYn/dVTXsBqPra0WUgGW3BhyHurqz7gz+b8pHGaW9ZPH2sEhiczz4fz6qLsv0JZlXgDk2qjYoUOSiu7g0naERtYzQUEqBkgt+1fm52F2a5OR9pDHA7e1tEKDP5gn/EZaKJo/vcoyENDzUbf+C2NT8L9+/FMYnVsEhyP3mkkqbD/UfNcX31Ddex2MOwKzRduHnwwoifuGUksyI5x02avnlGIvJxGszlfGdU5vwTKM66cu/rV19efs1EOW5bXRkeEvQbGbqh2BHLtx/QClgwM7M+zsN+48dvyU3x/4cP5YWt9rV69c+gKUdrSmYQjl6opAIG4+lMl4Yit9GF1C4XBrZ9fx99pN2xfZ3v7B6PXh70Cpe79ZWJQV8dB7PZVMfrZ3dJ70eLxFlsZkIvmd2ZnpETAmHWjtR+wrKkjdp08xXHjv3G5PuKvr+LtsvneQSMTP6947vZZGudj6cu2F6eQbaR/OuN3us3x9opHtL0WjkS2wtvbje3hIgMSfw27IkRUJevyxx8q69JuAH6TrTcxFL++pmt6ZjJxWqMP80OwcjdtnAnPFF5L7i5LX/o5mONXVDgGfBzxuFyPMdw90Q0t1mBHvleTmsedXr1IXv/ALa1fP/WThwq8vJtfe982p5z7+/aWX3w7F5J+lHYFiUsoahxfXR/q3MrEGSRIFByHiZAXaf5QYz6ysw8vXx+Gl4THmCk8nI2j9XIScN/qD7BKvr6wUpw3gLsrvJfV3OpgYX0tduLD9tmMdbBJjLD7n6KxqUmRFZneLphNMpjOF/WhZG8lcmj2qL0BF+yZW1yCVzYLf6YbBhkY4XlvPwgdUg/LZn/km0+GQIJXJwvWZRaB6BpTwX5mcycf7U4KmqNXO4PivdD/8xZOhY9Ow0wlYpXMpIrBQPAlgNgGg97rYF4v/DYCV26rZLLon7+L/iM3OVFlcnP9i3sWfd1Pl41NNB7BmE3cG7rflYvqdYOBa5/P7/c3NLf8P7Lj4pxbm5z6RSaeTYEz6MX0fAnELoExcv554mJJ+quDf2zfwqCRJPjvlplLJq0PXLn/BhoK/maXfKqa4pG8jcDQ1t/4ycDnDSdnbU5Pjn+fKMvPKwslPxJ6jTLYh/ThF7+JfGOOR9+5hp8tVbadMWZY3COn/bD7NsBnpN00zXKa+Zu8hG4cQOBoam34ZOO5I6jM7en3km2B/4g3HITcYKO53uFAiAsht13dabFuN078V8gQ3I5l4zeLGJmzGohCk8e+6HATUYC0Q7kf17W7v6WTidpQM031k8uXpY+0s9VwassJLa1fvPlHdtfX80uWHnA4Hm0Vwu13SpfWxD9a7wlu3V/fQPLm0g9UmNvgGjjUSq8mNViCEvy7oh7ffdTtsxWKwshmBtUgEIkzpPku2xQnpX4TNaBROdnVAbVWAEFQnNIfCsJaIQZKQ8dnNDWilXgB8PH1eRr+1vgbmVjfY9WoB/Ce72uDlkXGmjT8VWZQaXdXySnqbpglgxN/vzqUiXolF2I2u9vlAEkWqUAjNVVUQIN/Te0O3Uet9OkMnDNKQSGUgTeqcJX9TkcB4Kg0b5F5Twr+yHSHXkWDpBVlLSo6lXgzZbFqtdoe23lDbf/H2cA91yaKNoRt2GkUKfoDGW5d5t0VtQMMTO227CDsNLA9+0kmlHdTN1NDayIWrxczpLVgF4n/seM9b3G5Pk53y4rHYi9OTE89DqYu/UXyqbRf/PPhrsDO7zne2rMMdGDz1n0RRas+fT41FY381PTUxDNaudYYdLgKBOBrQTSyaTSqWdfGnomL9gyff63K5G+yUK2ezKyPDQ3+SyWSogn+5FGL6tqhcXLHh5Gd3T9/9TqfzBFcNNRqN/N3a2uoilA91QtKB2C9YhdYYaWoULR2dXXdWhUInbZYlL8zPfTayvU3TcOu1NMqFI/L1NTKmmBkhCuOQnt5++g72cedSNzc3/iqZTMSgwoxCiBsHJP4cqFX0S//whPT4Y1Qwu2hmmv1toYyuDej1xN30IeeOoWA+7Wt//mfC8OmT/LFFawch4VRBn1rmc8L6ufO3euvGhrMzNZIkwWvjU3DfqQG97hwzT2fJMQ5RYG7tve3NO2J2ZF0bqoJBsu21qRk6aeD56sSP7yfk2d1RXwe1wQC8Mj4JouRw/GTxlV/qCjZ/Ouzwr8FO7JCW2q9g9fdKnoQgRAhhJqSZEOfqQIAtstpAqpILTaDkmgrexWJJFqcvSWL+gnMu/2NrK7Ccn8iocnuK7h8ttL22hhDvTP5C/3/23gPKkes8E/2rCjnHbnQGOvfkGc4wi5lDkaIV16unPZbt9XrfOjw/h137eWX5SVrr2Gud5+O3x8/eXWltyZJtZdGiZEoyg5lEDjmc4cz0dG507kY3cs5AvXsvUEChUAVUS6REDusna4AGqu69dVE3fH/4/rqXA3rf77LDXiQGB4UYg70NWIolln2ODBB1AUTSNTb/XouZ9AMOEehFwH/nIAIXD4IQQ2Aeg/tSudK4jiJhA7yUhLwtl0alIuUUENh36i35Aa0rfNw+vjtgcHIsx1po3YhwpG7cpow/cRd5aRT5lgzyHv3OFbRRq6DGlNB9lWo/LXmly/U0ELznisjU9BEqsB8Ep8sN0Pqcsp3I/ATPNn+sSI0FzhojzBJQ6VJHQ5KJOJ1IJKq11ziANOgXS0lF3tsdjmGX230byBA0lpJr/pUvClj85Wxg5cb1y03bJ+rBMT1z9H6dTvcw15/oJ74yN3ftiyC92ZVc9JUNryKK3HDSiSxUlncZ2tDfZzKZJ+VUhsn8trY2/iKVTGDwIUzb14nMjwVp0NEx1MloNJkcDudHgbemVCqV9ZWlRX5csVA5roAORd40kVjfhc+zFIs/Ocxmi6evf/ABkMenwSaTiSe3Ntdfge4eNlIkmt3CJyWVbwaDEY/Bn+e3tVwuXVtdXnwaOocbKoq3t5gowF8gP/eRf135uY+0f96FrfxHyZ0uvIatTyR8ENQC/svERN/OznmTY3JhPrF5hqEoZi0QhJsmfKDXaAm45rjosMN6Mp8Fu8EIUHe5r11dW4sZBJAnh/thLxaHMLZgV3IW/PkZVJbVYIDNUIgQ1LE0Y3l864UP/vzou78CtcHN3Qd/klONmfq2NtP7E1kWqMsra3D3iSMEaDOclx6mGahUwaJDoF6nAx4OJf/i+HqbVg+JQh7WIxE43tdP3O6bPcOCx2mHTD7PuTOQj3EdDqMR9qNxiJRSdJktNz7nrP2pYoEoQbAyQa/SkO8q5Sp8//WrEEwkawC/3h6sjGjVwNST+LE1ToJytQJ2tbHkMTizg3p3+qhjNK4GBk/IeCIuoLI0RSirl2ObDpqi80ccowdspcpXlPBdtBpgkwf6uaOhFEAbnhI6isLnh/fa5tK4tDhPfqfDTrhyMlAIzq8c5nyxOtA4IA8l2oh2IvQTA/3koGna4PONP0xRtFpG9Ww4HPwaWlADIJ66T4qkpqN0IfPrpF1X876n0a5g2O5w/nb9WvzMpba3Nj5RLpUKcDgXf4XMShFFbiCRGdfP50ARZfAfGBw64XTJS3UKNTK/LwX2dq+DNPjg5k2x2GIAaQ8uSRbxsYnJD9MMw/dGqEbCob/kWRrF5upDZ15RRBE5IpFBQy7ob3jZjE1MPcowjF5OnaVSaWdlaeHL0Erm1wn0S6XvOwzob+xF0Bj8kGAMVoIHB39V34tKjUFF8fYWFAX4v4nyBsVVCwEddzQGlEtrS4wYPRs7ueAYNppfWFiFB04fg0prUnrQqtQQz2XBoTNCUyXRBNM6jRqmBvsgNJci4HekxwkmvY64tt9+dAq+/dJrhBMgVEjMLCa3Z6YtQzh9D99lndtkaE45JvYuhxciKbbowvH8s/4tODY6XOPYJxoJft3CMKkalh9xOOBaIEAA9lokDJPuHuJCX6ffJ+0dQG3kpzPA72wmI4Hn8VKGeEdgEG8zGkGtYqCMAD629uMzPVZLTRmB7umJV1+HaDpdVy7U6frYWlo/ukqx2GtAo1aDXqOvOxaw4FCbS2fsUwmvoSfDyx+MW6daTe9a5uMb9rX0rjVfKqm1ag2m9IfHt15kfZaBrQ977/seTscCPMCPrfwUtuIj0I+tKtCc0PnKAe59C9u74HnhPzN8D4O35KSLLf4c+OdvZtPpFPdcCWP7paxYZIH1+sZu0+n1g3LqLhTyi2urK09B+0LKX0wPxQotiPvjcy5IubWKgX5Gp9MbRkZ8f4ieCXO9LOwF8Rm06d6CzvF0iou/IorcwNIlrp9v7RdzM27EF9ts9qHBoZFHKYqiZVSLXeufW11Z+gGIW/q5OZPveXTYuP6WkEF8Xl//wKjRaHqU35BCofCMf3X5ZWgPixOrW1F+KvJmyGEzaLSEIo6OTdxpMBhG5FSE94PbWxufRc89doH8UeP6u5EQShL69fR6hkwm8/v5bcrn8z/YWPdfhUO6+Ctj8KcvCvB/64nYRp3tdtzTe2r27/zf97I0zeDUfpsHYRh0Y4b8Jrg2arSQTRchWy6CXq0RqZkCt90KFr0ekrksjLhdDY8Ah9kEgy4HBKJxzI5PXQovnEPAH7uxcwssrog/4akfGXnX1a/4n7y3ygD92uoa9LvtYEegXC4Mwez8Iw47bEQikC4WYD+dJAz7pDK2ZsXHbeXc/OsO+YQrAJP6aRFQx/H5WFmB214iKQQpiOVyYFCrwKTWklZfWd2AcCpdJ/JjwchoqqOm/kKPzl52aCwVt95WvRpZ1q6m97SBTFRFCBSRpPIZ9Wps22XTmO1TtqH0u1wnQpuZfcPzwauuSCGlp4gwoNMw9dh/bI7WU7v58HCVAheNsK0/vWddTGz2HeRiA8lSxl0oFxn02+QnLcMvPtR3MwakHNjnDg6g8tn8pZ6TKjQnetI9P61Yf+z90kER1mgb7zOxxUlI6Cd08debLRYPWqTeJadNxGV1c+ML1WqVc/GXIvOTzQwtI5d2t7h+suHFG/Ejx47/BqNSTTT6sFB4Yu76te+CtFud4uKviCLvHJHaxEuR+bVY/DUajW18YuoDDMPo5FRWLBbXlxbmPl8PiZKy9kvl7ObaKydtWGMeRKIeHBr+39F8qOUKQfXHNzfW/rLuFSc2F4qBDkUUeUNEhot/J49EonRzOF0j7p4e2an74rHo4/uBvXnonrqvk1fiYRRvDeUb3sQOD3t/mZ9Ck5Bqrvv/B7SG2UjtmZRx+BYTBfjLlJ8CK3rbQEGLIF3P/944cpWC5lrSP21mTNS003ewEN/opxkanpudh5+96zYSe84Xh9EAe/EEDNrsjXh1vmAL/4DLDvHNNFjMNVCNpYqqvXVmEr75wgWgGQYC+YgvWc72WlQGTO5DACaeIF4IXTuayKetd3lOrXm09uwx++jGbGJ9FLvMP33lOnzojltApFqQ4jV06I0Q1+UgUcjBbiIOJo1WoLSgGleTf6makgJzIBRLJXKPOL6/z24lyoJwNk3qd5tqKfri6Sy8vrZBCPmwd8C4qT93vu/mtIZRQbSQVL0SmtOtIcBfpli6NmvSoEb3YtJpSV04/CFdyTOvBK9bcPWXwssWmiaIv9ZvbBX0Wg0MOO0QSaYhmc2BmlJRTwYu3rQY3ewrQ1mnolUNBwitWos7Uz0b8z94X//ZeTVLYw0vH/C3pU6EVg8Q/kHzOrY1luItJIKxJeW+2mlBJa+oz/WjYxPvpmlaK6feRCL+vVDwYBXE3eY6bmLFgHQXBn8pt1ahhYv8rjNHj79Xp9M/Ui8HPc+VtaXF+T+Fdku/4uKviCLvIBFJHyYXeDTc+9FcaZycPvKoRiuPzA+tp6l1/8pfCCyOfPAhRjAqFdcvNheKpqmdnJo5r1ZrjvOawiYT8c+GQ8FdaAccHedCZR5U5MeVDiz+nUIRW6z9KpXa7Bsde1RmKCL2blleWV78R5BP5tfJ2t9tPyLm4n8nmifO8spiU6nk5yOR8AG0Z9LoZPFXDBBvEVGAv0zpYrF8M8trDGIE+oXa7Op3dl96OJCLnqlU8VcUcNZofMEzCGg/fO40ArSc4Rer7xgw63RwkE5Cn8Xa4ABoVIZA8lCPC9b2D+rW9CYgN+t14PP0wmYwBCpaw1wKL07d6zmzUG8LPLl38cRscuM4nlE2V/eHfmHi4Vfu7z+3uZ8LOyPFtBWz6n/nlUvwnpvP1Ij8+A6AYnQIdVd7r8MJVwM7CLhTsBIKwvH+AaAaF/KlFkKAy8bKgUo9LABb8Yd6XcTaH06niWs/ZvPH4Py5a3PEIwBfOmYcyD06eFs6Ukgyz+1dMa6nA1o1g0A5zRLFx/RQHxz1DhHOgwrq02v+TYimM6QVapWGuhxbsSLQT26lUqmCx26Bk94RGOhxkIwAryysQjqfJ98tJDZ9gMql8dxK1TwYsIcC7hJMKKhjtNXrcf+JXKmAFRJl1A95La2OeE0Dm7066w76jE8MWRE5+C7mP3Xp9qxLsFOLxatKLai6weGRU0ajaVROe8rl0p5/ZekxkB8r15HFX8LSL5c1t2WhHfGNHrfZbL9evx7//rnA3u7H0WKbhM7adSWeThFFbmA5RFx/RxZ/3+j4bRaLfCbxg/29v0Eb/Q3oHNfficFfytovJBFrgH6n09Vjs9t/AXhrWKlUurS0OM+lDuuUwk8JdVLkzZJu40+Sfwj/jYD0vVqtrldORdVqNbex7v9cuVzGcY9SCrduXolyXPyFln7i4m8yma0uV88vQwuhX3lxeXH+myCefUrK61AZg28hUYC/QN5ogC8lhwD93GtbfD8Crmy0kBzGLP1AqwR5BSgIIZxwZXUdTo17WwC+XW+AtUgIotkMsajX1AJNgN/nsEGvzYrAPdO8jsKTEEvS5a3vHxC/9ZX0zti9cGYbfVvJVYvqq1H/NKOqKR4KUDZ9Ze3JM7808TPXPjhy39Lfrj5xsgQVbSKbg8cvXIJ3nz1JLOEdl2Wq1i4cpT/qdMJKOIyxMqyGQjDl7pG8DBP36bRqSBdq/HdYkYElWcxjZjzoNZsJb8HWQRiSuTxx8e/T2osI9GeuRld0z4eumnDnYtBfRueP9/fC2YlRVKYWm/BR+Syx5K8GDpp+9GzT8wCXd++pY6heJ+FZwE4aOLvB+kGopc24Dbifh1xOMOg08NryOlEQ1L0XNM/vXX2QpCAg5IW1/v+XwCVWz+gOHDrzok1jvXZP/6mXzbQeKwL4GyAGmqn+2tz932riX9ugt7c2pDaJ3Qj9yCsSR1/fwH0gT9FRDeztfbFQKCRAOq5fTh5coUgx5naycLWAf6fL5Ub38QlUBOe1UE0lE5/Z3Fifh+6WfoXIShFFblCRGdcvJPNrY/B3u3vGej2ee2VWS5jE19f8L0B7XL8QfMgl8+O3VdTaT9M04x0d/1WKoi2NhrBsZmd76/9BwAPXzye+VSyNirzpIuJpIwagO7L4u3t6xx0O51mZVbLRSPgbkXBoDaQZ/OWm7utE5idJqjk+OfVRNBbdvCaVgweBPy8WizkQ34tIKiGUMfjWETmELu8Y+djHP0HLAeR8tv5OzP3CNGXc+Z2uweJ0uYmLtjoW48AaiwaakNSvisGemlbFWKpaZ6Kvj3KWqmNFGq6ub8LGQailfFyI22yB3Xgc0qViC+jHggHmGQR0cUw8l8qOe+mxWgh5HsajyULWFCmmsKug8ULw+rSKYdRUvTQMflPVov3Fg6tDBkZT/lnvvUtaYIq4lky+AN944QK8vroB2WKxZu6WELYe0G/V6sGlN5DPMsUCBFKJ9nOhdhv4GoNOS4rF7yf6POS7cCpFznIbTSR932sra8RdX09rKu8duDPzxPZLpmcOrpgx/SB2+8f3+rPvuhXuPDoNWrWGhAJwNS1s7kE6XwBONUH6ja1Cn8MKH77rVhhwOUg/Eh9MmobnZxdr17PEbRt8PW54/+1n4ZFzp2F8wAPr+8Fm6kAuUyBTSz3IZRnA6Rr1GgNFqxhPrJy5Zy2z9xt/OffYl/584Wt/cy225oVW9386mVSRYnR6PceQL0vqzyjT4XtG+AzXrgEKj6FO5QrqIOd2AP2MGgmI58NtAf+jY5MPqFQqk5z7y2TSF3a2Ny9D58VUNpCWsMJ1WmBF3Vq1Op1ubHzqk/yFtpDPP3599uq3obNbq2jaHGWhVUSRG046uc2LzZEtoB+JEwHq9yFALcvoUywW/EsL838H7UziYmn7pMj8Du3iPzE186BWq72F1xQ2lUx+LrC3sw7Sc6Fi7VfkJyFSz7QQ9LcAf41GYxnx+h4hxE8yJJ/Pz/tXl78Hh3Px79ZeKc/DNlLNEd/oKYPB+BC/oFwu948b62vXoFXxpozBt5kowJ8nf/zpT8lKXcZXDhzWOwCf3+2aSDhEmPJLdntjAKFJQxi/TRbacVP/S9h1HCNcTJx31/FpODU6DA6TgRDcYVneCbSZQc1aHZi0WkKcV6pyt11jwMcVGtB3NEW1Xof+wMqAmaEBAlDVKjW1kFjvQ98Y5xObgxigYkDNl7n4+gAmKnNprYUPjtzjRyC7SOpB585tbsNjL74Kry6uQY6Q8LXG63NkfTVtB0tY/lV0jcR+L5mEbEmY0a52MRdXT/pbzYDP4yLWdZwa0KYzENJA/24QssUSRvhwf+9NuacClwxL6V0daQP6/24E9t997iTpB5ZXNn6fRYD/sn+9zpFQw6w6tQruO3kUzp85QQA6v8+wciMYTxDgb0e/ywfuvBnuPD4FVoMRipUSZAsFuGlqFI6ODNQ9ABww2t8LR4YG4fSYD86O+9CrF06MDMHMYB+4rSZyP6hPKJ0aPU0UNfFidO7jIHDvt1hIKkMqn8tBOp2S/ZzWn9FKt3ParwH2k5/8JCvnmnod1Q5x8WRxKpVKnDuocEPbcJ3r9fRNWqzWY3LujcSqrq3+fZ2gik+aKObm3xVId4j5k+tOR87Bm4Gjx078pkqlarjfVirl6/Nzs5+B9k2uVDydstAqosgNKBLWRjH+Ez7w4Nj7yStOH4YA9c+o1WqbnDrRXJle86/+ValUxCFG3fKGC5Wkct2L2+KK3e6ePofD0eJejNaB1xYXrn8DOrP4K15PirwpIjPERiqLRs04MT55n0ajdcqpD429zMba6v+qVCpp6ByO2InIUsrS3y2TBqNHiN/j6f914HmFozbtri4vfRY670eEhH5ElDH41hLF1V+m/Cju/1/7+tcPFV+NBweaYPBbvlt2m4s/8Ba7ezxnriwltu7Ps6VBHEM/0usmpHUnxoaJxTmeyUIilYFIOgUOk7lRFwahw3YnXN8PENf56Z7eGhFevUqa4uOxZkuwKmBioA9eXVol516NrvU5VdZykS1r8TXTg/0QSaYgEEsQyF5An+/mI9Z+rSPt1tnyvzj+Hv/jmy8O7RRCJqrejuXdPVjY2oEBtwMGnE7wIqCuRuA5hQAr5hXAvAS1eH+AMZcLFg4OMFKC9UgYjvcNNFP88Vqsw4Zi9GZ6YIC49+M0hrjtbpMJKATuL62uEZK/YxZfcSm1pVnN7GrwB3ajEc6fPQHYzb+RDpFtlkszFLw0v9zoH3zOxGAv3D4z2fi72Vk194O9UISQLN48OQZTQwMEtENd14I5GeyoTVjNcRKB+9ZrxZ8T7EGAQxAuLK6APxAk91WuFAfr5I9il7DY4l9Pj/djSzelwI8g3EPWbUPblr4PE+UMDY88KDcdVTQS/mYykQhA98W0KxutCC+BnE2u2GaXPnrs5Id0Ov3DXF+w1Wp4Y33t93O5rFSeaklLP75eWWgVUeTGEBmEYl1ZxKEW138HWgcmZFZbDR7s/y2aL7GFnQP9UllP5Lr4i/GbtChB1Wq1xusb+000nTc2K5hBfHtr408FLv6d4oo78rEooshhpJtxAjpnGyL7FOzib7c7zsisko2EQ1+LRiObIG7t75RxiBOxrAOdUgm3pO+bnJr5ebSf5KdEroRDwT9LpZIxkFa+HSrtsSI/PVGA/yFFsAh3lKnpIz9udR1BPzrKaFEs3eI88tTTwdd/IVMoUBcX/XBuegxq5P8AFoMeHQbiMi7AxwS8jthtCEBHwR8JwYS7hwDVegY/oIR+Ajx1hK+vB9b3Q5ApZFT+zLYLKw2wouG4b4goG/YuXql5D7BVmE9t9CHg78fXvbB/1bmV3Tc1rOJ1PgL8934sAYFIHAHaZQT49dBjtxALeK/dSggJiWVdpQYPAsrBTBpKlSrsxGMwYLOjZlUbDcRNxMSEGByPDfSimY6GKGoTVgYY1BrY3AsSK7yB0bIVtkotJ3fVuIM8qK7zN52ABrGBkPgQHXvhOGkjVgDgv+87eQSGet2EFLHNPaJ+vRqB/n99923EG4KAfqpZBZeIsOnrQDWulQrKx2VgvQCnfKii0lxqyw8qxPVD9Pk5lMX/JyUS7NRSDLnCuH5y+EbH7tBotG459RULhVX/6so/Q/smVorQTxJIy0zbJ7XItrjUjY1PnrNYLf8BGk8QWwyFgh872A/sQHftuhLPqogiN750YuTuSubncveM9fT23iWzLhatF8+vr60+B93J/ORY+7vNgw1L49T00Q+pNZqT/LYk4rG/2A/sbUEr4Og2ZytzoCJvpHTyXukI+rFxYmTE9+5DuPjP+VeX8T5FyjghFVojbCt//An5kiT3I17f2Gmj0fQeQZueQG16GQ63F1HG4FtUFOAvQ0TAvizwf+GVV2h0bVv4gMyNOStyiIL/k86J5bnE+kKwlDwyt7UDWo0aTozWLP5U3XLMCnSB2NKOQadNbwCHIU9y2+/EYjBot3duUV0wR8DGfhjVpaM28xEL7pBhj5uAXLcFAXarBQ7iSWK5Dubj1q3sgWXY0Jsu0xU1Vc88oFGrELC3gcWgA5w+T4XAP3a1rxnKKdJGo7aWvo/EudfvZdDmgHi+RtS3n0qBw2gkCgGKd4N2swnMOj1YDXoolEqQK5dgCNWFrf2zm9sENOeqRWo+tanGIN6K+uEhBPq58ALu34b9vk6wd2nFD9jJfsjphtuPTIIWp0usiisKamVQMOB21s249X9awuP5/Apsy+dsK1tj43McqrC0E4Cl3QD5QEMxT3509KG/YmvpG0Tjvd5Ii/+bIHII/dpI/axW24DT5b5FTgVYQbazs/XFSqWMLehSqahkbSAPkbZPbIFVA4/B39PXP9LT6/k4KoZL7VNNJpN/trqydJHXrk7adSWuXxFFblB5I3KGa7U6m8839jNy4/pxxpPlpYUv1sOhpOL6xeYhAGmA1M3SSA8Nj0ybLZaPAG/BKxQKTy8uzP0THA70E1HmQkV+XOnC3yPHxV8/OjZ+l0YrzzhRrVazG+v+v8Gu/tCd0E/MK1EqJIgD9h09btA+0dLr6fsNELr4ryz+f2g+4Cv9Orn5K2PwLS4K8O8iIm52Yq+iMj01CQf7Ac4FmeWV2XIeNzg6eBO0kPpBE/w3Bt+jQ3c+9cXVJ3wVitJfXl1HYLcM56ZGidu/mHDWfPz1sN0BifweBDMZEtNur5PotV/TvAm3zQLlSpUA9RIC1Ti93QnfcKO+W46Mw3cvvE4s4elSlkpAzoE+zgzq3en56IYdo3ts1T81NkI8EvjzFtUwd7cCXrae9w4D73G3C+YC+wTA+8NhONbXB1W2aUFXqxiYHuwjyo9INkvOcxiMJP1eOJkCmqkZmPG/Bo2GZBnA90DzaC9adCWo2PmNHZJy7wN3nCMhAfheWYDWKbdNwSJ8SHhgnq279DfvDjiPBarlfH47aLi+sQ2X0G+M3RwcGsu3fn70PJ6UC9BB84pAvyz+ip+UdIiZ6wT6G1p0Cj3n3tGx8zRNa+TUl04ln90P7OHUk5y1n8/i38l61bJ4dQH93cj8WhZZi8VqHfGO/hd0L1au/Hw+9/Xr1658HZobXNl5qn/av6kiiijyxonEXCPFIs7NkS1kfmhuMUxMTb9HrdHY5dSJN/dbm5ufzedyEWh18Rdu+vlzJSfC0KduKUy597TBYDT1Dwz9Fmovl80EA449/+rSn6FXvsKha7pVUOZCRd54+VHS9+nsDuew0+W6WWYdbDQa+Va0mTZTKuOQpIGH19ZO+xKxbBqEZ2hiauY/MAzTxyurHAoefCaZSERBPuhXxuBbXBRyP4FwTOOYdRwvvEPDXjLg0WuNVa49lpfW6fV8rXbjcwT6AdqtgeRa/9oGVx6ph1vk64z+fGkMJJWKsLSL5m23qA2pm3uO/7BcqbCEOG9rG567ttAoAIAHIduGJAujThd53YxFIV8utX5NtV9mMxlwIHINpNZj493WWlgeZkOwG03g7XUTYJvOZ4DRMJhxnT5i8cZtKgOe1BAAT8NzV+chkkrW3dY5dQTVBP0tdbP1cyjiITBotxHsjF369+IJoBuXUGDWaaHXZSO4OprLgFNfA+qLWzvEs4Cq16Vl1PCeW04TRQEtMRwwFMfu9d6+Hjh/00mw6A1EoUBwu5D5T+RqrgyWKArY+g9a0wjQdZd93LZEPo/6vlw/r7XDa/0M8MrSCgH91WqlOmrp+9IvjD30WdT/eHHolNqFtVptROOAn2d+ZgmxzBO8sSA8V5anCy6Tf40wC4BwQ6vV6ci4Qc83GUMIzJMFiWYYvIgKWfzJMTg4fMpoNHnltKdSqUT9/pWvQavlih8v1zUtnli7ofviKjwaLq1qtBOfmjnyB2iRbdxDqVS6cH326p/D4UE/EUW7rogiN5x0IvTjg3694CDAf3jEe9ZisU7LrIuNxaLf3g/sXofaXNkpJEpqnpSaEyU9nzDgmJo+8u/5cyEqsoQAx5/EY7EwtDOIdyU2VeZCRX5cOYS1X5R/CO1jDF7f6ENyPW0KhcKSf2X5CWh38RfuU4Qu/p1CbOTsSYjyDYH+e/V6fUuaz2w2803/6vIFkA45FOPWIKKMwbeuKMBfIBzT+EsvPkf+3t7awC9ULBqRcl9j8rmcmDsbw3vlx9mQ4+SJ42LxzVQkTFLvNZjZecKWy2Uh8ViLEuBm59TihHVoCZ/MUDRsBkPw5Wd+CNsHYYSmKAkVXA1MGzVqcBtrwH0lFCLM+C2nCARNaiSkgKpD2fG+XuIBQNXxLwbGUwP9Nb9EBLQThSxdpMo6/PfPjt63paM1Bfw+mcvBk5euw+LmXktGAGEaQarxX3Ou85gsoMdU8uiv/XQScqVSS/twnH8inyPtcmFSP/Tfyt5BQ6egVtHw6K2nQatSA5dDjxW5WZJKj2aIN0SlngGBB98bZwm7isYeBfXQBdyGTKkIcXS/4UwaAokEbEQjcD0QgOVQEELpNOjVahI6wN0pLz6AyD9fmiUZGli2Wp60DH3hfQN3YpZjWTHqiUScNHxs1FvlZ5bAz3uHscAKzu06kXNs/fxrMBmgyLUNQr9CPk/GAHq+iUtatVolm9pqpSKWk1qHXVf7BgbuERkjog94KHTw1WwmgzeQ/AVVyn2+ZTEV8cYR4yQQI6+SSlVFNrrHTpz8NQT+G5aAarWyvrK88LFioZCDwy2yiou/IorcYNIBdAjnFkkXf6vVNtjXP3A/yAxNLBTyiytLi4+BOJmf2BrTLa5fak5scfGfmJy+R28w8NOGsZlM5ksIcLwC4grQjmFZylyoyI8rIsS9nQj92iz9+HXEO3qLXm8YlFMfy7L5rY21z/NCEcXGnhwX/048IFKGCNrd0zvodDp/BXiYELVlaWlh/n+AeMhhR2u/Mgbf2qK4+ktLy0a/XCnTvL9pwSv/fCzkoVchEIfAjJgLDFsql7iBKtTaNeoUlse7ng/6W8D/IwO3Xv7CyhN9aTZvxeARu68/e30e/PtOuPPYFGGrb40bbwJWHAOfRLgD55PH4H+qt7ejww52kU/k8iQv/fRQf9tNuKxmAnqxC34wGsppTdNlBJUps8pQPu2cjL8Smu8ljUdg+pUVP6zsB+C+U8cRwNZI1svWLfXYSR/7G4y63HB9b4/UsxYOw9G+vjqfAfYKoGE3EQeTRosAKAP+3YMaeSEA4QR45JZTOACy+SOwTZ8Dqdr5bPv4hbPYl9E9YB6BfKkERdR/xUoZvS9DAX2G0yUSKE/6giUAH7cJ8yt4HXryXbV+ZyzL/6lrao58sQg/uHQV0vkCTj8Ye1fvyc+ddUzhTVEnwqWurPQ/DREj9EOLoyqXy0rF9rdZ+31j4/eoVGqLnPoK+fz8xpr/OWiP6+/k4i/m2g/QDvqFpDlSCyx/s0thBn90z+8HTrWDftPtra3fjcdifHe6Q7H4K6KIIjeGdGER59Kb8sOg+ICfgH5GpTKPjU8+StOMVk6dOKZ43b/6WbTZ56cP4+ZLMRd/OXH93ZSgdA8GHC7XrwEPcJRKpdcX5mY/D62eT7JS+CmAQ5E3UA6bvq+hADCaTAhLe+6UWQ8bj8f+KRQKrkLnuH6+0r9TO7uNwRbgr9FodF7f2O8IMmlkdne2P432ZSloHYOdFIDKfuRtIgrwF4jIRp9s8tHC2ObiDzxLPYgA9TqIE2qlyXsESDj0Leay01I3tGvsxQj/yKGi6OIHfXdf/Pu1J++tsCy2LhJguhOOwLdfugS3T0/AQI+zTu7XHp6OXf5xujxsPd+MRsHncLbxBJBK0WcWox4B/xz0O+2gVquIlb/Z+hoJnd1sJC79sUJSy7LE1k49GbjomUtsOvEfOG1fvpgHmlFBLJ2Dbz5/gZDmTdTj84VC8VuBitPQDPSZLRBIJSGPwHY4W3Prx/eN7h9ShSIMO2rhjesHIfK5QaeFh86cIMSBwk7n3yOnEsGAnCapDikSBoEP3D+YRwG/ZtGBlRf4HIZuPg41rwmWZBIwo7qMWg1YdXrSL/g7TslQbdTZ+vPjtm7uh+CFuSWiYNCwzNqHfef/0qE174K0RYa/QLyVJ+TGQoUWF/y3rNh+h9Pltdsdp+RUQOJVtza+hAlzoJ2gqhPol4qb67bA8hdVDYho1ienZu6xWK18Bv9CKHTwsd2dLT/IZ/BXWPwVUeTGlk7uxfw5krMwNtL24dexsYm7dXp9v8y62HAo+BVe+jAxHhQxryh+O8WymogBfh7g0OpGaoCjocRlq9XI5sbaHxWLxSx0T933Vl7fFHmbikwXf87bRpzQb3TiAYZh9HLqK5WK2/6VpW9Dq8JNytNG+LzLAf1SRghy3syR4z+vVqtneE1ik8nEX+1sby1Be9ihmNJNcfF/m4kC/HkikaKLDKhioSAcVHz3fSH4JwOzUsupxwfnwvdCq6xwwLQoF2iaxgoI4NchKIcMSKfGkrp/7NbISzuv92QK+doNIbCZLxXh6WtzcHRkEE6Pj9QhbavlH7ua91utxBU9ikC0CQFWp8HYaBCXDQCDVCNJsQfg63G3g3S2phzoQWVh4B8qJDA1P3OQj+qvRdccjIohlnk1qIrvGrh575nAa4MsRakwwv3hwjJsBsNwz6kj/Kh/aNV/UA1wPmCzkfR+GHzvxhLgRu3F34XTaVBh/gHUTvzddigMFqMB3n3TyZpXAedOX89fiC3yGGxja32mWCSgHns/YCs+eV+pkDABhuIHHbAE8FMMTe4Xh1hgkK/TqNGrDowI9ANF1YF+sw+h7U6g2R504EwEryyuwsZ+iLTLzBivf8T34N9oGTWOBeG0wkKLjJRlmMhPe0LuQOgntGSRTS0m8EN91dCk45i5Ea/vQQo/JzIklUw8HQoerEJ317lORDkA8hbXjlp1fPhGx087Xe7fg+a8W00kEp9ZXV7ix9AdhkDnp/6bKqKIIm+cHJJFnJsbW0C/u6d3As0zcgnFIJfLvl5PHyaWM1yMzE+4VznMvNjYP00fOfpzCHAc5ZVTikTCfxo82OfSmHay9iuAQ5E3XCQMf2Ju82KWfnL09Q/g7BRTcupD+5vy7s72F4rFYgKa409I5tdp7AnbKcfFvzEOxyem7jCaTO+D1kwaTy3MzT4G4uOvo/JNGYNvD1GAf7uILroqJFwMMrTG7wvBPyd8UC90za8yDIMVA2Iu2ZLgHwEfmgf8gXd+NVhKOF8PLZwK5hNjsULKU4aKBselYyDbxJk1VvyF7V1MeAZnJkcJiG0WVYPZvSYTxLJZAni3Y1Himo6t1gT08+4QW+sxsR5O4yfajeh/m7GRIYAK5qO6a1G/GSswuLvMlHOaWD5F/+LYo9e+v3PBu5sLORhGBbvRGHz12ZfhXUemSfnkvnkuCk1H+Box3pDdBuuRKJSrZZKa0K7XQxTdA071hy9d3d0Ht80M5286gdqtJiXgZhTLZUgVCpBDQD9TPwi7PwLw3L3WmPkRqMccBHUOgzI6B3sbGDVaokTAKQdNGg0hCcSZDDilBKE/rP8ANRJ/oQqj3fEjmc3BlbVNCERihKtAz2hCDw/d/hgC/TH0NbaEyHUHeytaQ6RSzQgtWTr0vLUsrINDI6flxsyh5zvi9698Azpr0OX01WE06kIrf2OOGBr2Tnv6+j+FlRncD5/NZj4/N3v1Mejs0irZPmWRVUSRG0e6uPhLgY6WuH6NRmv1ekcfkZszvFqtJNdWV/5GJHVfJ+4YTjoRnEpZGUlc/9j45K0mk/lDwDOWoPnwy8tLC8+CfMCvAA5F3gzplHGoE6Ef2iqrzQODw/eDTP60dCr1L3u7O7PQTjws1zjRjVdDuDdp7El6ejyD7p6e/xN4OBDtmzZWlhY+w8ukobj434CiAP+6dIjlJQMKG3NBPB2GGPjnDwb+oG0MmjroJ5/TDMNWm3+LadNJHeVymd82TqpptmD9wsoTv4mAIUPQKjqbqjCYHh30CJTieHbs3m4x6MGIXrFVGqNQDKaZBqFe07Edy7jLBfP7+yQ+H5PPHfP0kfLwNdh7AJ+Jy3GYTKBTq0Xd8rE4rGaooO9UCMzvZEL6xcSmlSPtJ3RvqIwr8ZW+23qO7XzYd9/VtfSe9aX9WV+wmLCVUWOevnYdPDs2uH1mkqT9Y1ta2bT6Y6+E/XgCCqgbsaVfje4Lx9q7jSZCGhjNpOHuE0dAq9aQ8ARMKhjNZck5NN3cb5HOppsZGPF9kX5UafCuiig7DFgRgnkDiJUfGueS9lTrr2yVxP0nsllMTw92s6lBDMid3ayx2f+lSpkoHcY8PRCOJaFYqUKuWnT//doP/q/7+89+4qR17AB4mzOaplE1VanFodG6enYKFrPryyHpwyJ17mHKEIwvsY0tGVeYyR/dhwanc+JZ+RsLqlansyPgfJfM6thQ8OBruWw2CuI5qIUL6hsB+iW16n39A77BwaFPo3trxNAVC4Xvz169whHnSKWqktzsKhtdRRS5IaUT6Bdj8Tfw3uvHJ6fOy03dh4QNBg/+PpGI70Er6OdnPOmUuk8umV9LuJPL3dPn7un9beDtP0ul0qWFudnPgTTYeLuEsCnyNhUJQr9u6TO5fQp57/WN3aHRaJxy6kNb/rB/dRlnG5Ly4OyWQaOTpb+ji79erzd6R8d+ryXMhmWzgb2d/5JMJuIgDfglsx8pe5K3jyjAH2pAJhIO0eFwCOqs+li4Ra0+8FkykHDe8HquWU2dfVyNBozQ7Z8Mhpq1nSULFrqOKAHQNW2aMx7orykCaIZgR6puJEbfY2u/qs4zwNckknq2U0E7AuHERI3J+86MDYPdYiKWaJy6Dn9G0RwohVZuP4FwH2Ow63M6CejHye+WgkE46vFgtwMCdnERUyP94HFa21zXGwWxOO2fEcc8AKVm4KXQnKtCsXX6fH7mekr93P7l3gf6zq2Omvr3R8f7d5cyO8PPBF4/WqgUVKF4Er714itw3DcCZydHiQWfuwWuvbhNAw4H+FF7sRU/iMC/Ta8jMfcFBO4dCHiHMxl0P6H6RbUr6boFnmVrMfZ6tYp4N2BlBnbXN6lrYB97FbB1br9GbH4LQUJrh1Ik3p8mx+MXLoPdZICxPg8M9zhJuAFWoFRZPpNALYRChX97NEX32KxwaswLryytkvPUjFqznQ4PIuCPSf0aFhn+86RSq1mjwYifD/JIpdMpnB6SMvBCNSSAPM2x+3Ogvgu4pz728U9Qn/zkJxvM/Z3O59JivvzyS8yZM2cYtNHEpHtkzCDB4weDfqKVRu9bFtW6u7/WNzp+l0qlMoMMQWUvbKz7nwdxC5YwF66cmH45oF8D7Yss7Xb39I94R/8YjZvGZqBcLr02d/3apyuVMr9Nndzp3qreG4ooosgbIIeMKxZl8e8fGDxms9mPy60zl81eXvevPgutwEPK2ngY0CFl6Sdx/Wgu/09oP9NQTqC5/2BjbfVThUJBKq6fm69FQZACOBR5A+WwYTYNFn+r1dZ3iBAbNniw/+VstpFtSMipIcfS3y2dsNADkbxiLDF95Pivov3UJL89iXj8v21tblwHJZPGDS8K8IcacEELbxUNWiFzf2NQISBFBg62SkJz8HPv+ZZ/Xig327D0VzH1fesAErPs1RQB1YpwcNF10M9PCcgJO2zxhKrbCIbSLGXRa8Hr6SEWduA1BqrQZI3ngVcOcAoFf4Zj1DFx3kEqBUUEJNcjERhzuYk1G7cKg1SHxUyAaVsZdZp8DJr1Oi1JZ1eBagP0m3Q6yBYLdS94Fq5GVofv6D3p19MaPAFWpoyDSy6vLfyPW8/fmSpktTQqZ25zB7aCYbjv9FHivcCx99dmaRbsOj1oaBWxzMfzOXDrjbAXT0Aom0E/QAWofKUWb4/+wx1oROfhGHwticfXEnd9DODx91Rdc8FCk9eAoiQ0Jmxrz3H/Ys8Im9EI58Z9cNG/AZf8a/Dq8iqoVSoYdDuh326DHrsFTHotyVJAaqNrGQdyhSLsRKKNokulUvKYdRjHgottzsizkkgkoFwqNf7G10XCITYCIWzxJ5tLsQman9JPZuo+9o8//Sl8gPA6KQUATos5ONCPF7sqb6zgcSVcVFvi5TDotzucw4cg9CvtbG/+HWapBumsBz+Oe78caz/Z5KJ2u0bHJ/8YLbQermB0v/7lpcXfz+WyGegczy/pTqcssooocuPIIV38+YCjYe3X6w3OwaGR8yAzdR+aH5Nr/pXPo/lSCPo7zZWcHMbS32LtnzlyDBOJ8ZQTbCEUPPijUCgYgO5x/W2ZapS5UJE3Qg7BrSF08W8YKLy+sQexYVBOfblc7urGuv9FaPe06eZSD7z2SY3BTh6I9PTM0feiCeMBfnvyudzjC/Ozj0P7GJQK91EyabyNRQH+PMEgCVpd9jtp/LhBzykAGum6oNXdnxswZYmjAuLKALGUOVw7+OCfNVGaqEVj2M5VSiORZAqeeX0O7jmJ3dq55vCk85/1EoHzwyfEeTgGPlsqQgyB6WA6BS5sQa6ZvoEY8FvwcKsqoYIAv9NsIm74DSpB9M99Z47CZiAIV9e3iXUcAXv1SwfX+u/vOzvH9YNTZdp978DtT31/99Vz4ULCjbkB0vk8PPbDi3Da54WTmKCwCg0LPo7Nn+x1QyCRRB1FEzK+RCFP3PUxyMcp9LAVH78nIB9aifZq75tp9Ug8Pg6JgCYBH5/joIPjRPMM9P/U8AAh/3sdgX+Ok2DrIIyOEGAdD1YEOC2mOmdCFWKZLAL+BcAEiKVyqWLTmF591/C5z3lNfZh1WZL0xWa1sqVSib94NQQBb9JctMA1PvtRJ+xOSgHhdzIWVGHcaktcP15QR7y+++US+qVTqWcPDvaXodVlVU4eak7E2noYaz/Z5JotFuvE5PSnGYYZ4QrGlq3NjbX/GI9FI9C6qErF8ynWLUUUeWdIt/lRzNJIwD+aGw3jE5MPqVQqk8y62FDo4Kt1F38pvphO86RUO6XS9hHAgebDu4wm0weB56iXSqX+p391+RX4ETyflLlQkTdB5GTSaEndBzVvm6Po2R6VUwHaB+Q21/1f4indhNmGOqXN5F553sgdY/pbwg69vrGbrDb7L/HKwinH5xbmr/+/OAsSyHPxV7wP3+aiAP9WEWP1F8vdqVvPHoz88/ar/7YMJadRrU+ZVYaNcfPAzinHRKBu6cciBfzFNvzdrH5Y+JNRI6wASeX2nuPfeGrntV+nVLQuiIDvdy5cgtuPTEC/09kCxdut+yLQlecKj93Zx91umA3sERC8FYs1yP74yJejs6MENeD4fqMezY/xROO8494hsOj1cHLMh8B5FZZ39wnQXk7vjNwPZ69CM76QdWtt+x8dPf+9F4PXjr0WWTwFFM1gboGrm1uwFQnD+dMnSCpBrmYNo4JCuQwugwHsRiO4KpiDQIU+V7ekJcTKgBqwb5ANAP+GSJhGrXNr94bq5IX+C7tJZAqse1RQNfA/OdAHI70ueP7aAhyg34f0ElZ40DSJ69+Px+uZEKo4nqRoUmsPHBrLxXP9R58dMfWsQY3UTyy1S6NCth20NiZok8lMp9OpFmbIH1UJwA8NEPlOyuW/25gSWvuJYq1/YOiYwWAcARlSqVQSa2tthH5SWnSpDW030C/UoreBftRe0/TMsU/xXenQc5QM7O387n5gbxO6W7YUBn9FFHkHyI/J4k+OgcHhk2aLVRaLOJZ8Lje7trryNPxoLv5ylaF88E97PP0jLncrkRhmD5+/fu0foH0uFKYPVACHIm+aCMag0JLeNbZfo9GYEfC/D+R527DxeOy70WhkA+SRacoJseEyInUKOyRkfp6+/t9Fe9uGV0I9feYncrlsCg6nfCOi7EnenqIAf55YrTYqkYgLCT6EkwAZ/C8Frp7Psfl78dfxUgaSpewdm5l99pnA5ZxVYwo4NeadIQTYbnJPb7IVFg9sPugvSbwXUwbwJwCuLQ3Xufpn7HHr6GqmmP/qK+G5jyBAqcmXyvD01QUY9/TALTMTLZZqUWkB8fW3das3JpubcvfAQvCAxMSvhEJwxOMhbvWNszFA5rvCN+LeqyRenqqz/FfKVTjhG4Ka5bsKZyZ8EEmmERhOQL5cMl2JLntOOSb90HRhx4Wo7uw5ca3f4Io8Fbh8a7aas+Dy4ukcfPPFV+GRW06D1WAgbcEhCRj4Y34CFQLVWoYhLve1dHqUBD5vJdirWepr6f1wekH8H+b/+xfUnxqVCo6MDBAvBqw8YCWmPU7ZQgGnWEAPDeqH82dPwusrazC7uYN+PBrQPe3OmIcvV4AtIaBYsastewNGxxZ6ZjDBCt6Y8QF/ixu/4DllW9M3tLqIlytl4a/N13YcVgkgy+LfIX0f9wyT8VQn9BMyVaPHRmPpHxi4B2QuqNFI+JuZdBqTdEhlPOgE+rl+kxu7Ksrgr9Xq9EeOnfgDtVp9gte0fCh08LHNjXV+/JzslH0yfxNFFFHkbSRdXPz5wF8yrt9gNLoGBgfvB/ku/tn1df8XBCz+cmOLO7n4SxKJYUXosNf3+2iet3IFVSqV5eWl+T9Fr2Ls4WLej4oSVJE3XEQI/cQs6d0I/d6F9io2OfWVSqXdtdXl74B80M+XTnOEWFx/A/QbjSaLd3TsYzRN89rJFkOh4B8d7Ae6GSOUTBo3mCjAvykY9PM54zq63rFQJQz6DXZ5ApIRRKYpQ6qSHUvlsmP+bODufwlcKlnUlgOTWhceNQ8s3eyeXqZYCgO6ksyDP/gAWl3+GV47q7e6j1y1aYy5pwKvfajEVt14eK7u78N6MASnfSMw7R2oueaL3r3IW2L1rlHwYdd4n8NJ4vwx+F84OIDjfX01aEtAP583oPkPIbmrZwHA//s8bsI/UK02fQTOTY/Cd16+hK3f1Euh+TMI+K9CcwNA1V/ZUVP/3kdHnc98fuWJ8yWoGDCgxh4FT16ehQ/dcTMB6jgtn7HOvo/L9+/tk3vGhHqYiLBSaeKpZnpCES+Ihv6i1geYUNBjs8LF1TVYRWVajXpixZ8c6idZAxohB2zzumbJfIUCwInRERI+gd39dzPh/nHL4Pxp2/gVqKfqQ6Afv3KbMTFWZf7mq/FZuVwWs46Q9/lcTpg3kM/8f1glAF1vk6R0yIfLB/1ShFUkhGbEN3obWlBlMVQXi8X1Nf8qtmKJ5aEWWpDeKNDPD/FhENjXHDtx8vc0Gg2f4KcUi0b/aHV56WUQt2x1jJ8DZYFVRJEbWaTmHaF7cVvqMOziPzY++RDDqAwy62Kj0ci3YtEI3uiLufhL5Q3n5vJODOJiB4NTEE8fOfprKpVqotEIlo1vb23+YSqZjEO7AaSbi78C+hV5o+WwHjeNw2qzDTicrrMy66nuB/b+Hu1VktCd0E8srr9biI0o6EdjT4PG4G+jV34oAptKpT67uiK6L5HyQOxEhqzI20gU4C8Qu91Bl0olMrDQAKWrbJWpVioMZu7nsferevWu3VAyTcy6HrsFzt90EqLJNASiMYhlMrAXjkI6XwA05tQZNj+YKeYG98OxUxdCsxmvqX/2gf6zrxgZHfZ/bww6iqKreaqk1VYZzPQppglk6VruOYS1WdIO9Nri9j9tHdmesXn/+ns7L9+xmNg+h5qnw2nkLq6uw2sItI729cKQ0wnDvS6Sxk4qDR8nNct/DQg79AbImAoQSqfJd5jpf6bX03BnZ+vGXs6yzu0WVCqmRqqH6hr39Dbq5NQEmHHfY7dCMJGCQrVofzk0573NffQ6NMElB6sZPaNNPzJ8x2uPb71wRxX1AQbuWdTPYXSt02qGLAL+dsyaj0MHtgJwyb9OlA/lSgX0GjVMDfaDz9NDwg9kmUi4+6GqCOT3wWYoBOh3hxSq87J/Ay4u+WEI9SW+L0zYh1n8K5xCQcS9QEXSDJYbfvlYi7KdCXoQ8O+2ADQmfdR/Ghz/j9VMLFvFxI8VNKmzhUKRZRhayFhPXnU6He6DKnqlIpFo1elwVNUaDeRy2Uo+lxPTLsPU9BHq69/8R+p973sfX0kgemec4DAA/JpMxOlcLkfhzALFQgGPKQa9F3OfI5tadCs6VLABPc9oU0sZTCZTr8vlksuQWw3s7Xy5UikLCf24/pTizRAuqp0W1o65qdHmW338xOnf0mp1d/Ee/WoymfhvC/PXvw/iSj0lbZ8iirwDRcQbSsq9mAP9euExODh8ymy2TMits1AorPpXlr8H7aCfr2AWUzJzr91yhbeR+U0fOfZ+nU5/nteMUjQS/uO93W3s1dfN80mxMirypsmPQejHKd70Xu/YAzgVsZz6spnMqzvbm5fhcNZ+4fiTw+DfMg6PHDvxc2hfchu/LYV8/gdzs1eFYTalDm1RPG5uIFGAf1MIqInFohzIxA89SY0GtdR8LQvf3QOnNy+HF1idVk+VyxVygd1kJAcWDPAyhQKs7uzD4s4epHM5nLsMx4obN3MHt/7PlW/fNGYenH9k4NYX1cBkMtWc+n8tf/cXcpWC3awx7Z+1Tz52i+sIP96dDMZqtSWJHGcZ4NynsVQxs/m7B2599a6+0/6ndy+e9ad3Zygao2+A9f0grAWCUJ2tQq/NCkMuF1EC4HRzJGVd3RJfq6GVuA+/HbI7IFcqQRoB7Dx6XQ2HYAIz/YuSBtas5VqVingJYMXAiMdNCP9Y3vcIKcPJUS88+fp14pa/lTsYvQ2OXoMm8OdIF0k/eA09+zaNKRYtpFwcwi4TF/8icem3aHWE2A+z6HNx+jiWHqf1u7axBa/7N8Fk0MH0QB9MDHlq6Q67qAEw6z6u6r5Tx+DJS7MQIcoPQkoIu+EYbIcipIQhBP4dJhMYEdDGbP0qtYoQ+GHSRcy9cBBLACYoxBkRuPALg84gBKhiln1V/VnECpsyWyVZEir176pl9BAi0F/lnddy5PN58poulVicxQADcl6/cmCeH1LCLi3Os26nrfrSi8+RxsiZ7HHsf31BrfDK5kSUsIqk8GNZLdvY5LLqYa/vbppmtHIGLl5Q93Z38FjplIdaKhc1v5/FNt/ChbXNxR89W8zxk6d+RafXP8Qrs5rJpP/6+rUrXwFpq5aStk8RRd7ZIgb6xQBHC5O/wWBw9g8O3gsyXfwxcdf21sbnK5UyXrjEvKLkpu6TDfq9vrGTVqvtl3ltZNGc+LdoXfkX6M5zImrtV0SRN0GkFG8drf11Qj+fnApwlqGNDf8/8EJsuindxMafVHiNGOgn505OzdxvMpn/FbSS+c0vLsx9BrVJLMym0xgkooD+t78owF+mCHLV0wjSZa06836BLfdH01kSB1+lKo3hgcGtVqWGI95BODk2ApFUGha392Bpdw9oFhPFqdRrqb2Tf738He+7B255tlgulRGqd+hVOihXy30vBK/9SrScevJhzy18a6GYNpA/EbSAOAOtzfzM0J0XY8X05kvh2aOLsa1BFRKclo6hGAilUhBGgPTS6hrJAOC2WaDXaiUWeIfFBHqtBjgWen4/YLK/uUAASgh3phCI3YxFYcThrBPm8fqs3hi3zQwMTYHP00tY6/nfclQAHqcNAfCaNTySS/ZAE4hy0mIdVVF0mVALAEtS9ZmNOkgX8iSOHv8Wz169TrqDrRfBonNw2xkE8rH+BbPmX1pdh6WdAAHr3l43WE16zNQi4QVRU4jgEILzZ4/Dayvr4N89aJIa1sM+dsIxcrB1t37uOtwm7pdR11Mt4vYYVZrwWdvE8/xnC1rdPVmRz/kxkFWJoyLyviLxfQvgF/R7owOk0gFKiNA9VE7cHDlcLrfPYrHOyBuX1dzm5vpXBQy53Vz8u5HldHOha4B+9Lszx0+c/iWDwfh+3j2zuVzua9euXP5cvQ1ibLmKVl0RRd6B0oH7RMq9uCWuHx+j45Pn0VpmlFklm0jEvx+sZTuRsjY2vAqhM+joFtdPznG63B5PXz+O628ob0vF4vNzs1f/GuSDfmU+VORNkS7Wfm7vJaV806s1mH9ItuKNjcei343HYrsgDvrlKt2kMg2IkgwPDY/MoHH46/VriCCwH95Y9//fmUwahxsI9yZd0wkrY/DGEAX4S0uLOzBheW8FwOyA3v3qWm7//djK7N/dh5E+d9vFGA5isIvJ526ZGoezEz54eX4F1gIHxFpcYMvWx3deevjWnqOzNMM0rOxqlZpGQP28idHn3+U+cRHEtfJYhBMC3/pPBqtdY0q9p/+22Yf7b928Gl0d2M2FXNu5sK1YLpFphWYoYiHfi8YhgA4M9DExHvYCGHQ5YXpogLiwU1QzM8CMxwPz+wEoI5AczqQJ6V2f2SJqTnVazEQJ4nW72r6tJ88jHgEudN4+toiXs6YSVdWpWboErRMP2RCgdlRjhaSNa43dbAKjVgfFShnMOj1c8W9AEKcPxGAbXaWnVbFbe49dROC7EszFnLv54PBBLt6jYdR0pliAhe09mN/eIV4BvVYLjKB2evt7SWgADpPg7plrsYpWwW3TE1AqlWEzGCb94tHbszpQp6L5pDFcjBvUjIbG9bNsnSUAkwBUKRJeUa6UEPhXFyatw1fP9597gWKpFDRj34VEjvyJXsxSLAX+KzKOKohrdyleO1qUAt3AfweGXCFBpjB2lUvfpxsa9t6HAbWcQZpIJH4Qi0a24PBx/XLiVqUY/Bug/9iJUz9nNJn+N155bKGQ/y4C/X8ukR5HlmVLWWAVUeTGExEyMSl2bkkmf5zpxHIIFv9yuRTwryx9C1pd/IXAXzjfS7WxK5mfTqfTj45N/Ge0njY2RJVKZX15efHT5XI5Dwp7uCI/RelCqtkpfV+D0M/nG7tDLv9QqVTaW/OvPAHy+Yc4OYynTQvod7nc/QODw/8ZhyNwhaH9SD54sP9JdGyBtPKtI7+GIjeGKMC/VaSIz6r1FH0tg+CO3lNXVvzf+RmGUTOzm9swNsC3aAulZkzF7v7vOjFNvACeu7YA8UwGFcpqLgTnb+LOMuq1kMrm0bk0dTmy9B6H1lo+ahnB2no+s3tVkEtOSJzGEf817gNB99Jpx0TIUrY6i1EWdmIHPMt0TeGAnfCxVduk14HZaEDgV0Os9U0qvppgwr7Jnl4E/vcJ8A0kEjXgbDRx1HnAzauYgM9pNsKg2wHC7uHAO8bX2D0eqASoaRWzmth2z1hGUiK/C7ufj1oLbFnLUDVuu8n+PgLQsXIhlsrA8k6goaTQUkzy34w99E9mRp8iJ9thA72+nixnLa8FF0bXMoHxaDllR9fSWK+DU+0F40l4ZckPTqsJvD1u8DjtYDHoQa1iiDcA2rxANJmBYqlUN+qzEMsmVb8y9f4F/LtUoMqsJ/cM4WLCECukdflqUYt6rkxTTNbAaDIz9pG9AYM7hJ6qTN0lgUuPwP2O3AZQOBl3A/1CMF+RuFYIPoWa3gZhpKD/yXuZlv+WRRU99yq0+euWE1c7MDh0XG8wDMoZrJVyOYwW1MehtpBKWbHEFq9Omn4pN7oWIj98zdFjJ3/WbLZ8lDfOoFgsPDN79cqfVCpl4eIulaNXAf2KKPLOEilrfyfAQQ6tVmcbHBqSzeKPpLK3u/ulQqGAifTEUvcJFZAA4t5acrhOMJkfM3P0+K+q1epjXAPQ3im1t7vzh4l4LAKdyfwUK6MiPynplklDLMVwjdDPaus7DKHfwUHgy8ViEfN5deMfEu5R5KYTbjFImExmy+j45B/wFW+4/EQ8/udov3QR2q38ssIOlXF444gC/KVF6HrbBrAcGmPcpbWux0qZ8WgqTWK4cXx3Q+qO0zUIzDZKxQDTrNfDe2+9CX5w6SocIKCJ8R+xDSNgec/JGVje3ofl3QDmBFA9Gbj48IihN21S6bB7Dhmgr8QWbr0cXjqBvdLR58GT9rFLp+wT69Bu/ecmOHY5teN64eDqZKKUMTA00/BgwG7+2MLPEHZ6Ftx2C4z29IDbYaux47O1LhDuNLSMCibdPbAcCpKUdduxKHHXt+v0tcxydXJ8fP3EQB9URKYNLu0ddtdniWUcx+MzkCymjdAag80dcCWyMsRgNwWsqKjgsj3kJA0C5i+vb0IJaxHQd+VqqfrQwG1PIdAfAYEl3aIylO/rvyl9H8BSuJBwojJHV5LbQ5lK3oQt+hQqPpbKQiy9CVX/ek0pwtb2RVW25vJP000vALfeHueeD/RNZdwymB+HQa5ebnLnJtoi1MIJ1Lz7436zblZ64QQtBv6FgJ8/wZc6fCZUAnDSGp8hof3tRFiFQH8npmpyqFRqs6dvgE+O13F8hsOhb+VzuRhIu/hLaawPC/r56XLIuUePnXifxWr9d9D0rsGurD+cm736SQT+s9DZlVVJU6WIIu8wkUEmxk/fx3fz57n4T9yH5kmL3Doz6fRLO9ubl6DdxZ/vZnyY1H2SoB9qZH4f0OsNj/DKKcdi0f+6vbWxCOLpirsqQhVR5I0SmaSa/ExDLeE2hNDPRwj9NHLqy+WyV7Y3NzDYPiyvhhzOoTa+IbVao52eOfqfVCrVGK8sNpvNfGVhfvZx6E7mJ9oeZV9yY4kC/AVitdqgntavBfSjgc5Wq9U2YDVo8MzFE/5x7Aq/sLULdx6dboYENFK7iQt2qX/wphPwnQuXIJ7JES//qYF+sOCwgJlxSOXyEIjFMTA2fGf7xfs+4nvgWVzvVibo+mFg9o46wz/EymnLU3uXxuLF9HP39J7GpHgt4D9eyli+t/3ymb1cqJdhNBS2lGOg34sAvlpV0w30220I8NvAZtJDzUpfrSsp2I73gFPnjblcsILAP/YC2AxHgHG7wazVAZ8Z0GWzCJbxpkcAPx6+Fi9P6m3mp291G6f2cuEB3Cx8nq/PTe6hjNq7G4xBKJFqlD5k6lmcto5sQHNzw90K50ZO+smltSYe6D+7gI41VLb7cnh5aDcXdqTLWa1arUYn04SYkK5fxnLcBOjAIRJ2rSHzUP/NfuApJ3hthzJVVV2P+B2xfFI3ZPZExq0DB0TP0wr4NcC32NMUcyWy7FlN7Y6g63rQ81W9s/fU85PmwXXobPHnP598YM8/ioL3Kt7f/HtoeVyhNeVfJ6v/YTa2jWN4xHtWo9E45IxTBK7XNtbXMOugmOvcYRlyuY2rmFt/G2HOzNHjj1pt9l/lPUfYne/i3Ny1j+VyuTRIL65i7Wr4wCiLqyKK3JjSIb2pFIt/i6UfHz09nnGbzX5cbp3VSiXh9y9j5m4pFv9OoL+baz9fGUrmT9/o+FmbzfbvgOdpiADH3y3OX/9nkJcnXFGEKvKTksMy+ZM9Sl8/IfQblVMBdq3f2tz4hzr/kBToF9uj8PeGYmSDYmn7MMmw6ujxE/9eo9We47ejWCy+ODd79b/XQw/Fwg+VdMLvMFGAf13ww+1f26C2tzZErfw41R7UWNRb3KVPOEZXXo8sVVUqNe0PBEkcv4rh8AA/qZ2EoFPec+40fOfV10lVR7wDmD+eWN7vPXEEvv7iK4Sxfj8XG3w1unjyZsf06quh+WMqFUNh8HtkaAC2w2FIQYG6HF25W8/oqre4ZtagPpklSmnr36587zxLU6hZamKZxwR45yZ8UCiXwG4yQ6/dCpxPAj/PfcdG86j+MYv+mNMFa5Ewiav3h0Iw2dsDRnWTlB2z2DcuIJfXbeXVWsQCDjGIp7Pke5wlwaW3YwTPQCvwp9OVvCmUSzjwPWDFyTHvUC0bAVuF2fUtEmpRmzWr+Yf6b3kBmhsMvis9P4a9ZaPRr3el+odcfoqidoK5mGktFbCE8lFDrJjRF9gig7qxinqxSLMUa9WYcsedYxGvqS+OJtUyr2xSXqgQN/wwODu8mt7tVdHoB0NfXUn6QbOnKt7Ze/LqSdvYCggm3YXYRt/VxOrEbi4ygiZyLc3pD9AZ39t92RftOfr0Lc6js+jHb7OSYE+JnVzIli8V2Anr4F6lUuFcOou815YD1YGJHorVaiUPTX4IMfDf+NGHhr00Gid8j4CGJr3X08cc7Ae4fhbb2Iq40FF6vV5nd/f03AbypBrY2/uKjPR9Yg/zjxw3h6+ZOXLsYbvd8X8Ab+4sl0uvo83t72UzGY4wR4w0p1OOXmVxVUSRG186WRqF7sUtoF+lUpmGRrwPUoS4RpZgj6hvpFOpA2i39ovNR1z7AFqt/N3APzmnp9cz6PH0/R4qgk/m98O52Wufhe5KUMXKqMibLjJINcVIhxugX61WWwbkE/pBMpl4OhIObYA8az8nnUC/lGGCEHujvckHDAbje/jtq5TLS0uL839UKpVyIC+uv21PrMiNJwrw50kd9HPSAv4RyMADhbPKNgaMS2MNunXW1XglM4kJ6ha3duHY6DBxdRdNEVeHhQ3TKUXSs8F7bztDmOYNGs5Sjr38Kbh1ahyev76ICfioC8HrR07bJ2LhYqIXf49Z6M9M+uDU+Ah864ev4lmFuhCevdumMVJTlmGMvui52MYQw9CqMme5Ry++XjeMeHqIVV9FXP47pWZnWxveeN/8Fv9l0xtgxOGAzWiM3PdyMATTPT2Y/lRwJlV374fGPRI3+mqFxNbjcINytVwdsw4mocJywL8xQV+L+b0alYpsfmxGIyEOxBkUlrYCkMjlGxkIp03ei1aVMQWtk5kYoZvUQWnVGqpHb6+oGaagV+uoZCmrylVyqkqpStFqhj3rno559M4MAv0ctwKpZz27b3s9vOTZyh44aVpFqSlVo/8Y9L7MVjVbmYMBBPz3oEZWyL4anhu8FFmezpZLZhqrF+j60GRZnp2a1j67e/mRPq0rP2LsCeJvt3Nh55XI8sRBLtafLKUdZaiqGaI6grxdZ95GfbD2gZG7nqFYCmtVuIWHW4Ty9ZQufLcy/kMr5Logf2ezmYbVX/i0ZEiaQ9HFi1uk2uL6UbGaEe/onQyjMsgZp7ls9tLe7jb2bOmWFofPKCHUpPP5MIQLa5sLHT5/euboQ3aH4zehBfSXry3Oz/1uKpXEoR6dAL+iUVdEkXegSBD6SQEO/tzIAX+d1zd2h1ardcmts5DPL635V54GcRZ/sVAoTrqFP7W5+BtNJovPN/ZxiqYb3lqVSmVjdWUJAY6iEHDIiilW5kRF3kQRWvtlpe9DY/A2tUYeoR96/qPr/tV/hMO5+EuBfmH4YRuD//jE1J1Wm+0Xgbd/Q3u74Pq6/w9SyUQMWg0jnTxuFL6hd4AowJ8nQ8NebPHHb6Xi+8VcqMvnnDMXnth7dQIBRGpuawcB/6EG6G+D1K1RAHUlQA2t1kA/d1UNIvv6ewATB2JrOMLnqovRxfFUMavHaecMmHivnibugVPH4fFXLmGCPeYH+6/eqWG0P/QZe6NT9uHYy8HrFVqlYognAUL+W+EIUTaMeNxg0ukII39TSSH0UpB4z1NgcJe5DCZC5Lcdj5PZdCEYhJmeXgT+VS3XUrycf6ReqtYbFZxuD72a1IYUVWH5pHcNy8hKameMcCGwOCzCQ5QXWJGA+4gwBhAHgmrywcFz1zj9CTTjsPmu9e3WC4rShgpx21Ji2+VP77jDubgOW9FxKr5a+EH9LnCTSxRcT24UEfDP1ctnQ/mY7smDS8MH2aiZQc8CTZQqVaLcYFnuF63FKGhoNb4/Y7SUNn5n64WZaCllw8YcdBnpD+wIoUW/i8NkAKNBB5sHYdK36JzKoMmteXb/ys1z8bXxQrVkZmgV6UYGnc+ROqDLdclybiKST0zMxzZ3j9q8+MHmk+DhV7yA5KC50LSSQTIM1njxmZ6JU0i5VGrwRggeDgotNp1yzvJdWRuLq8Vi9djsjpNyxih2V9va2vhqF/c54WaW/xx029RKgf4HHU7nb6Ni+KD/+vLi/O8kk4kIKKBfEUUUkZZOsf1ivCcNa7/Faut3uXtulltRfY78W5w7HOSlOOW3r1tMfwvoV6vVmumZY/8RrT3jvPqTe7s7H4/FoiHoDPoVMj9FfiIig19DKn0fGYtmi8XjdLnljkE2Eg49ls1m8L5AjHT4MEo3frvEXPwZhFuOuHt6f4u/N0FjMLMf2P14ncG/E8mwkj7zHSgK8BcXvqVTijitAf5nbN61l8Nze6lKbqBUqcL19W045hsmSLGdEq8dMUmPLoqQ1532jcDT1+YIa/56Ys+lYlQUhmNGnbYOfAFsJiOc8nnh6sYmBpbq7+++fO4Xxx9+yam2FD7oveu1H+y9djRXLZgwQszkizC/tQfRVAYm+j0w1ONs+sFTFMiSxnahyeKH3/WYzcT1fjdRA/9LwX2Y8fQRIkBxWrja9TqNuoae0bV9BgfOd9o0k9cnw0gxaQ/nYi4EdEkoxDgC/rj65Z39mos/CRmows2u6csMS+Hfi4sv4Mf0t2l219KBvtno6vB2LthbqJQ0akZNKlWRV5bcj06tBoteB4VSGTKFAmH3T1AFu0ani+Xz2eKF0JzjUnipl2he0L1iIkCcwpFcZ9TD+kGQF0ZBwZneqeLl2NLYhcjCcLFUwloCcu/4ebEb9OR3wekhtWoNhONJWN0Lkt/GoNZRf7X4zYcqdWJAQtKI21iugM1shF6bDYxaLVzb3CblYe6DMlXuuRRe0KsYTcmmNWWGTb17NEsl0fecq2ZLiAL3vFcrFa4PucWBLJo6vR7zYAgfafKKFju5G9uGxX94xHe3XLKcdCr5rMB9TiwXtdiC2kkhIQX6a4RVM0fPI9D/O6gIjowRg/655aWF347XmKrlxvQroF8RRd5B8iMAjhYXf0wm5hslZGJqmVWyyUTiyVDwYBXErf1SLv5yQX/DxR+nMz1y9MS/1Wq1t/PqL8WikT/hkfmJHQqZnyI/MZHJr9Epm4bO6x27T+4epVgsbqyv+Z8B+S7+3TiRpBj8mV5P3/DA4NAfoLFobLaALUcj4T9BjbgK0qBfTAGhhNm8Q0QB/jwZGh5h6xZ/PggiQEilVrPlUkkM+BPwf3vPiRee2Pnhh1UqNXVtYwsmh/qIJZ2IYAgdakShlng9PaBdWIZSuQzhclJL19n3MbDkGov/OT3uJfH+sXQGzTQV42NbL5z6N94HrvpM/ZlfmX7vpYvBRc9Kars3kI1YMCfBfjwB+7EE6FdUMDnYD26LmZDwEfd/qIfhsxJ4nd9Awc31WazkzV4iST5aONiHI70e0DCqtivZ+r/BWKrm9o9k1NS/D7UJrsw7lXkttDCOwDiNz+91WHHuIAKGF7Z3Gy7+GopO3tFzwo/+4BQHLUR+UJ9Mw4UkAuqLkyvpbW+JrejoempADNqx5wH+7XpsZrChPsap/HC/4OwHS1t7ML+9RwrcCG8zFzSzjpcCs9YKzapwJgAMtnF4Q5/dCqN9PdDntMN+JA6bwTB6cCqkU3VqLXxl9alRzN2AvR9wpIUZgfWJ/l7wOOwkfIFueAmwcIAJHutLQ7UWVkDj+67W23nCNwzTQ/2E5BB7BTz9+ix28yI3r1fr4Nn9K49yKRZxneVquWzRGiMujXVhyNh7+daeE9eoaoWv5OI/4/zwBwL+cTrD9h++tnhptFq6WCh0WlT54F/rdLpGzBaLrJzU6J5S6+v+x6C5mHIcBvxc1HLZqaXY+/mgn5meOYZAv0MI+q8T0B+LhqF7TL+kRl0RRRR5x4hUXL+UezEBHGhTf8JoNPnkVoLmprDfv/wtaCf06xZX3Al0iClEmamZo+82mkz/CnieYplM+guLC3NPgULmp8hbS6Qy+fBJfUVJh3t6PeNojzIhs57qfmCX4x86TFy/WNiBlLWfjEGbze72+sb+kOaF2OByk8nkf19anH8Kulv6FYPEO1QU4M8TjYpi69pBoas/Bv14wOBBJwr+py1Dm4umgYWtfPAIBuUvXFuEB87UCHhbR1GduR667f6b52Hm+DEE/hd3A41vMWA0aLXNczH/G1uBB1Gd33zxIgJ3FTjIxVyvR5eHTjsmg2ho0+dc01F0xC9E5gcvhOcHKIQ4y5Uy5NB0MLexQ1j+bdEEDHuc4DCaGgR8bdKl8cRqb6kRBnKW/8XgAQL/fSSbANdmzhsC38vCzh4B8ql8hj3hmkwhVMtZo7nYA+agEOuDeso/b4+bWN1xKsRkNgf/P3vvAeVIdp6H/lXIOTXQQKPReTpN98zsbA7cXWaKtEhTkh8tyU+WzPOkY0k+z+9JFKMYLT3p2Xqy/WxJPrLlJ1nmESlSYhbzkrvcMLuzO6lzzt1AowNyLNS7/62AQqGAxizJ3eVu/XNqCkBX1Q1V99b9/vD9YoIDuOA7N0cJ+OvEQ1KNCVZmTPOnm73XjxfHtnPJiMVoZhF0C3xJvJxasL+7C0Z7wuAkgB/72CC67BcrZTglZdVEvgSDwQA/iN8M8GKTsG0+pwMGu0MwQLMNGOmxuWKRegrQOpLvxXJRqBJpt8tmhemBGIz0hilYB6FCwNddMGDr8EhMi1hfYWGd7hoigL8/SsMC8A9V0h+31jZhJ3kiemAwcipG4VIMecZN5A1iMlZ4rnu/dNK9m08+8mTiZjZgcT993j30rXtDk1dF9ld5gQeNhH9MqVhUxs6D4m8sefZbuappvlR7+/ofRctRJ+OTAO2vZTMZ5DbADlTGrClfZu3S9hlVmxZzfx30T069ze/3/2sV6L+J7v0KS78WS67uRqeLLq9x6TB9Xysro81isXh7or2P3kaRtUT84G9UKU7VwEOtHO3E0tjk4k8Axx0+n//XQZHOtFwufXf21o2/AJ3MT5dXiKj4NbTGoRpgN6xPCKi29cb6Xw+K57ydFPL567s729eh7m1zlov/WaBfcwzaHQ7XubGJD5M1aK+ieJ6U/7dkDH4aOnfv10H/a1B04E+kXOVlhPunf/on7MXp83ygK8jmclngqhxUKmXeZDIxlUqlweWfABZOZHOn29t673v6vy1/uZ9jwLF3fArXVjaoFb5RpMzv5I1crQJG3iNgRIDIKP4uHycOw2jAD3Pbu9TdX/qr026Rj5VgNFqAH50eh29dm6FmYQJMB6f9IxkjsFhnCuCuHy13Cdidh7u6xuMmxsAtpDb8W4eH1u3kMSwSEN7lcULQ7QaH1QouuxXcGGtOQDCCR1RE1O312soBCv5dHvp5j4B/DEmYj+9T8G9glRxyPPUw2IgnBOs36V4DMMYa8Bao55Jn8lzJniicdJkIcEXAP9QTQkwMC7tCn2BbyFVzD3ZfwJgmMyiI3RBYPpec779xsjqRKmf9CNjNmBVAVCLgFusKUMCOYQ9o2UfLeb0twqVWtg/gKJNR3EmhDQjokdxwMNwFse4gOG0WAcCTS6CF/ZmllXoIhUgW4LJa4L6Jc/S+ImAHIX5f2YO0hJ34ESkzK/IM8LRVkwTsXxoeoL8JnAbCtnd4DEs7+2AizxSmhOzyuKDL5QIHqQ/2bblcgXy5DEWyz5ZKcJTKQCqXx/yJrixXfMuTR7fe/MzR3Nq4p+8/viVy92NQj/uXWf4tVitj2txgPUPDPLr7ezxehuM4pspV2VoNs16yhkqFBjyQlxRvIn1rJmVT6z75u0X8bMPoiXAkMupwONUDRFMI4Eaimq9D44JWbe3XIsrphCG3yb1/8vz0P/L6fP9KFdP/wuL87PtIu49BB/266KJLC9EAHO2ynKgZxOl+cGjkYaPR5Oq0zEKhMLO5sfYkCNZ+9RypFdcP0DnoV7oX94cjPR8U53IqHFddWFyY+30yRxahszlRBxy6vFSiReqslWLYCqqxSED/HVarNdJJIWgw2d7eVPIPaRknbjfERmnxF3k1zJaJyenfJphkXFl+uVT6/uzMjf8kGm4qGuXrDP66UNGBPwiWfukzeWFT++lR8hAHBw5EOkAqgpt/Q7w/L6RUkzcrayq8OXr3M1/ZevoNBgNLXf7dNhsBqd2a5VqMBtg6OQa/0wlOReo7pUjG9UiXD+wWMxQrVflv6IKuPE76P0pA7LloGDC9IMfUzI8fXO99Q/gy+qczFeBMp6WM2Wa2UXXB1cOF0EPhC7vvPffTCyvpXdeN42XfVj7u2U4eGfZPUgJPgQhgEeC6SHsCbif1CAh53RAO+AiQZxqAsiQIxiNuN/20c5qi5S0kDmC8OyyQEop1RqVHjasJ5HSsAfLVst3KGpWLA+bK4dyQyWimJyE4x5SJCNiR9I4qQ8jnS/7RNYMA1GQEfVg6dX9958qlZCUdQnJDg5hqUQplmIz1wvmBXrCZzbKSRastyVQa1uIJyJfKMjkhgm6HzUz5FfA64YBHsMqLGQsR7P9gZkH0EBDOwewFg5FueGRqQo7BV3RYw51HpdC1tQ2qKEHFSY/fCw9OjqEpqO4HIZ6DgB4VFPdPniN1soHHYaMKEkaMgZC8GXiq7hA8AVBBgNwIi9t7sHqQgFNUAgA//MLhwh++sf/OtxnK7B40pvZDaz9fCgRqIMb4a8T642Yk7ZRfYqQsaZFrJZ/xQTeTe2bt6el9WHHtdoJkOV8gZZMHsomoqpUVC+BFLGrx+PPTF3/W4/H+GjSm7Ht2fnbm/S3Y+3XQr4suuqhFax7SynKitvhbfT5/zOcPdER4iiLkDF//HwrQofSKkuamdqCjI0u/2+P1ie7FMrs5X6sdbm6sfziTludGLTI/HXDo8pKKRjaNdik01ePQYjab3eFI5KFOy8tmMo8nDxOYSvt24vpbEU5rufcb0aAyNX3x1y0WSwPRIFmfXJ+fu/Wpcrmch9brE53BXxcqOvBXCT78iglDfjkRwMhzXEMctJLsT95GnbHd8/791YXU1ggCth/ML0LA65Lj8ZWCACzq8cIGAf9ZAjzDLo/SAV6ugPCBh5FwGGa3dymydBLwh8z+QpWk4wU0iEDzgfOjsH14BGUy3G+drgbvD06e2gzW6szJmtdisjDSlQnYZp5KzEQPC8e2fxR7cGvY1YNugsxO+dj/7a1nw/HCkRWPx/hxFASY+eQxdSevbdSoe3o3xrOHuykgt1nMDSkLEPPWLf9pKBOgOXewDxME/KOlX2pjyOuhlm2bycYsnG4ELvlHKlC32jOr2d1egfwOqBs+tnFl90AE4TwYeLb0UOgCAlWL1BFXj5Z6n0hcm0K6PcGbQPCgQIv+JYyL74vKYJ9vMeUJrPwszG7uQKZYEjMwCCDa67TRdo/39VDru1RbwdiPvAVpQA8KwUuDp7wMD4yPwmish35ufBZU2RTIx/2jEzhKZ8ButcAj4xPQ191Fwbx8txWXwL4MkftgFHkUBE8ARj5I9szghU/oXYA6B1S0TPb30h57YXWDakNYA2vazhw6ByzaCitoqKW8b8dIq9amWyM90fNWm60jTXqlXN7a3Fh7HNqn73sxoN+o2FOyqqnpS+9xud3vhXqYCHr8PDE3e+sjuWwWFQ8visgPr6O/WHXR5dUvHQAOpZWxyc2fzEP2/sGhN5J9p+sz9L765lHycB0aXYyVc6SWR5QW0WDLuH4CNmxjYxMfIGuhfrlgni8mEvGPHezvbUJ9LjwrbZ8OOHR5qeSsUJuWsf39A0P3GY0mdyeFIP/QxvoqcmtorVGkMdAqrXSrmP4GMj+cD85PX/hFm93+FsU1MHXg+vLSwkdyuVwaWqfta5dJQx+DrzHRgb+2qHPaaeUzV7/I5EH11vA986fVfCieP3Kj1fd7N+fg3Q/cLYM2SaiqjwCvAX8ANo+PqPW/z+uX09uB6mhM7Yes/Qjuwn6vTP6mBP3SHoHlPaPD8MTcIgJXw7PJheCj4TuSN46Xgwj90BUcrfg5AmYJMGWWM3uBv9v8PvxM3yOosaz1mv3JXx5523GOK1rnT9Y9K9k931b2wG42WsTsg4JrutHAEMCeg2RqFa4srEDA5YSwzwshjxsiQZ9MFIgx/7jfJ+AfueLn43EY7+4GEysQ0g10hyjwx6avZHZ7CPA/FfsV9gpHznQ570JFCnoXxAgAxovNI8meeJfOe/t3WcHaT93Tnzyc6X8mMTOMZIu86NKPLvjnY70U8NdET4azHgNUGKztHsDO0bHc31iPqN8HF0f6BYWObFWvPyV4zDOLy3SP9x35E143NQ4Wk4la7xkxE0L9pEbDN4Yx3FrfhumBPrjj3AD1kKhJQf58o5kE24bhIox0XxTXEqrMCGECijIZxbnIP7B5mJSvaWSMi4PW8A5fJwhQPv/ND6a2S31LQj+ycLSHI9GHoENrfzx+8PlqVSbL6WRBK9VFK25O05KFsQlTFy79c6fT9c+g7jHCl8vlb8/euvGJQiGfBR3066KLLp3J7aYOk9z8rdFobMpud/R1WhAS+q2tLEk5wztl8dfiPWmZ0hRT1UxOXfhNk9l8WVE0l06l/nh1Zek56Cxtnz4v6vKSSJvY/o74hxwOZzDQ1XVXh8Xxp6cn/5DJpONwNq+Gsl6dZNCQOYcmzk+/y+Vyv0dxDVQ4JDY31j5wcnwch868EJX4RR+Dr1HRgX/HwqgBfwML+lopce6pvev3FqsVp91oMVSZmkkgagNI5QqwshuHwUhQzH6nBH08dQkfDHTBSvIQ1o6TMBAIKJhE6ugQieOcVisUKmUKrGu8lGENNPeY7u7phWUKPG+crPpirnD1uJSxsAYjDHYH4dLIAHzr+VuwdyxYpTdzCf+14+XUHf5zh+JFeIfBWr6ra+KEbNkcV7I9kbzVvXC6aWWU9eMFgj5k5T/J5+mGfARo/b97ZBC6A17K6I+Wf6zLYTYjxvwfUMu/yWCAib4eeG55lYYTbOUPAslS2tdlcSPY458/WogZjJQyH0Z6BBK8+HEaUnn8MwvVWqV2T2gaydZw8ma+sPn48EY+3m00Ghkpb8A9oyME8EfIJQTiPMkFvpXw4h8xHv7q8rr8q91khssEiKO7Pi+58GtkjN+OJ+E4m6Mg/E7SB0jgx/Eq/NymfMykNz3YB0GvoHBWYP7mJ1NK66C4+9IbRuJykLInyAoHELgJkBPgqfklKXyBZzh+8519D31Q5K5ox0SvtmppseSqF7d03xvru2ixWIKdjLpSsbiws72JC8uzFrTKkAQtrb765SqDfoPRaJq+cOlfksX2u5VdWCoVv3TrxvU/KJdLBWjN3K8zVeuiiy5UOiT0k+bGBvd+3BNg7Y5Eex+5jSL5w0T8M8ViERXlt5u6ryOlKHpCnZ+68As2G7U0yuXm87lPz83e/AK0Voi2Av1U9HlRlx+zvCjQj9/7BgYfYlmDtZNCuGo1ubG2gvxDt5u6Tyu7R5OlH48bG598k9fr+xegCGMla7TU3u72Bw7299ahMaZfvU7RWp9Q0cfga1M6Yqp8jUpDHBrHVdULehn07xaT3i+uffcXDkup8Uy10JsopSLHxbSNF02z5M0JTxNwdXiaJsiKqV+dSt0+O9wVpGz8S4kEAYk1aDyQp2CwN+gHzLwW8gus+eIlmgVZ3snxE709FBlyUGO/u3c1gHH0CFi7vR4Kvt90eQo8DrsADVmGeSJxLVaqVZQ5g2l7N/Nx+2fWvhOeO1qzMo32ZuEALK/K0WtbzSYCWDE1oIsSARpEN3u0WEc9HuhyOOlZqARYJOBfcnu/c2SInm9gDcxjB8/HyE9W0g+O1fR2l0CUV4OxWA9t3MLuHmAKPuzOPmd32mnA8AWwfmvv6vB67iAsselh777t7ovCeTzT2Kqm263sPuHfY9dnaRuwryb7euHdD90NAxT0Q8usB9gGtPYjB8M7778TJgd76flSGTTGvu1jJ7TV47KJyh1e8Zfmx5NXfBd0SkyD4ogqZZSPCSOA/ivzq/DU3JJAEkguY2FML/zC0Jt/c8QZ3YUzFm31K7UkzNEE/QRjO0Oh8APQmXD7+7ufq9VqCLxbEeVI9dByp9V6qTZo0s1ms+XipcvvU4H+WqGQ//SNay/8PgH9eTjbfa4GugudLrroUpd2MfRagEPMFz50v8lk8nRaSLFYmNtYX0VCPy0Wf+UcrqxXOzKxJmvj6PjkW1wu9y+C4hVC5sXvzd668WcKIrHbSt2nz4u6/LikDbGmllt9E/D3eL1Rr9c71WFx/NFR8kui4u2s8dcK9JuhTYjN8MjoA/5A12+CwlCLXB6J+MFHtzY3ZqD1+kRP26eLpugWf5Ugw/9TP/g+BLqCSGTGVKoVBonnMNa7Wq0qQb88qOaTG36GNZkkb2qnzQyFchWkPO3CBnBtZR3unxwFl92uwup1YDZCwP8iAf5oDcfPVmMdg+N1fAQ0U5I9qw2kmPd2luNzBPDeWN+ipHb5WlkOAO/p8lFiOQTdb73zInzm8aeFRO2kIU8mbnW/IXwZcwcyZb5q/ub+1dhyatuDFn2D0UC9FiTFBJIXdvs90E0AfcDjounpMBQBSexky3oD4OUh5vXRuh8XClAle2wruv1PD8ZgZW8PMoUyeh94t/IJ33ExZWAMQox+mJTjdQghCluJJAWsWM60dwRjry0vHC/5ZlJr3axBgL2Y4eCn7r5ECQnP6CZo0J7wVAkCX796HY6yWdJGKzx6YZKS+NWz4/GNigTpVBrbn4K+YBfcPTYi/EgdMxqvjwoeyoJHQyEY8c9imAaGExhY2kcSN4HkGYLfURlQ5qrkWeXoPayS7xIhIT6nWEf0isBreC02msKvDvoFIsVv35iDA1JP7EOO/OAx2b/9K6Pv+PdsjUGOhyaLDVmMIsFlK9Z85UKSvrxIPS1I5Ef2NpHQj4L/3ljfHSaz2QcdSCGfv7G/tzsL2gzVypfY7TD4y65zNoL2z09d+BDB/g8oHgAul83++a2b1/6C9KGyzIqqfN2NVRdddJHlDGu/NCe1BP1OpytE1h2duhfj+6GyvbX5P0VCv1bWfjWDfzsysSZr/+DQyJ1+f+A3QMF5QtZBcwvzs/+GvA8kT6iz8oTrZH66vNSitT5Rp/JVp9Kkn/v6Bl/HMGxH2KhSKW9vrK9+D1pb+7W4h9SekS0NE/2DQ5dC3eHfJusoc71UvnJ8fPR/ra4sPQP1cdcJmZ8O+nWhogN/oGCfNRuZGoJ+ZPjHF/hR8lAJ8lmL1Upj2jmOwCwiZCDyEqv/nd0TWzeXV4oGg8mKwGyir5eARIHMr1iqkOtX4ZgASD8BjpgeTwJ0WoJA7FwwSPPeLx4mYNAfAI/FKlP+dfvd1N0fQR1a2FuJ5P2NQBld7stVcQ5Csj2/T4gXFyETAuTLwwNwbXWDnjd/uh58Y+SuRAUqpi/uPjWym4pbEUwL5Hg8BNwuGAwHqRs6WvetJjONQZcI6jgCzHmQQKsUc87Xzalki/n9AMfHcJTPQVn0chgPh+Gtd98Bn3/iWRqz/rWdp6JGMv+ylAegBuPRHrrHsAlq0EeSQ5OtNOnpL23lE94n4td7kK8Ay0DW/7ffc4n0la2ljzz1OkAPA6bR8QXb+p3rs5BMZeCec8MwOdALgvKn3rc8aN8/bCv2CxIeagsv3meGPk88I/WORMLH0/j+CgHyBUy9RwA+3mdM/Vgk/YqAn3oPMEDrLT1H+L/DbAY72eie3BMMoaAKGlEBg2XuHB7BE7ML1KMATy1XK7VBd+Rvf67v0b/iazzGsWuR0tTEVJZyL1ptNgbT95HBYCB/Y01EyH03kQPM5Ddk8qekOZjOD+osua5gqPu+TsYkhhrs7m4jWU6J3NMyKUutRb9dMj/lS5/1eLy+0fHJj5NqX6hfg6+k0+k/nrl5/TOgvaBttbDVQb8uuugiiZYnlNrKqHbztw4MDr+ezHXmTgvJZNLfO0zEl6E5xemLietXz5VsT7R3KByJfECZto/Mw/sE6Hwom8moGfzb5QnXyfx0eUnkjDSaSuWbprU/0BUccLpcox0WxycE/iFcN3Xq4q/l/aMJ+qO9fWM9PVFMm2lTlMmlTk//eHF+9pvQ3rVfuemKN10aRAf+QNP51Vr8SfazLxWLDYNJjIGmlj+fyXE06Ip8cyMb/2kCUpnlvX14xz13CHnZeQkOK6KvVUOPAj8FOEXCu9FQiFr+V4+S0OP2QNjlosDTbbPD66bHCBisqQjepBTxIuAW/4hKh2iXH9YPDmXLcSTgk4kGpeOmBvoocz0qCMpQM187WvR7bS5+N5uwMoZ6fDheGzMGuAmgVoLOeht5kdqAaSCZU4aEC4z0PPT5/PS843yegNoKrCYPabjDPeeG4OnFZTKTckYEvniG1WSCAeRIIP+WSP8KOe95uOQdyabLOftXdp4MU/p9EIj1Xn9hUgD9yi4XG4vAWfJYoKDfoOhH8m92fYeGJ/z8ow8K5Hxc4+OhpFFs+hEE5Y3W/Co9CQbSnwayx74ulCtQIPeoXCEgvyoAe0zZiAoJ1GGwKgURXgF/x/SPNosJrEYB6FuNxqZHq8bz8rOFHgZPzi7BZjxBFSm0NlytfKlr5L+8qfuub5D7gS7t0gJSK/dzw0usWCgobywF/yAwz2qR+tGtN9Z/JwHaHbHk5vO558hLdQnrROqmXtAqX2DtWLOVC1vZ0t8VDIWHR0Y/ZTAYRurjhy+enhx/an5u5uvQOmZVB/266KJLk2hY+7XmJC0rI926ukJDbo+nU8CByvXU+urK56CR0E/LIwpa1Kete78/0NUd6xv4GHnPyhpsMkem9/d2PkTm5R1oPT/q7OG6vNxyFrGmVrYh9E5E/qHXMQzTUQh0qVRc2trceBa0Xfw74dVoBfqN3eFIf6yv/3dJVZTrJT6TSf/57MzNv4NmC3+rMBslkZ8+BnWhogP/s6UVk7/k7ksH27tjj37tz5e/NJnnyyOnuQJ87oln4Q2XzkOXy6mIwRbHv8y+DgBSvDffWKDJYITRLgL+D+Own05BsVyGwUCAFux3OhUWYqlyNZqeDUFho0cBAwFy/DpzSIEvuoCjIqCpkQQI3zE8AM8sLFOwefVoMfTPR9++hSkMjQSp1p3QGUoIeGmgH0Zi3cKvDdMIo6hTG9p2XujEfr+flneYy0KmWIT9kxMY6+uhaQuz5Duej67t6JGA5WRLRTjJ5GjoAvm5dsE/UvnM2re7y7Wq/CxfHOqDsN9HCxHqxtDwBvyYLRcp2HZazGBijRTYK2F8vlyiFvvzg720Pxtbpgb99RZKfA6SZR37Cfu6UK0QQF+FCieEfiCDfp78hhZ8FJYR2fgVfYj3EDu8JiqN7CYTAfcW6rnhInvMDEAbz9cVSsrz6/UT6oIEfs8tr1FPDAH04yPCHz/cc+k/X/aMXiXfC+KmTAOlxUir7o5WL9UmJn+zxeImgPse6EAwbnRne4ta+6E9mZ/0gm4X2y+7reLWE40N9/UPfIpl2YiivHTyMPHh5aWFJ6G1lV8n8tNFF13OkrMI/ZqsjGjRi/X3Pwqdcy7xx0fJL+Ry2SS0jytWW/vbhUDJoN/pdLlHzo19lLxjFelW+dJR8vCTmxvrM9Ca6FRLGaqzh+vykkiH1v6WKYaDoe4Rh8M50GFxtYP9vc+jwQAax4KWR2KruH4l4Jc2NEz0DAwOf4ysUQKK8vh8LvfpmZvX/xIaLf3K9ZGeOlOXjkQH/q1FScGuBv8S6Jc2Mvj4wv8y/Ma//Oz6Y/86VykEipUKfPXKNZjsi8Ll0UHZpF+3krfPZIbAz2I0wlioGxbjcTgpFqCcSMC5YEgOF1danQUrNg9mJLwDAfyDGF+PQP/Z5VUxtRxAl9tJQGAzjhvr7YGrCBDJQalKzhbPJW1vjFyOP52Y86fKWbPFaKagFJnu0SJ/a2sLzvf1wkAkRL0UgKm3SoLDraC/1A9YTbT8GwkAPshmyJYFm9UKj1yYgK8+8wLNa+e0WuBcNEKt1ut7CdoOGnJgdXOfXvtWIMMVTLRHydQa9rihPxyUPS2kW4jFnRbykCuVCOi3In2yIj1eTa6pw2wFO9kE0F9nw687+Nc5GxB4ozs+gvsyuuFXqpQIkH6vctSrgKWKAFapHqAiKBwEEcINGOqej/fcbDSQvYl+p5Z8kJj5xeNpOkCxZ+XXi/hsMcK9Pzg5ha14Elb345QHQLozBPxzYWvgiXfE7v+0x2THFDB5cUPgr+UuqnYVY05TaYPXQxXRTYtJ0cW/6cUai/XfZTQaXZ0MvFw28xRZZG5C44utnRZdy31V2kv1YweGhi9Gwj0fY1hW5hjga7XD/f29922sr96Eztz7ddCviy66yNIitl8LbGi6+WP6PpvNHu20vEq5vLW2uvwtqFv7W5GeAtxeXL/BbLZYxyfPf4DM1UrvAy6VSv3HpcX570Oza/FZ4U9U9LlRl5dIbsfaL49FtPaTcdhpimEoFAq39nZ3bkGj4k3LxV89/pSeP+oxiJ426I34iUalG/DFQuELt25e+5MWZJqdhCDqY1AXWXTgryE4QBTaQxQta7/S4k814B7WfvSegdf/xdf2rrz3IHfkR4K4he092Dk8hvsmRqiLfd0yq7Sht55rLAbB7R9j/rMEZC7ED2Csu7sB9OM1ENxhmr+a0UQJAQUmdwEsuhxW8NhtkCmWIOhztcxfjwB0nID/2a1dCkxvnqx63x69P3HJdy5fgZrpbzce6z4snZipJZm0LVcqw5WlVXL8Dpzr6YGhSJBmCKiIfAJ1Sj+1rbwx6RyWG/F66NS4n0rDxlESJiMRuDQ0AC+sbcB0f4yCaIzb30wcipfh4aiYklnrEOzaLBa4ODwADrJXtzGHAJ1sGAPvs9llsE3PlUzuIicBBevIVUB+klzvi6RvEdTjhhb8QqUCVZ6joN4gA25FwDleA5UhouUeVQtmUn+Mu7eR+2M2GSgJosMk3C/8vUY9FPiGrpJT8Ym/NSbtEz5SosRMBg5PMrB5mITEaYqewyqUTBaDCQZ90dlha/jLI44oWm0wLg3zIWqBfi1yGLlHQ6EglEulTl6q9MVqtlhcga7g3Z2MPdSgb21tfgmaQb8WO67afU4N/CVLPzs6NvE6UgeMV7XLz3uttrW9tfnbuztby9De0q+Dfl100aVJzmAQPzN1mMFodIZ7og/dRpG1/f29v+E4DuduCXC0IxTTYjPXtPQbDEbT+emLv0nAv3Ku5nO53F/Pzdz8HLR3LVZ6h+lEYrq8pPIirP0Nbv7hSM+4zW7v7aQsDPPd293+O5FUsx2vhjIMUWv8NaTs83p9XedGxz5OBqKyHphW+JsE9P8/ZMwrPTLVln49xEaXjkUH/mfLWa7+DeDfbbDHf7b/0b/+zsHVdy4ebkQJujMhIP/ujTmIBf1w+dwgjT3nRf/+syzj+DsCQ8nyj/HgcwcHMBoMUbBYP52HCjLpV3lK1meQU8YJLuchnwcy+wno8fmoRb+VsmG8LwozG9s0XH4tu+cgQMlIJjgmVcoY97OHJrI2oGEBrGixxuvkimW4vrYOL6ysgtVihv5QF0yQ63gdDlq21I7GfWObsT8iLi8F0runp7BA2nphsJcC/eEeQdGRKRTgKJ2lxIbCpQTrNm7oeXB5dEBIZKdSrpS5CpzkcuC2W8FptlJrvZH8hxkFkAMB+7QkkuiVxc8I7CWmfAHYS60V2QzIb2aR+JVi9ZqgOEDlBFrpLQTUI7g30e8mCvapp4IcfiBmBRC7AMtShn8oHesZsa3ajyZD78XB0SlcXVoXsi6IHgaYMcBpsCZCVt/qQ7FLz7tr1kXSV8janxU3ydrfynKkfpEJ1eH5TtNU0c+xWP/dRrLA7WSwZTOZJ09Pjnehfeq+VnH9StBvADEH9cT56Xd6vd5fJ6fIxFkcV51fW135rcNEfB/aL2alBa20oNZfqrroootS1ASj7ebGhtj+vr6Bu8xms7/Tggr5/PWd7c0XoJnFX2uubuUN1WTpx3ny/PSFX7bZbG9RnI/cRl+buXlNK21fK6WoTiSmy8slnVj71dxDVrJ+skUi0QehU2t/Pv98/GB/AdqnGFaGIbZLLUz/5vZ4/Ug2bDAYB5RllculJ2Zu3fh9MYOGFplfKy4mPcRGl5aiA3+FIKO/xOz/wEOPwPbWJtk2wG53MBwB1eQl2JTKD5rBf8VUY47fFrr7i490XQx/f/+FO5ayO0MESBt3jk5g9/AEBsJBCrAD1OVeYubXAP+yuz5NgC4T/qHVee5gH86R7+gOjocgYEagV+EwfrxCXdkZXnBJ50XlAYLwsM+r3XjRwuywWihr/zEByvlyyZCp5q0uo7369Z1n/AaTiekL+mF6qA+Wdw5gcXtXsGqLAByVBZUKR1n3l8jfY11+GI9FoZecgx4JjcsAocCaaNXG2TFdKEHQ4aQu84fZLGweH8PDF8blsIC13UQd9IOQ1g6t+w9OjgqEhTKRIsh9gn2VL5XBSABxvlyGk1yBWuzRik/TGTKS5V8ysUshGQicGZA8EniRKI8CeZORuuKbyDXRio/u+VYC9BH0S34WNSEAvx6DT/5xYi5AGdwzynvO0/uF9Wlk+ZdCIupZEup2f+lvNZga7IP+SAienl2Cg9MU/VuF56DAlUz9rsisi7PMkXPT0Gjp1wL9WtprWhmrzWYoFgqM2WIxlstldeo8KY2fVUzjZyUn2Sxmi7vTFFWkHQUy3r5Czq1gqirQBv1aeXm1NgPK+emLv+R0uv4ZNKSjqlxZnJ/7UCp1egTtXftbxa3qoF8XXV7jorIytiMZ1QT9FovFE+ruvrfT8hB8b21tYMaREnTmYnwWmZ88V06cn34XmSf/CSgWIZVK+ZnZmRt/QNYoWmlNO/GG0udHXX7scpvW/qYUfmjtJ2ubSCdl4bpkZ2fr7+FsTxs1i79S4dYA+p0ul2dsfPKjRqNxRFkWjr+5mVufILgjB9pkfu0Ub1T08aeLlujAXyUI+qU9mVDob/l8TqnF07L4N4F/3GysOfO26H03Xs9X9h+P35xYSG0ECThmNhJJWIsnqPt9byBAQKsX/G4ntdRLbPtUGKYOZEGIAR/vJuCfnIsVQKv4EDnfa7PTGHun2QLZEi9a9Otx9CxTJxD0ux0qa79YguimjmneYgE/HGWyYDabYSO9b62xPJOspC2oFHhkeoIef9/4CPT4vPDYrTnSKazook4AL4JlUeGAio6twySYTSboIcA86HaB0yakM8QwgXyxRMn00vkCnObylLQOFRxvujwtpKwjlXLa7CAAcRb2T09AAuhhnxsuDPZD2O+l16Pu92L6u3K5SrMEUHd8sS9Yhm0MrsB0eAZG8BAA0R2fF1LpobXehnUxm2i/Uou9ySR7WPCigkG6N1KGAPyFU9w/uZ95+XYK1n4F8SJPyxU4BvDe43fsZ/wNv+OeYernSHH9csy/4la6rFa4b+IcvLC8DtvJY9qyUq3qe/zg2ruGXT3XLGDEF4i0SWR+LUG/3e7AZ1/J5E+TCmQzGdxLVvWGxa2Yvk/am3pjfXd1au3PpNM/OD09QQu80n1OHddvUOzV1n7Z0k+eXcvU9KV/RV7o71D0El8ulb45N3vrU6RdWWhv6T/TkqW/VHXR5TUvrayMUgq/ptAnaesbGLrPYDA6Oi2IzI+PHSUP16GRxV/NxdIKdGgCfhDCoB71er2/CgpywWq1OrM4P/fRYh10tCIS00G/Lq8EaZdRo1UYogWt/WHB2t+R5HLZK8nDBI7BVkq3VoYJTdBvdzhcE5NTHzGZTOPKciqVyvPzszO/S9YpKTibzE9znaKPP11aiQ78OxMtgr9OFAD0u9VgLjwQOr816R/M3Uyt9Kyn9i0IRDOFIizs7MH89i7NW9/lcUGsKwB93UEwGtmmhHgoaMmXLP8I6NeOkhDzEVDtcBGQCuC0WKCmRoRiExB0S4R/za734q/k7x6nXcwOAJCopCyb2X3qVoCs/3LEPpLydXfBHbkBuLG+CQ7WWnx95PLyaTnN7OQOXfuFo1CRK9tYApaRzX4rkYTtxFE99l62dtdJ64olAtYLJZhZ34bzA71COAEF1YK7fvw4BW67XeZLQGC8dXQEyXwecxpQBYTMfSB60RvE1Hr0xomx9ibSFuxHBPNGMe4eCfVo7L3BCIIngqQQqXtd1Pg63JdSEuarZUiR8itcjd5DiwmVBhaqxDHKLAsAyjwOvOzmL/yNFbPH8ORRQjK+lb0DqvjAtoY8buj2eSHodcmEgox4nqSskSMHyA7v8YNTY3BzbRPmtvboYQWu3HUlMRd5OHQB0+NJMf1SfJr0MmlihSUvHfmxUDws7RhqG0j9CPhGa/+dnQywWq1W2Nra+CpoZxSQypas9gZotvbLJH4Op5O8TKc/SMq/X1H3WqFQ+MzMzev/oVIpF6C9pb+V65zUH/qiVhddXsOiYWVUk/qp3XobQL/d7ggEAl2XOy2vhun71lbQ0qh28W9lbezIxX9waPhOMkf/H+QUeS3Icdza6vLi+9Pp1DG0D4HSY4p1eVnlh4jtF6390Umr1RrupCxMK7zTzD90Fq+GWvFQB/12h3Py/IUPmUzmaWU51Wr11sL87Aez2cwJdB7Tr4N+XToWHfi3EZHkDz8qA9PV7P5ql395e+F4MTp/unUpUTqJVLiqkRLBIbmb2SxYd0HIr86LaBgt1hwvuJk3eIFLIqI8yfK/FE9QoL59ckpBabfTTc5jwcQySqOycA4p89JQPwWn7UKZqDs7Aa0IutH6f+tk1UYbTIDoUE+3EMuuSCE3NRQjwH8L8rWidTeXsD4avmP+7sBEgdSrvJLe8ZD2Rw9Lxz1prugvVUtGlmcNLLrr8wILPy1TdHGn0Jj8bUOM63fbbSAheGTzH4mG4YHJUQHA1wTPBrT0Y5MIhKdhAAj0WUaIwTeQfjBI5HvkGEylh1Zxr81GwyIEF35FbzAg9L8S6zJaN6GuJEFvgIrFInIC1CBfrkAFQTu+VxD8s4b68ZIaQORkQMFQBKneGDow2d9L+3lpexeur23D3jG5t6vrtCwM00DFUKw7QI9FhYXBYKTlCsoEnuoT4uSc40wWpJtkNVgO7wqNY1xoOwb/lmR+ioa3ip1TLm7lrTfWf7lTJv9sJv1EOpVKwNlx/VrWfuk76yer2JFzY58g5U4qLl8lL9E/w1Q4tVqtlcuc0r1fKx0O7U39haqLLrqI0i6muJ2bv6VvYPAB8o61dFgOf3xy9BVF+r52/CetrJ1KSz+dM6O9faME+HwI0wlKBZH58WBzY+13jo6SB3A2g786bR8VfY7U5SUWtbVfDfrbWPt77uu0ELKGePr4+GgLmo0TyvAaaa9m8W8YgxT0T134sNlsvkNZBgH9c0sLc+/PCEo3rfF3lou/vkbR5UzRgX8bUaTpoXH+ottzq/R+MvhPV3KWv1n/zi9kudIQS1AoQ8CfSczXHvS4qcs7WnPRpdtpt9I9zc2O7PxVVfJ4JQiVhzMDNqOZsvujuz+CyL1UigLeLodTdEVnGtK9mQhA9DhtBAwbtK8NdXCKoN9IgT8npOgjf8C4f8p0r6odgvZRAsiX9vbh+snKwN3ByQWHwVJCdvZhV/SUbCvYNwhcOb5mOSiddBVqZX+5VrEmssfu41ImUOCKtiJfsZZqJVuZq5oKBDzvJ0/B2++Q6fSCPjeci0UoWMd+xDABtNaPBEO05izbnM8eRbLc4znxTIp6WeTIuXaLmYZICEoCtqEveF6hOGnJuygS65ED3VYbeMjGUYVEjfY/EvkxWkoDhaeDxAeAwJ01MHIaRuQPuDA0QM43wPOra1RZhGfEU2mIn6bgmcUVqswQlEjotcDSdqPyoVQqU64FsWzearDu/cL4Wz5q58xS6j7JYnQWg79Sgy3ttTTpmi9Vk8ns6gp2yuRPrf3fAG1+gVagX1kPWq9IT3Sgr3/wk6RfYvVr88XU6ekfzM3e/DJov0Alchw9B64uuuhypnRg7W+XL9zidLlCPp9vutPyqtXKwfrqCqbvU8f1S8BDknYuzkrgwYa6w9FYX//HyXvCLZ3M12onuzvb7zvY39uAs8OgdMWoLi+rvMiMGvLWHY6MWa3WDmP7a8XtzQ1cQ5yldFOn7mtSvLUC/Vy1uri8tPC+09OTQ2gce1qky63CEHXR5UzRgb9CVCn8GkQE/WrLv2aKv7/ffvxn83x5WMrVHu3ywsXBAej2eYDjajRuW/ZFF4dqtaok+QNoxFtqEY5Ba/NkOExT/eF1t05OKHDsdjWn7DObjOCwWlVAtvHaUhQ5HmsiYLJUqbPLo8IC3dmFNIHQ4AJ/rofUYXsXgajpmfhM7xt77kSQiQsUKX68SurFEzha6LH40RSNPujWCUcMLQ0YxE/3LxwtDzyevDGKbXDRsIR6W71OBwXZ11c2aLrBKlel5Y9GI3D53ACZ2Y2yNV0iNJT93xnBQyDkcEPeXIZ0oQDFcgWybJF6T6ADAlUcSJ0mefiDRLyvdQ/q90f6lMrlIHGSgmjQTz0LeM2jpcAD4ROGFvBiPSViP6F7efLM9IHPYYfHbs4LnINirD8CfXzi8J5nikUp4QCw5CBk9S9VKjWnybobswe/+FO9933dwBnQZaxVTH9bchjQtmopLUctrP19dxiNJjd0IJlM5ul0KhVX1EfLgtUK+FNL/8Dg8IVIpOdjDMvKDNmkD1PJw8RHyMv0SWgE+q0IqpQKBx3066KLLq3kLGu/el6UwX9f/+BDDMOaOiyHT8Tjn69UKhlotvbfTuow2dLv8/m7BodGPsmybFAuhOdzBwf7H9ze2piH9mn7dEujLq8kaWftb0nqh+TD4Uj0/k4LyWC2odMTXLe2yqKhHn9q4N8e9HPcElmn/PbJ8VEC2sf0tyMc1tcpunQkr2ngrwH06fdAV5A5Sh42xMxZbTYWGc0Vx6rBvwz8K9WKSXII9xHA+pY7L9Lc9mWyKfnYFThTBoP1CHK18NQSjVHqLFOPZUfgOBHqhrn4AUWp6PaPv4edHkV8OYDP7RDi1xleBsWMlDauwaGAB5vFRME/QcdyzZB/QD6HVrquAwl4BNI+dHNfze8OvBHuvAJ1TSUuVqpQL8ko9leDdaLCc/zTyZk+iZQQ3dnrvPYCo/2V+RVY3N2nCgBK1kcOXt49gJW9ONw/dg5GeruhJpH3yeR3AoqXrO8Y8oAs/CUMEZDT9Cl0MI36GHXWPc37Iv3V53BA4jgFX7tyHXq7/DAa7YFwQFD2CEoJMYyjsQThe4MyRvgbehDEQgF41wN3wjeev0luR1kusd8R3jIyTIYlQJ/jqqkyWRhWoVYOWNw7Q+7o6ogruoyLOai79sug32AwVMiLpmI0mWpVTMPQAvR7PF42lTqVKqUVO6cV2281Go32rmDHTP7F7a3Nb4A2M7X0IuehWZsvxfmzY+OTj/oDXe8j99guXbdWq+3t7+2+f3NjbQa0Ab/S0l8D/WWqiy66nCG3Ye1Xpg6T3fzdHk+YzKuTnZZXKhWXyRz2NDSHZrWK61fyCzSBfofT6T43NvEx8g7oq5fCF8l652PrayvPQ/29fRbg0EG/Li+btBmHrWLr1db+czabraeTsmi2oU2Zf0iLTLOVi39DeE0b0L+yQkD/8fGRMrymFZGf5vjD6+hjUJdO5TUJ/FWAn4n1DbD/46/+P/49//Tn2fjBfo28BPH3et44hMs8r5xgqLDUpZplCPCSBiIdoI/23PXZL2w9PmViTQZkx59Z24bx/qhMVIeiHKHyyFUAVOl7TWZ95wXAz9RJ6mgdMDacAPrJcAQW43GokL/tnArgP+LyCK7xgKR/NpByyOO+wlVpjDi14PMKEjpysNVkpm700ryG1vWI3yvWTe34ILinh7we2Ign4aSY8pagYrWAKQ2NpGlS4yVrrjRB0mNunCx1ccDh4giGI91KCj168Pp+ghIhYp/TdqgA+5PzizSV4UR/r8iZwMgKFaXLPf6JFWPzpfR4yVQG8qUidLld4LLbG+5Da8Bfb7/8IKEHQixClT3fvTkLqwcJsJtNcGGwj/zeA+RRoaEAypR+grVeHU8g1RzvPQMumw1+9sF74JvP34BEOkMfzO38QfinYw89OegII8NsVrFR1n7SB0oSPyUhVJm8aOhLBEE/WYTy5DufzWb4QFcQlAovAvqVgFvWphNgbyYXsho4ziyx+NdqjBUzHWKkQk80dtFkMvs6GYuZTOZK6vQkDi3i+hkpZkEYf0rgT4Nozk9d+DmymP7fyOGyBY20Z3FjffV9ZCxvQ2sSv7NYqfWXqS666KIlnVj7LVpbLDbwIIMxXJ0Jt7e781ky90mcLEovrdtJ3UdBv9VqtU1OTn+IzN8TijIqpycn//fS4vz3QTueWO3WLAEe3b1Yl5db1GGIZ5H60Q2t/ZFI9AE4a3knSiadeYqshSSPRKXSTell0MraT8deW9C/vPhbR0dJzGakBvxneSXq6xRdXpR0+gJ61YiWpjCdOoWBgQEml6WEaEqXHXlC4arVphgi9F7n+Zpaw2j0m12FtexeqFAr9SNQ3U4eUTdsZKLnG3zw60BasvoyoACcorW6ynOQLSN7fAFypRLNR1/CtHXVqpC6jwBKjMkPOJxwnM9TwJhGF3Dyu9siuZzzDdZsjucoCDYwLCgYAegB+NvqQZym3ONFhvt7xkZE7/466Fd+T+dycHCaRg4BxsFYVyP2gEROonZLVMch0v1349cu57mSAzkOHr04ARaTWT48mcrCd2/MUuI/FFSE2A2WtAGYKukHE0WApM47R8fUoh8QvRMEU73S5V9qotjXIhEgfrm+ug7PL2/A4Uma4nCfywlnvxe0iQAcNguNs8d4fLT27ySP4cbKBk1ZaEROAIe9rtRgpMdQmeWAAabxSaC7kZ4wnGRz9Dq4eFxJ7fSe9w8/bWYMaJaXQT80MverWaCV7v1cqVTkyuUyfYEU8nn1w6mZlqZWq5kZsoEYooFNJs3AtFQOg8HgGhkZfafBaLTDGYJ5qddWl/57sVg8hrpniFZqKmUdROWDyXzh0h2/5nS5f0nJSF2pVJ5ZWpj7raPk4YF4PUlLfxYjrv4y1UUXXVqKYu1wViyxTdxwTnRKm8fjjfX29b+ZYSRa2/aSz+deWFla/CI0ErJqgY9WZGJSvQwmk8kyfeGO95ktlgcURdQy6fR/np258TlojiduFVOsh0Hp8rLLL//yL6vX6OpxiEYkeX0C9bHoCHWHx7vDkY6AP1nrFFdWFv9LqVSS1ijS+FAr3lqRaRocDqeLgP6PtLD0/5+3Cfr1tMK6/NDymrH4q638ik3+brFa2VKxqDxGfawShNDvBNiztVpNTfJXeVfsoc//t6WvXACDwYtA+ubGFgXTl0cGoT/cRWPOlZZlgfetmWgPKestrIla9YvGMnVRL3MclCtVkUSuQo9mTRYa+30+EoGleBzylQrsnpzSSoZFy79UECMC4RpTA/RVwDz0FoNJ/ivQBtYDDqwmEyWrq9WqEp294khBkIGfeiXg1alVu9E7AuqTZFNO9Hjp2J3InwQxPh35ELwOB3Bi9gAEuV+/el1WglS4Sm3KO/zC23rveR5z+O0UD0PPJham17N7I6SO7NPzy2C1mCAW6lLcRMmVvs5LoKyY02qBByfH4DvXZ+Hg9JRuTy+uwFAkBGO9ERrmwHEya4CqSY3NFC7PwvRADLKFIg1FoPeY3JvtwyRsJg6psqE/FIRzkW7wuZ2UaBDvgyIAQ/UIiqWR4t5w8Tw8O78C87t7UGN531c2H3/0PYNv+u+gDfqVZFBNoB9aE8O0eubpwhLjU3m+phnbH+mJTpLFZVcnYzKbzbxwenJyAI0vNIC6t41WihzGZrfbJ89feJ/FYnlE0Ul8qVT88tzMrT8sFGgewk6Y+7X6QH+Z6qKLLq3kdmP769b+vv4HOrX2k3d7ZXtrEwF5OxZ/aZ5UWzkb2PtZg8E0NX3pX5L1zSOKImr5XO6vZm5d/zQ0A/5OXfz1eVKXl1yUpNugrYRrFdtPrf09Pb0dW/uzmfSTYrahVpmGGrwhFeXT7y6X2zs+OfURk8k0pbwuAf3LBPS3s/RrKd50pZsuPxJ5TVj8W8QDKd10JKu+2l1IGUusZhKnn8kLWjnYZQs2Aeucx+zaWjndvkCQngUt0pUaB1vxJKwQMOiwWMDvdshu6XLtpIqK5HkSxEawiDH66KLuMJsJWLVSAjl04TexBoGdXjw66HJCqlCggD5FwCdasN02q8BWL2IpIQSAoXUqVio0rz0tVwT128kkZPIF4Ml3P7keEviRyYpayRus/qKXAnofYKw9V6vChdDoptvsyCGZH2gztDfEYP3D3tP352tlf42rwQMTo7RtAILy4UtXnqdKEhojUKtV3hC58yuvC124Sq6G1y67jY7TCU//qtlgSm1m9gcI9jdsJpIQcnvA5bBBozS6/EtMANgco8lIQT66/WeKJXrkSSYHC9t7sBk/pGkMsR8MNNRAan0zG4P0G143FvTTa6SohV7wVGDF/ktlc7C6n4Cb65uwuLMP+UIJY8nA6xAyDUhhGbLnhyhIQuj3uGBuc5f+fFLORvtdke+5jXaJtV9i7m+V71mZrq6Vu6aW65wct4qREiC8SB3KjbTLMXJu/J2dpPAjz311Y231rwhIP4Jmwhy5uaoxyPr8geDExNSnzGbzvYobyuVy2T+/ef3avy+XSwXoPPe0Dvp10UWXM+WHtfa70dof69zan81mHt9YX/0ONGZikeYztYt/SzI/Up5x+sKlX3I4nD8LCiVpsVj44s0bL/wHVXpTrZhiHfTr8oqSDqz9EtBXWvvp1hUMDYcjPQ9Dp9b+5cX/WiqVkBy5E+/VBqWbx+MNjE+e/zgB/Q2cHpS9f3nxt4910K/LyySvGYs/NMcDqTV2LAEshmoVx1sDizg9x2AwsAh8oXmwG6DZsk0B1oSnbyXqDP7bb+xeecdm9uBuI2s0IHBDV/3vzy7AdQL6Lg32w0BPCHiOl+PRedmqXs/7zihqz/BMQ7x9/XPdsD3eHYalRAJy5RLsZdKQr5RhOBik4B/EdHMoR9kssIbGtQiWirnlpZkt6HYLoJWmlVNqJ+qKBATOeF3WYIS/X//+T1V5rtbvCi/84sCbMUaRq9e+DuLw+2kl7yR9M2AymGnWgd5gAKqCxwBcW1lHhnr6uVzl+DdGLn/xDt+5WWhMY4TXMd3lH7vhNjsyX9166l2kXpZvXLsOIz0RuG98RExh2ByPL98tSSFCfnvTndPwpSevwmm+QI/B+5XKF+EqqcuVxRUY6O6CqcE+muWAq9Wg1ftDIk68f/IcZK8WyPXycId/dM/KmHI3j5cj6VrBYWJN+FyRNlZpOsSl3X16bsDtpGSJZvS0IHWQUz1yNerqn0ilQSJ7NLBG09Xk/Fi096Fb0Ejip5Wur5MUMGpPGHXcnJHcT7U2nW6h7vA5q9Ua7mQw5nO5maOj5C40usypx2dDnSI90f6+/sFPqNP1pVOnfzg7c/NL0BzL3y5GTgf9uuiiy+1IO2u/5pwobX23Ye0ngCO/ub72BdBm8ZdEKwxLTebHTk5d+Bmn0/XzoAD95XLpuzM3r/8RWc+ovcE6VZDq86QuL4u0sfZ3MhbNPT2990Pn1v6n0mlq7VeOBYD6Olb5uWHz+fxBJNEkmGJYeU2CL+ZbsPe3Av16eI0uP3J51QN/DRd/FrQnDFa03je584NA7icle9fSNKoVAJIbccVtsCX/Sd+jn90uHD772P4Lbzssps4ZDQbKy58mgPL7Mwt0iwZ8EPJ4IBbyU5K5Ks0HDzIkkkj5GnPD14kAmy3PPIyGQrCaPKTx/qfFAswfHMBYd1hI/QasIkKdb7oAegTQ2YbUA8EuHsCCEqGp3NzJ8SajASrkeCMB/+QfGy+cTD6euHHP64IXfqCoYsME+fjBC9Mm1kwn0fFYDwW3KEgoeGN9S0izR6TP0XXtsv/cNajHbKtJAi2jzt5lJvbA331l+6mfIeDQsn6QgNW9OEyQ6070RcGF4QgaWJ1n6q3CmPxLQwPw+OyCUpVCBQkPdw6PYZtsEZ8Hzg/ERN4G9R2pi9Vihl5yDCpYCOAP/crwO568L3h+Ybdw5Fw4XQ+s5w6ix8W0z2qysIL3BA/HmRzZsmJURT00gQdQlIUKohoSMOxcCpx7ArSt/LJrv9lsrpXL5aYFXKxvgNne2tB6ibDkHAM5pxVxVNPiNhKJ3gedvVS5vb2d70JzHmipLPVDBoNDI5fC4ciHGZaVSQPJmDw5PIz/7srS4lOgDfhbKT2UL1N6Kf1FqgtKu5SuatGfmdeGdMjkr3bzl7yiLG6PN+Jye8Y7LI5Pp06/QwAHenB1krqvlYs/Oz5x/m0ej/e9oJhTK5XKc7MzNz9J5vU8tI7rbwc89Odel1eCaI3Ftgo4r8/f63A6hzq5OGYb2tra+Ba0dvFXfm7wTAwEusIjo2OfMBiMfcprEtB/a2lh7v2npyfIHt4p6Nc9bXT5kcurGvhrvLC1AL9suec4DhnLTQTsSozihmKRAFoTBeFsi2thaDmym6NbHRKfSS9l6WVJAUjMFtz+paG3/vV2PjF4NblwOcXlek/yaQ9jYI148O7xCeyR7YXVdVpI2OcGn9NJreDopu91O2gcvWSpl9n/ecGFvMoJ84I6gh2t/BtHR3CUz0GhWoGZvT2YCHdTAj+8BFqT8fy6V4GAtTiRfd5ltUG330Nj3Bul0ckBU+R5HHYam3/nuUHYSBxS0H3rePU+AvyvQGM8Il2kFLiSYz23P44F16o1OBetG4uvrwqgX2gfV3h77P5/gHrcuhr4m8Tv/DlX7/o/jr3uc1/aeeJdNWCc2E8LO/swv71HlSrT/X0QIqCdtk+ElcrsAXh8X7gLunfdcHCaUrSTl3sXd/snKdg9OoGg1wUXBvqhNxQQlDM8r7gmUE+OWDgIy/tx5GcwfmP3ytDPDbz+StQWSJNtgxzyTIYrWq8kZvr2CsmBVCkbzJbzdrMRvQGMQjAC5WPAhjKokEFGyZzT6Hi61x56/K299zxLXlJSjudWqV9QY0QfEKfTBQaDgSGLUcZut/Of/du/hYvT59VpoehGhgLyVxikZ7tUKtEFLRkjFonNX9oCXcE+m93e8KJrJYV8fjV5mNiCxsUsQzkaGdZYrVZqpAxekvGJqTf5/P7/HePzpGuQem3t7my/f3trYwEaAX8ry5WuPddFU1qldT1DeOk8/fl5TciLtfZbbye2v1bjMuvrq/iuaxXXrwV2lBZ/Cj4I8HjIHwj8K1Cs8QjwmCPA48Nk/s1A5zH9DV5h+rOuy8slCmt/K9Df1jAR7Y3d1+k4zKTTz6ZTKQTorUA/gIbxMBjqjg4Nn/s4WWNFlderVCrXyNj7YCp1KoU26qBfl5dNXtXAX5R2RGVN2nLycpTj9/E4gospkCfgqpXWn4IjEFygG1J4IJDhhSB+2QMgZg9txfpC6OZjK9TKvscOnr+0lNoeI0eZkQnewAogNJHKwmEqK1t5MQMbfjYRgI1p+KTsAKgIsJlN4HU6IORxw2AkRI8RSO0FEr/BQIDa9w8J+K+SaszFD2A82A1mI3IGGKFcq4pBBYz8TyAfBALiB0SivXqKQWCa18lo2T7f3ws9XX5ap2qVo1wG2UoBwbdJ9JgAUAD/Jw9vTAPL0LQDQZ8bLKQdqINAksLFnV3hyqSoqC141WWw44RJ89BDM/BXuv0bB12RvV8b/cef+cbus/es5nbGWMZoxuwKu0ensHt4CkEPchZEYCgaom7+9eR/gqC3w11jw/DVK9dBCrcQmq3sB8rsCEfpLHznxiy4rBa4ONwPg+FuRZQ/I4dKBNwuqthZy+5FN7IHrgFnWALrZZfBmn5T5C5s8BOkr7hUtWjfTO85koVjM6apS5Vz7gJXYh0mWzZo92zdG7wwy/I19PcvYo5ZRZ+0JGIql0q02pi2D7+LqfqUoF85XugzX66UmarAe0HHAoa7gMBr0bTA7emJ3t9h/Cp/cLD3OM/zMuhHxI/p+oSNoykb0dOEFMhOT138eafL9YvQuIC9vra6/MHkYWIf2lv5tRax+otUF1lUymE447PWs6IrAF7FchvWfnV8Md3cHm/YfRvW/pPj468TYK7MiKPFe8K0KJ/+NjA0fDkY7P4dcphZOonjuI3VlaXfIfP+MbSP6W+V5UT3itLllSJalnYl6G9Swrlc7pDb7R7t5OJkaVLa3tpEfg112kxlGGKTITEc6envHxj6GFkndSuvV6mUn52fnfkwWXshV4A07nTQr8vLJq9a4N+Cxb8VYZk0WTSk4VBsmlkAQFv7L7+IRbCrZCiXPAAoQLGx5szbe+5//m099y6vZ/bDW9l4JF458e5nk26eYQxIBEetxwT9Go31W1XhRK4P8ju6xpcKVRqTvp44hKvLa3BppB+GIgKwx2sgaO0n4B9d1fczKUS2MJc4gInuMD3GwpjocXig4PbOwyPTE7C0vQ8D4RAltpN8rmvA1P3NFZZt3Hf7vBT042cK4qU/CH2qBP7UNX85vTcmOUcMdYdkEr+Ng0Pg0MWCtK9SrXD3BqfRY0DtjqicBPHaSstu1Wow59/V99BzZb668szBzMhibrs/U867MaY+kcpAMp2BK0srBKiHYDwWocBcCjNA8TmcNERgdnuH1qPHFig4DNbySTlnNdnM5r2TBFOrcZQ/AOucK5fhyflluLm+BUME/GPmBkzbh32O3BBTAzGabtBisrKPxa9d/Beut28hczOoXC2R9M5tsGSnfYNVwE1UGEEd1JbJDVG687eKXVeK+rmVRB0l0vBcVysV9VgxQ/NL1UoWtmGnyz0MHUipVNw9ONhfAcViVlRiNSjoLFar5fzUhd+wWm1vVtQRFRjfmJ+b+b1cLpuB1hYrPV2fLm1FA/BrjZHmCKr6Xp3kgyoA9GfqVSmdMPlbtLZYrP/BTq2MXLV6vL6++m1ontvV2U7Uhgt5vRLr65+IRKIfJmXKzLa1Wu1ga3MdU5wqycRaZTzRjOvXn2tdXk5pY+3vKAyxN9Z3D2Yj6qSsTCbzfCp1iqE2yrGn5h5S1oHpjfVPkDI+xLKsX3Epvlwu/2Bu5ubH8/kcuo9K404ag52EI+prFV1+5PKqBf6iqIlA2rGAmlWb8oXaRPYHrScgNfGf9FlpDZUGNh3sLLClYVf0kGyYhgyTvDufP1rufjY5FyLAlVUloZe/IlAWU+eB1+Wgm8NkhqhodVeehuAq6vVgdkDYo+RwAPPxAxgLhsBmEuZDXry2FFs+0R+VQb9kweZB4B5AN3x14jmzQjlRKlfoNWxGU1VsvzKLgum55PxQkSt70bqL8fxDPYKlHK87v70rKCKIuI3OzQF7cBea3bW1qA2UQo8xM8bSw5FL6w/DpYPdQrLr+eRCdDW7G+AZgwHd/Zd392FpZx9cNitNsRf2ecDvdlLAPhwNwdZhErLFEuxnDk2/MflzWwaGrTImg8k25XQuH2zWnt29Yd/Mxj3AsMjDR44tw62NbZoNwGIyCtkXHDYaCoHXxHt2Ws6E59NbsXFXbEn9LEBzznmt37TcMFuFsyjBivKzxHaglcbvrBQ5jdb+3tjdyB7dyYBMxONP8agxqdcDRM8YeTy5PV7f2Pjk75hMpouKe8yRl+dfzty68WfVSkVNXHhW+ikd9P+QonaH/0nuPw0rrvKzelOKeiw1EWSSa//Q/XM7PAOS/CTfj1eqdGjtVxoOVNZ+TzfZOrb2Hx0lv1oulSSFpjSPtZrfG7II4T7SEx2I9vZ9nMynbvmitdrJ7s72+/b3djegdYpTHfTr8pMinXjdNKxR7HaHjywppjq5OFmHlHe2NiX+IeU6UyvFMN0GBofvIGPvd8i4U2Yz4kul0ndmb934vWKxIIXWKIF/O9CvRbqsiy4/Mnm1A39JzorNk/N8KjYl+FeT/SmvqaUAaEUgqFQioEgAjG77xRPH7OlKLF449cSLJ04DpdsX5h0E7ggse3w+8DkdNPbfYjKAx+kk34UUcJSQTyQBFBwCpLRwvGj556HH46UAdPP4mMaML8TjMNYdArvJQoE3WvyFxrCyw7qQs6/OHoBpAhmebSQaVFj/8axUPk/rZDfasmIIhNJF0bSQ2ZqWPMN7AgGwms30uulcAfaOjmkGASx7wNV9BdqD3Carh6qv5fsWtXVlo7GH1is8d/BE4mZ49nQ9xEGN1hNT+M1s7cDCzi7YSF28pE/9Lgepm4+y7XMG1vhccs59X3DqiK9wxXwylY8avbV39z/Cl2oV9pnEXNfN4+VgGZ0NWBZKHI8x/TSdIhyfgNHI0nuA94hlDXBUSUUBKPBXihagaPUyaOXForb601sGksNG417rmq1c6LRiWK1Wm81LpCFdTSuplMtHe7vbCxr3Ut53hyN95EX6wWbm/tS/nZu9+UV8MUMz4NdKf6Mz978IaQE6mRbHNfXjK71v26R2ZTU+q9uuHpfKz9LfNfulwzpJ0gnnQJO3gfTllX4PfsKkE2u/psU/Fhvo2NpfqVTiG+urj0NzXL8SeKjfefI+GAxF+geGPqm0OJK5MntwsI88KPPQTOLX0ZypP0uvLjlDqdhK0dkgL/UzcQZX19mx/bG+u8m4sHRSVjaTuXl6eoKhuMqxpxx/DWvQkXNjDwZD3Q38QyCky/zyzM3r/04k0VR72UhrlrYeibro8uOS1wLw74SURwL+Ug5eKzRb/lnVtUDr82HxxHfzdG0CDKx13BlbImAzDtpAtSGV4Fd2npxaON0aMRlN1NkeXcjpipKrUeb4gVAXtYpj/Luc310ikEMOAF5SENTk6HIE+hWM3yd7i8FEwTvGTgftTjATYL16mKSXWIgnYDQYBKfF2nhd6TPDK0L7GZoa0G4yi2kAlXNjPb0gppzDcp0GW1psr3Sg4bic8cWLJ2ETa6RA+HxflJLt4Xm3NraQfE44uAanb43de4vnZFdwaRElTYxKF3SlwqYhbINnwLSU2gwupbcj6XLekuVKtnypaKT1J2UGrZ78STFlqjA1U40cnC2VIVcswU7yRFCaoHcD2c+m1v0E+B+bTGYj6WeuWq3SydpqMFcfCV/cezRyaW/xdMu9kN7ybecS/mKtbMYMBwTxC94ZDJIwcnzI7t270zd6S+wXLRcvLcB61qZ+3qXwh6r4udamHOW5rSz96n6mirJoNHaZZQ3Kl15LOTo6fJ7juIqqzvKeAP4LkUjPbzEs65XOIf1/fJiIf2RlefEZaG/llzwhdNB/m6IRFqX1WUuUCkzpWvIfX2l93caCq07vqvyuFCXgV44h9d8Y7Iez2t+i38+6F7zGd+WCVA85+BHIbVr7m8CG202t/RMdFscnDxNfIe8TiWlfnStcCTwaCInxd5/PHxgaGf0UATcR+YI8XyTX/N31tZUXoNnSr547dfDxKpUzlIqdzu8oL/cc34rUr61xwmw2u8j4uNhJARhmubOzhY3TiutvGhNjE+ffHAgEflXJpYHHFPL5z966ee3/JeMZ+ZfOUrip3yHK9spzu67Y1eVHKa8F4I/SbsKgE0W5VvF8bfvKO06qmdFitRRkWMZB8C5nZIxVs8FYsxksKZfReuo1OpJTwbEjB2vOgkZ86OPJW2/fzSenEXy/cLj45i6zZ+3h7os/GHb1HIjHNGjsMZb/85uPPbhTSPYRQEkPIJgSTASoY+z5eCxKifN4EdgjAmcU8Fymm5P+DIKl2YSx5+Q7AmoTgk+FdR4PdVtsMNbdDUuJBOJSWD48hBEK/i2CQz8vdZhk7edFIrwazUlPeoeWAU3pBQXvgu3DJFVeRGzePagDf7qovpqcHyWgny6q7WYL9HcHaXw9KiWW9w5EvoEajLijV3mOksBJfcZDHfxLv0kTvuSxISlu6PfnT5aGnknMjJV5ziaFPzDi8gmBOCobAlZ38T39b9i4cbTsWsnte7Yz+y6jycSArG8QCo65I5X98pEnbaj0HKSStZ2TAy5bzrNclWMtBhP39r4HV0c9sRTZTsl11/byR7bV7J4zV8obaqQhdpOtOODsTvY7I6gMqon1VXae8llt5TGCpJEGBX+E5jFQX9ThZ9mqYzAYsNEch+yLpA42m50pFPKcomxZi04Wkpjhogn0o3ablG8xGk1Of6Cro5cqAfz53Z3tGfEZ4UVCP8nVH0bHJ9/k9wfeSz5bFOes7WxvfWB3Z2sZtNP1nRXPr6frayFngM7bWRy2snK/okjvWliNlO8D5V6tAJDaqSRqlfbS9TioK9h4qUyttt8mv0Cr/tcK4XlF9v1PsJxl7ddShtL3zu0w+VfK5b3NjfWnoRmIS3VQphlu8Ghzudyec2MTnyTzen/9inzl5OT495aXFjCNrhaZmDokSgopeFmVpC8mxOXlqOcrXTpQ5N7O/I7ySpjjO4ntb/K8ifbGLhmNRkcnBeSy2bmT46MDaAT9ajd/nobBnp9+l9fr+1+hvh5FqZFr/CUB/f+VrJuQiLod6G9leDnzXuhzuy4/rLzagb+WtlPTlfmvVr7+G7la8U284B9PhiZDASKCcIYrkhGaoS7hCKwfS9zk3SZbtsvq24s6Anv3BqfWjcDioIZcpRhihCB5wJRsKS43/IXtJwZ77YGVN0fve8pvckoKA1o2gbuurexBzGA0Ca74Pi+MEcCPcfqi/zyNsxc/NjSpceUnKAQQ3KIrv5EV5iMba2hsfU2+EI3tHw93w2I8QX9aTh7CoD8APpudAm/aAaIyQegMnoI0rE6+XAaXxVavjUx1D7B5kASGhhbUKncFp3ahEfgbNnMHA9JpU329FPRjGcs7+7SP8dBylas8HLp0XXGvQLGX+w+0cydb90vHPd/afe7Oo3LayzLiVUn9gx4X9HV1QV84CAubOzTN33E+bTYwLH+5ayxDtmyZrxhXUju2vXzSytVqhuXcro9na7CbTzqXTredgncC6ksYo9Tvea5sWExt+SNBXwaEsmoRm79INrTi1CoEc29m9q0ZruB58vBm6LCUsnEE/5pZY9FpsB37ze7Exa7hdfKg5cV2Kd3BlLH+VdRMg/Ciq0AjQWU7qw7dOI5TunZyBPRLbv/K8UEXtuTl1Squny5uIz3R8yaTSY4nbSenJ8ezpVIpL5aLmJ/uMbXg5NSFf0oWsO8ExQu2Uqk8u7K08LtkAXvYpl1SnyjBmM7c30baAP52nkzKPQqv+qz24Hilkt61U6q1ChVSh2Upxw/+vaq4vhL8y21vUY92/a71u1K0uAa0SD1fSX3/EyO3Ye3XdPF3ud3dbk9n4U9E+EQi/uVajZPS1LZKH9YUMmi3Oxzjk1MfJcBGyVZeTZ2m/mhhbubr0Aw6WhH5vSxz5g9pjda0QL9UdX8lyhlz+1m/tZJWHEFKZcCPDYwqSP2kup6VUUPeyNrCHugKXe6kHFyP7O5uP6Fqp9Laj1JjiZyfvvjzZL3ybmj0CKum06k/mb1142/ItSQOIrWyrRMCZumzksNKV+7q8iOVVzvwV0pbV6Eiz8XQJxsRosduhYFQCIxGZGSvQbFShnypDOlcHk7IZjNbmAoB7HulozHcnk0uPNTnCG/dG5xcH3H0bD9XWuhmKbs9Cxxa741G9qCcGv3rta/3v7778hPT3qEtsXzWwDOVHntg/6CU6kFgXSXH220WkCPmRSWCtvA01d5pIQ+pQgHK5NyaSMZnEJApBeCYIpAVLfe04fQ7+d3A0CnIZTZDqlikxawdJaHX64Wwyw1iFj8hbAD/McJnhNEI/Gl6OykdHlUQCGWuHAjODUPO6IadNeOkJwP/vcJRV7qS96ILPFr4KYEgHsAaYGF3T27ZkKt7xm2y58X7g5O6NFkqY7tMqVohbGYMBhtjLovHWW6k1kYfP7h+B8/wBobUL+B2woWBGAX7qESpiXwJeyenSqO+HMphZkz8pHewQPrT/Hj8mg9Yge8gXcrK9cMEACzDi20WFCNOg1UC4nSiznMl4/XjJe9GLu7dzcbdRgNmbGRFHUp9Xpc8M35weD3zSPed353yDiDrvZZFW/mbcjHXKi/sWa7xStZoZSxpOxZ/C6bzQ6t/MNjpS7VW2d3Zvg4qkGKz2a0T56d+xWq13Q31l1ytWCx8cW7m1r8j+1ybdmjFpuokfi2kRZYT5ed2G4A2+Ow0BOVlBaBn5H9ulQtdGd4ltVdrHKr7RKlIU/6u7MNW/cxC+3ug1fdKl3AtV20d/L84aWVhbOVarLD2D3Rs7S+XS1vbWxvPQ6O1XzkXq+dlWheLxWKbnJr+oEiAKkktk0n/p9mZG5+H1in7XnYG8R+Bt5EaFDWFurwU7XilSAceRO0UjFrnoWgpF9uFGNJjf0xzTbux2DKFXyQSnTSbzf5OCsjnc6tHycM9aJyrGzYy1swE9L/Xbne8sbGv+NLJyckfzc/e+hJ0lipT/T5QKhB4jf1PimJdl58QeS0Bf6U0LQDNBMsWxD96XU64ODJAganEaY9HohIgQwD22m4CNhPI9l6gf0CX6O1CfHhjbW/Ya3FlqY2cALvJWA9liL+xtgXpPMGwDGv51v6zbyhD5bk7vWPrUtk/0//6a5/f+J7hoHTSnUxl4RvP3oQLg30wOdDb5NTf+J5jaPy91WSESs0MZjEdHdaZ4zC+n4NytQpVRTsk133acFE5gKEAbqsVsuUSPWb3NAXFcgUG/F3iefXwAvxuJOAV/y6lAWAEjQBVD1RJuVvxJFR5rva60EV00cZnTLZg3DpeGyAgn15spDciZxI4TKfhNJunSolKtco/HL7jGtSfzyZL/83T1dFnk/MPp8v5AIYfuI321Ot77rwZLxz7nz9anMR4AWTVf92lCYgEvBRYVzlO7ruD5AktDyVo9paVZSymtxxPJm4F0pU8AbiCtwCe67RZIRrwU68BTP+HmQsen12AcoUDDF3vsXfhdUy5asHwdHI2MHe6FkCWQlQ2mE1WMYRCUNYwYmuoFwkPNLyBvB1c39x95qd38/Ebb+25F10/ldZ+9Iswrqb3/PvFZKjGgs3EMUv3hqdXjTyDGgm1S6daCdDK+qNFIiUpW7Qs/XTrCoaGrTZbqJPBlkmn17PZzCkoFpxen99/bnT8V8nLdLB+JF/JpDN/Shau/5OMPWXKwlZKC525vwNpw2KvBppsi9+1FuDqBaA6xEIZaiHV4+W+J60WjpLnkNJ7RpnKFaBu7ZeUT/8/e+8B5sp1nQmeQs6hgUYDaHSOr1+/QPIxi6QoUYG0R7Ioy7K1kmV7Z7zrnW899vfNjD1rf/bOamzPymFkr7+xx/bs+huPR06SLFk5MYr5xX6dcwS6G41GaORQe8+tKvStQhWAR5GPj3x9H0GgEapu3bp16/zn/Oc/rFOAHRP2WXrdzBBX6gsoX7MPpfHHVgSRvsPSxEGlPyetSbvBaH9DlNHhdAbcNxDt343Fvk7WOlzntGqGg6IPOoPBYDx95vwvm0zm+5htIc34z69fu/I/oHmtcLW186asmW9Qikt97JhnNSr6O94BoDGe7Ty0hKqVTW2NV3t+UxyNimi/GkNLk+KPgYlAV/DuNndVi25vvQCNoLo+ZqhiPEHLC1vYIAXa+bmD+P5/WJiffQpaa2ioOYC1xult41g/aW+/9k4H/qzRpXyfbdwdnae++szOpfNGg0m3trsPff496O3yi0BZiNBiVNpjs8Ndo4Nw76lhuuHdVBqWtqMwtxUDvcEAR9WCgxMV9DEqfpqAzv6uTpjfjMLL80ug1xl0z0Sv3pMrFRwEGC+TTehMnIH7xOD7rj0dvTRwMbE4QMCg/uLyKixHY3DX8CD0hwIEDLNp2MfPGNm3myz0oeQHIX1BIgsg4JRU/6U8fLqi6QTgif0tEXA7uxul2zjI5aBc3YXhzgAzaMLWjUY9VAo1if1PKwFIbQnp+no9+PSOlNfkQPAmA/4bhVgEvQ3VCg9n+nrqZ2J+c5syE5Bl4DE5tgJmzyHIyyBS0F/ha9YvrT/z7q1cfAIL6KEQIH4ly5c8/7T14sPoOEBnQqTDC+8+d4qyLmo1xnHBC6B7amOTHjvwVb7fFcJ+6nOVouEbWy/513MxO26X0wliiMOhLjgz0AsdTgcZk5qY8gCQODqiaQrYTJyx0mnxwHN7V7suJxY6sLwfj2PM0zrK4LBaoSfQASGPB9xOG+SLZcgXSnBUKEAql4fdZAqOikUgNp3uWnLl7Ae775tHBXvc+mvx2d6FzNZQNLsfIp8b9Di/6NjX3vPKwVzmTt/otx/pOo+OAmWdWCUboIEZoNPpqqR/FeaaYIF/A+AXH+ZgKHwXtDbO6NSL7mxfBQakYNmpvr6BnyXzhFWgzpAb6GfEG2g7FNUTEb8WrYlhqFSwVxO1awb+69RHkANQFoSygkX1SPjNBv8q0f5mAm3Kcq5ShFXqvzQHi8z4qBljLN2fXZabAX6lvoBe8T22KcdbEvKsMt+VOV5uAafL26mpRRhZJpRmbn+vEO1vy64qFovrW5vryIRSo/irzRcdWTP1Z87dgQDkUWZTtVwu+1fXrl76r2LVk1ZO3psK+jXYRq3AKoD2/UUtAqoViX7HgaI2Ab/aGq/2vtZ4s+Nb03iwLCPW2fhGj/kNO+E6A10YmAi2s/F8Lre5t7e7AXJgXh8Lh8PpGp+Y/CWTySQT6yTXWnI3tvMbK8tLr0Dr601124pjlG0e5PdO5XODc/edNs9P2pvX3unAn23NKDP83d6xuZXU1vdixcPHEOo/PzMPT3a4wII17nmuTneXrs4qzUsH6HA44J6xETg32A/PT8/B9sGhWIOeg4N0BtMCaLR4pCcEYb8Hvv7qFcxf516Oz054Ta7ypGcAc5i564crXXOpjdCjwbuW4/kD22xmI5QpFPXfuzoN7qVVONvXC4PdAdpj1jpg7Typd8KKLIJ8ZhmgR0GXHY6+Tz+mqQECMEal/9PBEC3xVyZ9zhAgSsv9BQJiRF+g9aMaf6XGywQH8QmZAAs7gjaKz+JEmraBGWvYySc8mVLOaSC/D3gc4HHY6Tjix4vbu1SfoMpX4P7O01K0Xwb6C9WS7fOr3348XcmHhYoCImVeID4I5QXJ3x67Dd57xyQF/LIJIB7zfioNiUyW/mHTWatDzu7yVGrF84PYlLvIlw0oSoi/HQwH4I6hfrCbBb05wfkiHDPudyMWp8dcIrjZaDDq/3T2S/01PVIEBB1CBPwoXHhuqI/OE3QSSGfLYbEC5xEPjfyXKxbgC8+9ChzZ3rAzEiPbd1xPrXU9G70yVoSyC39nNJjouUPQbzLowag34T6clw8XnwxYPblTrn50JGkB/SLzkP4uk9+zZWXqOgxwLJjY8HC53CFyM+xv56LL53N7icQBUujIjZCrDg4N3dkVDP+4QsRva2d789c3N9anQTtSxbIfmlU/OAE40FbZOiWgaSZup2assEYIKxKmBKHSeZLA8E0D/03KQKmBfgvzLEX/WeAvzb8SyMG40hhjaZtaQE5t3PUqf7PnQWrKSD8bWWI1B5ROADgxDNtuakBDq1Z4vQwwWRM73R7P6Tb3wRPQ8E2yzrPrr9SU5SQFHz1pZ8/e8S+sVtsTzOd8Pp//h2tXLv0JU+pUi2qszOu/maC/XbZRu0wjUDkO1fsBvEOi/20A/mbsIbWHFvhXgn5p/WM1TpSvAd5A8K+RnsWuk5qVhkAITNwD6vNH2fhodPsVkFnKx83r7egcGTv1SwaDoY99n9hNu1ubG//H1ia1WZqxarQAv9o5lPUL5POatXu02F0n4P+ktdVuF+CvRUuVXVBP9j36T/95/gsXyDXlRVj/7UtT8JH7L1BqttA48fJkXQBCMxuN8L47z8EKAb7PTy8AstmL5QqNyFdBANoI9j50713w5RdfA85g5J7avTQx4o68ZuaM1dnMeijPl+3PxC4OPxA4s/rpwOPXnt292r2c3vJncnndczNz8PzcPAwGA3CqJwydbjfVDzhunOJV45pXX9Hr/5O+ydW/gKyGiWAQZmIxmiKQr5RhOhal4B9TAvCbZqwSQBkCNeoskLadzuXhMJul9HW7zoqqpgZ2t68lZgYMej2qucNIOASCzhyQMdulFH8cVavekpn0DkbJd6RceXqTKteq1r9a/uYHc3w5INEYDOQ3AY+Hlt5L0UQNngL29991tgH0C53kabnDlegeOl/ocY+4IoW/Xvl2MF5KmyQGQ8DjhPtPjYLbbtPkYWGkPnaYhAI5x0gcyFdLSPTghNW4Bh6bFR44PQp+l6CVgE4AHdfI9cIX+8k0PHNthoB5Ay3L2OMKwn9b/dZDiWLaher32E8s6xjxe2mqAaaPOGwWqjnxwswi6jhwS6ntMQL8E9AY5S+SLZSwvBMIYF96LoqfVRjjU5oUehGYo3q/VOKyXi0hFO4+124O697u7hRun9istfFTpx/zeDseAQbIlMvlK8uL87+ZSBxEoZGRUNHr9VV0GGAZApAbHOy1XJ/Vt/tNT8M41DIC9U0eWuBfzSBR5r5Lv2EXqBrz+5sJQlmqqBLIsaDfyjzje0a73e7p6x98zGazT+r0Ogdf449KpdJsLLbzpd1YdBkaDWLWGcVStdnzoDX2bF12VmiQPQfsuCv1PnTis7KxmgO39bXRqmkIibWK9tcfPX3995O1uM1of2F9e2sTS7pqAQQZMCBNN3nm/KdsdvuTzGd8oVD4x6mrl/6Tioq4Wk6/mpjfzQT9zZyPWkwjZdOKhLLORdVUI3gbA6MmY3kjzlw1x66yegm7ViidjEqhYXadZx2hwGzjh21qx6XlhKNrucfjjdjtjv52Nl4sFPbIWr4KjRiB7wx0dQ8OjfwrYoPIUhqJMbK2trr878TfqYF+ZZRfWfe6mbOLHTslTmEf7HdPwP9Ju6F2OwD/ZqBfdkEZOV1u0jP03WuJpY8h1Tt1lIPrK5swMRihIvfHxeyZa47xjyK46yfA3GIywXPTs9CBEe2a/N5jNhnhvefPwLcuXcXIrenlvemeh7vO7xRLRSPdFEFIz+1eGyzVylv/LPLASr5W3Hp1f67zenIlUKyVzasEtC4ToOwmwHIsEoaBcABsZH9VMQLPaQgB8syrY8ivyIQQv4TAfSIUgjkC/rE0IGoFzOzGYLQzQBkQtK49+RmKHhoIPsQtIv0caf6ShgD5ihQ1FlTcyZGtp2LdvJ4unDAYCtB943bW9uJ1RkXY4t0ix8EqalMhv69vv/BAtlYIcJxgSxv1OhgKd8G5wT4Cmmcp8MdUhjuH+qkThr3lsEeZL5YAUzmk/V1PrjrQGUCLOZDne8aGYbwvLBMBPE4UEE44CvTNbexAigBvHSd3s+AcuHN4ACb7eyjg5+vlFzmJK1DfEjJDlndicHlpjToiJJbAc9HL3bgPnG6YVjHWHYKJ3m7y2lDfVr5UhJdnl8hzSdBd4HSu/WKyfzG15T0oplwFvmQulMvGXDVvI5sxoOyjS29Zflfo3NcHbOFNspECp9OVeCGXngX+2LBcoJGMiZU8bORvLIeDzzaD0eB2e7xt1acmoP6I3ByXLBargYD+jxKj9RQzVBip+ubszNR/KhWL6VqNL5NrrmwwYOEBQ0VHAL9Br68Rw1bKf1UCK/bGelKuD1oa2s0AJws6ZTXCodEwxKYE/Wqik1qGu1rN4jezsQaW8pglo1EC/PjAeW72+fy9QyNjv2wwGLrYjRlNpsnBoeEPGI3Gf7W1uTHFHLdUNpN1iCnz+5Xjb4BGYUHle8rxV2oNsHoDSqO9If/5xChs2dSuG+U5aqD5E6Dh93g8k23ug49Fd74lOlyVCt86xXep73fyzLmfdDidnwDmHBeLha9eu3Lxsy3qhatRjuv7u8mgX6sErRYQVQNDaqCfPT6WacRS0d+W+dBtpGupre3tOHWbOXfZsZbGVrnG60G+zrNCpz9UilGLudNSXDMc6bmbkwzFFm13N3oJKzCBYs0Md0eGe/sGfoHYYW72++Rau760MPfrCaHsn5KR2MqJp3RyKe3cZk4XLWZXw5jDzbu3nrS3aXunA3/W8GrmQaurhb8vfOHFldT23Tko9SMYvLK2Dt1dPnBZreqgWnGJIdALdrjhibvvgHgyRYGznqrCH0fXOz1OmvePAHQhs9lJgP9BTQjsUjBo0Ou4Vw7mImWo6R4NnN94uOvc5sOhc1uv7s10zqY3uvbzSUemUOBeW1yBl+YWwW61QNjnoXRyl80GAa+LOh+kDiLF/CCVoWJ2KPZXqpRppFoAvJgDX6UlAJ3kGBGQGw0G+v6priDM7+3SqD+C0LndPRjq9IHFYKSAFynuHGcRjosg/ehhCsS6eWDQGXBxkuiytbnUhr/K1UyYc4+lColBTUEuOka29hPUmUBe8xf846vi77BRo2sxsxVcPtoZ1OsExgFWWzg/0EvTJ3C88Jjw/YivA84O9glaBuKpr1vL5FiL5TIsbO4I5QNFXYIqJzhLzDo9PHLuDAQ8biqMKKVEUPAPksNHcJusk3GIJZNUE0EyqXFPKCb4nvOTVAtAzEAA1m4Rviq4HNAp8Or8Eqzt7dMUAl5KzcD7FTkfXrsDBoOdMBwO0vPBbgSP93uXr1NNAGk/C9mtsenU+pjJaBSOTBBzEPZHmQ4cJKq54BfXnrnjU0NP/HbA7N4VQb8E/CVPNYjnzEjmMt5Q2Wi/ORSKTJBzZ23n4jtMHMwSsG8eHTv1EZPJxOTb8ZVUKvWXs9NTKOKHCotFcv6LZD6WymUdMV5rFUxBqJTLJ8r9bbY2DO0bBZxqEWepKddQFmyofV9qMk/jm0n5bxK9ZamibDoLzml0cFkJuHcPDo38SyXolxpZG12BruDHCfCfE49ZKr+pB4VDSnE+tKoIqIkLKsG/BN6lcZeAnqQ3IKs1DergH+DEKFRtLYTElKVjG2j+PX3995F5YWxnXwSwb+xsb82Adv6vDLRMTJ79cafL/dMgA/3Fb167cvl3Xifop4+bCPpZx5vauKoB0mbAX42xyZbYbEZBl7Zzy7c2HblaIF+LQaTF7GqYd9AIPJVVhJTrPKsVVJ/Xr9PR0gz0a5bws9nsPpfLPdrODkqlUjK6s70ECmcSAfyT3ZHIz5HrmbVzePL9F2dnpj6TPTo6hNbUfjZNtVl6VzPnutKxLt1flaCfPV8nDt6T1rK9Y4E/Tnpx4VQzgpRetPoNE9XE399zz1e+tPHsL+CNHEHg01en4cfuv5vSsJXWrBQV1kkRXREg2i0WsAXNslgxbZzgHDg31AsrsT1Il3KW7VzcTUCPXtgA0uCDkC9WuIux+bBFZ6rc75/YRv743f6JXfLY2ysm7a/uzQSXMlt+AoL1CGhXY/uwyu+LkWserAj8yb5yhSKlvWNOvNQ30ccgmpIiQBa7ubgdhQcnxwh4dVGwO07A/1J8j+b74++W9uMQJuDYSIAy+kml/eE+bBay9mYydHvpShaNaKkMX20ls92J+eu4t8FgFwX92JC9QPP1yTacBksyYgukQFjU6WLIc5z5md3Ld+r1BvpjEwHXd48NUceJVKnAZjaDg4z3u0i/ayLg5ep28jG3AVMRNuIJiq0lwIwo2WW3wsOT4+TZdgz04XiM2G2VCejGPh8e5eqaAngsYz1huHd8GIQyBc0aTysiIEshkTmCGhwLLqIzoK/LD0PBAKXzEwTS4GzKFgqUIZDM5hUuBY4zGDjKpnA77OAlD2Q+HJJ9HGSOmN3rrOlSJkiAP0v7L4Ec+HNwTIOWoqA2nU5n93cGzrR7DToczoDP3/lxvV5vr++erx3t7+39wdLi/Pel/WOkn/RbRvEH+c1UYiOcgH6V1iSXXc3IZnPb1R5K8M+CSnY9VTpNWWNQaUCqrcE3q6kZXkrKtgT86TwfGBh6HwH/kWYbJetRBBoNamn77Fg1M1zZfijLZ2pVF2DHXEqnUoJ+NREuNne37aZSa71pewdcj0rA0VJBHMGGx+Ntd13kd6PR75J7Jlu6D0AOvOrXyOnJsx9yuz0/x35WKhW/O3X18n8ol0voNG0X9MvWzpsM+ttxPqoxjdQi0GzOufKhlmqkRkG/5cUu22RMaIF8rYfS0cKuWcqoszRmSuduEeTniW1KR+MNOxtb6LK0rKrRHem5k9gppnb2Fd/fnapiOSbmGhkcHrm7qyv0cWJ3sdtAduI3Zq5f+4NisSBVUFK7xpTnS63/as4ZNS0XtbFnnWJq4/66xvyk3X7tHQv8Fa2dvNS68dpn69q6s2Pkqdfi8+8nBh4FjNdW1mGSgPUG3zHZ5CH5HKOvfocD7EazEE3moRH045u8QIV3Wm3Q2+mDTQJEX4xPB2wGCyQqR9SBMNYbBrfVjnRu7oW9qV4Dpyvf7RvflTYSMHtyP9LzwHq2Wth7JnolPJ9e6+B0Bo6TcsjJi3y5TPeHYFvPLCcCjhTWhJqUHkD+IaCmgn75ghCBlujv5LMRfwDWDxMQz2XpezvJFFgMBlpGUILZuJ0utws29g/oPlYyUW+xVrGZdQYcU34zt+el+6zUKEUfwa6edGx+OyqQ7nUcjHr7UFlVFu1/KnpxNFsturGPVrMRHjg1Cl0dHgq48T2MfvsJSJ7o7RFK48mI+ccxd4z4b+zFybks0O9JnwS9bnj47Ckw6vX1aDzNqa/rIIjcAU54NbuxLQg4ggCyBwhIvzAySPpm1kwvqAsCkn/Y3+evz9GKAFU6HwSnSW/AD6cHuqnGgsNiRsYEA/r5+hgn0kfUYUSPFR9UO4CjzIBevw/Cfi8d14ooPrl/mIZvX7pWd+x02jyJCseHyAGkyVym0XY4NhxZgT8pwoWgiAKiDp+/32KxtFUXF5vNbpcJ4lSrlejG+tpvR3e2p4HRGxApr6zxeqLc32ZTiVRqGUtqYJMFmSzYVBqHysibdE5YpylrxKhpAagC/zfDANdQ8lcCb9ZorOtYmMxmr7fD925oNK5krVarSuKlyiimXHtVnWmgdh7MimfpfGD1NovP748QADhgsVpDRoPRQ9Z1E7n2k4nEwddWV5aeBfV7mxQBvSHwr1FnvZ32thRRayEk1izCSNkiPX3997YLNghw2Nre3pyFRop/Q4R74vSZf+b2eH8eZKC/9NT1a1f/PQH/OP+0QH9TltRbCPqVTBd2vTEy32kF/LXSjKRrscL8VqkzIm3rloyKvo50LZY11OpZDfhrUf6l8WLBZ1HcVgEaAagWy+j1jLXasavdx2TXodFodJG1uy0HHDJltre25o+PkauNjo0/4u8M/AjI07VqR0eZ/zE9dfUviL0n6WioRfmV92Blapeac4ad78r7LBuc1GJYqN1fX5eD96TdXu0dDfzFqL/0pxpFrCHiD+JF9lDXHa8kSke9a0exMcyxu0KAP6rQ9xCAxtdp1EI+vM9mp6BucX8f3BYL9Ho76rnfdd4PDQ5z9Z7g9zEPfJ2A0fWjmK3H1VXBd1ElXhB5q1Ha+D88/yL3wv61QavBUp109x+wx2fXW8pPRO7bvlAcSz+9ezUYLyStZV5iAYlrCCeuFDzQ6HKtykPQ5yEg3U0AsxN8bgetTy+BTCwzV+NFR7m4jODv8Jgwj3/vKCPQ/Ano3TxMwXhA/C35b7QnDFfWNgT1e47Tv3RwPfRI5/no6lHUnudLFj1Z2zANAvPXUc0/eZSFg3QaDHoDlMoF/i7f2B4IxhVdNLPVgn0qtTyM6x2yAs4P9hPQ7wV2XSuUSjDcHRRK80EjI0P6ZjR+CEvbe3UAjO/3BXzw0OR4/btChF8A6LliEXLlEvhtDqkIAuzED2B6fZs6EZBxcGFsiLIN+JqSTau0lgVGxX4yA5cWV6gegSQYaTEZ4cGJUXDYrGAm592Ewonc8RYkVoOkDfDS3JJQ/YCMn9dlg4lINwx1B2UHTFMVyL9UNgvfv3pdEE4USxoky0e+b2y99NHnjdcS467eS3f6Rq/ZdOYkHANuaedsST8KirqCoUm4MSBQb6VicXpxYe6zqVRyCwTDoS4yKFYWkFgHJ8r9bTYNwKJlGCrBvrJ8HVvGrm6YkGbs8PnDHo8XyyN1E+Oqg1y/VnIWyBSsZQiQWTtMHLwWi+7MiNocaiwrpfiW9Pxmn0NlLqzaeLBUf1t3d+RucszuVhsul8pboB7Jqansl80T1zoX7MOEYxzoCo4SQ/Ruu91xmvTJCSrXXigcvoOM+2+urS4/D3IQVFH0pz4mas4WDbDfrgNAeR7flg4A0AZYmvnEVqvN6/V2nGtz+/xuLPoUOV9qucDSM31NQP+PerwdPw/HIEQE/Vd+o1DIS1HHGwb9N2kMm+VlK1MmWKcjC4jY7bQK3JRBToVuJhAoE7u8lcB/kyg/myahBJBqjkQ1p4om8CdrutnhdPntdnvAbLF4jQajk6w/OM9rlWo1k8/ldhIH8cVs9ugA5NVOABrBp3LOvZ4IdKs5xJZfra+b4e6eMwaDwd7ODsjxzJXLJUyTqRL7lT81Mfk+pfAwXnLJw+SfzM5MfZGpmNFMtV95r1ECfq2UugYtF7LeI+yoViqVAvM7pQ6A8hpnHby3PKvlpL117R0N/FWaFvhX5i6VOJ7P/1jkXV/9ZvSV4mxy/SxZCLnvX5uG+0aHYayvm4I9hikPPruDgrbNwyRcj+5At8cDZCWtLwu80hdHngNuF41WJzJZLpo7MCJYs1vMYDGaKFDDvPt3n5mE71y+pvt+7LVhm8FcG7SHUiC/oXFWo4XvdgWqeosBtpO7dceE1EHMo0eHxXCwi0aWcfmgcibiulyp1OopC+h4wC/wbEfFaHPA6YA8AcNI+weaa16G6d0oAf9dNGKO7717coIKFyJQnzpc9t3rO52cTq74dLhT8nmYAHehGgEHC5tRXODo2HRaO1IOnQV7ZRZ7rv/65osTpC8G3LeXjCVGs9m8eewj6hvoOXZg2Ti78N5OPAFYnrGu9kMOfrQ7BPedGjk+P8yvE7ksrU4QdLspaMZ346k0vDi7RJ0e77njDIR8XjomfE253+MTja+wlCMK8M1ubMHC1i6NxheLJarBMEIAOwoBotOink7A108cZYfU75xk+F6YWaAOiYFgJ4S8HvC6HeC22mjUn2NEJ/H/qL/w7YvXANPk0bmAAo1lrDJBxhsdB7lqoePS4eJjLx/MPtxnDUw9ErzjlU6z+4A5AMngrdNZnU5XU/qz1jVHDIanZqev/2mpVMTcOBnoB+2yU0plZmWk+HU5IKT2dr8hNolqs8YhawA2GErMQxZhJnPJ2Bno6g8Euu4hoHNSbzB0gAbws1qtd3k83o90d/fMbG6u/ykBNgvQaKCzIFRSOAZ4E6ITbThDtATarBynQ1bLfe3sJ5fLroK6wJYB5FF/pTicktYvOxcms9nV09P3gLfD94jJZAppjftx4wykzx8mwP9VkINApXCUalWFJoBf7TUoXrM3CbVo0y0FrNRaG0JiSlAlV/Lv7buBaH8xtr3VOtp/SgD9/wLkoP/7BPT/JgP6taj9zZhSN0PMTzoeLcDGjqEaw4WNQqtF+1mxOSkSjb8rgTx6rcYWYOcrqLx+y1ob81CLvaV0oGg5U+qA32gyWTs7A0Nk3Z6w2mzDRqMpSJ25jdT9+hhFenpKhUJhem939xvbWxuX4fhaVzIwJJHTG04xakOXRVPJH/vv7wycb2c/GGjY3t5E1iFWDeInTp95wulyX2D2jbZddn9v93eXFuefgmNcoAT9UlMD/M20dBrOi9vtIaeka9LucI6bzaYenU7vwm2SvibyudzF9fWVL6RTqSg0Xgfstc5WD7gl5vVJuzXb7QL8tXL8m0b98fHB0D0vEGBlns9sjekIQntpfgk2Dg7g0XOTYnm2Y1q/02yB06EgbCVTsHF4SMFjv88vgmlouBQx6jvRG4Hnp+dFyj2A0245jviS74d8HkrjXo7t6v9p64XRj/Y8NB+xBZDmp8vWCpYvrj/TF8sd2EwGi5RyLkTpqzVwO2ww0dMNfQQoovCcpDIPNZYSz+T443GIXS1XBTG8YrVCgGsZMoWCIGYHQEE+pgUggQGBLZb7G/D5wGOxQtDnhvGeMCzuxHCQdV/d/EHkoJiihhHmwocJYMYfGggAXozFhH2S7YzYuqVoPzbdQnrLv5nd69Qb9BR8n4qEBbV+pmH/9WIIH50bep2u4fNsqUDLK0r4HJ0pD06MQW/AJ+bzy6P0mSKWJMxRzQCHyUL7V6iUYH13n1LwMS3AajaJzhU1m/y4P0fFAuQLJaqzgIKIp/si4HM6IOB1g9NqoXT8ht9yx6+FlBFhP7g9dDL8+LvupSkP2He9Ti9zXEjTBudVMp2Fh06Pgd/jpHoT1AlRqUDsMA17ZH4eZDIQTSRRRMG0Uzy467+tfOOOTpN7/YL/1KUJdz9GM2Ulz4Kh8Di5ud7QeoF5rIeJg7+bn5v9As/XUPwhLz5YbQFN0E9uhnwqlVQz1hoHXPtvtd++XSOStLWgsrfKSa5HK0EB/BHAdEd6zgS6gu81my19oG0IKpuOAFZUu/+/LRbr76yvrbwI8sgz9octQ8QahNybFJlQgn5l1L0hguvv7Bwixx1qtWGc14nEwRI0gn4JqKkZglppFrQPBOS7+gaGHu3wdnxAbzB44QaYNeS34xaLxUUMczb/Vg0EycBQkxrrnMZvtK4trUd9P7f4ddYqLUT1OjJbLJ4On6/daD/s7UafE6P9WmsagpAPEdD/cyAD/UWk9/+mRqRfsl3eMtDf5jiy1GyJRcYKJLJsIxrxt9nspDmIWWH1GI1GK1mf9MSGyKMD+egoE0ulUnu8wBaTHF1KYcD6uCpeyxhHb/X8bEOjhXXksowJpUNXCfzrKRRk7IyhUPe4r7PzHpvNNkmG0gHtrzEoko/sljv7+gfOk/vDxZXlhT9LJZOYmsmW95NeS05e1gH6emj+7d7TzF1doVGz2exrZwep5OEqAdNpMqd0E5NnP0zm2Dg7FmSOHWxvbX5mc2PtCqjbKGpRfuU9piXod7pc/mCo+26Xy30PWcMH0OGu7Cs5b07yvb6JiTMPbWys/fud7a3rzHhX4fjeqjbvT9pJU23veOCvIfIn81Lq9foaFgonF15ZpPRIaskUnDwRuf8Va+wKXIrPjxmMei52mIIvPv8yPH7PeXCYpQC10BCnRdwE2BGQuHIQh6noDoTJ30GnE2SBePH7CMqfn56jABQ/d1utzK1aUGO/d2yYivfVOF7/DxvPjP1E/3sWwxZf4RtbL0YSpYzdZDCBFGHGbWDe+p2D/eDzuOrAUSpHyNexpQAms+UiBfkVGhGuEpBbpg8UMjRwmHagpxR/KwHdXtI3I/nbqDfQCHIsnYZSRRTpi8ehy+GAiMdLS+JtxRM00k1ApVU6blTjx/z8CtnvzkESSuUKVeUvlor8nYFxBIZmcVh0ryZme5DuhL8d7Q7CQChAI/UNjXxhP3tE9RUk54mgxi/kvj9zdYYeG+bRj4S74L7xEVGQEIBT2AZYgWGPAGJ0SnQ5hLHD49xPZ2iax/nhfgFsg/JOpsjoJ7/DfTstVvBY7cdWHtO/SpVl1as00SEiVaXBNImHzozX55CunrJwjPx5kSWAn/ndrrrwYql8vK8uj5s+hG1wtLLE/NYORBOHumQ1N/Ct6Kv9z+1fTZx2D809GJhcx6IH5DxYfT7/wI1cd+TmmSU3qT/fWF9FCjI6qvLkJob5/PQBx9UEygaDoVZBr4SCukZAP/T09tMBIDdhlZPflIqsRgN52zsA2gD9rHGoBvjrFRqYh7ErGBqN9PT+qAj4X5fxQOaqPdzd/Su57NEv7u/vLYt9YaPP0qP2evfRbleg0YBuBvrpOASDoXvb6Ve1UokeJhJxxXnAY5RABcuaURqtMjE/jFT1Dww96O8MfFSsInDD44LGocvtCRcKsSRznK0oz8prR0ktVvub/Z0y2l9TeZbaLQn+WwiJtcrtN5O16W4CoCzt7KtUKu2L0X5V2j3yegno/4jb4/1pkAv5fX/q6uXfLBaLtyzoV6xJann9akKasmox+DkKqiHTqLMzcIGA/lMGo8GPgBNUrgnUhanVqvv5XP7VWGzn23u7sRVmv/Wvic/snGSvz9dDQ38zxg5Afq0100XQSg9SAn96H7BYLE4yT+/zeDseIkA3AD/8uquzWq13j5863Ts3M/1vyT0aSwNLGi8GaCwv2paDt0m0X2seyZzY5P51Vzudx9J9OztbU2aLRUeutw9brbZ+9nMCAzZWV5b/PZlPeP9SXmtaFTjarpZDmiXc3XPW5/c/arFYz5A5b4Y2mk6v7yTn8dfT6dT/dpTJsOktalUwbohpcdJuv/aOB/6Kpgr+RWVPNtpPAf9RrWD8+vZLjxf4UpeVN2c8Vmc5U86Z8JLCaPjXXr4M5/p7YTgSpKJsEsG7Rl65zBZKgZ/f24PtVAqSuSwMdXYSMK2Xu5/JH0MY0Y/uUUE9LKl3bFGJVdt1Opjsj8DU2iYG6/Vf3fzB4KeHHl8mgFa8yYl7Rsq820kBohmdAXXauLAjQaxPAKBFAu4RuGMeuwSBMRpuIKjRTQAriv1hZN+k09NnfOi4Y717fO60O2D14AAO83kKUqOZNHQT4I9j8N47TsOXX7wolDLkBH2DSKePMgXw90vRGI3kI7L3Wlwlq86EXaA3+fn0hmc3f+jUk7Hyu+xUxb+mEmFHcL9G9h9yu8UREKLknNjH66ubcJDOUiD/HtKfsN8DfK3xvidNiBg5T9RxQ46Bo2yGGmSLBTCZDBDp8MoU9uUrqnTmxfMl0u45nvmemErB3AebTFGOEYgUPQCiE0h7YssZHLhzHprtT6gi0BPwQW+XH9K5HLw6twybBwmuUKv4Xj2Ye3DtaHvkx3sfvdgf6u8ymky2di8yAowSKytLf7i/t4uGbk585DFaA8fR/voNlTS1nFTaSQL4lTcvTuW5WUSSPV1KsFL//FYEJsrWgk6rplbPGtrKZ/o5RtOGR8Z+xCVQHfVtdkWzEUPd2ds/8L8Q4P9r0Bh9Vosgv2FjfgM0f2X00Wx3OMhy5myrDFQ2l73My3N82Gg/S3FVAkhZ2b6urtBQpLfvZ8xm82n44Qxyzm53YBrOAjSP9Gs5AJSgQ2l4S38D83u1eylbOx1A7gC4Va+xdtNCZI4ish46fT7/He3uhACJl8j6J5U7k609eL84PXn2SZfb81PMOGPJvu9cv3b5/7qVQb/GWLYC/TbxIYF/BG6j3ZHeDxGgOgRy8K6+I44jJokh7HA6PzzkGH0i3B15enlp4b9m0ul9dmxB3Sn1w+Sfv2GtiTBrM1q/zPkEjawJGuk3my2O/sGhRzwe7yN6/Q1F99tqZOy7BgaHf/rK5dc+C42CsGrpFu025RqkldpQX7s7OnwRm93e3c7Gs9mjaLlUzkyeOfdjZIyC7GelUun64vzsb6VSyRgcs36la0wN9GuJLDaAfqvVhvfFd7vdnvcR8N9GCpfamOuD/QNDT16/duUvmPFWskNYh+sJ+D9pqu22AP6MyB8b+W9G96fg/2ubP3g4VkiOIu46hAwNkx5TqoWo7WtLK7Aci8EjZ06Dw2ahEVfpikZ690QwCPO7ewRgl2FqJwqDSIlHcC9G9PG75/r7YGErSgEjUtslGjlrHZ8d6KXAH8F3gS+ZvrT+bM8joTsTf7v6PRsBiTqMDNdqVbj31DAB/UbZHU3qr/SOBAk77DbwkvuvRJnX0QoAOpqagFF++d2RB7ZXQi16DvrJ8RiTSdg/OqK/x+g6/t5Nto1OkesbW3WWQaSjg25QrxeBP0bmySdDzu40iDT/ZPnI/L3oa72kHxQ/v/vcBByXKzg+JtQJWD6IU4YELV1IQ/h8vafo2Li8vAYeux0eu3CGlsZTJQyIG94/ytC0hrDbQ504+MlRqUAnideKY6SZ/gbSfYCr/y2eNe5YKQE4yV0ingue+Z5UW1DFUStgfZ7ZNnsexbMpOnVYxwQneyF3WHD1D0RnAXkTHU6P3XkGdhMp+O7V6/TjRPkosJjeCt0XfKDtaH+1Wk0vLc5/7uAgvggM6IdGej8rRqUK+pnNtktJlh+sfDttUZLxxS0ITppFhrRAPwv0WSO7HiXpjvRMEmP7SWKIeN7IvhKD6u5QuHswurM9A9q1it+siL9a1EgtgisXhgpHsAxUO3XYa/t7u6/A8aXEqvlzKu83UD1NJrNtdGwca7N/WCviQ8DeLlJSvR2+CVSrbtUpslEfNFfpVgP+WtRiZc1ptTrTAI16OWzeKQfyqgLYbkXw32y+aLFDLJGe3ruIId6WM7RcLiW3tzYwp7hh7cE1m4CQj5O58CTTFwL6C1+funrltzXU+28Z0N9GBQ0t4I8ibEjft4+MnXqcgLf3k7F4XfYoOgFsNvv7Jk6fndxYX/0MWXfmoHFuss9S1L9u4txsIbQ2QX+rdC0L8zedp2ROWvoGBu/r7Oz6AHntghtYZ2u1Gq3AJAr7tWxWm+1+o9FkI/NbKiv6uhy8LapqtCzhF+qOXIA209JMpL+nz5z9MOm3l3mbz+dzz81OX/9coZBH1hRL75euL6n/LLVfq6rCMeC32ZwDA0MfcLk9j5Nx9bbRxabNbne8W683/FW1SkX/tNJb6uf8FlxvT9ot0G4L4M80FvRLBkkd/DM0fwr848Vk3SOIYNbjsNGybRajkQqmYc45vva67GC3mlVXN/wd5v3P7e1CgYB/pMQHHA7o8XbUwT86DHo7/bB1kGBKzSk7zlEgfWVtnf4uVkw4VtM7xQ+G74l/c+flTvwZgvbvXZ6GD144R5X6gVdZ9UWKuxTFx0ZBI3B1RsAxHD7OgedlABVAkrrH7yFYRjFDpMrj8fJizgFS4+e2ozTKj8c1GA7QqgKr0X0RcGJJvDJMegYQGJp2CwnzP64/Gy7zVQNG+N91epyK4DVqI9ToOOLxhpwuIX+fP/bpYCrBxcVVGOkJwb1jQ4wLRaLFcyLeFv7OV0q0ZKPLZgUn5sPzQPuM+7GbzGA0KLUF2C4pwboc/vNi1F5iAeh0EuwW2RP0T50gFAhCTj8eDzpQMFcfxwE/q4mMjvpeueOt4LatyPDgpD1zwOR0yM4o68ZRzrSry+uwQM4XajEIfecrD43cbbTZ7S1VzqXvb26s/78E9CPtUg30K/P62ZuqmuCVcpDVjMxW4F9N30OLkgzQxEB5q5qG8BNbg1mtvBFLp2UjbBZiONhHx0897vV2PAjt5/HzpWJx5zCZuHyYSKxjvjHm3/YPDH1EpJCyTe/vDDwiGuDN8szfMEqiiiHdju4BNSQNBoPN29Fxtp39ECC2ToD/BvMWG5mqKfbfUL4pGAoP9vT2/+9kzIahcXlGwLdBxu35WHQnSq5Dy9ip0w6fzz/Zql9kLbRDa8CvNv5aZcKalftiryfWeS49c+IzgLyWOrwR5/qNaK9zvtBrCwG/3x+4s9197e/tvYaphKBQ4EZH+eTZ859yOJyPM33hybX1lWtXLv1HLDkGrdX7b7VIf7NUiXppWPKwI+g/dfrMT7jdngdAxVS50UbOS6ivf/C3yH3yV2PRbaZUm6oQ2g2Lz71Rrcnc04pwK8G+WsqWqbMzMNDbP/ik2WzuaXc80ebNZbOz8fjeVHx/f4f8bejrH7inM9D1rla/JXaHtcPn69mNRVFwupnDEdoc52YUf9XcfrvDgaLDI+2OPZZrVbxVS6dTX56dnvpLco0is0bNRlFjd6mVpmQp/eah4dH3knvsR3V6fVvaA6BQ5VdrOMc9Xm/nQXw/A81tn5No/0nTbLcb8MemRk9khajq+f0Dju4XZw7Xhg16vQ7Ltp0f7IVOAnApQCagTMeqsQOnmsMvgauJriCsxA8gWcjDfjYLOSxDF+jEQnUU3CGdPf5ymoBMgyoxG/+eHOiF6c0tWi4P+/BaYtb700NPxD4QujfxregrHbgzLG/3pRdehfvHRmC8N0zz96XesLFilpIu/Mcx35GvIXWQKEWUJUzJ8bCbTEM2X6TigW67lZYilI6bHtfwAPxgbhFGI2EKKLH2PDIkODEijjn+2/m448X9ad/K0ZaN4/RUaXAkHIShcJcM7NIKBaQvi/E9uvoO+n11YF0VgTM6GA5SGRjtDkOXx9WgC0CPhJPo8BxNrzg4ytJSegG7sw608WOvzU5ZDDo4do6AuC88FnQMVMjvsbQePlcoUK9RPQGcH1iSEb+DzzWxukJV/A62muggoZOQr9XTMKTIPScOtLB/HXMMQPtt1hsEx5PNChacN7xwv+VUbh1y5wdX/xuPL5ZIwlPXrkMJ55XYF4/BmfpA5J7Vgb7B4XYvrFTy8Omd7U0UxNEC/WqGqxroZ6e9GtBXUpCVTgCt651l+qhRkt+S6E+z1kL4Scu4ZsG+jFaLlPax8YlPWCzWvja7wJfLpd3o9vY3tne25vlaTcpj54jBmCKGzRUC8t+v/JHJZB4EbQAK0MS4+SGbGm1bLdpfNyIJGJ8wGIxtObcODxMo0KZmCLLRfmXECsW1DKPjEz9CxuvT5PpuiBRXK5W9WCz6tc2NtXmytpjFc4bOlqO2DloQhlK7LtSuIYDGMWqn1rQyf1qNMceeY4naju2WEVNTDp3GOGiCDSwb1g4Lgw5ApZLdEqL9LDCvEWCgO33m3M9iBI8ZL76Qz3/h6pWLv8fUDL9lQf8PkdtP1yQCjN7XJuhHZ8hi8vDwZfIct9rsfo/bc7fZYhlT/hajqn39/b+WyaR+KXt0tA9yh5SW1gi9dm/GvLwBh5O0RinBvjJty4yOy+HR8feTteXhdlkTCPgz6dQLG+trTxHgmwFGNHBxYe4HTpdrkNwjwi02gylG+J0ZUF9zbmQ81KL9LbUNurt77rxR0WF2DA4O4n+5OD/7VfIa7RUl6FfS+7VSMGQlE8n6MNYd6fmfNZy77P6LxUJhMZNJzySThxtkvmY4HWfy+wPD5J70hFjCVdn0TqczRID/Gqiv8SftpLVstw3w16D7K40XGdX/ifB93+JqoJ/LrP9ktlAwPH99AR45OwFdXjfUNIOTEqyWN7QVB/1+2E4ewu7REWRF6v9YIEDBG0bo33f3GRGSqV+/uI27CJB+aW5Z+Jug5u9svdTxsYH3HnZaPQj+3fFi2oC/foGA7dnNbTjT3wODoQDVCeCl6DHa7jodBa+cKAhX5asCyG1AjY2RYfz75bklmCPbx7/0OgHkI9jtcDng/tMj0GF30M2g/sGz0/PQ7RMqgmFKwWY8QQE/pf1zenh292oHDVBzAgOhq8MND0yMNirnk98u7e/R/fQS0M8xOj06MQJOtQcI4EcRvlo9PeG459RyxTQGXlDJTxcLtDyhy2KmIoFYDYGCcxDAfalWpbn+eHzIJKjxx6kSHN0vB2w1BTq56uwD7cax8AdPB6cTHQ4cLe+nE8cVWRkI8ClDg4B71CuwkL+RbaIXRQqlyhIS6K87oORYv2GuYqrKSzPzsLKzS889Pc81vvxw4PzKBf/YXk9vf8RqtTnaub4IcEmuLC99BRqV+5X0fqXR2iB0Ba0Bv1pumxYdWenkk+jHrMq85AB4O4CTZqXplKDfzry2+vydA8TY/iQxFNtlcFSJQfL9pYW5b5VJg0YDX0cM8T3VDh+DWzWg/4YaKG3k9qvVYq8/Oju72hKGImAss7W5cREajUGWOdIAgmx2u3N8/PQvWKzWdyuPXTTAv7m4MP8tYgXy4vmTlJpr5XIp107fRIO/VZRfKWymlU+sFsViKaWsA429b6qVYOMV+5Q+e8tak/nSUkgMo5yBrq4L7e6LGOhXK+VyEZg1yGgy6ScJ6Cdr6z3smORy2b+5duXSH5H7juQkvdVBP4D6NceWrlRdmzp8/gF/Z+f7ofVaUN3f2/3K8tLCUyIVnR4zOQ/P9PUP3BEMhj+p0+tl65leb+gdHhn/9NXLr/0hyCuLSOBfWV1EOo6bDfqV16Ayj10J+JWiiBYC9iODw6MfN5vNbeW4A3WiFGbWVpc/nziIx5j9G4G5/2XS6eU2gD9G0P0q4wjM63ZZFa2cRw36BiaTyent6GjJhlJrZC4dRXe2/3h9beUFEIIUrPYQy86RzhU7TkqxVjrfyXVtGRuf+JjT6fqwmkK/NP7VaiWaTqWe2trafIms/UeK7RmyR0eXKpVyvq9/8NOgcn0YDEb76znmk3bSpHbbAH+mSUaITOAPRANGVPbHBQAXAtPjkfu+Z4mZuSuppZ8olMvGb752lQqiYc59p9tFo71KcKm+zAkK60iJR/YAiuIhYJvejUG/1wt+hxM8NjuNCmuJv2EkeCQShqnVLciWivS99VzcHC+lzH6LhxbYkxjeCONSuTw8R4Dd09dnybatApuACvtVCZDUgdNmAYvJDP0BPy0bSCPVKjBfGjSM0M+tb8PV1XUKhhEsCmKGYo45WRaT2Rx8i4zRE/fcAW6yTx0B4N0dHggSMI/bWI3uic4FYYBqohgfOh9w/31dfloyTwL91FHBC3XqN5NJClaxSoLNYDrmMTDmJHUAoN4B+U2eYJVCuUKV+fE8YSpCkfyNufw1XqDRY1/wEc+2sK/FFAypZGB9EonUfOFgBOBu0JOHziBqJXBUMBEj9jpOdD3ohPMjsAkEgI+A3kQAvV7UV5AOSCdpLfCN98066Jei/FK/6ieQ8UYwJ5UAGLiysg7T5FzSygFk/+Vaie+xdu2/P3z3stfkLGMNmXB3d2+7F9Vh8vApAgIP4Rj0szn9Jb1eXxHprqwnXXZQDodTd3SUkSadmkGuBHM6aKQjKz1XyhxkqQ/S96SSB1Ikm2UBvKWtBaBtB/RLwN8aCkcmiaH8cTLn2lIhx6oMBOT+5dbm+hQzFg3jT4zIpNrvxQjKzW7NQL9qKT0UhrLabG0ZzcQYfrVIJjnI8/jZuQmK93VdwVAvMeB+xWAwDCi3Vy6Xl8j4/hkxQDfg+DxK55XO10qlUmynb6hWDep0T6U4n7KPatRi9ll6qAF/CfRLLDkt0M+C/7f8utIYh7a0IAJdwWGz2dLZzsbJelck5/c6MGuQxWIxnZ489zNmi4UFLDVi7P/l1LXLf06uuwLIhcVuOdCvGD/lOt2MhVSP+Pf09j1O7ommVjtIJA6+t7gw9304rqNOWWJ4P1xbXXmVAKiN4dHxXybXl0yozWazPU6uvS/vxqKLIHdeaUX9bwbol5oyT1xLo4Vd09ln+hlZV1BL5UPtrulkzPLx/b2/EZ0oFaYv0v7r9elzuVy0nW2KTuTXNXYajBGtaH9DFQNk3uj1hrZFh6WG7KrV1eU/2NuNofgwrufN6P1a6yTrANB7O3yh4eHRXyTg/xSoO7N4spZvJBLxL66vrb5cLpUqzHYb7CHSt0VyjWTFsovK88j276SdtBtutyPwx6ZJ9xfz/HFcJPBvfjR4x3OdVk/mmdjln6jo+I7teAJiB0nwuRzQ10lAs99LI/aIuqmqPKO+roTwiA2x3j0q/i9i9Jr8W0scQiZfhH6/r14ujheY8A0No9APnh6Fb168SkGhnqDGV/ZnbfcHJot7Rwd6AwoK9nTD9Y1NCroRrqJY3VGxBFyxLFLJyYGRbWfyBdrBxa0oeB0YqR8Gv9MJautWtpiH716chiNq9wprtTyd4fhIMbvg2soGPDQ5TgE31q/nROC8srtXLzNHfyu+tpoMcNfIAAwGgzJ6PgW25Dt72Qw5hgL47HbooEFongLkQrkEWfJA/QQE9VilAAF+mWwDP+eYe3rdpcEJwFup0i/9RZ0C5J9OjOjTqLvBAEYyjlT8UK+jYy8AfD0F+PgbqmVAfoMpAlLOfsMp5JkXDKVf4omwGgvCGMm3oAyZKSn8IDI4eE7+fXzeO0yT8d+F+c0oBfuc6IAxc4bs+0MXFiY8/Qnyhp4YttaRsfExMn/aUnlHY3V7a+NZaAT90g21IlbOUOZYyoaeAf1qImNKsR+D4m8l+Je2zYJ+VhhLJz6D4rv1376VUX8NBX81Q5Gti80KZ9Wj/ZGevjuJEfHRJlEIWSMGSnxlaeGP4/H9DWBSIEBuAOH7evJdVYCPxhUoxBOZZzWWxw8zTq0ox1oGpCkY7m5LGAr1K3Z2Nn8A7KXXSPNn3+cGh0bu7QoGf4kAHAUtnC9lMpkvzM/N/H2pWJRqMQMzvnUDtCbUKW/ZsH+Kt7Qi/dJ+lPoQJmhMg2DLg0l0fxb4s6BfD43AX7rOlbRquAXSaVpF+1UBRzAYbjvaf5g4mC0Wi3h9UIejzW63TJw+83NiGozUqpl0+k+vT1357+Qcvi1Av8Y1p+U0aYhad/h8/TabvWVedqlUiiLbCJj7CCjWo0TiIEqA7OdGRsd/Dcta1k8ux5kIKH6SAP/fB3W9CjWn6psyfhrCrGoaLZppEcCka5H7sn381MSPeLwd90Ob7Klyuby5trr8x/t7u6i/I80jgOM1hwX+fKVcTrSzXVHgUjkfX++YtHK+1QUNsQyq39/ZdlUNqZH1dmlhYfZz6VRqCxpFh28E9Ncj/eT+OhmJ9PyyVi4/sX12k4eJz68sLz1dJogf5CkNasxHnpyvWrlciZvNjcCfbCMN8vTEN/SeetLe+e22Av4M3R8ba5xI9F9lBAMXHCo8N+kemB1z9f3J17dfeM9qOnqB1/NGzG8/SGfAREA2Rv97CHAPdLgpdV8vlffj5ZBOWu2sJlT8D8ECAf8IVA8LOchGSzDaGQCTQS9+/dhWY4uzBb0eiPg7IJpIUo2ApfS22WV16lCEzmGzwr0Tw2A1m+DVxRUaVRaCvhwx6MuU8q9DVCiJzInANuh1gcNiAfY+wouR/FQ2CxfJto4KhfrnFBzXquA227MRiz+q5/SVeCnVEcsfdurJj7A+fICMyVgkBF0dHtp7BMjbB4d1sIrbxkpup3q74cLoEGYfiGX7hCOlf1cFxX0sPajXCdHvzcMErZKArAdeivIzzAR8ZeQYzCpVBeBEME3+wzx9vXjsNqMJzFjK0IjlCw00Xx6Bvl7M7xdT8Rto/nW2A7IVoEZTAfYyGTjM5SDs8aDEbl1kj5OEEZUcf7HpRLDOFkwU8vpZe51rcCXwzP+ROYBOF3SQZLI5mrOPooVJ0p+9wxTVlaDpCXqOpjSQMcpNuAfWHw3duSGeE73JZDKOT0xOIPhv97rK53JXxXxKFuyzHnSler8sT4YYgbpcLisNihbgb1kjF47BhwTklBoe0rWtTAng4bgc260UndQCJ1qGojKv3x7p6b2DgP4fbzf3kxgVm/OzM3+YTqd2QW6UsOr1PNPBqtp2CoX8KvNdLaPwjTRWtCJHWsDWZLVavS6Xe6ydjZP5OZ88PNwHdaq8zPgma67u1MTkh90ez6fJRzJnCzECt2PRnd9fX1uZYrYhOcHYyBsL8lo2MSecHQfl3JHGm+23VoksmWiY+KDXl9fbEegMdJ0m12y/HqN9PJ/L5XOXVleWvlLI55WONum6Z50Pb2lrg0WjGe13uT1hu8PRFgsKI6pbmxvXxDGouN0e1+j4xKeNRmPo+Ft8JZlM/uHM9Wv/AI3rJgv6taqfvNWgv1WOOuuUrIPZrq7QXRzHtXIq8/H93e+iRoJiXNiUGrrPg/j+dkeH7+/JvPxZYK5Fcn0/RObpn5FrtwTq0X4lO+wNX/ObAFwWcLPjpSbKapfeM5nN7omJMz9ls9vbKj2KjdyfX56duf4nomK9Mn+d7Ud9npHzU2hn22IFAC1nVAMgVTjT20m1UY32B0PhMTIWHTdwKvhcNvsqGYc/KxYLB3CsQfRDgf7RsVPv9fk7f16tOgs68o6OMl9aXlr4O7LvI5A7raT5y0b8pTGhP69WK2nhcGWtepTJRKE16H8rGEAn7W3Sbivgr2jKqASbr4jjgosBLn5SVC1v5HSpD0fe9VSycrT0VOzKw4liKpAt503ZalGfK8ZhbS9OI76oDo8Pr90OAQKozQSEI6g2iVR7Ye88BcITwS5YjScgkSdArVqF6VgU+jo6oMNmF5jjTG9rongdAtCJ3ghsxQ+pwCBPUOPM4aoJgXSn20mp/KcHeiBPgB6W08PotEtvq31s9D3pRDlt+Pr6i/ZCtUQDvggW33P+NAQ8rmNfAwiU9jgB20gH3yTHVSagltLceUG0zmG07N/nn7x81jOISrA4RtQb+6XN5+7cyO6G8LsXl1ZhpDsoOB9IS2SywNcoVAaP0w49vg4YiYTA67RBsVQh/RUi9oVSmdL0EdzjfkUfBQXW6AA4blz9s+N3BEcL9hH3iiUVsdyfAZ0M5L1soQhGgx56vF5wmMwUiAuCfseguz7kvALVULOATeo4VhlAdoHdaIacsQSZUhHWDg6gy+UEl9kqROCl7fLiq7qWggjdOdlOgAX78inbOI1z5JjiKYzm78Nh+qiuSUAZCDR3X7zDi7oOZjDk7gqMzd7jn9gWJyQ1iiwWi5WA/jPEWFITldG8jvb3d58GbeV+NdAvA/4i6G8H8BubPJRRf1Bc15LxqBaZZNcC2Yl5K6L+bYhmSfmzatGherQ/FO6e7Ontbxv0YzRkZmbqc8RISYC8fjEb7ZfOFR1Dk8msRjOtJZOHLMVZ0xB8A8YJQBv0q+Uas2WgzrVZuorf241pRfulv+n3CLAznp4898+JYc4qtdPPiMH59OLCHEabUiAH4dJr3J7smtHplCuceiPAP6t4SzkebLRfbR6pKYfT95BK3B3pOUOA1cNms2VAOZ/MFstdjrN3PDB19fK/JuCCFcqVtApYB8at4lBTGyMt4CoKiUXuhDarYKRSyRWyruHNqkKAQefwyNgn9Hp9vWwmMgsPEwe/Ozc7/TU4XpukdVMCIrci6GfHsFmOumpJUVTydzhdLZ1tWBZ2Z3vrMjBiy9DoSDJIY7C6svSct8P3uFgjXeggp3OTNfA8UttBHmHXFEV7k9b7dpxMStZWg0aL3eEIjJ+a/KTZbG6Zey82PpVM/uPszNTnyX0/B8dzrFXEH3Uo2lp3OE4nBcy02CjKceCfbl4CUiuNrf4g64+lKxi+5wbGv5Y8THxzbm7m72pkXoE8p591KClz+jVBP5Z+nTh99uMut/tjcHwfqI97uVy+vrmx9kex6M4KNKY3SsfNVoJhHUPSGqlkceF1sZ9OpxOK8X5T7q8n7Z3bbjvg3yTqrwT/uCDgRV7P9wfRAPAYHHsfibzru2QB8tQ48G7zyTNPbb3cmc7laBm2VD5PI60b8QPgV3mwWczgtdtoHj3Wt8dofAXBJsdTYDhAALAlY4AoBbUcrBDQiNvo94nMITFaXKNZ/DoKwMP+DvA6bHQ/CCXz1SIFkx6bjUbSMV8eKwWgcN3GbhyS/JHuO1svW3+s5+GU22gzke+bkFFf46vw3cvXIYx5+F4P3XaKHMdWPAHpbB50ep2YO88JYoB87ej+ztPP3ts5OcvxvE4E/WZxHOFu/6nVpcxWyISBLvKbaPwQugPkOMjO9g9TcH6wD84P9dNoNo7V4t4eLCfiVFCP5ptzYk66uBzqZXR8qbqAELWnJw4dEqSPVgT4RiOYjAYB7BuMtNIA/R5lvwtOE2QJLJPxXdqPQ7fXDV6LTUXQkGmi4B6N7pNjMOj1dGylFAKE/hIPAHP5fU47lFMV6sTB6D+mB9jQwSA6F1DDoVyt0O0Y9Qbt/TJHrfkdOhQcPWcXF9eoo0dgNYAo3CicX4GRwIOR0xUnO4a33h04P6XjoSyqEFJD1uVye0bHTt1pMptvKGeO3OB2YrHoDGhH++nNiWwXFcqVXm068CaTSV8qlZRGkZJ2qxa5VeYis3RkYK7pMtM/pTK5MuWHvTlL37lprYVx3YxGK4v2E7Ax2Nc/+LE2QT8BpcWF6amrf8DUMVZGhVg2Rb0+OwG4DfRGMveSBCivK8a1gc74Bg1Zu1EjGZAjIMza0eE/384OyLyNkTm+onJOWNDOk7GwnZo480vEML8bWJ8tzxcz6dSfzc5c/4KY8qKMWgIcG5qysm8Gg6KWqEYj509yJijHhN2+Ml2DnUfKyCydW+HuyNlQOPKEKB6muVihv2NoeOTHpq9f++8gZ9ZoRVdvelOIqzUDHA3RRpMJA/6eU+3sB/UWtrc2r+I4BMng9Q8MPUmAgo35PLe/t/tbS4vzT4O6AOqtDPrbBbGqwnQej7eXzJWW4qLZ7NE0uSdI0X4W+LPsmHoEtVKplI6OMi+Q7X+U3Y7T6ULhzmehcR4qQf+bFe1vF9yqgf468CfHFSH3508ZjMa2asFj6k88vvf/Lc7PfQOOI9uSeF0z4E/nW7VaaYvqT/YklZxUgv9W63y7aTZKZyQB/aFRq9UagvZaldyL/n55aeGbZEwwl1AC/VJajTQeyki/lv2BS7J58sy5nyfrvYo4JYq1Zj4/N3v9r4ltVIBGh4h07HqQOxpYRgqdi3iPUh5MuVyarlSoWGjTdaHF2J+027zddsCfacpIn5LuL0X967n+cLxgFAiQqjwXvdK9lTsYTpRTXpqXzoJUTqRvEzCIJfZ2iiWIpdI0/97vdtCdWQgwlVTYQ04hRQAjxQhEE7ksHBHQPtbVRcEjxwvK7xjJphoCBFheGB6E71yZqivkI/Hc63TUtQGQzv7o2Qn4xxdeA3RKrGZi5pf3rlvfH7on9Ter3+socVU99hhBN7IHEOxzrLCcXojw00Gq8tlRd+TVR0N3vWzTmfIiaJSMx3pUsMPkOqpUK7xJb+IQIBv0+jpIH4p01V+jIwB/MNjph910hh4rzZ8X8+Ux4l9lVPQF/M0REG2k1HwE+BTsk7+RUi+UyxMp76IgnlQu7zjYzpPfmqm+wvL+PuymMlTZ32O1idoKKnYpJ+TCb+7GYW5rBzK5PAyHg1TckdINxH5JB2YmfQq63BDPHkGpXIGDbJaCbmQD4OZRH4An6zseWyKTpIKLHQ5JpJWN9isxssYMxnlkMsFjF87AzNoWLFPxRDKf7P7DQUf3vlVvKpL9Vy0649GIOxInnSkCL78BkRtpmBind5EbTVsgg22pVPIHxErIQwt6PwFPSspy/cZPzp00+Frq4lr5x2p5yKii7na53H6bzd5BjEybDoUwSN8qWDItuvODdDq1I46ekpLcUOLpRsfjDWrt5KprgX6MDHUNDY9+ol3RJwIaF6enrvyeKNTHRoWk49czz7Ja5GRfQ8rtkXN9ScxNVxqCquD/9YCXFlEjpcHWEL0NdAVHTSZTW0Z0PL7/Cl+rsfNXCfxrxDD3jYyd+rdkvskouORnxO6MfmZ1ZekiaBuA0tg2RMyMRlNbKTeFfE5pqKtpEDQThpSBNLfbE+kfHPqI3e44DW1Guc0WywTI2TfSvpUA662O+mvRrtUoxvQ5HEF2iL6lGB02AkC306nkXm9f/0h3pPcDrLYGmQ/p6M7W/7m+tvoqyB2l0uOWA/2KcWvlMFGbT/X8dEwTgTYcQCmBMcRWNmCdkUxo4NgRmTxMXCfX4ZPs9k1m8ymQr6Vqjqg33CHVRAfhRoRZKfDv6PD1jYyNf0qvN7TFxMPoPpljf0Tm2EvQWGGHnVfA9EsG3Ml98mp3pGeOrD/jzfZVLpUXoLFij1pKn5rTvx0tFnYuIfvIGu6OPNDmaeAP4vtfX1qc/zZ5nQW5BhEL+tl7PrsWNKQSYgrk6TNnf9lisTboK5Bxj5Fx++za6vIlaO4MYdO72EoT0gOzxVCvy688oEw6/Qyoa36cRP1PWtvttgT+YtRfMj5k4J8srnpBIZnHoHwZWTvk/ZIovEPB/2Jq2/v16Is/SS57N+aIozo+llfjmVrsZaRbE1sRI/xeAuysBKw6rGbwe900f1yiorP12b0EgFq7jLAU3ye/56ka/dTODowQcOyyWEGP+Kh2XO4Pqws4LGbIFcvUgYD7M5kMYkRcAKXokPjghXPwt8++SB0Kz8ennE6jvfLpoQ/ufnnjeW+sELce4z2hrj0+E/AOhUqhFrJ1bA85I1ceCp6/puM59JZKtZlpKj0ce47p4k1we/FY1o6HoN9bLy+HeeVXVzcoLd3ndFJHAFYy6HZ7BJE/ETxTxgLpR6ZQgHQhT9kP2KuJYJCq5SsV7tEkPw7RHoNwDjhV+IyOlOHOTupkiaUzFIR7rHaa50+3wx2L7eE47qdSNG3hCMUQCYScWtuEK6vr8OCpURjuDgoMAImpIIL/gMMJh5i+QcD/YTYHeWOJOhhQDBDnDJ6LDqcD1ghQX93ZhYn+CAXw8poKjfaIlsWM8+N+0p9zQ31wcX4FRRS960cxT9jZmRtxRtYnXYMxMqgyQId5lgTwnyK4/wzHTsQ2G5krxej21vOgHrGiNyWD0cjTkoc6HVcsFFia27ExxKNzW2/gcT3i+boRKbJJTNIzNBoE9G80BohBOezz+c/Z7I5RAr58THkzWevw+f+n9bWVX4nubM8wfW1WFeCmtTZqGrfM6yfj7RofP/1TBoOhrTrjpVJxZeb61d8noP8Q1EW0pHnBRiiw1ZDmb7PZzyqnRTqT+gE0GiZaOYmvF/QDaIN+NRq7TByKAP82S/hVMjvbm9PMW0pKpo7MvdDg0Mivkjksqw5QqVRm1laWf2NvL7YFcmONNQClVBs1Aw5TKVoa+0gbz+Wyyoi/NB7Kc6gmDFmPpmFkmhzLe/2dgR9lo9TtNGKr+qAR9LMMnLc04s/0QQ2MaelBmDF/1+/rPNPm9nmytlwdHhk7R+bYA8zYYxg1vrGx9hs721sIaiXwoZYadUuB/jZArFrKiAzw4wMj/W6Pt2VuOpnP5UTiYAXk5ZXZ3HSOea7T99OpVAzZNUgFl7ZFrsmQ1Waz5XO5ArSO+L8hDqk2nZJKDQRlqhYF/cjcInPpk+Q42irhRuZYcm1t5bMEgOKapSytywJ0dg1SAn8UFa0sLsx9ZmT01K+T86bKdOFrtf3trY2vggrDD5pru2g5kFpG+8PdPZMEdAehjVYo5JfIMWD/pHx+aSzYnH4l1V4z0o+ljScmz/4bs9l8F8jXMr5cKl1cWpz/j4eHiV3QTnOU9sOysFhneh34ezxej16vkzmm0bGwubn+EjRfI07aSWvZbkvgzzRlbi9SnKQyG2oLNS4a+ZcT199F8KAbpd9cNht0iWAeAY6ZAG8s12c2G8FOQLlJpHMLFHUQQTBfL9kmEcaPI8YGmOgKEvAfpyJtCCgX9uMQIkA54vGgdVUHvpjDPRQKwvX1Tfq3GSPhBr0sDx33gNoC940Nw4tzi6SPevj2zquenx76YPETg4/FdvIHhm9EXw4dlfOUF+8y2I8mPYPzTqNlf9jVu20ADiNJOfKRFNVly8CwtDt6859JrDlsRguNgfcHO0UALpSl+9rFK3CQydJj3UtmYH47RiP4j911Buz1VGGhzB6Ol8tqpY9OZwU2EwmY3d2FEQLYzSqBaemOXaoIIth4zMIHXJ2uz551ZBf0dnghSkD9XuaIVh/odDmF88IL9yVMD0BHiNNuhfvGh2F2awd24od0Z/i9H8wuwG4yBQ+eHqs7N6R0BAT4PtRpwBz8Uok6cTDNAOeDjQB8ZBjoyI+GuoPwwswCfPmF1+BMfy9MDvSAUNSAUzWTq2IJQvkUFv7GeYGskXedGYfxvjB878o0t5dN2uO51MSV/YXgpwY/8G2r3oxzGHORTaPjE/cTS2xA2gC5UWJe5frA4PDpdhwB+Xx+KpNJ74MGvR8flXJZjT7PRl4MBCCpefzpsyiaw4KUuvgYirNFevre5fF67yOH0wVtAAsCZvzh7sg/J8b5rzJ9VuZ9KqfVm940qLRaxrUajZYYjZxt/NTpj5gtlrZyQDFNY3b6+u+R84hiR5JxqBQ5AjgGkLLx7RsYuI9V0sZG5uDR9tbmq6AelfihVYjbzOvXVIPGh9vjCdts9rZE2pKHh1OlUklTOC8U7saUin9DxoFNecC0lqdnZ67/djZ7lIJGQ41lUnDMeLNjQo+TGJkeaNEwb7VQLOaZt9gxAWZ7atHZ+jVF1oLQ0PDoz1qsVq2SVE2beK2qRVbh9WzvjWwqNH+1aL9qfn9nZ2DQZDb72twVHw5HTjmczkH2mIldsb2ytPQb+/u7y3AcfVU6TNWiprcC6Jea1vWmvNbUBOqsvX0DdxoMhpYAltwPDnPZbBLk5VclJqZUJYJlsOD39ORaSxMwmuX0+jrwJ3PS4XA4vQT4HzL9V1vnb9Z4KVO1tEC/vaPD109A/6dE5fyWrVqtxpeXFn4nvr+3BHKw2265Ona9rpC1b+PKpdd+cXB45FGX0/WY3mAYIuNpQ0FPco6uxWI7/08icRCDY6dCKz0faUxagX4W7LOOI1coHH6wzVNR3drc+CKWpYXG8sKsE4k9T2oiwtSRSUC//fSZc//OZDIp08NqZK5+cWb62n8h94kcqFfiYB3myjx+NZ2haqAreJZ8RYbP0unU5wv5fAbk64RmlY+TdtK02m0L/BVRf9aDzOb6K1X+Ke2fgLdDTgSG2UIBJvpPC6Xe9JxQ0o/uQWkn86KivPA7ADYifXydUhcBAXajBODGMhnYIcAUgR6+PiLAESPVnJiTjr8e7wnB1ZV1Sst32yw0x18SqxOwo9CHsZ4wzG9FqcI7vvnlrec6fmb4iR2XyV5JFtI6PQGk+N1kKePYyccdH/Y9iDmKR8zxs1REbGwUSVrkKitHO2HcAQLpyf4e4ZhIf6dW12GfAOx6IgEn5LtjmcFvXbwGT1w4DxaziX7ASWMiOjDMpG89BKRvHCRgfm8Phvz+OnVeUiSUVPeRIYAlUq1mI7jECLvAwqjVx1bC1EadAcJuD3nOQJyMS7FagYDTSdkZFPjXBJcM0hg6PW7o8npgJbYLlxbWoFirUOfBcmwPssUifOCus0zuv3DMOhCqAjjNFnrua2LaBKYkYBaFVOLwwYkxMgZX4draBsxubsPdI0MwEA4IugfAM0iA0wT97PzBt5FN8J6zE/CdS9cpeyJfK3c8t3916P3Bey46nS736NipxwhArNejPsqkd+dmp6+43B5/m9F//iAefw4ajVc1+hmABuiH45u+Wn4tRvsbaNoWi9XbPzD4PrfH+25iFDngBg03g8HYT35nFpXQlbl17OOtptI2o2YrDWvL4NDwgy6Xu63IJDn2w8X52d8lxjI6blijSEkDVfaNjjWK2BHD9IPK7RLD5BliZGdAnkKhFgW64dYiz7gduih9hEKRO9uZ42TNKG9vbV5WGQP6OtLTdyrS0/vLCucHn8tl/3Z66up/LpfLUv6r8roAZjuSU4VX2Q9ntrQGnOVKeY+A/6rit6yzRnpo0tn7BgbvCYXCP6vT6WVMEWS/YclGcrodrfoh0sWUFTMA3kBg9Qa0dh1G9UcgGGpLC0JsOgL6ZekvZB4sLczPfiaVPEQPPXutaYF+LfruW6XS3W70WrMM3eDQyP0EzLRVCrFcKsXE8pTs+qEWPZWNFc5VchkkFGXVOLvdHiCL3Co0On7eUHZXixJ1WuAWx8qufHi83t7h0fFPtg/6K/uL83O/RYA4HmcO5Kr1LJOLZXMBcz5loB+E+Wgsl0uF+dnpr5DX/0RuvCaj0aSvVMp5ss5LIFfL6a+2prFj06xKjZoDydI/MIQO/pb6ENgKhfzi3m5sDhpBf6tIvzLVEEG/Qx3086VkMvkns9NTXxTLgKtV4lDaQEq7QmnQIf2Rc7ndj8jPb3VtZWnha9DIDJKl3jHb5m9nRX/WAXc7j4NWu22BP9OUtFMtob+6yN+4vf/ZzexrDxp0BkOhXIGvvXQZHpoco8DwuHifBF95EaJzzC5EeNgALQRwWKpUqAJ7l8NJQKMZluNx0hkesqjSvx2Fka4AzW/HbVrJ5z2dPthKHNIoN8eUrgNm8wiy30X6+JUXXwMsz54sZ01P7VzyGPX6GgH9Oh0natqT/S5ltkcvHsxv3eUbuwbym4G0mEmbZm+8VfJj2C7s9+LOUak/4HYTo7RKj+fi8ppQgYCAWYvenHPpLYX9UsrDk3fzhSK8OLMAj915lirvM8MEktI+Rsr7/T7YPkzC0v4+9Hqx8oFNPHnHI+4nY4YR9q39AyiVq9DpEuxYQTgQgIHmNCUCwXuIgH9kaWwlk7B+kAA/Ac2YdoEsBdbJgm0oHAS3zQ7PTM1AvlSmn0RJny4vrsH54QEmDUGg//OiBwaPXc8DwzxgnD3krYfOjsFXX7xCS/A9Nz0Hry4sUy2BsM8LQZ9HECjkJd8Uz8winnlP2DY6KjLZPLwyvwxSScZqlQcDZywFQ93dff0DjzHCMfxh4mCZGKZT5OaiR9pyOxdNtVI5iO5sXwN1USqll1uNvs6Cfi3xPhk4QUo/ufk/RPr4EdL/Dnj9RhtWnDRB6/JON6XdIMVfNeLv7wwMdwVDj7WzPzKP8sSK+FwyebgN6urG0jmTnhuEsQaGRh4m60anYtO1/f1d1jhpGb28wTGS+nMjkX5ZKTGMoLs9nvF29plJZ5aPjjJptc/6+gfPhrsj/5LMIzYHv5JJp//L9akrfy0agpKhyeaSKg1uZSmn+jhbbTaHwdA6r7dYLG4rfi+NCQ9yANIA/Mn2sZLHT7lc7idAoU5NAGtqfXX5+UKhUJk8e/5D0OLaqNVqRyCfN7dEuwEV8QZhP6vV6nE6XYOvc9d8sVC4MjMz9dl8Lsc62NSij7cc6G9SXUTNgaQK+jFCPDI6/ihZny5Am3OiVCruQyP9mR0bHcjXlPraQu5hKSUfkIBFD7wJQF9lrAAa51kz0TrVvH6H0xUaHZv4JLk2WzvbgILCAw3QrzXPlGXldCBfp1nbt+4UJ3M5Sx5qJXLZZ/Z8KFszpk1TUUgChEM+f2db6VkgBCWeAjnoVx4/2ye1dYD2y2Q2Wycmz/5rAvrvkO2A53Px/b3fXlyYewbkKSla7C4l+0nL5uCJjXPBYDD2se8RG+0vyDp8BNqMgts24q9g2TT9/MQJILTbGvgrov7YJGSlFPqTFP5peb+zvqGZ3XLir68mlj9lJKA5XyrCdy9PwXgkDGcHe0W1dqjnrGOEv14qTozy8rykUH/cH/xGpVqlkX0EzOgEwHxxjHBvE1B6VC5RYDwdxZJ/XppHjlHmga5O2CHAH0F7lSkXSKEhJ+T5Y/PY7bQM4Nz2DgW1M0frLqfRVsV+YLlBt8MGGwQwG/R67pndKw8MObuXPSZHBuSLChsNlBknL+1O9ZHdWvG4J3t76DHg8V1d3hAF93jwGhx7PzPyxMvk+Llnd68MXUouncIvoeMiX0YqvHjb5lhQKzTM7+/p6ABzOg3riQTkikWIeL3iGBNgzenpseIYum1WWESGgysLoz0hcXwFDX7pNT0IMfCH+fcoGrh5eEjz/lFfAEX6bEajmKghnDscVr/bCR+4cJZWQzjKF2lc/+raBq1ScH5oQIjKc8el/iTXgdzkYO8BPNjNVrh7ZBBeXlgi55GDQrkM0xtbcG1tnfaxJ+CnlRcCXjd4yHmi2xRZBTgOWCoxnc1RPYHYYRLiBK8YdUYoVPI1n9kd7/EENv/Xhz+hJzfPJ6Qayhgh2Y1FX11dWVogr83k5mYhAEAJ5lQbAUSvVCrlLChuRP8/e+8BJstZnQmfzjlO93RPzvkmJZBASAQBYi0wOGCvI/aaXT9rs7DrXYz9r8P+6/Xa68deex1+24/T2sbGOALrJQghgQQocHV10+ScezrMTKfp3P85X1X1fFVd1V0j6SIh6RNFz+1Q9eXvvCe8B8E58aCpWfqVoL8hPOK8teKPWgF/qz8Q7B4eGf1Ru91xHl648IZVrEl1UVr6+Trf8tKCxV9NwFazhCCYtfuHhke/QyeDf213Z+ePYrH9BWgWDCULhVLQl7EOO50uckN9j/LGpVLpue2tTeJO4AVBLTBDRZdV4gygX81VlO8vihG9YOJcgVv1097eznNqHwwNj9wR7er5MXnu5nrp6PDwN2ZvXv8UgGpaNjVrv5pyrNE2n88fNRiMbcc0n8ttqNyDJ/XjhduGUOvxejvGJ6Y+jPPnAijmfCadnl1cmPtqsVgwIGgbAB1rolwpJ/ix5T56uQijrSzXvMt6Q9lI80VvOkxFqedyucdnb1z9nXK5TG7rSmIxNS8pVdD/UgirOlL3qYE1KW1fI7Z/ZHT8vrOAfiq4jxyCuiWTf1UlNKvWqhnl/UzN4QW3SgGgRympBP2ymH67w9ExOTXzfXo5Wmq1anplefFXEfSvgxz08y7+Sku3EvhLdeYVLRL3DU/QCVz/qxmEWu31rVz8tUJF2Dwi5dHQ8NgDlEJPT59UKpXkzvbmZdD2RpSK2hg13PtxDKznzl+UsrQ0CspKx3u7Oz+/vrZyGbQNH3w4hZa3Q1NIlM1ut4XC4fdzv6H18KSYAUSNB0Srv1/xRQXwt1vTEt571SsAXtXAnyu8sMJvbNLmJ6UDawCWt0fv+mKhWvEvHG++24zgn0A6gWYCYf2dYRiIhFisNttdJa91iWEeX04QxFPOegKJ+WKJpX+jPPXsFS8CdWSNthqL4C7bYKorCrvHaQZM6TebCJSP8ycwEg5DGMEg8ZYHENg3tBji81hj8LVYKbM0d6SY2E6mIFsoEkg2HhWzFGoODqsZxro6IY7PKJYrpERwfG73qXu/d/Btfw/qrnFN763mdkYNokV7rLeLERiSByq5r9PblWqt9rbeO58R06qY7omcX76cWhzFZ1noVxv7CRjrkUA65xkBpzZ3anvE42UW9Fgmw/pwJBRuAHh6vsduh0KhBIVSmZEJrh8k4I7RYYh2+Jjng/CAeuM5EpkfeUyMhEOQyOfgAPthJREHv90BEa9X8KaAU0nahc94EMH/Fy5fZykVaazmtvZgJ34Id0+PQcDjYnWmVIP8JFPfmQTPgJGeCAL+ElxZ2WDvhZ2BEnZgbisX923FE0a8oFapUT4ZcNosLGtBEb/PFCxGIQyA7oPzp9zl7NjqcYSW3hg9v+x3+GBicvpBxGsNF1QEvoXN9bUv7u5uk7WQDtxauDPaqYfZH59Rje3vk5t/k5sf3lcZH942nlYE/Xx6vgZTP4Gr4ZGx+8KdkR/Gg1/VAlIqFQ8T8fiC1+vtc3u8PdCmkDVWJGm/pVagMxQtK5Eea78dwdt7LPrSPJHl4FMb66tfB233Ry1g1FCSjI5PfBeOhVIwrScTBx8HOehvRUCk6+BtAfrbpRJrcjc2my1eBCG63LZP8vlYMhHfV7YR5+LrItGuHxA9RoQ36/ViKpn4lYX52c+Bej52LWs/P/7Kdhm9Xp8eHoL60WFqQ3EfydqvJJRq9Fe0q3t0YHDooyaTWebhQ4Sd+3t7D6NQO4ftYnPM4XDqYhMvFotboB63+nIoeuaPbP+hMQ4Eg+eex7Pqx8dH/zx38/qfE4s/yEG/Hku/NG4vtbtuKyWJ1nprgLa+/sE7OiPRJvbzdqVcLmVAmwRUKavJLjrXlPczclkVzloXPeWMafu04vqdRH44PX3+e61Wqy7lO67Vwsb62q8n4gdLIAf8yvR9aiF4si6CZqVKYx8CdeCv5pGhlbq1VZiIVnaRxlzqHxi6w+XSx8lCJX18/ASCfykVpHKt8W1WyyLEzjo838wz5y/+mN3ueBPXdppgqZ2drZ/d3Fi/Ds3Ek1qgX2tuKMMMAc/y9+Ge3Hc6xvX87s7W7+C8Lmo8S9Wb7pUMbFWUkvyrnvKqVwC86oE/Z/WnwhP98VZ/WnD8QmWbw7t77vkHj8mWRPD6A7hYrRkE/YVkGSwWM6QQlPZHwixVW53fAuoC2LSJ6ZmJ9M1sFmRAYnu3I6gj0j5Kg0dp6igHPBHgIWiGqMeDoNYKywhkSUmQxudd29mB0c4w8zaYGuhuPEuyMNfqQv75zEkBzC7hnnchCH7k2k0WTiA0usZCBgJeDyMBfPTqLAPWW/n4RKx42BGxBU5A7j4KoLAC5qsF524uNUjp6cZ6oyBlv7q2usks2GQE7nIEV3qd4W2xJ7AHTKVhd/fWRn5/mCzw6wdxGO/tarjHN5za66fx8Az84/06EfwT2N5DgD4X24eRjpDQpwbBit/VEWCvzywuw1EuB4/fnIPecBDGe7pY/HtNaoZEhCiicqpHh8PFAH8ik4XjwglTAAQdTqZYsRgFb1jqO7vFCm+9dA4evnyNhReQciNdKMDnLl+Fgc4QIzckIj+v0wFWrJvB0GpvErwJZob62Fhf39iC/WzC8q7eu9fe23d/7Jn4XCheOg5v5fa7cpWctVAxGaqUB89oqtpMpqrX6jmO2APb3c7Q9jn/8IYJDDRmlUgk2jcwNPJus9ncIAlDwSq5vLTwqcNUiojHbOKcr4dCYV2Ha6lUWk0m4xvQPrZPGeuodO2ztHi1IOLwjk9O/4jL5b4fVFKKkZB3ENt/CoHsYrVatUxMTgfcOiAKfjfL1e8lA/1ndF9Xtfb3Dwze6fF6p/U87+Qkf3V+7uY/QmuyJzXlQ2Od9/T2T7ndnjcr710ulZ5dX1u9DOpC0POySrRwn23nJqrqdtw3MHA7Cte6QGwstndT8RaB/tcj6P8e3gJM2V4Sifh/W1qYewTkXCi8FUjJ6sx7mWmNu8nl9vRBm1KtVI7S6XSKu690DwC5d1ZjTIeGR+5C4P8fDAY5MWO5XI6triz9TTIRPxT7jtURhW5daQ/Tx0eLoCGIwkukDGhD6tcqvt/SEQoPWq224BkfWcP++9vFhTmK+6V9ppXbdUsOjJdKKFUBslqhR5pW2mBHaLCnt+/toDMVJF8QtJ2ovK3mgdBUxBCbb2Y/8fVpN6/ULP1SSIR7cvrc++wOR9s1L7a0sruz83t7uzsEQNXc+3nQr3Y+83aI03jBUyWA5P6vVI7zxjHeSKb0xFCOlZrHSLu4fofH443iXnWv3jEhJSwCc3K/V6bHVAupUrP0s713aub8d6Hc8RDIQf/h9vbmx7Y2N6RUk/ylxeCv1m7Zs8TPDYNDwxc9Hs/7+L7OZjN/truzvazxrFedtV+x5pSvWrJcXes9ut+rEfy/6oE/lb7+QTZh8vkcFBG4UR76WrVK2uMaWTexSOCf14Kyxfrm6O1fCdr9+Uf2vvEjBqPRVUGAu7izz2LNCchTnnkHgncJwFJhjuP4awKODoOQiq1R2PYr2beFeSzRuzHLvNkKM11dsHRwAHnKdY9vzu/HmIcB3a+uMoWJJK6MQLwmstv3IADuQWC8d3gsPBIrQzHudLkjdpalIJHOkJXb9Njelbu/Z/Ct5L4qxf9Ki0tmCfzawY1Ji9VsrVRqMN3fw2pMOesXdvZYC6q1SvUN4RlKRZIT78E23Hs6z11dWd0eNJksxr3kERwi2PZRXnvRS0LwWKgx0kRSIBi54yrk8mCbzbCD7ViKHzBW/k58jwA/NZXc4t90cQq+9OwNRiK4EUtCKp2F7mAQhns6WcYA/gRsOGQYqFFGiPh8eE83nGA/k1U9WyqA22oXCQOFUA3K3HD/xWn47DNXQRpgUgrsJFKwHU+xVI4UikHWfCvjZZCCDOR7lDTepCC5NDrAYv3nt3cNX9h5+vxbu+9I3xe9SIdNBQWEaqZ64jwu5c1Re+DYbDCesC7CeQqcFp5c7kfHJt6IwuubOaBSP8nnFxH8fQpBII1nA/QjmCMPbl3M1Sjgf00is6H60PPwld1H4BNginVKREvAhFIqmfE9BtZEdz1Zij7820zWtbqQyo/eMyPAIrb0D5vN5n5o3tDJjXZhdWXx0Uw6TYIOCU9Gu93RlgGdrYdKJSndB176A1Nqmx7QLxOMUDAJd3X3vhN0KC+wzQkc9z8S05KquX9KddESUkwOh8Pd29f3r0ARC47dV97d3f79FgRHZ7ZKaAjVWu7GreJm2d84tzs7O6O36xmQUqmUie3vSVZ0tgUNj469DiVQFMpkoL8oxnl+CeSgX0shxo9zK6HQhHPZY7PZOtvVtVAsbODxVIVmpYgBVDw4Jian34Gg7Md5jwUQ9oUrOD8+iftCDTjQT68OZ/t9gSzbiThTBqrGXuvp91tczhrfb40wZu0zFcob/vcL87OkXKNzTgv0t4vRfalBP99fTd4i0CYe22qz+YdHxt6De731jI9nBc8KCbyrcTOovX8q9Kv0Gh6OZX6MXqT+0apfK9CvFdfvHJ+YejuC3Cmd1aAY9r/ZWF/9Gsit/Gqp+1ox7auRzkkAXi0Eju/DuuJ+avduFVrTytrPLpw/rpGx8QeJiFfv+KAM/1wmfUwp9fSCfuVlHBufvN/n8/8A327c69M7O9s/w4F+vZb+VuEEDfm5oyOEIk/PR/AnjTVTqZSvL87PfgKaz9RXpbVfZW/i/24H/HnlFv/+q7K8BvyxjAwP1rhJVdP4mhYJmOGCf/gbnfbAwWP7lx/aPUncjjjHnMplIb6ShsXdfRgIC/HZAZ9HcFlHIEvgkF0Gg0gCp3ycoTFNlbndEf/CVLQLNpJJiONz6Pfrh4dQQJBFMfD1muTGfqo0oL8oHEC61z3T4/B3X3mK1YHep7SEEvP8XRMj8H+eepbVbefkYLpUr3zJajBLbP7SK0/MZl7Px2aoDVEE22QZZ6EPsQQC5gqrX8ju2xp0dW3BqTDKBIhOm3+/1965tlc+HCFL/pPzy/COOy40rONCRwsu7AYxll96j4rb6oDRThsksR/Itf8YcbAPAb3E4O+zO+F1Y6Pw6PVZKFcrkMxWmPdD7OgIejqCMNgVZqkETx3/uXj8OjDeALcVgb5F7ElRO8CyN4hf6/C44Q2To/DVuaXGKNWFL0Eqm8MrC08vLkPQ64Go3w+dfi8j7KNwAQLJdGeBt0+oBQ3fHeNDkDhKQzyTsXxx55n7jorp2r3hi9cI4LuN9rTbbmcbf11g/JO53iGId49NTH6Hw+Gc4OZp7fAw9SU8SB4RQXgD9NPVGYkO6GQ6L+zt7lC6Nnbw1QWhqsIpHhqqGQSb7OAj0kBxvC215lh+SRHQOBRFMqgPstRBilKrVTP7e3ufRqFngXgJQBCgSHlFDOh6c9fvgbYLqfLvW1JaMEBrMR0rierso2MTD3EkjS3GrF7d2Fj7IzGlFR/Pz8f0AzTzCjSEE+KFmJia+WHc25pyKOfzJ/+8s721AK1Bv24li073fi2rYxNZFtbdNTI6fr9eARLB26Ko7BVA/8jYndFo97tBpvCol/B7/6MN6FfzpgDub01LUCDY0acHOGUzmSWV+/FKBvYZre3pmQvf6fP7f0jeDqgeHR5+en7uxufEtWnnx8pitVpsNltbJu1C4WS2XC6dwIucvvGFFA0Qq2bta+IWsVgsLo/XN3aGx9WPjw6/sLgwR0pyLQusmov/ywb0c+Us605GngnCvvQOq9Uaev4PN2gpaZQKyibSUYquaxqYWq0Ezfu7llXagPNG6Qmq7Jum37TpJ7XQo4ZSsn9g6HUdofDdevsnm818BefZZ0CYX2dRLrVagzwwUioNtYC/WjiGVly7Fh+LZO13KC/cd+91Ol29evuF6nwQ2/8SyK3jamSGmtb33r7+SZQ9PgQcNiJ3+9j+3i9ubqxdg7OBfrVQIv5ioN/lcrtHxsY/RqmGuWemtzY3f7lYLOZB29qvZ1y/5YuGlb/VxZd250/91Wj1fw34i0Xc6KV/Kl3+eeFcdaJF7YHN7x184M/3iqnHHt555t3x4tGE2Wg25gpFmN3ahRubO4xtndy+KS+8x2oDh83KwB/KVmAxGxkpIMWS220W9l2JFZ7i0k9d+IX/p/cHELg67VZGdEfKgFg2w1zOxzo7BQwpAlOTaNGvc2uCyPy6QwHYPzxm9ycyPGnfJyb8kMfDQKvJaLZ/Zf+5cw903fk0nG5mIPYHAwd7hWT4sJDutpgtMN4dFTwLsCzs7rE20L9HnD30+xM43YCl/Lvwzt7Xf/1/r3yuFz+wHRxlYH0/DkNdEWYFF3QY5LFQAWNd6CPhBnWRIN/A2hd2eaDqrAkKAsPp+qfv9nR2wP0XphohDBRKkUxn4TiXx2cdQG9nCIa7I4wbACTPDH77qJ/2O3kdSPtHwx8L/znUE2FeEvPbe42Ue9SvjHugTnwNJva8dDYPC9u7jMfBhuNOGQQc+FwHjjspBoJeF3hdLuYtQV4ccRxTlNmNX4vduG/aNzQftHqTwGdSUFjX+voHp7p7et+PIKcBgimXLYL1v0SwfB1OD1yz+Js63t6IQGNQzzo5OSnMouBBJF6tXPyN3Ktk6bdiPZQCETsAxc9MKCwSw/gH3G7Pu7h7NEbh5OTkueWl+b/LpNM0j+ziPdiznS6nE0GpLmCXz+d5y6TSWvHNPADO6sLeEK57+wZuQ3lBFzA5PEz93/29XUptpCSb0xJULIpX0/jE1DtRCHuD8t4IkPeXF+f/CNoTlunq4xcY06+aD3twaPguj8c7oKevyNq4u7O1ItaxNjQ8eina1f0uUIDlVDL52yh8Pwzq7v1aDNJKi6Um8PcHAqM6qltLJOIr0Aw8ZMosQv0z5y9+j9fr+z6uDrRXnqCg/Psry4uXxb7kuQHYOAUCwZAeUq3j46OnQD3tmqoC4JsoaLWyyKqx07Mr2tUzje3Wa2ms53LZy3OzN/4a+1TN0q9mgX3ZgX6N7Aft3NZlVlrqN78/cPGF1MNssThAPR6al8v4+OiGAgDP2yZlGa5pyctQKmpAQfYqyoLK32j9XouwTi1uXbY3hULhETyv3wHNgEW1UJjd/OyNP9GYZ2reRmd1B+cBMqi8ailQ1O6rdbZJwFczS01nJDoW7oy8Xk+fcH2zhefcHKjLJmpKPxno9+Ne19Pb/zG5waFeSSUTv7q6svQUtLa8q4VuKfcXHvSzZ9psNvvU9Ln/ZDZbxrmm1I6ODn9rb3d7BQDaedG9HPlUbkVp5QHIv/LfVfaNkkNFKq868P8a8G8u/AJqgH+T2Vwht+V2pcsW3Pqh4Xf+xUYuNvxM/Obrt/OJ0XK94rBarCzunVjXj3L5xvclxv1TQC/OSQSPNosZLwt0+DwsvZzH4UCQGiTXaQGf4hVyuhkbPbm6E8DOlUtwY28PpiIRZq2mGxPYdVttYBaZ9Q3MpbwGd0+Owqe+/iz72+mwNupAgPW2kQH44nM3GIhey+0RIdZVaAb+bFN7JjF3zmqxGAjMjvREWb3Iur4Ri7O6Gur1o3u7Lt7AD4pc35rFv40+iyt1V3DimacSs280mYyGy8ur0OEnPgMH6x8WNoDAmZjucRDEWH5itD/Na09tou9IHAqyAcUKUcrDt5yfhi9dv8m4AaiXy9Uai8mf39qB5d195pI/3tcNTpuVfacui4Tj/S5U5AG84esmRhkp4GE2x8bxzvDk5nEhU4/lDwPJ4pEbx8NIxHz0mRnHltz6Y8cZgHRGqPfOLlknRMWJ4NlBmRpoxCxmq3nheCtwT3iGOBKUwL9qtdosE5NT7/Z4fbJ4+HK5TKT9f5hMJg7g1AVYsp6wjiLhXo9Vj75/mEp+FdQPIamn+GQGDUFIw9LfOAR9/kDH2PjkTyH4P6foYAZQkon4J5aXFp4QlQc2kGvZa16PL6DHYwGY50NyFV7CWGQd+eiVVjWZcGTFsUJh8e2gQ1gsFovri/Oz/wfUXR+VB6dSMGP16R8YuhjsCP3L5ufVKwgcfy2bzfCeBO0EFFbUDlkdoL+Ve78qSzYCkSm87gKd5egwtYl9xsJnBoeGZ7q6e94OctBfOz46+pP5uZtSn7Zy8T+rtZ/1O85ji9vtHmpX13KplEinj1PcGErKVD7Gvz5z7sL7laAf11Fya3P9f+xsMyWHBTTWA+4NbS1uuJ/l93ZZBoQXzOvwYpUWKfy08qor4vtDukn9SqXixtzNG38spjPkSda03K6/VUC/lmeEasYMPIO8ff3974Q2cf3YT8xDTMsDx+FwhEF9jQA0A3+ZAsBoMjZ5ieF6PuL+2Q7Aq6UzBZX3WoF+JahVWvrZ3uR0ujqHR8fep5etnubXytLCbyPApRhNfo4pw7dagn5+nimyWkmFN320cp/WKq0UbVqgv3E5Xa7w4NDIQ1L2IZ2FZJPHxHAzLbmEP+dkafssFit5qvxHnJMR/p7pdPoPF+Znib+llau9UrGgdpY2gX58qG3m/MUP43l+J9+QwsnJP87P3pDS4mplDOB5FVqeq9/KRSPVsXI/VwP/AHLAL61rPh0oKL77qimvAX+utEjvx/Cz+F4rF5PGRBxwRTbwSuHm5d3JxXv3T5KRZPG446B4HNzNxb240RildGx8ob1O2kUImJYrRcbAvyFass3zJrg43A8D0TBTCtB7BPzPd3Uz8J8jcFyrspR/o52d4LYIILnGEcuJuBJcCKzPD/Ux0GsUme0leNvTGQKf08nS2mVKJ5H13N7goKtrE05d/QVnAoPBup7Zm6wjSu0NdQhu+fjf7MYOmM0mBrq7HB03EfyfiL/lNcTUeLap3dN5bnb3JNm9XUwMU1aBJ67Nw4N3XWqw9VNKROJMIKv5cSXP4vfBYGxY/xuj1ATST9vcF+mAS7kBxvRPoJrtCgi+q/htItSb29qF5b0YRPw+sGLd6bU/2smeW2+kSQTNo5A+evPFGfinr13Gf+AYJJc7PjD60BfsRksGH1jfyh24lo+3wrsnid6jci6crxY8VpPVIOd+MOIpaeA6qU6xXsWoLXh9wtdPJC90yPPAvxrt6u7vHxj8YbPZwgvptVw2+8j83I2/RMFHyscLoAD9VCKR6Kh2q7gbVqvpvb2dq6AdvyytAQD1w08J+kWG8Z7xvv6BjyoOXVYq5fLq+vrq7yLA3BF/A3DqrdA4eD1ery4m5Eqlsp8RyNBe6hy4rYRsqc9UhaORkbG36cnvTmEY66vLf1kTXF15YUFNUGl48HCXCefWSE9v74dUUprVs5nsx9dWl8mTp1VKI11WCRUStnbs60pCKN59lgnXkWjXFIL3t+kVIClsRiRSquF6Gu/q7n0LyEE/kS394+zNa38DcgubWvvVhEK+bWptYn/7/YFuPB/aKuKwLkt1IXWmmsWf9TMKlu/1+vzfDxwYq1YqayvLi/81kYgn4BQ0qYIEXFdtCT9PTgo3UFhNQ3tw+1JYpfQAWdnlcrk79LoY12rV3OLC3O8j+JdS9n1LxfRTaUNSp1xzqnH9dCGIfSvO27ZkiNtbm08VCifHY+OTD6opa7H/x1Ser3RB51NTNhQAJqOpKdvIyUn+mGuf9Krk2VAqrvnSysVYS5Ekua83hR7RRR55E5PT76VMIzqHqba/t/Mnh4cpksHU5pkuS79ynkn/1lAAAMjPduV7ytJK0abmXdN0vuG55p6YmH4fversF6FzatUMzStQV27zdVLbc01TM+d+wGq1yjg9cE/759kb1z4JcsCvJfecFfRbz1+49CG73XE/37co612Znb3+vxR8OVrn6is6tl8D9KulGeb/LY0HgBz0V7n3pT2krnzeK60PtcprwF+98IPPNEMIGHjQ2s6a0Fj0RGLW7QzF8CJLAAlarhrUvFeTy6GV7F5w++TA2Tj7RDBqkKzWUnw/xd6LqdHrxjo8vbQC8XQaLoz0g9vmYDH6BJAnO6OweZiCeC4HFDk+t78HvX4/dHt90IicE13npdeLQ/3gsdsYwR9zkxfBM8Wej3RF4MrqBp2mhmfi85cQ+JPVWJbre/54s69cr/pNQOkAu5iFnjISkBWddV61Vp/yD92E5pjiJlf1h3rf8I2/WP1sIFcvBQ7zeXj85jzcf36SucobmAeEFQqlI/jy1TnoCQXhjecnmPW/EZfPDY7WoF4aHWTEe8lsTnDlwCd3On2V3VzcbDFZGKneViLFvr+8f8Di9ruCPhiOdkJfJARWk0UgG9R4kstmg7vHh+Gr80t4Itdcn958/ML7B9/6OfxRqc8R3sdrQWr3Sna363pqdfKgeDiaLZ905MonVhoGu8la9Fhchy6T/SBg82ze03nuStDiOQa5treKh6NhfGL6QZ/f/5A8vVgtk4jH/5As5KLCQpqT0qHUmMcWPIA8Xl9b6yKVXD53pVQsklVLCW6kzuA3Xi0BW3YAjo5N3BvujHxIJZ6/ns/nPj83e+NPi5Sb8TSfsARSZIevy+2Jgo6Ch/k8B4S1SMhumUCuQ8hWs2g3BG1/INiLly6SulQq+cVkMrEN2hYQJWGezL2/szPSPzg08h9xb2iyouE8+PrNG1f/DNTBrybAUfapSvyeGt9Bq9SGSvZ+Bv57+/ov9fYNUO5n3WdcJpM+wOuop7d/EK/7lAqDk5OTJ25ev/rHdcFzidqrJnRrCYbSq9J9uUlI7AiHx0EHGzqO7YJiHsnOpemZ89/u8/l/kL9XuVy+vjA/+1/Tx0dp7n1eGdgYG/LCsVrbewIdHx1+HZotYloeNbe8tLFea4EQaV5Zo13d5/X0P5Wjw8NH0sfHu3A2MPatAvp1s69TBoRAIHhHu+flc7md3Z2tm7gHl7u7e1bdHm9TSIvdYR/DMymQSR8XQQ78JUudVM8mQGU0mWQZKIjM9IRYm7XBO89iD9A8T1v9TiuuX2nplwC/W/p7bHzyAYfTqZPBn+1Nj62vrZK3nXKe8QomTWVruzmm0wtAWbS8J7RAvxLwK5TaBsf4xNS/OEu/NPonnX66WCxkQL7GpHrxskOTtX94ZOxut1vGps/2yZs3r/22QmmuXL8AckOHFmGojC+HQhrPqYD+Wq26tbK0+HMoo2Sh+Uw5szL9W7m0Af0maD5HeXkGuH6RcAZw70uvauErr4ryGvDnys/+518w4gZYU7H6g81uNxDjP4jGeNDe5NQsCQ3hGIVJ+3YmYc5XC0aTwVAzm8xibnmB4I25tuOT3Q47gtsAs7rTZbOZGRFfuVyFxHEa0icnUCxUwGsX5q6E5/uDQfK5g00W92+EnaNjyBSKMBoWvOckN3hJCUCM/wORMIs5B6l14kvY5wXK+EfVQ3BKFhDaoHn3VeNzqaUZI7Hc432GoiEWk08x+qVqFQSmHWP2fGBoA+qqC05mCbOZLOX39t//7CfWHr6vZgDLVjwFT82vMCLCmthH0WCAHPpg//AI/vbLT8Lrx0dhsr9HdI8/vbWqYZ7ai0j/bbedh7974imRDwBg2N+bf0f0dbEn49d9q5m9IEUNCPoPoZMo+8FeEnH3zSVGzNcf7oD+aJgpTKr1Uy8J4RF1GO6JwNpBnPEn7Jwkhr9ycH30vs7zfIwY27xH3N1pvBaE8SCYYTCTa0MdTwCRtI/XWDYs/MSgj2C5a2Bg6AMWq5W31tfxwJrbWFv9jYOD/R1pjEDO8i1TXoU7owNms7ktQRz9LpmIU1YGicmf3YuK0WhsrAMxjWNTfBspJiqVitVM2goDuTbWjZQyx+cjF2S5NZnIdBC0/sHi/OzDouKCF/iaQAoeoHabzaaL0f/4+OhZUHdJVgWpt6goDzT+AGvpCjk4OPx2PRbscrl0sLK08Ag0W/mVB2RTGjm6iOwRBSIiHGrqVxzHxbnZG/+tWq1K+aJbufkrORQapQ35mpZVvBWjOBO0B4dH7unq6nmLztCPRslm0snu7t7e/oHBu5V9XC6V5uZuXvtNbHMe5AK3mlVXKXjybdSypjbiQL1e/zi0KZVK+RjX4y53Txn4n5o+9y/8gaCMyK9UImXNtf+GQOgE5AKxat7tcLhzBNq7bedEN39dKergFlumdAJZHoTwQIT9G/tNF7s6btHFrc2NR6E1GFNbDy9X0N/Ogq0kYWOp+0wmk2tgcOhBFa8gRX/VKxvrq4/hnGEAbXtr8/GJqZkh5VrDZWvDNfj2m9ev/hWcencBKIwOIN8bUJQy27Ausv0Kn3V0gkWlncp106imotqGFr/TynbAW/ubQH9Pbz+FTt2md5xwre/iWfiXII/p58NIWrmgn3m9aX1fhexQKWZpWdfVDABNZ9vwyOgbeaU2hYPoOetoXuEe9BVQD69SAnMZf00w2BHBs+4ngNsnKQxqbWXpl1Hez4M24FfzTlNrrwz0OxxO1/S58z9ls9lfx/cdynwpXA8fSyYT+6CeKlCLyb/lmH0rlhagXwn4Zd4+IDc88aBfzf3fCHK5SPrsVVFeA/5c+cVf/MX6L//Sf1Fz+a/jJsAfPjz45xc9LXLakGljEwQAI9RupNZCa5nd0VQ505MqpYMEdEwmKYZcIO8LulwsvpzcywNuJyODI5d9Naty2OdhANbCXOmlGtaFlPT4f2EXxf1bYDEeZx+liwW4vrsLk5EII8dj363zdnIxs4Bwo4YFPeh1M56AGjY5Vyk4q8Z6wFQzZKV+KUPVtpk/GKI0dd0BP3s+hQws7e43iAm7HR2zhrqBzwerpbVj74dsvpO3dN258IXdp6Zxzzcu7exDvliE+y9Ms3tSm2f6emBuZ5cpNp5cWIaNeALuuzDFQh+kDpFa1nwy0T3M8HYE/5995jmmTHlq/4YXIlB+T9+9S1WoLT8Vuxmcz2xG4icpv9VqF1IuiNkX4ukMu55cWAK/2wX94RBLjej3uBhZo9kgpPq7Z3oM/vGr36CgQ8Pl1Nxbxn2916K2ALmDqlkEqa8M9Upd7WCVuSsRbh6bmHqn3x94L9aHi5GsV7LZ7Cfn527+ZalYLDSaeyrcqx2IxlA4PKlnbVAKvIPY/oJUf47F34AHpdoBqyS1sVJaP2LvN5uNtplzFz/odLmaUtEhsNrd2d78JTwEl7j6Su7LkpWHB1b1YEdHt544SQIpsf3dWdB221OC01t1ELQCuZrCUbSrexL7TI93Rh3779MI0CU2a6Vrv1nxnixetrund6x/YOinsU+b3FBxfDaXFuc/lstlyS1G6e6uZtlsypLSIiWWUaU+au79yiwHUi5s1+j45NsQsN4LOkJXlKWru3dKzCYiA7vY5oOlpYVfKxQKx9Aa8CvDKaT2Sa+t3M3Z3x6vr9Nms7UNW8mk08tVIW8m33+sIJh6IBDs+ABwwixuCY/euH71V/Eck0AQv16VFk52+fz+tuSRhZOTq3jLtNgHasqPb5rF/wzWazVAyy4EHt16+p8K7rdP4zqgQ1bNyq8V9tHY919moF+PlVbVzX9gcPhuu93R0+6ZR0eHVw8PU+sgrpNUKonT+PgbPp+/icTN6/XdH4l2PRXb31uE071fC/izy+V0Ec+LTIldrVYStZqQXlbjktaImpu/Wh+180aS+kgV9Hu83u7evv63g06PEjpntzY3/kjkKSiAPKZfS+F4SxTYGp5afP9oeTRpufc31l1Pb98FHO8HpT7PZNK7W5vrS9MzF+5vVy/cgxZxLu1CMzCX5Ep1RZHJZB0eGfsJ4jbmepx4a349kYjvKfpTzbUfQC7/yzJdgQL0kwfV+MTUxywWyyTwoL9ez+zt7X4Mz+xF0N5DNEOnXoGgXypac0qW+pZ7lSnwbHa7cWJi+s14TCZv3rj6OKgDfq0Ql1d0eQ34axQF+FcKr9KEoQUpTUparNJiL+IBVPr42sPfvp2P32UCo4Ms+2QVJ0BPv6yUBVb3vs4OGIl0QjjgZez09DS2smsNegFZYbMVv0es77U6lxPeUG9MZXpx2+xwWw8C5FhMyEOPMiKB/5FQmBEFCqSCp3OeBF4hm5wImA3E1mNBMGuBUr7CQDz+h4eqoRHy8Gx8YcBiEnztKU0d3ZKUFduJFLOkV6qV6r2Ri89wfcRvlppMpzO+wUOsz9rDu88MUWN3U0fwd48/BZeGBli7t5NCGnaqExmbY0dp+MSjX4OJvm64a2xYID887S3V8Q37vXDH6BBcXlljCoTF9FbHZGgwHajYV+/pPLeO1/JRJWe9mljsWsvtdyULxwGT2WySeowyGOQKJZjf2oWbGztCDj4DZUuwgd1mhRL2ucFQZ94SRoPJej25MhTtvnMN1Nm++Tmlpp1kGz4ejGSN/IDFYh3jv4eAdgcFpF9bX1u5IgJyXjgC0AD9TqfLi5cut7psLnsFgSTjFyCPg3pd5mKhFIiaXN3EdH1mh9PpmZ45/x9sNvtdysEpl0rPLi3N//LR4WES5G7pUl818RPQ54GAvowECFBuInjLgDZAvaXucy3i2FvlNmavJNB29/S9GXQA2mw2M7e3u7MMzYKKch3ywJ/VZWh49HXRru6fVArQVPAA3VheWviPh6kkCUVqoF8N6LTqz1buoVqhIrJ+ARH8U87nyalz7/EHAnfq6SO1ouYhQK7CKID+xtFhahdOrblKwjY1S7+aZ5Mao7SsfeHOzgk9Vq5EPM67+TfK2MTUWzo65KAf5/znr1+98mvlcqnAjYO0Zpss/XQhAI5YrbaOdvVInZJ9vqSpplqkx2yXRoy/rJ2RiF5Sv9r+3i551PBWfrWUfarg4WUK+s+Sg55Z+z1eXzf22Zvadlatmt9YW6VUazmub+orSwufOn/x9n4EQ13898lDbGBw+IP5XO5XEAQmQa6wVAPeJrfH09XsqVPeBnWwLwt5A7mcp4wNVwP+WqEQSs4Rt3SZzWbf2PjkQ2fJS59OH38B93LKHa/FH/FN9yhp4SnSisxPUtw2rb1wZ2S4r3/w/dLY4Tmdmp+98QyO/4yO6tTj8YPHQR30S+OqyuSPIPzbrDbbJf5e2Wz2H1ZXlp6G1oCfD6vSyhIi48rp6u4Z6R8YIh6jblnl6/XsQWz//0HZ7TlQzwzTjjPlFVN07OFq2Rh4BUADyKOcaT1/4bZfwzX3FrHPBkCb2O9VV14D/i0Kn8vV5/OTm7DS6k+TSLJ0mOE0x2exbKpbtrPxe20WK0PztWoNjAgbyX0/GvBDNOiHDo8HqrXqadi9gOobuxXvf8Kc9OvcDiS6ojeQtNHIPAcyxQLkyyVGCEiv5BnQuB/+aDkRhyg+txfrwCsOTNiUukGy94smYvxth9cNmXwBrGarYf141zfq6W0Qp2zmY31k4afv9YQFpSmlx6Mf0739Ftdet7ODNNUWOAVw0mapJAviXS/N496+QqlWTnzl4GonyxJQqcJTi8sC74GRb7nYAmz/8k4MFrd3YaQ7AtP9vRDye6BSYQoLXsXR6MtzQ/2MhX83eQip3BFsFA76Ip6xvdIJs5hX/WZX9v7obfP3A8xVDDXLlfhi504+Hj4oHEbSlZyXiPnYqcJgk4AZ8gj46YK6GE4hjGA96g7GQTvNl1rogzT0dRTA6ZB6r8frlcXy0z3wkPzs8uLC76KAcIRzoM4Bf96rQplSjF2RaNe4zhjoWiJ+IKXr4sMQ+MOP3ZsYyfFzVc231+cPTkxO/4xS4w0CAdNnbl6/SozFBZADKElDy2tqG31lMpktLre7LQEZFVy/3wB9BHS3smhZR9RiaRvro7un95zdbm/LY0Buj+urK19UtIN/ltSnwP1NGR3NU9Pn3+fz+9/Pfa9RKpXK/NLC3McOD1MxUAc6Z0khpXXAawFjNaB2SghlsXimp89/Hwr+51/ksarF47E/3d3ZJo4SpVW3FZmW2pi3szwzJajfH2jrgYMA/jiVSsSU74+OTbwxHA5/gA+dEUH//8DfnIBcmQbQLNQ29obOzshEu1CJWrV6tLe7LeW2bueSesusUzpc1ltxREiXjcLw8JxvG2ZBhbJlxA9ipFxrxfOgOi9eZqBfSymlBWYbF/GyDI+MvtNobA9kU6nUV/P5XAxOlYSsT3B+5hBo/SFldME9SEbohkJ7ZHJ65iPzszd/k7g3oIWXEl0ul3sAFIowPFe2QG4VNIP8/FUNH1PpHy2vCLVsB0prP7P4Yxvfarc7OvWOFe65saWFeSKX4137tfbcbzZ3RCvQr6Voa/aw8Qd6hkfGfhTHnimaq9XKycL87BN0tHeEQm3P9XK5nMQ9aI4btyaCU1CxEoc7IwP+QPB7gZsveK/l+dkbH+dur3aGKs+uVqCfyV+4L78Jn/cT5JHG150s/bHY3s+uLrNUga2IYjVB/yvF2q9jD1fuTcq+bpD7WaxW07nzl/67CPoN2M/H3OdasvarqrwG/LliNRuaFpEI/iXQz2uGpfgRHvxLwL9kAUPGbrIk8Mtso780MgDnR/pBSqVHIFxw5eeKgZ+Vp/KZBPLJSk/gnuLyK/haxt8XqxVmXc4Wi1CoVolmn4Faj80K3T4f+OwO8rGG/Uwato+OmCt+LJtlqfFGw51czP8plK6L75JRl/gFqJCnwmEhHQQPMFf/mqFu3M7Fusjgb7WYoMPrYQSEa7ED4T54vwF3F7lrW+H0cOUBqQT8mbtgvHTcOXe03reLwDpTzruPinmL2WikFPanfSO620u1ZB1TF+p5KTxWi2dTsF9IGddiCVjZjYHTZmMkgOSN4HML7cidFKDI0gIKfcmUAngfSt/36PJT5qGLkS4f2FLcOLNXc91YuCs0uXEXTK7Te/layXHzcLlzv3AUjBeOAseFbEetXjHVDAazmaVbNAgVw4oP+XtuXPCNXBVBudIyCCDfjOC0gVDv6x+c6uru+QBuYr385ziH4qlk4jeWFue/TGCP7luTiBCEwqf0kkrjgKZ4zEBQXywrHojx+MHBGjQLsUpXSWlc+Vg6dnV0hLpGxiZ+DtuhPMwr6fTxH8/euPbXKqR7vFJBVfMeDAa78J5N5HPKUq/XCrH9PT4jQTuX5BcVpCis/e0ESFnKLLK+R7t63qjnOQjMr4gp3tSsFEoCK/ZZKBSODg6P/Bur1XYemg/DOoKcx1Eg+uVcLkvCt5LY7qw5o/Vq9ZWWIlWwZnc4AlPT5z7ocDgbbukIEvbKpVI12BHSxcyuVbKZzJdWlhYfhvZCt94YULU40IbC0+vzR202e6RdvY6PjlZEN//GGA2NjN6FwuUP86C/WCg8cv3alV8VQb8EtoDrd1WPENobEAC33Rty+dw3cG/Iw0tondJhvW5FUCe7AsGOPj3ZFKgtR4epx0Ddvf8FkazdynIG4VoPlwa5+L8ewXbb0COcqpnN9TXqr5zYZzLW9WQivux0On+vt2/gw/LwNayIxTowNXP+Y+ury39wcBDb1qgzA1gOp3NAOU4ot22CHPRbQK4A40MIlDG/rVz89Vr7mQJgaHj0bpxfeizYjbojoP2LUqlIYTRamSJ0s/e/WKVNmkwlz5UaeWbDu8bt8YTHJ6Z+3GQysTVH8tHayvLjuWz2hKz9JpPZ2q4+uA6fwvlVgWYgzo+hTPFDLv4Dg0M/xnu1iZ5dv1PCwt2eb6NyXihd/Jss0Far1T45fe773W7Pe0ChTK/Xasm9vZ2fWV9blSz9Z7X2v5JBv9YerkWaKH3HgGNruHjx9p+zWCxvlcarVCz+Kcjlmlct4JfKa8CfK6VK3aAF/ldW1w24MfCbKw/86VUC/2wR1yv19JuiF3/r0diz/9loMDlmt3YgEvRBJCDIFXWZRVh01Zfc7OFUKiPSvaNCHrInlFavxMA+/Y7c05kJvSYQ1DksVog6HOBGoO+z2xvPIGBL1vdOlwd8NgcsJxJQwn0yXSzCzf09mIh0shADKa6/wcEnvlBOe3qQEe9xXMrRgUY3rz2bWAgbjCYzfY08GASFRI0x4hPwLZULtTs7pkjbTpu8pFEHON0srTWouZ5OzE/OHq+NHRazfotJ6HzmSm8xCzwBpOTAPmAY2mgAq9HMvCSMJiOp8tgNXWZb/S2hi6W469D4yfXHLOV61UCEg8VKBVb2DmAZr7oY2sB2FaNB8syXSb/Up5+4+fneD469Z9lYbyIF4UvdabTm7uqYXubGvoL1rSTLGdf68S6Cf3M54PDmA26f1VWzrdarNTVLguye3Culp/OOjI5/r9Ppug8UKcWKxcLDq8tLv4kgLwGtc4Y3YhbJjY54+MR7mVCwj+i1PuSymcu1WrUEHKEfqJPEqbpgRaJdg4NDIz+nTNeHtzlJJhO/urQw9yWV/Luq7QDF4YDgbgR0bOSFQnE+n8sdQmuLHD8GL1rR6YasyXrc1d0zbbPZ2o4VKU7W11aeVKk/32cgttfgRKl9eGTsIY/H+26ydjbfsV7OZDJ/Nnvj2l+gcMXnij6LZUKtHq0saK3yq/NWIyuukcjE5MxPooDVCFfJpNNbszevXRsbn9RNnqVWUP5bmZ+7+ed1IQ2pFmmbllCmNt5Kq2NT+zo7I9M6CAlrsdj+Ij9Ig0PDl6LR7h/gydUQMDxx4/rV/14ulfKKsdGy9jeErI5QuM9itQba1KOeEFxsdQmpt6LoFBjbkoqJly0c7tRL6lfY3t5Us9K1DCF6mYL+Vsz0WtZ+yi7SH+3qvk/Ps4+ODr9SKJzQWSWRgUr9JNXHuLW58Q2z2fI7eM8PKbzamOV/ZGzio75A8NMrSwtPiJwystheOt/sdrsM+OP38ggM44q28eeLEZoV8Vrrlw+J4vdt5bySZRch9348x+/HNXURzgA48Kx6BvvkMjSHkrSN63+JQL+Wp5bq5XQ6A5NT537SbLE0zrXY/t4zBwexGJFFkvt/u/rg+BZ3treugPw8lbxLlcaJRmYjnEvvsFptE9ytSEH0j/t7u5uK8VYaNoC7pxrJXGM+hsKdPUPDox9GADqlHHc8S7e2tzZ+BuvOx/S3I4p9Rabua8M10orgt8mzgs7Oi5fu+IjVZnuX1Odk7V9bXf64/hq9OsprwP/shQf+BtzYa5VKhQf+1Ke0QVtuC4xdR9D961+OXfkP+IHzsWuzMBKJQH8kxGLnieCPALtw07qoCDDInkQx7SGXm8XlE7AmEF8ma39VUAC4rTawmQUFp+S6X1dsCfRvlmbPaITpaATWk0k4LJwwYDy7tw8TnRG8h+k05ICrhSx9vSBYMuC/kdmLChb3OkT9PvbslZ0YWIxCqE3EEdoPWF0V6fsgt+Ca1/J7A4/sfuP12UrJQ28yDgQQ0gg67VaIBPwQ8mC73S7wup2Mb4AUCgTOyVPi2aU1mNvcZTXzW1z1k0rRuJbZM0ZdQdjKJ2R1Z5zzBmE/F7gKoJHVQNZVpOCo1UuGOpnrDfyGrxbvJbWnAeIJEAfN7sNgx/jpJl6m11oZTj0eDKAuGLO/8dAzoaDwJgS032M0GmXWJzzoDlKpxP9cWph/jAPKjQOiUq0asY9q0Mxw2rSJdkai09x3WpVaPH7wLDSHJ6hZ+01SLD80Ytt6RwcGh/4ztkUWL0wb8v7+7i+srSw/A83ggfdaMIB8n5JZJhH8jehoA6Sb3fy/KYRIinqrARQt0N8AJAjq7tbzgGQycUVMBaRmZW3MUxJKurp73uJ2u9+GZ6VqHmmK58fx+dWNU4tEQ6kJzZaJVhZeNQuaHq2+Fus6e0VBegDXyUdw/20QsSHoX0fQ/w2jyeT1+QO6XWqVhUgg11aW/j8xNzvvZqsG8LRi2fm28oBBValBlk6s80S7uuH4JnEuH4rPqvX1D07jGvuXFGIjfadcLl25ef3afy0WCzmuvsrwHKmOTdbTcDgyA21ASqVS3juI7S+BfrfUF01YbZMCspWrMQ/0eQu23WIlh4tAWzJDKvlc/rlioZAG+To4q+fLN63oiMnWyrGumjUDBevA6Oj4Q7int7XIEvje2lx/DE4Z6SXwygN/NmYooD9OShXcmz6C+5LMLZoUk+Fw53d7vb47tzc3/jkW29vh6m7Ec6DDZDLLGP3LpdJOsVisiu1SUyqboPX6BWgN/JUeSY1+crpcndGu7ts7OsJ3IPjT40XSKNQHa2vLfw1yMj810P9Nm2dnAP1a1v7GZbPbPVMzFz4kV9geL+L4U0iVIxLt6sPP2nrxEZdNPp/LgVwJIxkgAJr3BCOu8XAw2PHt3PiSR+P60sLcZ1XapOSA4O+p5nViwjVhGh2ffKCjo+NHcQ67lXXGZz27srTwC6lUktj7tc7VV0XqvjMQjKoS4cKpdymTEy9cuv1f2R2O7wBubAuFkz/Gvk6DQs5+pfXlWctrwF8skrVfy+r/x/0D8A7B4k+ljhOMDrV6CQ8Wk9lsrCL6B2HRyrSAdwTHL1vB8ktfOrj8kXKlGp7b2TWsxg7AajGDHwFtX6gDukNBcFitDKlKFncBnIp/1wW2fBMx8huEk0WK9zeKrv2MWQ8kC78A9AX3fYMYQmBglm76KhH87WfTLNUfhQzMxQj8d4LdzHtInf4peQKU6xV6tI307TuFRICFK1SqMNQdZfXYTqYaS3jM000EYPR9ybWO3QohtfXzu09fnD1cnzSZEMYLcQzMc2G8Nwoz/b3MLZ94AyQvBGnbZeSB9SrD8J0+L8wbdllb46W08fcX/8lK/VMXlR9UL5/bxbgUSDFiIQ4E/KyEw5QtFCCdxyuXb4QPkEdA1BY8fk/fvQsGAfTTBiOlz+PDO9glutdzcQeyDbqJgA5ONzPZhk73FmPmqyjAD/X29n0/CqFj8oGA6snJyT+vLi/+wfHxUZw8C+gSwf+poF2v08FD89IgZVVg00ggzWlspCSwoZSrS8glN/9kIr4l1hW49Hoya7+oFDKLXgVs7vf2DUz39vX/jJoCY3tr82e3tzaIYb8stgVfjThEQvwLBZ1ToIeYHpA6qQmkeH2+sMXS1jJJdS6hoPgsvAQHq86c4lqkfmSFHMa9pqvdc8j6sbm+dhlUACkKWraOjtCgPxCcdLlcJIgOA6in3iKXR5SlPrm4MPvnOOcycCqYtEoxxHucqM196bVVH2ilfVJelu6e3qn+gcGPoIzVUFpkMullBP1PVqtVCovoNrHN8nmVGgLav0gmExTaouViq1RSqbkJS21uZ7lgYx4IdvTabO3J9JKpxIrEsdHT2z+G6+u7edCPx9DywtzsL5yc5KWxa6QPFb+i9J6R1Y+IxxBEteUZyGQyT4peIK0s/i+6Mk1HjHorIKvMBtG4xiem3qYnZIjakkolvgbaln5VxcdLZaHTScSmlbpPae2n1H3uycmZhxD8h/Q8P5tJP4n7yQHIyenUgD8bs/W11a8XC8Vk/+DgT+ESVmYKMOAaGR4ZG/+30e7u+Z2tza8mEnHiDTAFg6FhpbdMLpddAfkeqwT+yn0LoL2iUgn8JcWdI9gRGkJQecnj8V7APbe/XXpDrXJ4ePi546OjXdDee7TCi24lmd9ZLP2ybD7chce11TVz7uKHcBwb8kexUNifn7tJxgwLySoI/Ed1VKu+v7d7BaDJ0q8kbWxwHdG9h4ZG3k9EsNxtKjiPPoFyjmQwkS7lPUDxb2VmKiOer+GRkbF/jWN/NzQrTmsn+fzfz85e/11sbxbaK9I199FXgrX/BYJ+Kyis/ecuXHq/y+X+QZApdEqfvX71yp9As1yu5t35Ld+nZymvAX+xSGBfDfRT+WWzofaOU5b/euHkpHGAVAWLPx/rL0tRdz44tDDojvz8P+088YPxwuE9parBWMKfZE4KEEumIRxLsLRw3SEEqRYri9MnAjvJYm0QzfhkVWdAXwTDstwVBlEZIFm5jUIogBQTL4TDCxCeKt7p9oANZePVZJKBegL/gx0dEHS4xDgEYQVRijqJwP2wlGHA/+bRqhvBv5nuTSn/mNICP99KJNnziqVi/ULHOBFq0PcbLPPx4rH3U5uP35mtngRMZiOrdBVl2KFoJ2Ps9zodrC4VRkhoaFjl+aPYhP1yeWENrm9siW00sPAHyfhM9+pBsB/tCDLPgVqNG04xhSH9zmisw27iGL5yfQ5K1SpTNHzX0Ft2zHU6Hwz27Xw8MHu0HtjJxf1H5Yy7hr0m6HaEinht7oLf5jo65xtePR8c2ajXGsBUayOTvEKkDZ29UkFBwTk8OvYet9v9RiUgQ+F6HYHI/1pbXSamWXZIEEgGFaJA8j7Bwp5Zl/I1Cn/LNlNKWWW1WoN61kU2m7mG92SZHPh7gjwlnEkk9Gtc/QND53t6+z6GfSnTemN7djbWVz+Kh/aa1B7s+xqi/JII+gXHE3yrZjBK7QBQEVY7QuFRPbnai8XicjaTSYJ+a/+tENS1AEor8jpbtLunKfuBWkGhYp9SPbrcoRCCe6fT6QrYHY6w1WrrIau4GDvb4j71Mgrcj2xvb/5JbH9vE+S8JWqAXzmXeeG5VdvbEUGpuWY3hMfBoZG7u7p7/i0fn4mgf372xrWv4NwiwjFTONz5vGP7c9nsk7jWvgzNoF9J3tYK3LZzpW5qX2cnY5NvOc60DmN7e7RuatgHA/0DA+/j3aKx/bGV5cWfFzke1PYItdh+2ViEO6PDOF88bbqpiuv3cW6O6A31eEFFJ+hvxeCvZvG3j09Ovdnn8+sBG8ROn93d2b4O2kqwbyVLf7vMGQ7u1UFkfhOT0+9yezy6+oqU47u7O4+CsIZoLWkBfz4TTHVvb2cO1/RHx8YnP+hwOu+DZs80IvKbGZ+cnuo7yW/GD2LPBYJBZTaGeiqVXIRmZZAW8NcKTeLr2LD6k7INz5/eQCA443S5Ltjt9nMmk7lDpa5nKihLplaXF/8ZmsOLtLJF3FLlUouc6srwLC2lbQOw4b7iOHf+4k9gXzVIWFGmOkLQ/xkReBuxTzsdDmdbZX6hUNhPxA92oRn08+PLe2kYu3t6KR2ujAA2k8k8tbu7vcb9tqa4B68o5e/b2NuJGHdsYuqBYDD4QyiONHl3kHfjYSr5mwvzs5/HvyXPDS1l+mugX3tvUrr5s+9NTZ970Ov1/Rvgzk+cV09dv/rcz+FrWaUfVcH/K6Fv9ZbXgP8ZikaKP+kA0doc2b89Vmf9B4fe8fvLma1HH49de3e8mD5vRfRbQkxF6eqYtRwxDrm82y1mBHEmCPt90OX3Qm9nCMxGk+Cyzm7IIWGxNhI5n5QJnnEAGKFBJAiSUqBuYJ4E9Lff4YThEMAapcfD75AS4MRdFhn/hUZS2juKsaf6JIrHdryxDQFx0CByDHQHg8w9f5el8BMe3mHznrhNdvq5U+qnK4dL3U/Erk7V8MAkwj7KchD0uuDe6UkIeJwgkfSdRsLXmXtAA1vWCSFW4JErNyCRzjDwToWMX2GfF84P9EFfJMSAfsOfvlqX9ZH0RwXv8+jlWdhJpRipHylULvRNwo4pPXBjY760kd1znVRLViH8oM4yBlDWA5PV0rhVqV5xxQrHrv2Tyz1fObh6x92dM9dv94/PQ7PFiRcKZZYhPAhheGTsnmBH6AElozFZXlH4+dulhflPFIsF3nonHRo8AOHBsZYbb2MTDXdGpkEHmKR7JxPx50CufuE13dJzZIqugcHh2/CQ/SgJivzNcJ6sITD5aTywt4ATZnBuVUXlgswduS7ktNRqixk3e11u/tiPkpt/OzftW2GdbCUwtYo/tqFwG3K7PbraSJkNLly6/V+LihDdsaTELIxC1BcRyP3N3u72OsiBfRmawZ1W//EWM6mouWK3S/mkdsizgx5Bx4O4Vn6Es6TVs5nMTQT9j5ClH5jLr8+Pwt2ZXGulgkJCfGlxjuL6JbdkLRd/PRZtJSjlLRgyLwbcB1x6PHBwHu8UCie5SLSrB9fYQzjUDdCPayW7vbXx/+J63YFmS5IyREfLE8EcCoXbprPD/Wjp6DC1D62t/S+qm38LECvjJwB1UkhVwE/Ko8mpmXcGgh26+SByudxzKp4OL7t43OeZck1NSdLoq4nJmQf9geBFvXUoFgqLqWRiA+Qu6zzwbyiOxasxj7LZTPK5K9/4n4NDw0+GO6NEbquW0cSIIHGwf2BoUPkBrofy8fFRAuTnlQTulIov/r2m/YvC73COdPp8/kGn0zlqtdknLRYLZcQJgkoGlBdSEon4Z0qlErkmK0F/yzX2EoF+Ne8aNWu/BbvQfu78pR/H8bpTun+tVs0tLcz9XS6Xpf2W7d9d3T1tw51YP8UPrnFjCiBn8m8ClDh/LN3dvd8GnGJGCOla/jycZnrg2wTQGvizC+s73NPb/0Gr1aqmuK2Xy+UrmxtrvxLb36N1oNd77tUO+tVCRtRi+41j45NvCgSD/x64ccX9eXZ+9sZP4VkpZbJRu14WytmXqrwG/J9f4fn3pFhvNfAvfRfE79VGPX1zeG2u52IjX49df+teIXHRaDJbJZdzAqH5UhnqxRIc5/Jk+YShrqhATtfA+wbVmhBnAJEAru7GWJq6DP6eOOVcdhuM93ZB0EfWeRsDu4ITQR38dgdz/ac0f+RpQCEA2VKRxf0T6KV7Bj1uSOMaKlbLxljh0LOdOXCZLRb26Ijfyyzz26nDRod0OTsIqNJGXstVC5aHd54eXsvGQkYTy8NHaaDgrrERmBnuBbLxMg4CEEj8iLiPYvnNtP65Zp5gnf7PU1cYLwH1E/EddHf44dLQIHQGfEzBIbiFi9kJyHFD0oJw+J9+++jVWdg9PGTKA/rIZrbC/nECrm7MubCOLvKMMJtO9/666CsBIGU7AEkXwbgDylBzPh679rqQI1jqt4WIebgCzUIh/1rp7esf7erufSsKECH5gOLQFwpXNjfX/yR+ECNXxSKcHghaFjZl7C4VVcGe3Pw9Hq8uN/9KuZwSQboS9IPivcY1ODRyBx6GP6XMA1+tVFaWlub/UyrJcsAr879LbeMVGHUENgT++Wc02mG3O9x4tXWBJ6vTgeDmrwZcb7VLsp7DTSs/va27p/d2PTndxWLQ+10irKtUylez2eyXtjc3HkNAeawYB61Ly51ZC/S3s8q2cuVrvBpwzs6cu/D9Xq/vO4HLTICg/+rNG1c/hwe9XerfaLSrH86g+OD6pLq7s/Vn+XyeyMD0Evq1IjDUcl3k2yblsR5FwdQNbUo8tr+M340MDY++Qx5fXa/E9vd/Y2d7aw7UXUe1FBOysbBYrE6X2912bzg+Pn5SwTHSKmf9C15TZyCm07I6NhH6kcv69MyF7/B4vdNnqEr96PCQDxlqx3HxcnHv15M9Q2sfsuPO4hhnSreOu87SV8lkgjxniioXD/yBq4+sH6msra58bXdn5+bwyOi3+fyBb8N5384bRWi4wWjp6xu4fXNj/avlcqkser3J4rdpw7TZbGabzY7/szutVpvLbrcHEMR14FqImC3mKIUbUO51FBtcIu9PO6+cwkk+v314mNo6OkqlJyZn3o5nvJ4QElI8HqyvrfB9xp+RWl4lt6S0AP3tmNablLY0Fgj6f8zpcr1J6j/iMVhdWf4b7CfyxKP+MeL+7ne7PW1T1uJ+n9/b3VmGU1lEk/xX+nf/4NAdFqs1zN8nmYh/JZvNSBwBfJv4e6mmaA2Fwl29/QPf6XQ634pfa+K6IIU6Hqt/tDA/+w8I/iVlFw/8eVlO7Vx9pYJ+pWFKrzFAliWKvovn4G2hcOfP8F6ytVp1Y3lp4SPp9HEaVIxtoA76v+X79qzlNeB/xqKw+gO0Bv/S53yMOJuMg67IwuBwZOu4nI88k7x5z9zR5huq9ZrTYBRuTSCWwPobpyeYMoBKw6ovVcYguL6fFMuwsrMPxB2QwPlO1nkGesUa5BA0Hy7kYbQnwnLcOxH8W0ynGMGD/55EoL9wcMBAfL5cghv7uzATibKH3DU+Al+4ch2sFiv8zeojYTwQGewl9/iuUJAB9e14sqGAGHZFaTN1bORjns9sfXWwCjWz0SR8SGSG77jnDvDYHSBlMySwnyuVWLYBr90OJoMA+gUmf4BsPg+fQdBPYJ/u73U54A2T49AZ9AK9Jbjzy7Az4wMwyI7oOkt5+KXnbsJx/kQ8fYRflaplOMgkWaaAcqXKwincTgf48TkUxkB9ZbNYwI6XxWyGAvZPMpNlnge5k6LYhpohD6WexdyuO55LGI9LOWsJyrZUIeep16oV/F3Ja3Xm7u677fjB29/a73Q4uxWVpoM/gSD1Exvra18X2cT5+dXYvFD4IZd+fiMTZ0MDFGlZli2im7+MBEmrZLKZmzVJmyI/+FUFy6HhkTuiXQz0yxjiEfQvLS7Of/RQILThgRQTasS2KF30xFBm9bQ5HaHQoB5yqXKptJE+Po5Bawvdi+rmr0Noaids27BtThyrs6R/Ui3kWoj9m0BhaRv7YiGXy16N7e9dF8F+Yz8CuXKJVwBUofngVIvn1wL9ZznclcQ9CEYtjpnzl35CELBO91QU2C4j6P8MD/rJqoN9powL1lWwPx7b3tokjgQ+FvkshFpqluhWoLQRwoDCS1srO+4NRfI8Gh4eIdDPpzyrHx0dfXx1ZemroM0yXwe5C7Kqq25nJDqKIKclSKEwo9je7uU28+NFAyU6QCyvEFSzXDeFzyDA806fO/8DTqdLlzfNadtrxdj+7g3Qpwx7SQR2DeFaD2hTTbtGezm59wc7Qm+ANqCXL5TCb39vh9KnlkCduZzPMsGHwzWlxSSPt7nZG59C4PjVgYGhd/r8/jcbjaZ2ijIDzuf3hjsjZOWtipw8jfsSZZIE5PFvo/h3W2DfXOqVcrmyfZLPLR2mUmvxeCxRKpWoP93EP4Nr1aL3Tqlk4mECtaCeJlIrvOhFt/afAfSrhWbJ9m8KiTh/4eKPuNzut0t9S0pDlHH++iC2T0YSh3hvQ3dv36Se0L2jo8MFUuZI44Xr2N/b138Rn9GHRwDjfcFByeCevr2/t7tIhHvhcOQe5X0Q+EscEHzbJMu/ktivjnKTtae3/1wg2PGAzWZ7nTL7hFhqpWLxsc3N9d/D9m0pxk9NYagVMvdKBv2tPAAtoG4MkKXv6+0bmIh2df8Cn/4T5Zz99bXVf4fjegDqRjdN5ewroY/PUl4D/s+/8Jb8Vt/hgb9SSKr4LM7KA9G7Pnt3+Pwzn9p4/DsTlfQ44di7p8Zgsr9HHqMOIMT+IxbbTx3jdQR7R0cQPySwL1ivTWZxSMWYf8JUdgSvvaEOpkhw2YRQX0aCZzjlEXAgqJ2JRmHuIMbc8ClrwFwsBpORCCPIG4qGYPMgCTVDXVQ/4MnmtIMVQXEWwW/m5EQExQUIOnzWh3eeHpjPbARqTJMhkOedG+yDSyODQsew8IQ6FBHsHxdOoFapIdB24f3MYpC3cCLvHKTgS9duMhBPLvrnB/rhzokR9jnv1i9Z5lm4AL4vxP+LMf3442urm3BldR3YucId7RQ+4HbYWf9E/EK6ReIaoEL8AxQuwKsVBNJEI2NK+KevXW70M6UP/OzqE8NsDIzKcwOgy+GDb7/jXXD34G3M44IvRMyGoPjxtdXlL6LQQIzd0mEk12aIFweU1fKGtyRICYXCk6BPuKmjIHKTuzdv7VeCdANZ+hH0/3sV0L+8uDD3nw4PUwS+1QQaZSpCk+LeqiRwfn9Ql9cCAsRnVTIg3DILnYbgrWblVrNGNtyQUWgdQ9Cry7pVrVbSlXIlgesjga8xFIr2S6XiTi6X285m0vh3KY8CpdJd9KxXK2tuO9DfzkrEH/KNz1wut29y+txPo5B1G8hB/5M3rl/9p1q1auOeQ4J+L4J/WR5wPYUsbThJPwnNoL+VpV8Pn0HbbAUotAaxnX3QplC7RkbH3wKKGOJ8Pv/4/OyNvwfttcXXU+kGK6tfINhe0YRzaR37PwXt3dyl5z0vYNKGuV9PnLpq7nAKn8E59a9xTp2ZB6JwUljA9vOZEtp5Dn3ThEmV/mryxoL2oE2WPYOEauyr9wQCwfvgjIA4n889VyyyHPRqBGZqhJMmlf6TzVVKxzo3e+PTdrvj8b7+gTchAHsjrotW8eAGCZwZDGfE8xoFz5Ij3C/WEdwtZLLpxXgstobrgchpad8m0jiP2KeGSLRrwGQy6QL+eKZntzbXnwBt5d03hcVfA/SrpTG0gPYe3gD9M+cvfr/b4303nIL+ys725sd3d7bJYt8A/eRx4fcHBnX0f21/d2dW/CeLr5+cnnmv0vuPMik4nM7ecGeEeamoecP1DQy+DeXlR07y+XixWDgs48EptZm5gOBm4XZ7Qm6PZ8DhcE6ROz8+zwvqa6GO82IeQecfrK4sPaXgYVILmZMAaYPvCV6BoL8NL4tS+dzWEEDfQ8Df39fX/0s8fxT2d2p7a+PDYkrGViEUSoPFq7K8BvyhPaO/+B0jflaj79C/cYEbE4k45W0xbAls/w0Bi0i2iAgON32JBV1w4xdQPM8K39gM3CZ7uccZup5Ip8fpAblCEY6yOQZmC8Uy5PHf5MYfQ6C/lzpm9yQASbUhS7WkH2ikBMR/dwW8MNXfw1zhzcbTfY9c6pkbv8HEQLFUyLI9jUB/IXbA2P6J9I7i/4dDIbhzbAS24ik4zRVYR6DsZwqCrYO4kI4PP3JY7fCJ9Ud7heUtyKhWswnecvECdPq9pz/HzymkgBQGZMnqcLmZ54D0OdUxcZyB5xCsB1xO8OJ1FwJ+JyMbhNObgLiSEQtTnSUlADkYUBaDHazz1+aWIF8sYh+YWSpACmkIIciPBvww1h0FDwJ9ep7ULiIXbDzBYBAVCKLZDNtEqozLS5tQoJAMqRqkqCBALzgpCt/FL3Z5Q/DQhQfgTSN3gVUhA5CaIpNOL62vrTyWzWT2xEdQ2AfNi4ZLEzHaG40mk2iZENzfaT416tzoDPyW2YR9ITucRbZcJtx5vD59bv6VShrn+PZpNxjMErkfL0TRWwj6bxNSMClAf7W6vrQ0/1EC/fhZGdcD3rZSwsOTbcy4Hug9Nnz4XT58hp3odSFLAas/flcWruByuwZ1NKOGa1SyTp41RvvMRadWW09OcTsKjbrijguFk81rzz37h0SShP8kUEIWI2UKKK0wB/61qvLvdrFxavH8ytjrViy9mu58wY5QdHRs4udwL+WtsvVsJv1lBP3/gPPBpniWMRyODD2PYavt7e58HPuRXE61WPy1rNlabv5afA5NhIWRrq7pM1gFZaAfBdWN+bkbv08p00A7LIEPydEE/bgOCRS37b98LntTPLvauac+7zWlU1iUhf5AC6u19J4/EOgZH5+i3OGSy289ET+Yx7k2RgCiXb2yucxN0A5/ecnc/HX0l9YaVM2aQa/kVTI1ff67fX7//cD4VurVo8PUMvadx+PxdrepUv0wmWyQ0YJ6PDMfgiJ5S6rF3yvnahnXamZpcf4R3Bue7O3rvxTt6nm3wgvmhRY66jKUfQbPpc1KubyOz1w5Pj5aSSWTBBIrcLpfSQrbprOkoyM0oPeBmUz6KVFRosXir7q+blGKzLPEXyut/Q2r7cy5C+/3en3fDadnQzW2v/fxzY31G2KfNZ7R09M3rmcfRJC+g+OQlOqKwH6gVchfq/A33O+mxsYnJ2lug+AVwsC4yCFjEl/bcebUibvo+Ojwfy8vLTxCnlnQDPK1suC03Dtf4aBfaw9vCfpD4c4oypv/HQXihsIPxy29u7P977e3NpdAvr+0k/leMg6Wl7q8BvxBm8lfUeqK71bZxA7JhDGGGAX2dwoMZ+BM5uIP8knJv1ee8Q9dfvZo8V0mg9l5c3MbbmxskYqAWfkZmV1dsGoT0Bdgo/QYAweGAcGxhbHk93QGwYZgk0IFyHotpLozCDH+ImV+XZY6wMAUBNPRKCweHEChQtb4AqTyeQgi8J7q7YYbm9uN5wTdLgZuNxPJRhfVJSRcF4gFh7s74fWTo2AxmsWsA0J9k/ksS6vnttkh6HQ1OljaKYhboKsjAO8OB1koALOy14X61rkoCtKlkBW+LjbBIPZR7OgYdhIpWNs7YOz+/Z0hCPk8EMYr4HYzJQF5TtC9yJNAjlvUimDaJ13GjbVtWNjeY88pYx+57HYYxPuTt4DH5QCL2QR+uxfGApMw5BljCgf5RKrDfGwVnpx7ZmPC3CVp+SXhoSpqi/kcpUbByK8pVDY21Wq1ogo6sOoWn8/XqSdlGBUU8Jcrp9kqTOKhyFzr6lKaByz9A4PnEfR/WAX0b68sLXxUiuknl3MC/fQ3AX5p3leF9cGDE9YeSklI/8bPpfcbAgWFK0gufa0KAqNYKpnYBm03f6WG/XkfAjpAv9rBpkY+Zqcc9XqswFQOYvtfxn4lTo08d0nAX8lErwb6W/2tjONvZeWXXtsx9PJx7qrxe909vWP9/YM/bzSZOrln1DPp48/evHHtn3BuWLnnsWciGCFSP10pxviSy2af3tpcJ5CijOvXErxbsfhrgX7VWGqyqAaDHWeJMW8UIqZaX13+rcLJySG0dg0GaJ3Cj120phD8u9o99+jocA6a15EW8H2hln493iP8nNICspZItGsMBcZ/h21s7Bt7uztPb26ub+B600MoVse9jAf+3zQr7IvcX+0Ub1YiYps+d+GHcE3dC2wvrhaWlxY/n0zE0xcv3fFguzrhnp2OxfYXQB3sK+cOgGLvB3XllIW7HwMBuO+dbG1uPBuJdD0AHPBHcHhte3vz0wg6Ox1OZ5fVYu0wmU0+lCFozZFCmc6jPBFiovxwhO07qlaqyXKlHC8WCjEE4XvZTOYYAX6JyyoDinpJ/1ZV/tjsZDF28vtXq1I/2N+jLBlaKUNV19fLCPQ3ATQE/d/h9fn59Gq1+EHsE6srS0S0a+fubSCvCJ1rEA4OYte4vjAGgh3PR9nLF4OUiviMXiFk4Z87Pj7669XlxUdR1pAAfyt+HK0989UC+vWG/anNKSOeleGR0fFfQSwUaQxCvZ6L7e/91Mb6KimTWmVJ0FSevRrLa8BfZ9FSDuBhKMWpSaVBdCVuJPziVnX3l66w3V95V+89v/nE3tXvOyxlBxC0G+oIgA11IWa9htirWCnVvWZHOewInrgtzsrayX6HAFwFC/NMXw+cG+4Do0FwNydoS6CfrNjZUqHBF0AA32wSGO2plhR7b8H3JJLBiUiEgf+Tcgk2UynwIbi9bXQINuNJyCBgp3CAnnCAKRFSx1mxyY1wKOayf9/FGcYBwOzfYu/R37tHR4xHIOL1gtdmP+2+RhpB4T/WeaT4oH1CVChImFNy6y81vBeMCOYrjBjxpFAWQhcGeuH2kSHWL6e/BRbHL9XX0Kg3X5ScAUK7CuUyXF/bgPVYAvo6gxD1+aE7FACPwyHwDwB5TVhh2DsBQ15SdjQrsGPZBPzVU5+BpzevUp7RgcuO4AOvC01dH/X0rnLzQdq4aAMkYcAivjaY80HOI9FIK4OAQMO6Wjd3hMNjoK3ZkJVUKrkAzQKkNJ9ZY3t6+yfw+oiSyI8sJetrKx9NCB4DavGdai7+fNECT4I1ONgxoqcdKABepzAKaBY2XzQL5fPMK66MO26wZ+MYOgYGhu7X0z5s28neHos5PlG5tFzV1UCslmVfD5hrBzj4tivZn/n3mcA4PDL2OgRpP61IA1lDwPnJuZvX/y+u4SbQT1e0q3tET3yovP+qGRRE/wqef1y/Vj/osrAGO0L9NptdlyJOWXUUov88Hj+QyD+1lBXKMCA1iwsbJ5/fPwBt5hzFuIss7VqeIU39cxYB9gzCYrsYdZng2D8wdEdPb+9P4vRoKCcRmH59bXV5jqyyeuYNgtljPOu3QC7Et/SGudXCu47+apdyrSk222KxOmbOX/hxp9P1ehAUsMWV5aXPJOIHh26PN4pAuu18LRROKAY7B+2tnVJfGbhXqQ2twJN0X3KnHzOZzXwWj/rBwf4XcH0s4UV7o+zcwbGucR4rZ93rZOSAYl3N0LynEvlbN04rXfJ1uVTawbNyA7RBy60moW01h1p5a8myrkjX1Mz59/r8gR8FLjwL5Ym/XVqc/zIIZ55y7x7CideW3LRSKWdi+7vLwKWCtFltzyuDy/MsFGYZLxWLX8X2/N/NjbUbohFDjRtHNZMTaMfyvwb6tQ0CpkAg2DE2MfUrJpOpEaJFPFgHsf2fxjNcSbiqxaHQtH6+1fv6+ZbXgP8LKDRpVlbXjaKrPxWJREmw/JfLFTi1tigtak3An64pd//V6fGBlc18bGQ9Gxup1qteQx3sZoPZGLB6qoPeaMVlshufSy72Pbp3ZcRoFsIJfG4nvGFmHEIejwju6+L/BGBfRlBcwuoQiR5Zu82Uy17UcFL6QALYlN5PKgSJidl/LrbPmPSTuSx0erzwhulx+Ow3ngO7zQZBspzXBUBsaKTXE1IAvhVBv81sFsC2uA0QON5MJVlcf5SBfofoAVA/XYkSKaESewMIChAQ2iQpLKQ2CPcxQsDpgrBb7p0leUboKxKH/2kF6FkHR0cs9KI/EobXT401uBdIHUQeCTaTHQa94wj4/3/23gNAtqwqF16VU1dXdXd1zjndvmkCk2AGGNKAIu8JCoJP9KGCYkBABgcBRUR9gvj/qKDCrw+eyJAGAZFhcs733g63c87VoVJXDv/au86p3mfXPqFvAJ3Xe+bcqq6qc84+O65vhW91I+Av53xJZOPw+NJT8KVHvguZXIZ+hgKLaTsdbrtn7dHWalvl9jWB/sdP+rplq5JMfmeX3ssWD3nRZBcxuqCm02m8pJUnkCstrL5KY7mqUchNoKC3DGJBhxJYkjQ2be3tv8On7MOdMbSyvHSnlL5GDfTzFh8ApcVHzWJK33u9lV1GniMU2nsB1IXOyxaiLgH0s4K20MW/u6fvZqfLVW/k/ol4fCaXzRKtGw/62bRZrJJFJOzygq9uvlum8M8su/drMfcLN3Yo5uN9fVV19btBwZJcyOzu7n5x6uL4/VK7lbU3sRj5q6qPavkp7O7s3BONRjah3MWfJSAT8WmwJK9yfeRXvewNJVf/+vqGETCg4OHLQSz2CAo794MypEOk5AHB9YVA2uPW9zDB7WyD8EWA2DOEj5080tzSIaVT48nQshLRsdXbP/DKQKDuf7IpIBEQPjo3M0WI50gaxVoj9Usmk3NgzMX/x1IuUUmilnatmCnF5SKZDn7P6XSeBrrd5tOLC/PfxPYiZFmeurr6NiNKkmgkcgHUQb8IxJaswlAuI4kMJlnpuYir97XM+WTv2kcwQGLAWeVnaW7Ibt1c36mteSKvHjbdG5uCUPFMOK4Mc0jEYtFzEg+NyNp/1Qj9riDoL63juIa/AUHarwKTfSUcDt2D6/cPpN8p7kNc8evqGwyR2Ib298ekVJqyzFMKDTxKyeKeGYtGRolnCsnkYHc4alFs8hNCXYksjoiaJBPEAQL7XRLugWB/MhwJndtcX5vBNTAJYh4cNbCv50UH8H8H6Ndz7xel7KOgv29g6M9wn2dCZwpJlFHvnJudfhLEaRJ159BPuq1+kuUY+F9m6e7qoOAFB7z8kewBUMCNFJKJhDzI+Ikviq+lnxECk1ZX3RQeJCczcb8k2lCv/P5H68+ePb8/12exWkzE4j7S0QKD7S0UruZLlvG8RKBXJLcjFn2H1QY1BULcV8RbxRCBAo2tNxVvXFxNpTAAcq3e2loIJRPgRhBPPm2qqaIEga21NVSBsC/xEBQd7AGu6+2CQayPTLwn437ijr+yv4egP0ct/T6n+9CKz3gElAC3SYn8C9L1i/HzhzH3xHOBhj9Izynfsxh0f9hPpex+AugihwfQWIFC8d6Fgqn0TMTN3l9RAY3VVbSNCvnDk502F3Qh4G/zdgkt/KlcCsaCo/DA1OMwsbwCmXyaehyQUAaz5F1hBaspkkvU37fx/M88uzN5zY31J384WNFKFAAsaGZj3GVWfxaQYyc68O+c0H3K7fb4nC6nbvo7UuLxgxXc3GSllYW5Dy0obLW2d3Qh6DcrtPRko1xfX/vDtdXlKdAH/SKLpPxeZKmiz4NCqdfhdOqm/CFkScHtbT7mS5PY7wpYJ3nQr5Uyi3fxdzS3tI3IZERGSjQWmYTyHNlq8f1qz60l9KoBfv65tYRFvdQ8FjMC9xMjp95ZUeF9MzBx7JJG/9O4uT8rncPWqXRfMh5tNpuumzpb0unUIoLne0Gcuu8oObPVrOmaVmkUOL3eSp8hRRxbstnMxtTUxD9LWT9EfAS8Uk1WPGu6geOc0lU2YZutM8BJzzvEUDlCfLoIhKgBWcJpYh06cfLnfD7/W4ABISgs3j8zPUnGEx0vnoqKaiP1xDVxGtQB7I81vt9gpgMj87D0HY7FmoGBobtsdvsAbahCIbOyvPS1zY01ogAm67zJ5/frKoeINX13N0jWJSOutjzxpN6hkJ+wzlW4r42w90/E409lMhk5Vl6kyNNj+Bb1I+tZx+65quk9PR6P7h4ll92dnXOg7p58VZRLVwn034EY7T3AplyNRb8/MXbhbsLTI7oP/r7e5dIPiSDrzsbG2gtSGxWk+plS6VTYA7rOAqWSSadD42Pn/zkejxNlFlGaE0VmAmWqlNVqzZvM5gxKZRniyU8IcSUXfn6+iyz4apZ9Pbf+FwXgJ+US0ojy63eZbEDc+yVLPwv6UzvB4F24jsthsmo8IsdM/irlGPhfoSJI80cI70pu/6C+gWkdZZvPN5ceumk5tt1PQD8hunvF6SGodLtBVsQfZp0vVoVaxAsSQKbbVQEcVnnnOsRbeUlRQICtbE4mMfp2BPwBd0XpewJah1qbwe0ohtRt7oYo4R1hwn851sXrckvW8EMPPmoxj0UJmxs0+nzgd7qApRYo1r0ghRmAVI/DOskW/iLoLlBsnpdS+1HlBeceQJ65yL5/6Mhvlj0cJH0A4Ukg4QHF+8uWffkyplKnkWKhYRGyEqP4ndfmhU5fP7RWtON1yqdRNp+B+cgMTO9PQDqbhv72ejwaaHgFaUOiMNmLFFMCLgd3IJFKEzJIUzibaPv+8hO/8pRzbPT2hmu/0eKuJSEAigURn122eLAWfxwSOUUsPHOerSYQ6DbqehgO7S9A+WJN74UbdW1Xd+9vS+y2TCmkg9tbn1peWiBCDFmM1eKOWRdZuWjFiCvd/GsC7UbS+KVSyTk8YnAV4nE1hCaRxVszXZZ8NDQ09be1t78WOAI3rbK/tzfJtDHr8q3GCm1U0NUC/OxzG93YVUG/E6U+ycqoYA4nlpa11eU/QfAxDUoPlzIlCwJ/Q/GhTMmtr61+FQU7Mj7U4vpFObONtIcar4PCFb2+obGfxFIfpdJFMLb8D8lEgrDq62UfEPhMKdquFDZkt9vdKPTqcmakUqlNUAqwWm2jO7cukcRPbWzJGSGsVpvNcWLk1G8iKLydaQMC+r8/PXXxKZBAPylul9sI8Cf8EnNQLuBfkRCHoxQNzwieeZ2fh2rA30Lc0rt6+j6OY4AK12Scra2ufEUiy6KoCtvS43S6dNPAZrPZYCQc3gZjFs+ydub+Nqn8hoKp1rb2m9l0XuTzYHDrPji09rNroRGGbz1rP8uVYQaxAgxwLXPZbHZDLugkhGRnJ7gIIAxruCoWSgNW2aO4YtPfDgydeB3KBu+Fw5DAAoLr+8YunCNKSpYTQRGK0tjUfFKlnxUlEY8vRCORLTiUG+g1cV6uIDg8bfTZNzbWnsB6RUDpVUlS3iYlS76R8DhRqJMaf46asutFBUBV1qWjKpLkz+mYwnWpsbu3/09Z934K+nd27sJ1/EGmr/S4Mcrw1IuhzS+nHAN/pmiR/Gkx/suFB/8OpzMfixHeLcOabC1XM7hn5bGXLseDw4SGxG23wxtecgbrzFuZJWgqWZOlt0UpkAG1JVN84fCs4u+Kn68Hd2FmfRO2wxEK6jtq62Cgo4n+nmQKIO7/JCvA0nYQznR3wInONpDyrlNG/XSuQMMLCFv+QToFkUSSpv4j7PqRRILyDuTyRTBPPAfI7+hnErjPM09jOqxk6fnkZ5Q/LpS9SucUFH8xXgPFYjEXyQ6JEoDyHpT+NlFPCMIPIPMhkPrXu+uhr2oQGtzNVOHBF8IzsBybh5n9i5DMJWhtifc9bRpTgYJ+8hkJkyDkiN1N9XDLcD9NzUjICFd394gywBTOxk9+delHQ63u+vvuaL3hq16zm2xKJbdoEAB/ELvG00XV56sylLOaWGx2gjQ2nxck897KyurevoH34kLMC8v5/f39z83OTJEYPhH4VANTAGJSJzUrn9XvrzJkJT2IxXgG7iuSxu8KECGVWMblo76+sbejq/tnTSbjOZ/z+dxBaH9vnWtntY2QjStUA/oisM9bvLQUNEYIxNi+tPirqgJ9fYMfQaCmcPXMZbPz83MzHwsGt7dA7NJZUrB4PJ7Kigpvs9F2o2PjIPYsAn/ijixy8eeVU0IrgYp1Qy1EhVf6kLSaI3r15Es4FPrBxvrqKKhnH+DnF0/qx9az9B4xnc+QMi2ZCIL2/DE8ny4hPp0H+/x7euCzVA4Nn7zTbrefBSXo/zoKi8Qt1C3X0YUFx55br67Uir2zswzGshhcFYv/EZn71bg12Fc6f5qaW3vb2jv+CPu/TnrWzMb62heXlxYIiaNHfhZimdViSJdLKpmcZzIW6bUXr5wSjVH2KHUJYmtHZaXvVvbemUxmZmtzg9Sb9+ARZecQGVdEfckry+R6qoaMeb2V1UbairZXKrmAa7mal9EV5444IujXI2OVQ7Rei+Pjt5j2KSSTiUfHLrzwtxJJrzBFr9vtQZHCWNjezs72U1J/yh611OKP83IBx2/WoFGjEAmHN6GcK4I1VIg85dQy3OR0/tbyqKPlvzoAPSK5qJYxgF3HzfUNjW2dXT2fxHWJ8ZwppLC/PzI9OfEAHIP+yyrHwJ8rcro+UmSgT1L5gc5mXvrNx8Bk/4Qpv7G5TQHN7k5QPk+xAKDAQTgACqm03eSwp0vfSe73ZQtEOB/3TYcWb7HbHSZiUb9psJcCU7Fh57CYShcqlLC+PDULkpWdFsl6ToD5Y6NTsBmKFEnx8P/dSAyPA5jb3ITXXnuKAl6btXjvwdYm6GpqoGCdpPbbiERgPx6nYJ7eyiQBdXw9yKQVXgb0tgwHAKmDmfxBwLfiIUxlrW9i/mVfDlch2WpfbB8zow4wSSEBxY9ImkXyki/VWT6v5DWBe0p/TQ9c13AKWr3NihSIciGA/+LuJJwPXkDAH6fKAxu2U05qd0KOaJEUBYfXLv5LiBdrfF4I+L1wpq8TYvEkPDu7AAubW9bN1P6r/37q327sqWz9p59pvYWkMVMIxxaLlab3IxEb2WyGMDKXAS+L1epCgbjNyPhHwW03Hj+IS9e3FAUYk9XpcjoHBoZ/1Wq18m55hVg0+i8Xx0e/DcwGigt2Fo8cnk8O4kJXwGvzghJtYJ+/yhqLRc0I+Mx4fWsqlbIRmimsvCKNH8kL7PFUdBh4DEImRIidrmjasSPGIYvSHZUduMH14Qb3C0aAl6KfUullLi5ULWWWlqeDFtiXi15Ig9F0fSXAT46mppbu1vaOj+J4ZVODFdLp9FOTE2N/iuMhxtybVRQpwE5DY/OAUSGb3qCQTy4vLtwNYhZ/vs0UFkGBwKDl5q8W32/z+6sanS6XobAbuWQy6ZWZmclvgjg0QZR9gO1LTZDtKlq9da1uyWRqH5TK6iMrzzR4EYwAENF4KoGQmkBtQ3fRct3JXD9HiBBnpicJcJAzp9C6+3xVWjngSwX36U1s/zioW/Suqov/JTL3i8C+QvGG6861DY1NH8H5Q709COhH4Pz5xYW5C1JbldYHBNlGw8RkklojnCpaFkL2uVhFAK1PZ1f3rbhmKjwQIuHQ94jlFrTnh5anBq8AYF38WeWjGcr7v3S+22MsfKTYXnG+vXjXcDWl7JGLQW8Ro7wssns/sfT/DhyCe0inUk+Pnj/36Ww2m4dDjFG27jS1tIwYAewkVe3G+toYKIE/Oc+UTCYiiURize32tOtdh/zeX1XdGImEF6CcSJn1mtPixtEjxi2AOugv9eGLAXweIV3fkRRJzS2tPa1tHZ/A+c0QiUqW/iLoZ/tMTeY5Bv0a5Rj4c0Vk1cfP8qxCQOU8hbDV2FCXI8R/oJzwJRxOQD+Q2Ep7mryWiIcK5Ux09L5ei2vParXnCAhz2K1Q5fPQOPEiQz0BpxaaXx4Kh4C3mAIvD4lMhqado2AUcaGFIfYD6XGJ6/v4wgo8P7dA4Si9Fu6i3b7W6FxopZJAwH3Eg4QfwG4zUyCdRCDfUheARDoN8XQKgpEoxPA+dFXGexw+eEF6kEO3/CIZX/H7fEH+1EQt7qRushXeIsXuk4uS5yC/rXK5iteSWpQ+dkEG1Ieu+8A3Iv6bh2I2AOKxkMK2s1uKbVLqGIZAsNZTCwM1/TBQ3QMelRBiCvj3puDc9nlIZA+oUoQ8O/ESIM/gwOchGQ7MZYYNvn5F5UY+VwASwnHriQHoaaiDH50bMyGWr5yLrf3mZye/fuObO2/9gwZbDdFa080zV8zoICkBLPKGqFhUq/xVTSgMG4qBDodDq8BsztgeJoLBB4dG3mGz28tiPHHjvX987PwXgYvnJ2zQEuOtyMVfMb7DoX05baCJpMK0EIVWPm/Oc26+Xm9lrdVm03WhzOVyodD+PkkjKIrpFG7GWhvCEeOQWWJFTfIxFLr7Ozq7fxk3uCO5fEvtLjOMi0C+mputnmVfrRw19prf0NmN3dzV3fuS+obGD+E89bJ1QCH462Oj5/5OIkUFKBe4FeCaKEtQ6DySm38kHL5/f3+PtJ1e6j5ecNNrG7Zd1NwZJWVP08mjZCCQ4q2/lEmnw6Dv4p9XuYwoLIW+dzicum7+pEihM1pARHMcXcI80gP9JQDS0to20NLa/jEcE6WUjqTdtrc2/2Zudvo5KPJoKIRzo/H96XR6DbTn0xUDZwbbTA2w8Va1sqwZ8mv/4PDt1dU175fTsBIlIrbV5+bnZuS2UjyX2+MxQoJYQFC1COqA3wjot6gc8vck7MDt81fdwVyDZpJZXlogbv4p0M50IWJU5/uNr2devjcoQb9Q8eVwOnVDIuRyEIuKPEnUPEMvqRzRW0TPFbtklaVEfkr3fjJXnh0dPffJTCYtp11k27HUvyjTkFSmhkj9IuHQ07inH0j9yAJ/2h+h/b2LBoE/4D37cJw8Bkp5QOQBoGc91gL5ap4ktLwYwOclMPdrhYyUZIP2jq6TTc0tH5WVkbTxCoXkzk7wwzNTFx8GbUu/Vlz/i6Ldr1Q5Bv5XsbS2tRe6uzoKDPGfXHhSG71SILDeYbaFM5CrS6Fc/K8PPAFupwOctqJ3sAvBos/tQdBoo/HsxHWeHFv7YQTMWaip9MBIZys47XYwyx6gkvkfF1W477kLsBUKl4j98F7xN7TeNNvqrkv+XSx4OllI20lad6JAIFkAyG8ml9ZhcTsINqsVmqqroK+1kYLWRDYDB6k0JHHt340fUOBbW+kFi4TSKaA3H8q9BCTbpJj7EooH5WpJPibXXNzbofVvrvIXf1YoxvwXiQwlBYMsUzMu/YctWSiGQeBbkpbwIJWi9fe5XOC02sHvCECtqwEa3c3gRrBvEoB0UgjgX4ktwFxkCuKZAzzfDD7Kv3jIryArOEAOtQCZgUHbS0M+rzlQBa84OQwPjE4QhYIpV8hfe/fsg7/z3sH//iFQxhxqkjnh5myURKywu7uzBoyFhaQIHDox8kan01l2DdzcxybGRv9SYtpl3eTU3I9Za2Rp40Awb0Kwp2Y5Lz1XdU1NhyF301RqIZvNJAEuP77/EsnHeLBXBlqaW1qHWts6fl0G/dFoZB6FwP2GxuZrjNQrmUisgzrQ14urNfLsImu2mlVbD/SXfj904uQb/X7/r+GlmLCGQjocCv0/E+Oj90jkcfJ95bHN1qN030BtXavdbjcsZOfzucjC/Ny/QXkMsNo4FQprBokdhd4eVqsNQYt/wGid6diIhB/c3FgfB3XQLwqhEfWz0OKHbegFAwXne1Lw8VHd+tl6GI1PVw0XIUdPb/8ttXX1H2QzjJA87Rvra3++uDA3LrV9GbhyG0hNR0oylVwD/dhdQ21xlHKZ6Q15hRt9JevniZFTP++t9P1P6TPSVqnt7c2/lEg0WQUJPRwOh91ms+kqh4iyF9exLSgXvsuUvdx7tf2L72s6Xrq6e1+P66bCWyMWjX47kUiQ2G2eUJYHcUdVgsr1k9+LzlcUI6np5HvhurcK5WPqinFHXIK3iBrpmgL04zr+M35/1XuAAf24Pjw3Nnru46lkMgUcITB/v4bGph5cC3XbiYSN4Dx+HA6z1MjAX94/zFubm+O4b77CiNecy+1qcbs9FfH4QRgOx6Yow5bIYKFmydcLfbqkvvvPWnQ8H7V4WdQ4IuiYwnX8JlzHf59ND03W8WBw+87Z6cnHQN/Sr9ZPL5q2v1LlGPgbLHrx/VrnMHGh8lf8hpNVuUTpnsQVIODy/2Ahsv52u8VGcCAkUhlIpIup4ULxOGwgyJeBrZyz3iyR31V53ZSojzLJS3Z3m8UC06sb8OTkbIkMj7zW2n1bb+58xQWHyWbKmQqeaDZmI/np7Qj4q70VVKEQRxB+fmEZihjbREnqzi8uweuvP0N/43RbaTQl8U7YCIWh0uEEm5zyDyQLtyTay5Z6EuNvKjlWKMEx+cvjsEONpwJ2YjGqYKhyuaXsfybquUDI+dKZDGzj/bxuF1RVVMh3OrwOeX4prKGuIgAWjxMcFi80eRuhqaIe7Dp7B2HlX4rOw0J4GpLZRMnjQJYNFKELwHofFBgX//LnA+ZXpP+I18DS5i48MjFZ/JUUBmE2W1zcKXqxxbYKb6UhbXgmk4lHwqEwcz3TwODw7R5PRVnaMQT7mzPTk59IJhOExEIUZ64A3U6Xq4BglSVoO2yAQsGQ6yoKq51GniMRP5iFI8RMql3nCNa2I7m6t3V0nmlubn2vbG3DNly9OD72o+qaGkPPR0osFpWBv4hlWEtQEW6CzLPKzyu/6rlh6zKGA81cabWfOHnm1xBsvZEdSzhfQttbmx9H0PEUKAFCiRmaqYvCClhX33DCaHuRsr+39+8o8O3AYeYDtWwTijGiIjQYsZyVWTjqGxr6sC0M01DnstkdbBs5NEFLYcHWm4+JVqs7fW+xlK0pKnXJZVWuxb8vXZ/Z80xgHHyoxYMqwAf53YmR02+u9FEQWwIgCED3V1eWP766sjTHXK8M+DucLkPEfrierIO219AVF/AvI70h/1pqW6vNZh8ZOf0bLrf7TfK1pcwZn5S8ImQFieIZESd5EVTp8o8QorpEPB6F8rUHQLnO8s+lxQ/C8tqYawK1jd7Kytcz1yD9vbO4MHcPHO4/Wplk1JS/an0mW/jl9wWNgxarxWpoPpGwhEQiHgOVdVqjTrpFR9lm1NIvBGjDI6d+1ucjyttDIloE/c+PjZ7/Q3ygBIhDIxT9XFdXf8rIc+D1JsPhEJl/PPCXFcQWbMO9g4PYnNdbOah3PZPJTIlVF+Zn17mvWLd9Vglg1BtDNYTuxQI6L8EIwq/hIkWSzBNxR1V19W8QO1CpQwqFGK5NH8S16WlQzm013ijeWw9eTO1/Jcsx8P8xFon8T/5Tdh9j05rJRfR3/i1tt/3TxejycyvR7b5ELlkZzcY70/lcVyqfqohnUy4E7bQ/SV75Ymy9GUGt3VRfXQm9TfXgJnHmCChD0QNY2AzC7PoGtXjL4BQ37szpqp7zr2y6dlZKv+KYC69WWUzUhZyS0clO+xeX1uDQWbW45pHrPH1xFl5z/WnpVyaaESAYjcHCzi7019dRV32inJhe3yx6GOCfPrcbQboHmmurDuPvFY8u40OgqQAjySReM0q9HVxW26GLPiUKzMHkygZViLQEquFUVzv1KOjxD4DTSkC+CypQ7ibWfKvJJgwLEJV4NgaLkTkK+gljf7FarO2+QMMsSoi29A+AMqJfLuL7Et6G9Z19eGFuAbYJz4LFXDozX8jFuj2N/wrimGdhfLnL5fI5nU5Duapj0ch2vshzQCvX3dN3vb+q+ga+siRt3+ry0idC+/sk5EDE4F/meoXCEL8xlq6JqNCczWY1wQCCE7vL5TaUGzkSCc+Avru7UcDPtrFa/VigomUtsWCb3oyAlYB+qmFCgWl7Ynz0m9lsxmx0LJK6R6MRlmhNzc1QcahtgALQr7Wp89p8XYBWgRLZwOCJD9vtdj7n9uLK8uKH1tdWF5k+Kg0LUFraFIIqjmtC6mdYUYIAehfBwQ+hnMxPCxgYKXrx/YojUFtnSOCV+3lra/OrKEvvwiHo55mnRQzgimvo1JvECDnAWBGBdxC8Z1/Z94oQAzCmSBK5q1tsCGJPnDzzXhwHCpdvHFNr2M8f3trcWIdDZYAM/EtzhYRFGbFik3JwcLAJYMgie6UAv6jN1LKG6MXz098S9/ih4ZE77Q7Hy+AQ9MdRsP4YCtbPS7/LSuco2srj8RjyqsE1bNtAu4hc/I1kASHrI3EFfgdrESQF961/jcWihH9Ci+PEiLVfVFdZTtNcW9lzcc82xNdC8shLaXmNuPZfCS813ip75DCtkVNn3obL+S8z/Uj2sGfGLpz/CALwBCjHLYBAPqmqqm5wud1GCFkLu7tB4t4tK2pl4C/LzSBd0xbc3nrGCPAnBQHmmYV5eAjKSSTZdua9AYyQmgLz+qICnFfQc0SxllMPpJOn34F991ZgFEm4NoU31td+D9dyOUuUnqVfBPoviwjzxVyOgf+PuXDM//IiJmsxRRYVxSI06G07hwdhrqXs4FI6G5xYJk8kF6s2mawWr9WdTuSSnrHw4tAjGy+8iQDknTAC160d2NwPw0EyVfQEyBct0vlcLtXhbRx9ReO153x4Lk46Ocd4YSa84jdLLPeBSi9uVnnKhD+zsUnhKGHu7/Y2RTYT+55kLm3ZjcXgyYvTcPNQP2XtJ1imraoKZra3YW0/BM3+KkqkV+lywcLGNuUFKO6uhM0/D91NDXC2p5Na9ItOC+x6DBRct1VVw2wwCFvhCLRWVxXDBoi1P5sFG4J8v8cNO5EtuLi8Bhu7e3DdQA/8dNfJI/dVKpeCrfg6rMWW8XWDISqU/2GBPbanqeTLUPyGKAJMBTHEZ/ThJDQ/nkxTVv+JlVXYixwQH3saskGAeC6fK7is9uduDpz+X9fU9E2C2HVSCDqqa2qJe7yheR4K7W9L1zIRghUEqLcClFWfkGX99draygSop48rc5tGwYyP3JBfTalkUlYE8ACzZAH0+asajVhKidsqPsca6Fv6mUF1WHQ2OFFcrZaFUsFU2z84/Jqamppfl7XaBIxOToz/UzKRIO1WAerx2dwz5tPpVCoB5ULKkWNDDbhhqxH16DGs07FY39DY2tHZ/TFlHl4oZDKZp6cnJ/4wHA7tgTLrADDjAJi/FUJqQ1PzkBErpHy/vb3d76ZSKeLNogX8yyxvGoLDkWNlKyt9tQjAdHOhywUB//mlxXni4ii7+MugX6vebP0MCT1mk9kQOSL2oQ2UwjIvOMt7GWslNTqP1KxEZSC20ufz95Oc8zb7aWDWp2w2O45j6i5C8ME8v3wvxZpEcsAb4VnA9SQfCYfVlGyi9r1SVlq98WW0vcx+RDp9/YN/jOvnCTgE/ZHNjfUPL8zPXgBlyFiZldMoB0Q6nd5RaQP2OXj3bzUSTD6unChNb3E6ndezF0bwvDw7M/Ut0I/7PSphHu85w8psmlZeo2SjiPnjBTkVkvpYMjyeDK7lqhlzQMNLjTzTyVNnf9lTUfFW5vq4jqefHL1w7qPEdYG7t8gwQa/X2NR8BkAsFrEF5/Pe2toqAX6snCGvLzY4nNu27a3N6ZbW9qDdbtc1cuB4bqmurmnCPSEG+uCf9QQwRJD7YgOblxByZNM4SmOqqLw9/Vsul/tVwHoB5vM7q6sr71tZXiQy5jHovwrlGPiDsVR9Mrkfw/Qv55ZWDQPgCAEVPt4ry0uAA1v+G+BwwOZwgyax1YRYLZspkgCSg2Uhla2sdskyj0ch5jW7iWXIWshlrU6wWgvZfCUCx/zS9i5Ozr0iPDVRy3ghlUtnvTZPsMkdOHdbw+lzlVYPvR4UFQpFsy+WpfhmAyXds1ig1uelVvX13TCkM1lqjXaa7ak3tb5sbDG2Wf31xfsHbFY7LG/tQFd9PdRWVVLXfY/dAdUeD2wfxMDjdECl0wX11T643X8CdqIxmN/YQtC7D6lMBhY3g/Tvl/T3wkBbE5AMBnzzOa1WaMC6bCLwD8Zi0OCtpKR6LltR0X7DIJ7b3gwPvDAOkXgSHjw3Du86oz8OMvkMhFJ7sB3fgvXYOn2PvQBW3MdJCATphSI3gVKmPqQsVPj4g6lQZPQnqQCLIRYmGs5Afp1Mp2EfAf7a7h5s7IUgfJCgigXyvVkKiUhmUtkqe8UjJwM937ixdvgF4pYJSgFWsQgT1nvgBCifz5h7PLE87O/vkfED1TWB2ta2jlcJBBhC3nT31OTEg7hoZ/GcNP4mgwddhMlrrsg2WCZo4SXB76+yoFCeJ/H8OK7NuXyOgH4TsfgTRn8QCyf0wI26E4wJC7sohMjuk3oueqWiYfU2KjSpEmqRdhweOfVWBH7vkK5BlG3709OTfxuNRkhdPVBu8Vbvq1w+oSIwGrY8GrDyi6zYWmCDB/3mImt4452Ir1hCRuLf+q2x0XN/hUCBHc9yn/CCIw94bMRbwigxlDQmthYX5u4H9dR9Ig4KLe8ILUuaaqxyQ2PTKaOggGQfQND/ZWKVBX3Qz45xvv1Ub1H6jQl0ATApNrvdDeXKOdHB3gPAmLBoxHJN8n53tbV3kmwQzcyzEibxB8bHzv9JouhqLN+TJQJTtFOFQeZ1XOOiEreBnpv/ZQmZOmFFWvH8mqC/vqGxpaOz+5Os4o0I1gioPrC8tDDJ3EsG/mUWf3ux33VLJp2Wsz6whe979nPW2l+W/YJ5JpL6szZQW/dOUO4Bhb3dnc8nk5R0Ui2zyZE8vjguD7meWhZegCOsu2xB2SbFtQdfRF41espq9rdqClw90K8IEyFMfCOnzv4GF6ZVSKdTDyPo/5gU0y9S2paBfrvD4an0+Q0RskYj4cdQLiB9K3s6CV39oZj9x45j4WlcY1+vd12yBuPvXoLAfwEEymqmzdii59b/Ygf88quWQUDN+GEHbkxVVHgrB4ZOkLSrCiUQ9uM6rku/u762SsK0jkH/VSrHwB8UYF5TAcB+h+9zR7k2CDYKTvguCf0oqLJuRlbmPQv+yWJIJxYBfCgg8hZI63U1fQ+H0hFYjm7dQPj+PFb3boXNtR9w+NevCfQtI6DNSOfJE9TJ1MO8Hg8Gktm0x2K1ASHabq0PUHC6uL1dTPWHqLazomGTCKcdFQ1pu8XeibDWkcMrTK1uQH2Nj16NPAyx+sdSKVje34fBervEem9BAO+j1v+mKj+ML63BbuyAAt8nJ6cRtMfhuv5uCv4P3aCLMLva7aZpAwm3QYXDQZUL8m9o+jyXG97wkrPwrcefoUqKc6sXwefxgMdppyCeuOun82lIZA7gIHsAsXQY4vial4A57TuLqcgJgP/ZpKwzhN9gcnkVGgNVEPB5KQt/iWeg1LXS/kyAfD4Hz16chbGlVao8ITwLJNyBPpNZOotECZD/8N7Yzjmv3bVW4/Q9ekPb8I9aXLWE9ZcAPXnjY4ESyzRMASYunCXhkJDduD0VhtzjSaw+ArIkcQnt6e27XUSUgwLWMxfHR79MMu7hfajrMdEhkQN0AAlJa4mHvGnLDUUbGjd3APX4Q/rq9hizlKLwuS7lkdYj4hIVrThko6BfIXyjzGQbOXXmN1Fo+in52bHtQnOzM3+5v7dLrN1uqc2yUr11C2ErB+VmzNYdBK+0cOuN1vNqgQ1DgEOFxC8TiUQ+Oz56/m7pGfh+ErmQlxEF1dQEWhwOY+ErUBx738lkMkSAVGPDF6XQMiLIqY3ZsjGCxeH3VxlWVoRCoe+jILsI6mkHRYAGQAm2gftMLLgeEipqFofD4YNyRRB7yNk55PvzVr9LAf0lYbynr//m2tr6D+A6x3r+5OPxgy9fOPf853FeZbl7ymtkmSLS5jAGZkmGELiKgJ8UQTz/UdpL5JJN26utvWOoqbn1j9lMB0SwXlleet/a6vI8KMGa/FrmGk/SwRp5jlQqJXtaqK0lBe57LWt/yeKP97f19PS/m0/fl06lHpmbnSau4CKwr7UHGAJpkncms6HTojaXStbhgsH5JBExmTQOuZTeC9Zw9vujKnD11nIzscqePHX2/Q6n83bmPoVUKvkfOOc+iesqC/pFa7dizDY3t5zAftQNLSL7w8b6GnHH5zM0yPuE/Cpf3766svRMbV39rbjp6noGeit9Z3E9+x6O2TgIlNYgBv98v7/owL5cLsP7SC2TUWltCgRqm7p7+j6C87oDlGFa8/NzM+8Lbm8Rwsujsvcfg/4jlGPgb7BcCrmfXuFi/kkRxZ/xaUfkNCmlgwH97CudmK9qvPa70Aj/DsrFjH6P57GbrgOUrpHW6chyFbHgE1BKcszbrTbq8k/4AcjPSHhap6eRTFLismZpc9VtLya3WslFVnd24ZBGsAjGe2trYWp7C2aCQeirrZOIBwGcNju019eCw2aD8wtLsB2O0pRuE6vr9BrX9HdBKXefXEV8afVXwdxOkMb7u6vtXLx+gQLtn77xLHzvqXPwqR/+LT2nt5mEEnTQ76gSoVBQ+IQCFEF8kSOxaAormGQ2/mKaQZK94JuPPkNDCobbWqC9IQC5AusBIF+rQJUYJ7s6YGY9SGL0aTpEKTthKXUgyXfrsbrWmt2BR29qOPlMjc27RuLooZzQS84tK3KjNTPjgC60FRXegN1uN+SmSdxZsa6m3v6BG0Rsu1jHtenJib/CxTlOLP34WzX3fq14SnlMKzYV7GszXlcUMya9mqxOh7PeyHOgQLIO6oBfTVDXc2XTc48sA/xQjKutGDoxcqfd7rhJvge23d7C/OyfBINbJKzCCYyViqTUMvKMhXJBS0tw5F0Y9bT4Wm7raoCjRPyE480xPHLq3S6X+w3MPWjMXjC4/Yez05OPg3gDl+ti4erFs+Tb6hsaDcfJo2BKYr4fAf3YfsUY0REe9Cz+PFEdsbz2WG02o7HSG3Mz098BYyz+/BzjAb8WUKHn5g0Df2c1KMc4D85leYL34FDz5NGaQ6XrkjJ84tQ7KrzetzHjg1w+Gdrf//OJ8dHvcf0o3w9AGd9fag+L2WIoTAT7IsS3F4jXtCOXy4jF1gX9Pb39NyAIuotVkuAaO4dz4X1bmxtyKBQL/HlX/0M+BINtlU6n4yAGByXvSO6e8rOIAH/pmQaHTrzF7nCcZu9VKOTDS0sLf00yCYC6pV+o9L0CwEAT/Et10i9F7x8+VEa0HrNK0bKrMK+Xs3+VKdtcbrcb591HcE2/nrkPIen9xvlzz32a8e7jQ/Xk+ijuRz21amqNkfolExOh0D7Zy3kOIfleLPAndU/i+IuE9veerQnU3qZ3faIcaGltv35udvoHIE5XmOH6pqy8GAHmZZBCyvNYzb2fjqnWto6h5pbWP0D5UeFxhfLl2PTUxAdwPSfggifxM5Kyj5Rj0G+wHAP/n3ARgH9S2E2SFTrIgJfjFbUsL1qumDwhmczky7r6kc+zm4n9ujwU0881V1dRazch1iNp+iw07t+cGKruXC4U3fGtQ1Wdy7Nr663ENZ6A5c3dfaiv9hdBLv5ts1ihK1BL4/Ong9vQgdckKfSKRieABvybXDuRWoQo4SHAM8dXVsHttMNgWzPw8hVJE9haVQWLu3uwFYtCo7cSlPAbhVW8/qvOjsB3n3qe8gjMrG3CcnAHXj4yDDU+b0lZIAU+lnQL1KNBduCXMiXQ35mAKkBuOzUMP3zuHATHo2CdNEN/UyOc6GqldaLKBOn3ZryG3WaD28+Q318AoKEWpC1sUG/3X3TbXZvX1Q49GbBWLEtg/0By6efjelmgAqDuTlfayEn6O1DZtPiyv7cbxEW50+OpaOS/I/VZXlr8dCwWJTGcKavVmibgH5QLMxW8UUArpFMpYQ5VNWsFSScJYoGHjmG73eY0WyyGct0nkokNMJAWSTFIDt/rbXJGwAr9PQof9d09fSSutk++D8k1jaD/oyh4b0rzzsK2oVGBUeJsMGsc7DOogX2jng0i4kKhld/n91f39Q/9gc1mO8m2bZHEb+n319dW5kCsKOIFR5FFkL46HI4Kb2Vlr5F2ItfdCW7fI+WANsJFcSlCg1o7Ktbf2tr6aw1eL7+5ufGVdDpFAKc8//VY/PmxzbsEq1ongUad5OJgoDiKJKGi8W+DciDJhq2wY4ufR6qAn/zeS/yCBwY/aLc7WPBB0NU2ttMf4Hw6x/UjD/xZN/9SO5kMMmkSAjaN9tNy/9Ysl5gmVE/xRrXZQ8Mjr/dXVf02vi15baFgfW5mevIDuM7vQDmnBk+CqFTeGo1ZLy7katlOZPmCNS6wCj2Jq6h0yHH9N1dW+v4bKNfqAgKEz0mWQT1gcCVAv6iPRfHfxfmUpeuNbkEZw8G1lVnwKo8J/r56AM0E6n2hp7Q2+3z+qv7BYbJ/DbFdfHAQ+8cL557/R86rjq0H37+lewVq69px/TbiqUVCOEhoFg/62Rh/HviTMZNcXVl+vKq65kYjXgXVNYGXLS3OP4Jzg6yxDuZecp1lOZsleCytrWQOv5iA5iXyG6nF9NuBW8/7+gdfjnJRKZuRXDKZ9OMTY6N34dgiHDy8lZ+VL48t/VeoHAN/plwNq/4RCn9vUa5QdmMtbQ5YiIu3FhDgz2E3XBZIUsAvfZbdTYUbyK2zhTw019VQMDu/GUTQaqaVaXbWLiDoJy60NI6yz9e67Fi3ns6aCh7iGbC6s4dg3i8BYaA/c9vtCPirYWlvF1b2Q/i+hrr9m0xFC3hnYx2N+59cXS8CcJMZXphfoq71frcbWDd68lLhcEKTzwcbkTD2nwWqXZ7DFpR+6nW54GUjg/DA+Qn6DKlMFv792Rfg2p5uGO5sQeGuQIn5Snx90htq4y/Iq70yjr++qhKG21thfHmNuu1PrKzD6OIKdDbUwnBHK9T6KovkhpLfQ62/El5xchjuPT9KFCYQT8WhN3Di6RF/1wtQBPtEWCACOAv6RQI/a0WTn5L2K2fxt6HQ3A4GS1NLa6fXWxkQfJVH8PTFzY21Sbk+UtiBMF0SA/qPmkNVDXSbbTa70yhBYfzgQMQsrWXll4vI6q3mYqvmjiy52HYONTW3fBznZZ18cZSJV+fnZu5EYXVbOocHtplcLisT9mmCEryuC8RCIltn2e1aFGpk1DIkAv1CC2NLa1tvS2v7R7BurOKIkPg9RQjXwuEQz7rNW9pZ10pecCwJFA2NhNTPmBIok04vLy8tPAHqVnOhR4hO9gO10Ape6VJq40qfr9rldncZqXMiEX9+ZWmRpDbUsvbrKbRYAVUI9oEJcchls4aAitPhaIByt2y5XiwAYOsmsvaLlGi8t5q5ta1jsLml9U5pTJXmBArqowj4yVzaAG3PETMIrP1SMcRrILWN4RSgeuWIFjU90K9QOJK4ohMjp9/pqah4G/t8KFg/PDGOgnUsFgGxkkRutzISRHKYjD6vSejJIY8Ndlzw4IG19JcAA/b9QF19gyJXPCnJZPLeqckJ4sUoiuvXSrt4KYV39Zc/U5tTuUyWhhXpFuwvmiaRDc8D5V4iH7zCQdnq6q79akprNQ4NlhfiE1g/NrwuG4mEPz124dzdUO7Vx96Tn++le+F1zxppF0J6iwCeZJrgQb+Wqz9VHiF4DEYjkfM+v/96vfvYbLZa3LeuXVyYfxCKwN8B6l6MIs+LFwXQvAyCX0PM/TjGrcMjp34B5cufA27dTSWT3x+98MKn0un0AWi794vSFR9b+i+xGNr8jsulFaOKBGbQqmmR+fh+luCPxFsTATHBHXHmOJAO+W9eqOSJrnIH+ZQ7mo17SaUcNivUeL0UwhIiOnkfHKxuv8hcl4DXWLe3ZRYk9/nt/XDpGSlJn5TKz+d0QTsCfpJ6bz0colZw6v5OMgzg767t7QIHsZxLzZHL5+GZi7PEJHoIvwuHQL3K7YFGBP/roRDsxRkZlml9ktrvRFsLlDjREHw/MztPrfA58siy/7QM+umtC4ehCnDovg/FGlD+AUJ4KBMQWixmWAruUu+C7z39PKxsByFXyFESRKLUaKmvhs6GIhYkvAkPbL3w08lChrQ5EchI/uOYdLBKALafeKENoNzNmC7EVivJeOZuMDpWfT5/o4glHYXFh2Znpn4ETKydxWplx6Gaez8/tnkFgJ6bemnzIfHRBknRcrjx73FzCXTuyQtJWrG0LOgRMvcPDp14DQqsn1aC/uzUzPTkexGoLMPhfEtxr2kpDl13zcBrO202uwvEwMByhEMNVMjP6GBe2feKjb1/cPhVCNL+kgP9eQSxXzv3/LPvQ9C/C9rue2rjWdH2xFW0piZgND1HYTu49W3G2q9lNT+qtV/kKSL6jtajqanlrES8qV3hQj6xtLjwzwYI/WSFiajeor9VQT85UqnkHhgodoezSUpDyYN/0TgRjRu1QxHTLQmKP9va1kbGVBPTpgUEfd+8cO75d+NcWgPxmNLq31LbGCVZzOZyMRArUI4MJg2wY/OAWLTuiNYei8PpdJ0+e+2HEPT/AhzKdQUUrL99/tzzH8R1XLamiQ5RqFap/YzGrEshYqL6sv3v5Ppe/lsxBhDwd+Ca8vt86j7iPTQ9NfFpzsVfLdRM0UdXyMVfS0ajr+lUatfIxSwWq9dSTKWp5fVy1HVcbcyozTmFZRYB/6murp7PsqCfePzt7u58GEH/10Bd0cKv34q6oCzi93q9PUbaJRqNPIL9TGQfHvSzB7uPygeVlVZXlx4yypdTW9fwKilbkBPEY7FMyQ3M/FXxYvwvUwRrkpH1SDSu2H2gNI+x3yvOnL3uQwj6fx6UeLOAsto/v/D8M59gQD/f18eg/yqVY4s/U4yw+x/xema8niGmbi7NH1tkLSMf26RYgEBsbVKbxKxlhPxdtlme35ttdVqcFpqOrzZAwTdxf99CME/d4HP55JCvYx7PkInGqNvy2UD/xdG9uZMmu9mUyGTgIJUGp91KzJn0wg6rlcb2E2b/hso8xJJJbKcckJSDtEKmYtz9iY4WeG5usfgZnrgZisD82ib0NDcCIb03MWYI8r7a5ab8AxuRCP3e53ArYv4Jod6Z3g7Yi8VgYz9EPyP12AyF4esPPwW3DA1AS10NJfeTrfy8P53SFFugngKvPHMC7n74yUOeHnwlYRC74Rg8NDYJ5oKJkgDWV/kor0A4dlC6SB4K/kc3zrXf3nQdIVrSsvSzix1vGRVahyp9/nrc0AwRWKkVBKKrU5PjX5RCD0ogxAQmtXjKgs/nBwR6WpZTtY1SDZSTfNsujfMO+zifi2fSlIFbD/CLFJ4iK7+eS3LJ5R6FXvuJk6d+1e32/CworG2ZpyYnxu6S2Pvl++SZ9xa5XVFID5GMGwa8kE1EURMMbu2p1El2UWSFMREvgJpng0ijX2YZsiMSHDoxQp5ZEc9P8EY4FP70+Nj5b4JyE9cTFoVKLPnw+6sanS5XWSiKqKTTqYXlxYUnQQz6+ToYje0v6wfBGCs1Ark+zkEzzkVDbv7hUOg7AkI/PRZ/hVcNI8jxVkKRIpkqk+PxeNBI/XAeBhBg+ggJKFMv1tIu9x2bHUFkARRZOOlvqqqqa7p7+3+Xiysm62syEg79r4nx0XskYki1vgQ4tDyqknoi6NJ1BSZF8sIBUAf5hhQAR3TtN0J6WPKOwDYL9PYNfNRqs5XS9UHRLfsLo+df+AcmLEsUJsLG94uAf04yLOgW7DMfKIEBa6FlvULYsI+y56qtq29F8EnigNlsIDQF4cry4kdi0SjxHhKBBL1861eiiLwwWcMMzqcDQ/OJKANxbWjc3QmGoNxVWqQQ5T1p5M/1vLb0FAv0vOETJ3/a5/eTdLMlJSW2+e7mxvoHmZAakccIwKFXhhAsNjW3nDSZ9NOvkrm9vrb6IJSHZskHb/GXPVVL4B/X0fVYLDqOYFOXTwDXtPq29s6b5udmfgTlRjARczzb97SQUN3/auDzElI/qikkVdMXB2rrmrq6e+/EPbALlPJBNhwOf3Zi7MLXJWJo1srPt78a6L9SfB3/V5Zj4M8UAvrVwD9J36fG5M8CfO581UHJ/k5+TwYxef/4ow+x55Zcu2sCtWaGGZ2+4mZrTqcpJ5jQYkqIkSTiNOpyQ9L70R/jKiy5hgsF4OXYZleRhM4ELTXV9Gpbe+FipfCfOmc1Af1R6XwZ+KfrHf5VkjkgA/lqAuj3Ee801PgpGA4iyPZXVIDLXiTiq3Z7wIPvbZZD44scFkBi+p+fXSpZ3Mkdzi8uQ6Cqkrr8k4wATHQ+Zdb3I/gnPAI70ShNwee2Oyi4h6LTPr32raeG4J7HnoFEOkPPIZfP5vJw34UxaK0NwI2DvbQ+xfR7wNSreKtC6a4mWk/y25efGIIfnR+jChEFuz/egPgobEciEIxEmRFBnP/zRMmQGqrpIrlKCShkSfzU8nTLF1fE9xM3eImosbQoozDYcTlzgRDNoZBFUiWF8fp0QySLNI4h4pKeApVFWQb9WuOdL7j5WhAggzwuoUhUWNqIbAbTSeVz+WQmQz0oRAoxdjOT264AYhBsNA6ZnlNdXRNAsHIXPgebV5wwH39n7MK5v0jhG6ZNZAGb5dQg7enIZrNxnKsx3Ch9oFO8vso2BP5TIBaebSB2vZb/VtvYDbuD1tU3EHfQ38e69gIL0PL53a2tzbtQkHoGxKCfVWTJ9RER+pU9U0NjkyJvu0YpbG9tfUtSWLHzSQtAX24RWtabW1r7sY0CeicT8sy52WmiKGE9fVjB9yiWTHatUAMqJeEqFo1sSYSddtAoZJ0JBOr6VleWQqD0QGLdt9nP5KI21hQM2r39g7cGagLvMZnNVex98/nc8vra2l3LSwvjoPR6E4U+sAz1qpk8bHabLvM3vXcuz7KWHxlIGkiJZZT0UAj6m1vaelrb2v9I6W1DFW9/Oj52/jugP/9ExH6KA9d7Y6EgTkrAypIFs2GEcsYFdqyUkRLXNzR1dnZ1fwifp0Z59UI6uL31xwgKZ0Ed9BvyPLuEoubazyrSmPkU3SBeEka8Snw+fyfKdLNQrjDhlVn8eGZlAVE8v9Y+pph7Hk9FxcDg8G85nM7bmOtSMkicc+/fWF9bgnIwnOfuD6AC+omXUFV1jSFPrWQyMRoK7W+AuocYbwgj95MzXMmx+sn11ZUH+gaGRiR5QrPU1ta9em1t5blUMqlFECma+//lwP8RUz8eBfSzIVtmlA3O4n79e3wmDuLNhuP9j6anLj4A5YCfn8/sWDsG/VewHAN/rmhY/PMa5+QNnG/onvJ7gfW/gAIkq+kkxYSgX8TwLv9N2NJlXgCC+ZmNl8RMF/gNUjrfZA6nYy0ExBJLObGEk18QN38LJb0zFZoc1RegKKQq8qnike32Nj8/GVu+nZw0u74JTYEqepP92AEC7jS01daCzVo0yjisNmAI8Q9T8pFQgtYmmFhZkypGYvNJarx5uO3MEAX+bDFJe4HLZoMmvx+y+TyDEJTvzvZ0wmMT04eWfROpvBnWd/eo9f9ERzOc6e4sdrhcuZICobw011VDY40ftvYjlLm/29s6sxXf8UYz8apUJmu326yU3Z90RSafIZwGsUpbxfiwv/3uJkcNAW98ui5emGGrX6bpx8W0jHClwus1lP5OpRRC+3vf3drcIKEcSSmmnwIoyXrEhx0IyfzUxjhw4A3BemkMFwqFAv8bBP4eMFAIaJZOV9Nes3GIPBAWxbCJBCYF6O/s6jlT39D4YexflrQoG4tF/wZB/5exvWQhjr2fvO7K9ZEtFo50KrVpBPhXVFC3yQeg3PVORHLGkoWqAQ61Zy1TdPQPDN1eXRN4N85VRb8gQJhcXJj/EI4bmXSLt7KrkbCxChihoEG8Pip9/kEj4wDbcG5lefEZUCrS1Cznl2rtl9sTQAD45eetCdS9DPSVFXkENV+U0qGJrP2quch16qwHVOhak0wmIzgHgw6Ho1nvgatrak4j8D8P6tZ+HhgAKIXJMg4PQgrZ3dP/6wgcy9oqnU6ReO5PRSMRniOCJXwSpTNkY6N5gd1ks9kNZVjANcUYQztXOBdgoScT6AvY/Kv8PW23vv7Bl9UEaj/IzkNc/0I7we0/mJmefALKQZMofabcT2UKIfnAsREx8sxOp4uEZThAqfyR5zTPwcCvP4TT4URzS+vv4lrKZ6LJ7e/tfWZ2ZuoxUAeEaoSXV9IVWDWun2mvDAk3I6SQuI5X6V3QW1k5QIYLHJLL8e0HcKg44RWmRj23hHsXObe9o3OkobH5/RaLhedmeXJqcvyuSDi8B8r5xq/fIu9DRdx3XV1Dp91u5xQ54vbdCQblsEI1Rnd+3LLKc0rwR153d3cW4/GDSY+nYkjvphar1d/V3fu6i+Oj/wrqc4VXEMvvFeCflP+MgFQH8BvlGNGz8tOU0oPDI2/y+/2/WMQYhwVloeD6+uqdy4sLoyAG/KK258PajkH/FSjHwP8/aeFcN+l7FPZhCzZYja/S+7x8IWbZSFniFcTzeZGli56fhZwzmo37bRY71FZ6qYs6UQBs7u9THJzOJnNn64eIpZoIqXIslbwAZ17edObJycnFG3MF8BCCv+1QGAK+SvC6nJQcMHKQgK6mekq6R8j7WM/mggSuyTGAwH9saYWCZvI5YfnfCofg/NwSXN/fXUq5J51YahFyTaeNV7ZL3AD4b3tDLcxubFKgTk4nZHsnm/vhwvoUZE15GFtchfmNbbi2txs6m2ppKAJtxELhsMGZ1idtc8uJAfjGw0/RD3wW19JP9/7UE1i3VBah7NjunLdQyGb8dl+00VsbdJntm/kikzYL+EUxiyJ3aOD+LlugrQiSUAgzmue8rKTT6aWZ6al7GBd/3moqiqU8Kplfabyh0GGSvFLkzxTf220Gc27naVygWtw+G+KixZGgBYJLQipJzD40fPJtFd6K/8FucCRt3d7uzkcRrDwM5THZ8v14sCQLSSkUVubdHk+/3rO6XO4+bDcntlsSlPF2vMAocqvnLURqQJ99ZpPXW+nv7R98NwK0W7l+KiBovRcFp09i/aNwqBiSX/kxw9eF7QcRa7AVhdMBfF4jCqDC9vbmt1hlFSgVVVqpJo0WXgDkLep0/rrdHqvDYddVViSTiUcXF+YehaIiVYt7RbfeXMiYat2Ai5XFfpsyAvxRkO5HoN4UDoWWQQkA5D5jQYtWeImJsNLieLq9urr6V0wmCvZY1/5ENBL+6/GxC99gXPvVgABbDzYkTkVYNyHwt3oNdXQhbyS+XbF2MVl62PHNh+IZJQ/lY4yJEx/hQHg7ygPvAIb4Lp/PLa2uLL8fj1mN9uL7Rq4Pb+kvnZNIJDaNtJXD6Wy0OxyV6VSKd+uXx4VIGSR5ewy8PBCoeyfumXwIRj4SDv3NxYkx4r3Agn49vo6r4eIvv8pHGeiX64Zzegn7Rxf44zreQ8JnUsmkDPpFZJkZOAyhYeU/0VquBv7Z35hQPnD1Dw69A+fzG0GJAwrY318dPf/CZ7PZTJJ5LtFexhOaloVnkaOuvuEaIw2czWa31laXzwn6l1c6ACjlWZmJX47zp3vh+trqj3pwYBmx+vv9VTfXBGqf3d0JTkH52qK27sprAzuuC/+Z2P4NAn4913410M8qJEn6x4rBoRO/iWPrFlDKB0SBOjM/N/Oh4PbWCtO/onh+kRLvGPRf4XIM/H9C5RKI/2Bjc1tk2eCBEvtqhnLAwQtDig2YHE9tj3bZLDYLcXdvqqmmrvDE0L+5F6YgvNrpna+0uEgcm+zyLW9EFPjbTbZsT2XrQzPR1TsIMH9sfBruuP40jYmP4/62FtyHDbzWTcO9FPwT4F0wybD80BjrcTmgodoH26Eo/a7L15qY2V9wTq6smwib/1BHs2SQlwA5/pPKZqgywI5Y7NB7QL52sRTj/Tvh3mdHqWcAyVqQSKR2P3DjL+18a/Re81R4sSOZztoeGZ+E52cWKFM/STVY5fWA02GjVyxyEVAtJr0+UWoQJcl2NArP709de1PDyfttBXPYUoDEqaruBZDJugqQzBetSKK84mqM5yJvDlXg7/f5GywG09/xhQjZK8uL/x9u+hFQKiUMpUG7lEU5RwaGRrHaDLrlFq3rahsXa4ESjX8tS4nCNRkFhLqu7t4P2my2a5g+Ic8xvbK89KH1tZV5po1ErpG8m7tsrUjt7AQv4OVfAzrEqwQENzY1D6OQTyzbWgKjWjy9loWozBUbBaibsF7vKXfBhUw0Gvn82IVz/5uEh0C5VVZkZZcLG3ahAYZM1ppA4IyRMYCgYxb74DnQnltXytqvBQLSRPFXXJXUCwq7czPTk58hxKhQXBPY8ARN0K9RZ5Grv8g6WSLI2tvdeaGqqvo20Bl3xN2/s7PndefPPfdPhSJTKuu5YQXxmCudLteruaW1p6m59VdxDg1DuZA4u7a68tHVlaUpEI8lNZ4GUXhDGQgk24LRzBD5fCHPfcRzObBrMh97zf7eKOO6Jq8GgsnKgcHh9yPAfilbD1yvn52ZnrqTpGXVaDPRHARQAfzyNcLh/aVCoV3XdZ2QjtbXNw7i/vEcKMEh6wmiGBPY//bB4ZG34XO9CsrHXj4SCX9hbPT8V0Hbe0dVKXa5IIFJt8wq01gwyIL+EkFZJBwex2c6rXd9El7T3Nx6FkGR7PrMr+EihRow36uFi6iG1BA37PqGxvfgHsIp+grJUCj0FxNjF+4B5RjKCu6vZukvI/Wr8FYYIvWLhEMPSnwSolTBfOYOdnyxZNclqz+CzBncI8ewH3TDDAjfQkdn11tC+3ufkbxkWYuzXjgYK1vT8pO0/gu8jeTXo1j5eSUOD/4VPEcNjU2d7R2dH7BYrK3ArefpdOrhyYnxT8RiUTlETI+Q1bAn6XG5tHIM/A2Wy3Xh58ulEAk2NtSVWR8Y6wIpIquHDP5FGnDhIrAa3xuUL9NSW03frWzvFEn98P+Ao5pY+2XgKhOukELGExVYX9N0w30LF795NmeBhng6Dfe9MAZ9zQ2wfxCnIH83FqMKgZefHgaHzQ5mqcYm5hFIYMKZrk7492fPUaAdS8bSfd62yMzBav0zM3P0Z0MdLZRVv2iNN9EQgqXNIE3/Z7NawWq2clKaiZIA1lRUQFtdABY2t+nno9tT/lPe9qdf03j97g2B4ece3Hx+ZPlguyeezTgurq7D9MYm5Sko4L0y2SyuTHlab7fDDg68JwqSEIzGigoGs8X34Mazba9qvP4Rpp14674RBlO+r9j3qhpan7+q5ahjVS7RSOQh2cUf9HOIXynwBNyr4r3VajXk6g+HyideAOEtUHrxx0LAT65P3WtrAu8zKWPXaDw/bm5/cXAQi4K+ldvKvS+REyEAW0LwuoaCvW6oRm1t/c0I/InbNRF2nKBUbvCWNj3gLxQU/VXVga7u3nc5nU4F0KAPnc/vbm9vfXRudvopEG/kamAbQH88l/rA5/MFUIBsNzKesD5sbL8WOd6VsAiqufhTBRRx+UWh5wmHw/lq0bnYz09MT08SN3ZZiSoK+bnUuaYWk8zWscSKvb21OdPW1rFps9ub9B6aeKT09g++anrq4g8O06QohH9ecVlq60CgtqGtvfOtTpfrZVAuf+QTicTdkxOjn8PXGIjBq8jjSC7yXiZSkJfaxULSrxjjigAosbsYOtiwFYBywK9nVdPk1Whqbulsbev4KNafnQuEuf8eBMd/jmvQgaDN1FzhgasnD/5LQDYWjQYzmcy23W7XJdasq69/ydrq8rjEJcR6g5TNPxwLTZ3dvUT5w5F/0ZINh/Y/Nz524WvAAGpQDx8qc/O/wiBBzYNGmG1pY2PtHIKhNyGw1/VWqwkEbllcnH8qn8uJXPz5OaXmNSEaW+znpuqaQB2C/l8WreXYXZubG2sfXlyYPw/q3lp5Qd3UrP3UzV8i9dPFGcRDa3V1+SEQK3ZYkj12XpuYOsqec0nm/valxYXvDg2fGMA62PXqgOt0W09v/+umJifuAQ3wybS96L1CfvlxWv9VwovY92qA34gSUgT46RjrHxh6FY6td/EZOKBIMPrlsQvnviB5Jmq59uum4jwG/VeuHAN/g+VKM/5DueXxkurATwZOEQCgvmjxwjZ9j4DGup+J9BB5x2G303R1xOK/iMCfmErS2Ux+2NdJcs/LgiqZyGycP7X6WE2mzC1Np798//qzv2O2WKyh2AE8M71QdOU3FdPbkZj/e5+9ALdfM0KJ+GQ3/1LKPnwlsfMVLiccEE+B+Lb3XX1vvLAyt+1OWjLeZxH870SicMtwvySe5ambP3HTf3JyDjoaa4upAa02RXPQrIL43zV9nbC5tw/xdBaBu9Xyb8uPn3pX3099y2fzpN/Y+tKVg3zC8eDGuTPLB1snEul0ldVsKbL+S82XTGcgmUqXfP9ppoFiRUx7qRgh9IqAUpjXSlmiWPhQMIZkIsFusmrAjWVHpoenokLXZVdUcHHen5ub/gaIQb8ec/JRipalsuwgpJRGLiqlGlPEF8Jh3LvcjnrEY3J7KuZFhdfr7esfeg8KTQprPLHUhsOhP784Pvo9Adu4GoM9269pps5UaNnZCT6AAtM7QAecuNzu/kBtXcdOcHsGlGBLHiNqFn+R5VHxvFar1dbXP3iHz1/1dmxX3uOCxIA+Mz8380e7O8FNEIN+kXsxa8lSdB2IxzUVLBubms8YcddEkE1i+58F4+n7jgQQGOsfgBIA8CAgLfczguM/w3bM2+2O24gbcyGf38O2G90P7X1nfnbmKclLgk/xyIfUXCoJoZqrvyyAyQonwuNh293duQ/BytvBAChG0HabzWpzzUxf/DeGXJYdc4q0g9iHnQ2NzW9wuZy3AJSnNiTAA8fxp6Q4bjXwqpayTS68klvkns3QiOgX4uEA5W76IuEZgOPfUfmtmmcRL1QrQD8K169A4fp3lbwahUw0Gv0sCtZf1QmHULP2y3WVeYCEbuuE1DUWi45WV9foAn8ETw1dPb03z05PPQRKb7VSnDquofau7r7bfX7/6/B5yjwvCAjc2935MwRgPwRB2lPQ34uuJkAwpEhLJZP7kXD4CX9V1Sv1Lmiz2Wu7unpuwbF/H4iBv8jVXe4/VVlO/tzt9ni6e/v+W0WF942C9iZr+dOz05N/uL+/twPqllg9pW2Zmz9Z76qqq3WZ9UmJxw+ej0WjOyCWjVjLO6tozHH3T/N1CIf2V/f29h6sqQm82kg9cI69AtfA2c2N9VHQVhLzSjP5tWwssjL5lQavOtZ99r1IAWlECanqgeTxeLx9A8O/5nK5+NA/SuK3v7f7F5MXx3/A9elR0vUdg/6rVI6BP1cIuBZ9rme9V/tO47zCJdzLhOdo3oeL8TThom/K5rImFDhNuMCbzBaaVJ4y+jOkcKUFYCuxXxNJxbwOqwM66mop6CenLAd36SWdFvtOb2XzgpSGgwX+BSZTAJ3Yp/3dzx9kYp9/cvviuxH7m2WBq7++PT21MZ9DqcoVTSbhW48/Ay8dGoDOxjoaDlBk3SvCf3L/ppoqmFnfJMHr5ud3L3rf2ff6H35t9kc37uTCTUvbO7C+twfX9XZDX2sjRBIJ6spPzl3YCMLq9i6c7emA/tYWKHptFj2tTdj0JAPAdf3d8NCFScriH83Gmx7butB8U90IUWxkPGZX7vXNNy6bzYV7nglO906Glk9Esgcd8UyyNgNZm8PsIF4QRScF4qGQB+rNkMul965p7v0eFIG/WloauuhZrNZcLpuli5/d4SAgN4+APy+BftZ1FYDb6InrpdTeFonZn8R/2lGwqoOjlwIK3t9OxOO7Ur+mCJs/HrSu+JorHuZ8JpPWXJgNjuvSexR8TMTYUWzGAvt9gboTF0o8EpoFx5icR1oU865GMqUGOEvCU3dP33W1dfWEdKqB6RPipn1hdWXpo+trqwugFJjVLFEA5UocedMtCSvLSwuP19bWvdJmt+spcExt7R1vRPD911LeYp5h3QpigKSm9aef4/O+JFBb+0sitz1iYESw8YWJsQv/RyI+EwE0kXsm746tBpAU74kCotLn13WZJdcObm/z1v4rrbBS3A+gDPzLGSXkkifW/OeeeerDJPUhrqNWBMkZxpVUFG+vyyqtJwQJ3JP1gAqZ79alxfmHUPB9md1uN+JdYULg9pIzZ68bDIVDj+0Gty8gcFgpPhrl7bAGausa8XrDCDhulKy6IuVNDte6b89MT/5tNEoJ/PhxJLLs8u3CWvpF4F9x5HJ5NjxN7zFF80R0sO0tvzfiSisC/iXA70AkPTR88tdcbvfPsPXFcb6P6/VdEokfO4a02oxVvgGUgxf5UFivyfjY2lh/oqqq+hWSIkSz1NU1vJQox+fnZh7C8UD7CM8jWYma6xsar/F6K2/CtbRC1P75fH5nc2Pt44sL88+BGPBrAYarDRS0FGn8fLItLsz9+0nfmZeYzRbdULXaurpXh/b35nZ2gnPMGCoZUqCcz4Ltw7J1E4qyn6ezu+eOyspKBPxmEWFs9iAW+9LY6Ll/lNZy3tIv8kBkuYY0Y/tx/rfjuqeb0QSK5KYyqZ9a2KMaCGet/mysf6ke87PT/4FjbsSIxwoZ323tnb8Qi0U/G4tG10C8V/B7Vob5Wwj+5fMvVwnAAX25LvzrUdz6tbL5qCkjKRFnU3PLb+E6r5CJSMGxtLS2uvyHqyvLU0x/isIAeW8OoQLvGPRf+XIM/OEwHZ+WVZ/9DflbTv0nv1c7B5gFgwVER/UekOqWN/JbBvwTTapi0cpLghmoaInH9mbbXDYnPZfknydlYzdEGemJ0a3GXnFBAv28VU22pMiaV/r5zbWnHvDYK8KPbJ77lWyhUGcqFEwH6QP4pYHXf+kHS0/eshbfHTFbzKaHLkzAwlYQbj1Z5MI6tPoDNPp9MLNW5Be6GFpqu63+7BPv6H3tPT9cf/r0aHjhWlwybI+NT1Gm/ppKL0TjiVJbZFDuINb/52YWqWIh4PVCwO8Ff4Wbxue31tVAtdcDe7ED6q4/EV46jcCfjbfL5fOm3DU1/UE8iDWKgHPTTibiOx+cadlNhRtS+TRubmany2bftBesmyM1vU+2u2tXQQPwy9dG0F9a9NKplGJjQ4HZFItF5UcpLeJ4fwvWXWbzpwtyUQFgsuFm70esZNQ1/nB8pdPLCwtzxEpTIvQj/czFbdNNGAVA0nYFKXWfHoO/Ygw//uhDJYUUjk1AYAeZTJrX9paEUNyIC1mD6aQIGz5uRG5JiJHZkVkLAc9ELrdrGfglrygsVPb2D/yq0+l6HShASyF9cHDwxYnx0S9l0mmeAEnNysaG34iAf1LuS2xb69rqyr92dHX/DojBUqlg3bp6+wZeOT118T+4+8jzWgt4swKjqb2j62Rdff3bbDY7mw+89NDZbHZifW3lT6UNXQQ2RLF6PJmYrJjgi8haAQ2Nzb1GshzgGFpYXlokIQe8d83VBAgyAGCtPgrgL31uSePkZp5bmAZMpf0uJzRBzzVZFpSpVRvnjXl5ceGL3b29H8K13mXg+iYL9k1NTeAOPF5HrM44dslcJWtkBYmbBQ1wjeNpbGtz4zNLi/OjIFYeicCryAOCHfMFAwfxRCepSXXj/HGpd4BYUGbnF5sphLdyGwH9Qit/fX1jS3tn14dx/A+w7Yj9NIVj/UMb66uLoJyH/BjSYyZn55yI/LEUM72/v7eciMfHEEsaUcKZa+vqb62uCVyD436DgH5cU+pwbfZqjodMZmJ+fvbjO8HtFSj3kBMpxURg4YoDBQ1PH34+sYDTivtbcGtz8xuNTc2/qPXctANMZnt3b/8784XCF0i4l9yOoFTg8s/L9yF9T1z6W1raXuep8Lwar+sR3ZuAs62tjU8szs/JZHpGyDPlOsn3ExGxlgB3fX3DWSPti2v3ysb62gQYV+4AKLNRyN4kaRAA2UwmY8E15l96evvfK61JmoXsN339Q/9j9MILf4v7O9/WakA6w7zX8kQpKQcFmbv0ipp1n6+bSJmuBfhZxY2m9xFRYA8MDr+1wut9IzDEonJJpVL3T02O/3ksGt2DcoW2VojOMej/MZZj4A+H6fi0wLjoN0cF75cTKnAFwgyMaP0su9lYe55ar4tu9mT+zW1sSu75+UJ7RSOxhvPuqWycv+y+LE/01Glf9xMj1T1jX5u99+eXohuvjcZiF/31npmf63jFIgL3gQfWn/vZvMVcuRLchbsffgJeNjIIzTU1kM3l6OxvwHqQJAQmixlimVTV7MGqq8fTsvrqpuvvvb52+Invrj7yqo1EaNiKPyDhA0BDBkxQYXNHI8moh/j/Z/Ba06sbMAMb9LrEi6GmsgJaAzVQ7/fBLonPNxG0m64yWc3pQjYfBjHRXoGA3mpLxe7LG87MgroAr7bY8alK2EVPQVyDoF+2YCnAGt7fJOo77B+Lz1/VBDpChqDkNzfWvpHP5WKgTeZH62u2WAAFQVpnfmHWUp6Rz3mFFAr/xE1BJvgrA/8ETCBm2jPyEIQLwOOpqI5EwnEQpxuTY961NPhETiWpsm6tqq75dQQHAVAK3TNbm+t/tLgwPwbqoE1NMJXvwQpRLCFhaYNdX189X1VTc7/P53+lTn+aArV1b8jmsrH52ZmH4RCIiki1ytwViYtIR1fPDdXVNT9js9kGRPfCPjjAjfwfLk6Mfg37i1V0GHHFFoENIyCWjodAbe0NoD+eC7s7wW/h+OdZ8a+mtV9RT8H3BTgcCzIwNHHniJjURaRSlyMIibwSeEG1pPjd3t6cdLldf9/U3PpuI0IyU8i8sROPI70f4vq1Ggrt/8P05MQPCQCH8jHEe4xoZhHh2lUI9JVtUCBOF3FjwJ+SAIo4MGQwxqbmFHkSqZ2rmVu9f2DolQjgfhvblM0+QHghvn9xYuxTEpeImrJErc1E454dq6JQEDlm2ra6unxPb9/AsNFxgWOhwuVy9xr4aR73g29dHB/9OwQOclYQrbC4q0bmZ6Cwyr4yXg+pvUp9vTA/+6C3srKPeL0YaK9K3Hd+c3tr857FhbnHpH2eX8eF2SqcWFpa26/B/f82h8NxGpRyA/vT1MHBwf+Zujj+pWSyxAnBW/n1wtT48V1m7bc7HISHss9Ie4b29++TjElaKRr5Mcx7q2RBQ8EW3N6a9vurflBbV/9TRjoZm7N9aGjkHWOj574keTHJ91LzlpOVD3I9tAAtr7Dkxxd7P75cDuA/itdR2bqE42uoqbnlPShnlXkCkv6LRsKfnxgf/Zq0pqsR+GnF85fk32PAf3XLMfC/iuVrd999VAB2JYsRYg/eemGOpg4aCGj2Oh3gwYO4zS9uBemFcrls5oa6YaKZVaSCgkNBjXWpVsSRWnKF1Fs7b/9CwWz5qimfw8sWqDv2iK/z2RZP7cK3lx5+814qPJJC4Pgfz12glvlTXe3Q3VgP6UwGHA4bZLJ5Qt5nenZ7sruns+UCnp/32zy7b+987d8/vTc59Exw4k3JXLrOYrZAb11H+DV11/51JBlzPrp5/pq56Pr1BShUgMlMwA4F+XuROOyEYuSjUlNZLdbK1fRuV7O56iFQgke1BZwX4I2CQdV4JhBvCLoxowSweioqdN3Z+JJMJqbWVleIQkeO7RdZWEp1Jdb6XQgKr3UJCqqC5A5aZu2X751IxA2lk4KipWkQgT9hbJTd/GUhTR6TWkAYcHPra2xqepfNZj+t7INCJhFPfOXixbHPJxOJBIgVOnrWWhb4yy6KfF+WPA9QOPuXU2euaXM4nHoClLmhoemtFR5v+/zczDdjseiu9Lk8VsqE5Kamls5Abd0tbo/nNompX7RWkTR99y0vzv+/weD2Gmi7YeuNb4ByoUU0VkpzqtLnq0TgoJsOL5vNriwtLpB0eCLQr6aEuSSQwHpTcfUVPQMfb8sDf3bM84pAXhg6Un11+Aj4ccd6YBSwLR8hcdYE/OPYMJT2zkhBgXAN5+ZXZqcnv5dOp+OgDfiPsl4ClI8pFdBfPHAvO7DZbNV6dTZbqHJAjzBU5Mkj4mHRyxpi9ngqPP2DQyQl1muZZ6Jx7yhYf4ZLb6gVXiNSKmvNN9bdn7Vgl+q5E9yerqtruNdfVXXHlRoTuPYTboe/mpudJt50adC28mtZ+n8cYIEdW0JCT6nNFISwF8dHv3Ty9NlqXMd107QSZVRDY9NbagKBlyIgfgzX3Qvh0P6m5N1XIrhzOJ32mppAc6XP3+PxeEbsdscJKRWimsxZIOzqqyvLn9vcWF8E5bhRI8/kOSFYZYIoPrwE/Bsbm4bwWRygU3BNiK0sLz4K6l4dbD/zY5j3tuIV6QplOo6x/8D9rh3nmC7LPykoSw0PnTj5tvHR819hlDBahjNZmcq6sKutW+xYEo0xALEMyL+qyfciHh89r6Oy1KHkwDar6O0beDu+vAYEVn6cw/MoP/7x6srSJIgBvx5Hi8J76xj0X/1yDPwvs1wF0r/LroPB3J2sUFp8bwZHKBNrIbHv9dV+BNo5OEilIZXOUAu51+GZtICZxK2zE5oF/iKGZxswqVZMxVzrLPGarcpaEXtn9x2ffSZ48cTzodk7wtlo397Bgen+C+Nw/4UxAsaJv33R8R+fci8TbcdNLoSbYckSf331wGPX1w4/OR1abI5nkhUDVZ1bliyE8drmn2q5eRp/9I0Htp4/vXIQHN5LhkayhbzXarYQt3laYWryyGXxgubnG8yVxNVfZpXm4yPZRZtduFjhnT0vm3XlwJqwGFEiqI0jPdBfOlwu11Hj+/Mb62tCJnRsG2z2PO/ul8eN+nIFLcUzW6zYv9msSJiigkgkHF4lMexG4kurawLXEYI3EkvNjUm57fi4d3o0t7R1o8D18w6H4ybgNjfc2Ca3Ntf/RLLys4Ieu5kZSUfDgj/WNVwkVJgI9QMKjZ8ePnHq9212e6fOo5sqvN6bR06duTaRiJ87iMXG4vGDtUwmE7PgOLc7HV63y93gdLl6UAA9oQH2af8QN+zg9ubnFubnXgAxQNNTdoieXQ14CL09WlraXmLAulgI7e99K1f0VuFZ8YUeO6A+z45S+Gvkue9kQZ0H/ewzlwFSKBd06e+vQEgCu07JSid2/LG/zS0vLT4RjURWOrp6fgnXlLOgPlZ0741j6WIkHPo6Ct734XiU2Z31lEdq44n1iuItkSLQL1Io5rAeIQTXrXqVtxZ5Q0R5rHkSNi3gbyRjiLm9o3O4obH5TovF0sLWAcf2HK7RH1leWrgI4jnIgjUtwAEgbjN2bGRBbBig43h66uLXTp0+24HAc+gSx0OxErjfHBzEvjk7PfmVeDxOvOuMWPl/YqCfU/jxbcZ70CiUfTjWYHz0wmeGR079Hu4vRjwgSGhEU21d/Zvx+O+4BycI8S5RPpNIP4vZ7DVbLD5QAnHVpsb7Pxfc3vr7xYU5mbFfzVtLxAnBu/gDlI/vMg+WqqqaE0baNRaLPp5MJuX+17L286E9cmHBv0iRXgK+JDxy8uL4/x45eeZ37Qayl5Di9VaePTFy2jI+fuErKKMY9eSRlQ9HWcO0xu/lxPEbDTMqW5sIh1RPb//LagK1v4jyQrVgrBVQ1vj25MQYycIieyDpsfYfk/j9JyjHwJ8plwLitX7/lje/ufD2t179euvUWWthUCgAZiKrjSYT2EisPslJTy4aDEVQ+LEQKjmos/sJ4Y5WbC8PsmQtaFn8l+jv62oHn8DjmdHQQs8zOxOvCyZD19itdlIfkxkkDj2sR77IAEdygipd0XI56PO27gqemRj4Ta+oP3svvr+XpHO6GFpuXThYb9mJh5qy+ZwFN9p0k6v6yduaz5yDDAXBmgRb0nOqWZTYBS7nzDoL/397Xx7kVnLe13i4BjPA3PcMOQev4VDcQ9KakdayVLJja+1EluNySnElf8h2lcslu1w5/M9aVaYqa+ZStlKW5USyE6mikg/tSvJK8rE61lqvspJWy2NJLsk5OZz7BgbADO6HdL9Bg/0a3f0aGGCIIb9f1ePDgMDDe318/f2+q7Mo41SBWNSHrFIuMtzYBLvH4/H7fP4OVAawwL6Flcq3kd1baglvvFDKKotLx1uZc8i6VqHOAeuNtBU9w8rBBiYPEa/X61goCH+mdWz8HR+5dfM6CUtnC97RNqTKgenz+91DQyNPtba1P4O/dx5xuedEOd3b3f387Vs3v5hOpxLIrmTzHjZR9WGnSA5ZYbti22Cl2Lxx49pz4+fOEy8gF4UgGDAul7+xsekCObh+0iFu+VwuOxkJhz+PFfxXC55FGdl3yr1WPbvM6FU0+GBFIxMMhS443TC+36W5u7NkXhdrU6BSBbKquf1cAVUWPGm31VBg25k7eM9HVZQhzuvPymZK/hEqva/iHAyHt2fDl9/4w/6BwbPdPX3PEAMAHl+O25Oh/Siee8lk4odbmxvfXlpcmCzUCpEVwNQxIDmFq8vaNs9cr0iOM+m0VvqQ1+drQ/YtynyotHYInz4k8/jzhMH6DCYh/rPj5/91U7DpV/FXWZ3MxG34lYnbt/6I2ybUKSVCt81czOf40HVRhXiUzWZMLA//+/g7zv8evu0xnTa0/WieiLTdlxfm7/3l9tbmChKTfVlo/4Py9FsQRNGIPM4iQx/pR/Pm9av/efwdj308EGh8Eukb0rAoNJrIUebtmul0+vXNjfUvYcJ/DZXOPRXh5w2lrKwTGbVsJBLLiVCgsfG4xj3msO5BZLcowkOmc/Bn2gci8l+ypWEqmXRNTd7+3NjZd/xb977xxBF4HXr8sceeDBA9APfjFhKTfbqVNa2bIipw6xTlKYOM+Mt2GXHy8vP3XWKI7B84dmpgcPBjWC8+iwRjFeuG63hsfWp6auL7SFycVhbaL3KiAek/ZADx10SFRgGznM/XAC6kbx10zewsD7ldblcO8+re9v1tyjciO9ans7ls/lhTDwnl4Sc0v0DLcsBUBY3YECPP+daRK/i4lkCZ0D/OXxndykZ79tJ7IROz/3g2MfZEx/jnsQJBiL9TwaKSAmbkP3KWgWBgEx+X0X1Fd5/MZfJaYYWF35Ap77Yjm8mIFDHEvS4KPknlVlEYl80AgIlhCJN/naJcFOba6vI3UemWg6ocO9u9HgCysMmSquMkzDWZ2Jvyelt0KgSToohnH3/y3b8+Pzf7tY2NdVqHwWrrUKi5pbun90xzS8s7GxoaMJERVpfOZzLp1xYX5v8HVkzmUOlY1yUrMuLLFiYSzU3EfJdUPc9evfzj/0S212vv6PiVQsEmHegqlzlMhH4YjoS/MjM18QOO8LP9oROGLVPU+HsSeRvp9dNYKWswDCfFLJ9dX1v743Q6RTxGh5HbX4SE/LNKMr97A0J2BVpkQOTbpVrKkOh3ZP3BGt8IyU0tLy1ewcd1TPQCPb29p4PB5lFMVnutYm0ul5v0A1YEo1jOrSeTybuY7N+JRMIb3DiSpcXwY0k1j0raRZB2wXv7S0g/OfB9rus0nN/fQFKnKOknoct8Whsl9Xy7qnYKKe5/fnxo5Gxf/8C/x215gukLolivYWJ8aXLi9mtIvt7qyp+SsSQYuyyJZYullcgjTNyzb127cnFsbPxXg6HmDxW2UVWOv0wmM7Ubj30XE/5vx2LRLST2Djp5+espF1gURUOru/Ow7j2VSmXfunr5v50+M/7P29rbf0mw7/nBbyqfj+L14lurq8tflaxdqjnIEzMReF2kxPPd3ds3phOdh+fg21hWkEKGbCFWVQ64TH7ztTVkee7W3zuRyPzs9NRnT5w6/duGYegYMsnWuafPP/7E70xPTX4xvL01h0qJP90alZJ+UfSCyignM8zx7V6ul19G+nkPv/X99o7OvqHhkY8GAo0/iQRh/eS+sDL299OTE38Uje6EkZ3089EkqgKjQPofIID4M7BV6sfHsxcvui5evEj+pNZwIeh38CddF6lyd9F6Iy8zFjz7iT8wLj33SfPZbN64yBFXlcGg8FvFRbtwz4bgO9Y9JVNpdzDY5MJKmfU9WhEeCUjxRipshRP7PW7UFsLcAv/U1PLa/n+b+eRTXWfvFUK/RQtHkfhj8mmFKZMt/PadPzla4MomjOgWdNzfdJs6vCp6oz93/ALdUsVUHDJyIfKkivJsRQW2eA8uLULHKuj0nC88N8k3zmGhSbanI9sgkG2M8o2Bxnw4vJ1DYqXfEnrsjg/Hjg+7FubnRM9Ci89ZWzGSvrTaz0Ru/G03JrM9SJ/skc2Gp7ByQMLXhaQfP4+Z3ffG2wT1e3/y/Y7XloxJ0VZj+YZAwJVJZ/AD7c8VPMZyJNI9nzczhUIxSbzIXMec3bFAEoXf7x88debsx4dGTqxgEr+E28qDycoA2WWMGRMlIGG1eGH/9NTknf/H5dI6hfXLFnUKtu/ZQmAspOG3xGM6cefWV0Oh5leHRkZ/MRgMfRA/U7NuewiAuzZzK7GXeHVlefHbm5sba6h0/Kue2cmLISNoIsJbkiuLicIuvsEJ3GfvFd9+Pr29tfX83dlpQoxobQqZ4Yrtk6opGQrPP0J2o47wAQRn23vVuE9BiDKrJGe536be8aIBBjEFn9Lp1C4mbsRT/gb3HMJwelS6NpQ7loRGJLZdOHnCP4sodcg64vHYsk77YTnS7/X6gliGsOOK9fZXtGVmMBQKnjo19muYUHwY2fUwQhD/dmZ64vkIXjQQcjScOEXbCMeSYOyyHuwsEqMYlYObI33j+rXPtra1vdTXP/g+vMadc3s8vXjxDuTx3DRzZjiTzSwm9vbubG6sX9ne3lrmdojhc8xVuziwfVm83wdBFhyiaOhrUZtZjgW8nqXv3L75Qmtr22vHh0c+0tQUfD9ezx2LTKpADOMknD8ei75yb272HxOJBJumqDN2RPOPQkQ+RaS/SCLxs+lEgpCCrN9B4tQOJ28/4v5mZZeM+NsI88bG2oTb4/7c8MiJ38TrqJYBhuxMcWZs/OOrK8tfn7s78zoSpwDR1FZZnRkdBwELp1pdqlx+UXoRT/atc0trW8fw8Oi/aGxq+hmZIY/UaNlYX3t+ZnryB0hsrBM5DESROjYdGkj/4QOIPweWqF/CAxOT83K+k7/E/sdz8u8Q0m+dMTm6ZP8v5SQo/Faee09qKGjw+4jHuSj4yBZ2SCAMCXbS8WHy12BXByJV8CPxXbRP4N2ozR+6jb9Lq6XLitZZE3w/wtoKw1UVRDEY0l+oSp+n79vCC1GpIicrWsRaSWVh8iz4HH2lIlqoPI+QRGnP7uepk7wnm+KVSiaVHn5uDCGSQ9/R2WXghZG+ZRP4xCiC7lf3d+0XP0AurER0IX3ksRD/e6I0IPH+udlCqHyJccVh9wtqkLKNSUHETLF9iEeb3D8ectnCvRS3KSwc3rXVlbewghkrs9gYCaMdIIfTB3FbrsSi0S9gcv0SJsS00riuh5JXTJ2s+DQMnB177GcQ93+kT6ww41gsmrp5/dqfer3eLx47PvxkqLnlXZicjOE5OqDwvJGdKMJ4/M5hAjO1t7f31trq8rWdSGQbycmajKCpSBrbr6IFnfWIlxg3kL1Akmt5afHTx4eGT+E+Z8c18R5ew/f/J/P35sg2cLR+CJvbLytQVXUFQ8Pzj5CkcKKkz4vXrfI9sm+J2oOXgzRFiyiyfHi6zfiMxHKUjaSSHaLUGG3yKmhPXs7KIoky4e2teWLYc6ohQf6/p7d3bHFh/k10v2Ao7V9+qzX+/koIB9lF4/TY+M+1trT+umu/zsb9TjHNxe2tzf86OXH7+6i8KAlptI2qzRR56wiVrpn82LDq80TC4QQ+5smzkuKy+CBEFBXq74gMQE71HUQpU/UYFiyLohGlzvCGzXQkEk5GroU/0xAI/N/BY8d/IhRsftLn95/Bw6MbyY2F1jXxONnOZbNzqXTqzm48dm15eemtBNkbV2y4rcTgRg9VbrkwbZSkrQQCjU71aIhysb64cO/HSC/K0Clqhe0D1gAji6azgAn8dTxePzs0PKpN/knxxf6BwV9pbmkZm5q88yJud7KGUjlJU4GE+hSyGzWkIe/M2FHl9Ot4+nmyX1K3o629o+vY8aEPY93xZwrFIUVDjmxf/MLknVtfYHL5VVv5HpU5/MgCiL8mKgn1V31H5hGt0j3oFgMpCsPF5EZPKpcNNfh8+/n9ePGeX99Ebo/bmqZtvibiGVYJMVZg8/ciC1GX5WKJ8p0RKg2nl5EsFflHimuWE7osIrFOr7WFHSb91DOs6kdbWzU0BLRC4QkweVpZXFy4guQh/sI2rrKwlhFAfo9xTzKZ3IzuRL7T2tb+S1X8fUvZxmT6L2emJr7ObG9UiYfEkfwyiooLlSqMfLvIUh8sIob7b292Zup7+DXZws8iFM0trW1NTU0tbrfHTwx5pplLpFPpWGQnvJ5OpZJMoUbRvHU6+NBpZbiig4eRzy2m4cVsqGx+eWnhTjwe/ejgsaEPeNye9kw2s40J23WssM1zbcKHDctSdGqibHBRDaLrOxHWkmvVCOy1+bHHjmXSdlRZpIWqdGSzKbgObwxQyVipB6yMdlF5+4thqblcLpFMJuZ0tpvr6Ox6Jyb+19F9hZaOYXaLUDYvmodlWD956sw/ae/o/DU8VUeRbS3Kp7FC/eeTd27/2e5unHprnQh/NcNn2T6k4I2RbHt60X3DEGvId+XzxZ/kx0GlkUQHea6aQBFFw7aX09pmRdKQHWKmJyf+Dr9+mRhOAnhAYjnejdfyNlKzB+1bUjDPz8axCA9Hd3ZWE4m93YIsl8nqrOJvfl6K9Cn2OWRphyIdBHV1957QqeYfje68QrbURGKPP3tvUiOWImqFv0+EJMaUleWlt8yc+cfDoyd+i2w/qTkEXMFg6LHHHn/nCF6Lvjl/7+4beNyzHn8fKq9IpSqygX0GPoJBpEeX1H5CAv26p7dvuK9/4J+RkH6F8TOfSad/vLg4/2ncTjNI7eGX1eOoyzn8qAOIfw3h4Bkti/Q7Xe8AsCbj1Y3Jc6TonWG4UFdbM/K63Wh2Zd0qo5fJZcxzLaOEJPKWPRUJImC9BbzAYouwlIRColJBzS+kKs8qYn5fKfi56xXv3+v1Es+i6necXh/Ui+dkvOG8SS7D59cv7BcJb3/XzOUI0bUV9ENyq/uBIBi7PAEsCfdGnJdxemriK4898a7zPp/v5AFvh/Tt1ehO5Gsz05Pf4/amP0hYvyP5JWeJ9xUhZ4WRL8hTnDNYiXJhUhzFB68EiSJleOVPZLxTETVRyF45Czr/jNQ7zHqSrd/Giu7arZ3rL6LSFB2VB7Fmuf0qaBgAlN+r9b1J8rop2P6gFalFxJ+XqeWON5nxlo/cqkRB5K/Fe6mLdUPIEYtGr+sQ/6am4GlM/oe2NjdmmGtTGawMT8ZrquvEydNPt7a1fxQTudOIMz5nM5kfrawsPb8wf28KicmxjBjLPIZltZsDeeLbVCaj+Qg9Orb4PtCN/Kg06uPQoIiiYSEz4LL7pbOGE2Nvby+Oj3XuGqIxLUqvUbW1kyxXOVDoa5kuUvxsW5tzmD8pmrswP8eH+fPjXESInfqBN1zJnD62tl1bW3k7k808f/LUGbJHvbbzhNQ4GRg89q86OjovzM/PvbS5sX4X2Um/yuuvE/LvpPupnGglZB/fr2doePTd7e0dH8K64jnEFTNmgfWJ+e2tzf+Fda7XuBQdFeEX6Ud1O4cfZQDxryEcPP5VjSCgkBSGK0EhJK+4qKwnwyet1R//1REKoc1YHEX3ElaYv9tlhM+0Dk0LijU5LST091kDAM1vdszDQnZlHyGxIBFZSflnl5F//rrF+8fEULUgyvpA+BmVoNOM/FAtutbh9Xq8+NDK+SZ75y4u3CO50Xx4tLKg4UEENjt2OWWTJ7nUKMRuj2Q9ezqdNu/cuvncmbPj/87vbziP5MYcYd/kstm7iUTiNbzQv7y2unIP2Rcwne35nAh/ueS32CXce7yiTUlYyb7fqJSMsdcXGrWQWAnMSV47hWEX77vM5+Y9/gjZ5QS9Dza8nP8/WWjrAw0trFfFRkH+2bHC7hcuM8oiVBo9JTJaicadau4oDWcOz0XvycnjT4l/cnlp8Ydd3T0f1tgy0hgZPfnL8Xjsf6aSST6fn7aJTZnHynV7/+CxDwaDoWcMw+jl2ovI4HuR8PanJ+7c+geyVSkSGxx1DOy8waTs8cd5sNkxwPYt355OMoj/nszg6CRnKn6uQ4KTIY1vO3anI1kKjWpu6RhwdQy3SlmO5Gur1IFCvEaNTUFHQ9re7u7ru/H4JhKHxFdqtKWfKcehVmxTTHKnb6VS/+XM2XO/5ff7R8u4BmoIBEZPnzn7u/0DgzcWF+a/ha9FItKoAcCJ+MuMHHw/qIi/7LA+09HZ1dfXN/CBYDD4fsz+RdvyFUHSSGLRnS9OTt55KZNOJ5CY8IsMNY5pR+SfOp3DjxyA+NcQOrnQNYTKw004f3GCkqjgPTN1jGyV19q4X+R0cnEFk34DkY81uxuv4s+zQlo24XlFhP4e7yGyBFgo1GzEYlGqYMpCs3hvRPEZBO/rtIUo3L9Sw4Lyt3WEXJmRH1IDRgNefQzDrZWnhhfdH2ECTCqyspZpnjiJ+rJiKMY7q9BQEsh6f22eXlKU6+rlH39iePTE+9ra2n+WbCklyk0j4zWXyy5m0hlM9vdubG5uXN7cWF9E6jxT3dDTA4UkKzz/ogJlLPGnCrcqLQYJriEjYyrFW+aRrXgxF4TI0ufm75tVakWh5Spvl1DxAIVjHxIPL/2brTshCitVRVDJZKcpeY//Dv37IH3FPgtPjijpLxL/vb3dDSxP3sDr0NNOF/b5fN3nH3vyN+fnZr+8vr42jeyykUTyG909vUNYyX68qSn4lNfrJdtglVTFxnJpG//m/8GE/0WSfoOqk4t94DHOGU9ksoifl7wMot/njXsymcMbho6Uh1DDkCYah7wcFxlPdKIdzQoOLeOtICVLheJ9tbW3d3o8nnaHz+dWV5f/FpW5C4tmrQodo7Lw3tG+bpG7fu3yp8jWmsFQ6D1IQZAFMILB0ONjZ8+dx3Ll9trqyqurK8sTjLe8nJ04ELK3uxP5Lzk3N7e09Q0MXmgONb/X6/OdRgrvvvVj+XwUP/8Ls9NTL+zuxqNITvZ1DZJHYg4/qgDi/4BQSY5/mVCSWlJtvkD+s6bH8MVSu81N/kbU09Zsef2nl1atL7mQKz/Q1EUqmIqqlConO3cv7GJiXZpUwWe+r8rHlz1P8UwqwycTCZVwURlCSs4tLa1oZyfCe2JtqIYw04ji0CkMlg81NzstuBTm+vrqK0h/+z7rqLbg1thjXET2LAWeVEbGCxTZ//cfSB5kS2tbF1bMgySKJZvNpkjBHbx47TB5kKotjXhFW1aYRuZhqwZZoWeRss17YFnvkEpZtN0f15+m4qxD9sv2ykqeme179v9YRVk0FvjPKBUPUDrskBieCFg5TMcj+55O2pSTEVWk3FZTOeRJEj//6ZZbVrj1vbuzXzt3/rF3Yd7uWFmdbGF48vTY7xwfHl3CpJ3scBM33Abm+N5Or9c3YhjCrUH3byqfj2NC8OezM1NfikWjUVQ9wl+1tpOEr4vmnSgtTyV/eFniGDVVzeeqJRQ7e4gMAGwEk8xDy88x2XySRdSoZLuWLOcMtDx4cl2cY51dPWPIgSzjeUNIMdkWuqophlw/0DGa4z4makObYSaTyeRuXL/6Z6MnTk139/T8Sx25wMFobGw6NzJ6cnzw2NBGdCfyJn7ey5FIeBU5h8XreP3pueTo7Ozq7+zueSIYDD3lu0/2lf2BKcDObjz+1buzMy/GYtEIEhN9WTHvmkQgAWoPIP4MnEhYcas/5jMqAk8+f3F/S8Di52VVz3Xu7QCPJhJ4RYVoZmex2ef2WRbBRr8fzS6vIROzf0KkzHw29k+H3/NDTLdUQjqPhR3Cio2UEDAKhaVQFraso9sGlQg2EZEvvMeH01mQkH5XfDfhDjYFcsgZNjKNSb/tPfZ56DjRTdfAn3Pjzwnvwen7WIC70tZOUsxDFaw2iFmwcPtrEX98rbt4IZpA+xb3NL5Ulgk1Feap1hotLa0u3N6sJ7A41g3DjUwzZyP+iClyh4m+e2tzI4JKjQS8R1hHyZYVplEpqBUvbA6ef17RZkOKZaTfKZXFyRvrpIhX5ZkVueb8vahCiFUGC5kBEsBA4f1HSDy2dIg/f5a9Lp5rQFr5dY7KDXbfbXIY0ejO0sb6+l909/R+TPOnXFgmD5JD58OE8Cf29l6YuzvzJaz8s9vzlUv4DxxxU0Y7iuanyBjEe/oR8zm+L3SOmjxTrSGQ47SdRHKcl+eiFEe2PYttgpxluMpoW4kslxmj+SgGixwGg8Fxh6Yi2xp/Hdm3X61aiqGE/Kv0bJGcsPShmenJb4W3tyZGTpz6mN/vr6SmkMvr9XZ3dHb9PD6eyaTTK7u7u7exnnNna3N9NplMxpGa+POyEjF9QXRAEsLf39rWPtrU1DTW0BAYd7vdXciB6FOYprkaj0W/Ojsz/XWst8eQ2DlCo3udUhTAy3/EAMSfQSWh+SoC/+UXXjAuPffJnM6WgAe5NwV4QV8UcIV8fdL/6bnwcoPP40U5M4/aW0Po7blFi/QTCRJyN77izpjEQyHz+FvXxcKjOPlFE56rbk62rGNDsHjLJiHyJQJMQO6d2iSPST/fPy6Ha9j+Fj0LY7zR6hMZ6dcBJuoyJcpGbv3+hjad62FF93vo/qKbYkLRZNb2mnlMqbJeiKygCiVCjKWeI/1UgecLI6k8wrwBwIno8zl3NVe4FVvCUcVL5n0th/iz13RSCKtO+DWelyUXrNLm5Ek8lD56WKHw/vNGAPbMv6afV70uUWRr2Dd0TNA5QwvJUo+/jXBNT0283BAI9DU3t3yoajdgmuHdvd0X792d/TKWb2GkV6W/FrVEyobCIMQbgUykNgbpGIAemvkqiJhgn5FNo1HVNFIRN5Ws1jWqVDL/RL9pI/0+nw/5fP7Tqovkcrm1ubuzZBca2RbCBy4oLKhXIbt/XkcoiQ7a3t6ajkTCfzh64tRPd3Z1f6QQ0VMJXF6fr7+VHG1tHxwaHslns5kNrNut4GM1nUptpdOpSCaTiZFCw2YuRwpM5UkxPgyf1+tr9Pl9zT6vvwO3c5fX5+3zeLwDhRTHsuoc4d+4ieXRX5MdgbKZDJtqpJP6KHKKsDKq2NZHeR4/CgDi/5BBEKYlEnTsRHcnc8nCwp5HG9sRlEilLY9/NpcxL/SNvYTs1lkZSdSe6LwRgLtXPsRNhkoFi+P36kxolSxahT2S+YXXkfjj7yVXlhbpwisqPCPzLGmjkqKV3O/k0X3iLzJy2CohI7lX2BR8V0TyVTmQwrB+ghqlPrAeIt6QISP6Tl5Ytn11FfCakzSFsYMPNadwCn3l773e5nFdQ2EAIGANUCxUslpoCDiEPmHvlU0X4XeRYeeOefP6tf89fu58rLWt/ZeRQz6s6rcxuVmIx2Mvzk5PfSOR2FNtzcenFVW9lshBIBkPvCESIbkxSMv4c1jPc1hQyHE+bUmWQqMrxxGSy79ayHKhdxwVIvD8DQ3EWaQKi8/jefG1XC5L5gRP/GW6ZEVOB0G9ChopJ3LylDhREKMfm6aZmZ6a+JvlpcUfjJw4+eHm5pYPyPe714LVx5i495CDRMpy9yP7TsUg+fuJROKVjfXVby4tLkwisUxSFRUtazeIh2UuP8wA4v9wgl2gRcKNrZru6mns2LgdW8j7PF7Xm9N3LW+/gY+gr/H1C+3nbiB7PpaMJFq/W0lFYfq6nG2w+N+pkHAeFcgs7cWF1+P1Oob6p1LJa7FYdA0x+f2GYWS5PYGFwlwX5faBgADyCzX73HSbMZ3CUjyBr7S41KEtaoLt4HhFW+aB5RUD0TzSUcQP0yuryo+VEQut+wfFo3I4GGUJZORO+t5h7qYgKfLFykyZkTB76+0bX+rvH7zSPzj4b3w+/1mkqXCTqCmMH+1Ewt+YnZn6AZanKaRWrMsJ6T8UL3+ZbVpO8Te2nUteP4xzVSHHESqVbU6ynIeu7K424Rc5j4pbfe7G41vZbHbS4/GcEV0E/9/EzNTkC/glqRTPh/lXPc1QQv5FKWVK4l840nt7u+m3b7z1hVCo+W+OD488g88/hXWnpjJuSQcHIvgsiEzKpNNvRqM73743N/t6KpXa455NJpdEOfyqKEjang/lXH5YUbWB9qjCYcu+WhfwE95DYcFhc8ioh5QWNfKxRzqPWj5z56/+2uVyd5DUcUL6cygXf1/PE7/xVNuZm0i+L2lJXhZM/oOj0H+U0PL95ncZRmPeNEkFf7LwNLnd7uZ3/8R7PoPP3YrL5tdWV/7jzPQkKey3iw+yEJBFmN/Sz7YAH1Z/MlEqssq1sq3FeOVJFdYnW7ycwiMfyKLGRe44edh0FUb2dV0o45LndHqmQzVSAO5DVvirHtqfkyOsvGBz+9n1j3gp/YXX5EzkrLenp2+0s6v7QkNDw2m3x9ODlfxml8vlIbuF5PNmLJfNrWUymdnd3fiN5aXFy1yerCo/ttxaIgjVkWIt6XudeVpEPTzHYaIMOa6rj9dcljP3zM4hVhcp6iP0GBg8dnrw2NAlrIcMM5fKYdL5nempiU/tRMLsFn58YWFhqP9Bx4pAr+D1CBpByD8X+3w+/vD7G0LHh4afbmlt+ymfzzdaRt/VDFg27abTqSvxWOz7i4vzZMtEWkRUtu2tTjh/3RkjAQfHAx+s9YRqe40flBeaIf48+aeKj5c7PLfSy0+/vnD1Fyxnfw4tPT345MtnAv2k+iq/j6eM9FsGDhACBwdnuKFGG9pXZCEiymqgcDRihbTpqQvv/ROPxzMkuyaxxl95842PZ7MZshgk0H3LO2vQeaCGHAn5lxkCnPIinUi9U6h4XS1qCnIs+lsEVQRAXTxnGaSi7u4dUD/g1j9ejrJrIFXk+dd8OhGFyDso8qKpCvepIo/qlvBrtHcJ6v2+DxuCdqpEjhMciix3cCBRAxo7dzyGYfj6+geGSc0hEjka3t66u729RQh/hjlEaYYlHv8qPwdtX5EBgD4TbwDgjQDsuag7t3d0DnT39F4IBoNP7hsBXIcUSZ1PZzLZmVQyeS0a3bm8tDh/PZPJpFB1ihrXtLAx4MECiH8BOhX9uWr+jpXdRf9Xi9/hofB68FWNbRWO0X0lpxj+iOypAVlMLk2Xy8hlMumScP9aCgHRjgrltGu1fqcGz1USFSJZcK0FyTDc/nQ61UCKvqD7BoCGJ9757v/Q2Nj0C6LfyJtmZG5u9ndXlpeIISfJHKKdGqw+PXZ8GJ0YHZZFq5SEeOq0v85nuLFLz6qD/aztsQVnnRzII61s66Len0/1jEfh3gEPFhLjtyj6zSt4TUkAn0rEp1vx4cGi1zpetEOrJQKoHxxUhlPUaowoHEi8AY0988YyvjAvX0ROWN+i2s/kEFFI75l/NpmM4N8rGgoDgUCwu6dvPBgKnW5oaBj1erzHDLe7FR08Tz+Zy+WWMLGfS6WS0/FYbGJ1dflOOpVKoFJDpEwO6ZD9IxN9BKgcQPw1cdRyyKnQbmlpNXZ2IjLB7UZ2zwar4PC5kSKhYVNaHqQwOGr9o4JgwWX7TBSm6u/u6R05cfL051wuV4i9Vi6bnZifv/fJleXFacRU80f2mg3CAjsPqj8VoZGyIkgyOXZYeZAAAKCO4BDiy657rJLPr4uqwqGioqEihbqssFlUB2spAECgcCDxTiR23rAOJAKRHimLginOhVqMf0VEocoAIDJy8K9FcoPuNmQ0NjYFW1pbewOBxm6f39/ucXua3W530GW4fC6XQfQ4l8vi9vm0mTcTpmnu5bK5nUw2E04lE2uY5K9GIuEN/L5MtsgIvS7RB8L/iAGIvyaOGrEUCG2e/LMCjldwZJ4NfquhmgrqcnDU+kcFyYIrC1OlOWje40Mj4339A7/vdhtDmUz2Wiwa/cbU5O3v5nI5lujztRrY6tKHntuv2Q60Ldgz/1oFZU5kPTwrAACoLiTknzWm8kYAkeIuIv58UTDZLiHlhM2CYg2oO0jSZkQGNHZOsfNFZSQTGsNqPQc06wmJ5IIHiQ0CKvnBXpf+Jg+RTOCLD4uOXJlnkEsAC0D8NVEJsax24b9y70EgtIuCzev1ujOZjChfmkCl3Agtgg9aMDxMxJ9gZnbOWJifIy95r78oD40e/MLL7+LAHqJQO9viWy9tWmFuZN3ntAMAgNrCIb+X9fLxRnF2beQhU8759dKpiCi9FsgjQF1CIz9eVHRXFCHDO5KktS0OYy441BMSPZdb42Dlh6hNVNs1Vkr+dYyO5ZB9cIw8AgDir4l6IUHlQCO0SVQZnUIkfKpa1VPWptU2stQzZPetsLTL6jSIilGJtqjhw+1KDDq1EPTV7J9KciNh8QIAHk1orIO8t48n/bK1UaSkOynVoFgDjhQ0POQqBxI96+yqc6hzQaOekMrA4ZacVTsPieoS8dGIKvIvMgKonHO6RB/k0iMGIP6aOKpkVKNSeiVV0en/H0g4PPuJvHHpuepsd1gPbV3N+9bYhsapTgMBa2WX5XyV7J0LAh8AADxMcFDyRcp5JR46VQFRUKwBRxZl6JEiIxk9K4tZ1kFNIR0DoSH5W0b4RVsOs2e2jfh2cjIsOp3L8eyD7vcIAYg/B1rVnUWhqr40NF/0Hfo91e/Qav2632NJIv89VUrBwvw9tDA/l+/o7LK8wdlMxrWzEyEvpVXRGwIBl+Ey8oZhWNd1u915j9eb39rcUArqcp7n2U/8gXHx4kXh/6naQNamOt9hd0jQSbdgq/w7GRfY52H7yWkc8PdG/379+6/Slzby7/P53Pl83iBHNpu13sP9YxH/XC7HXr64EJDdGPBnc17chy6Xy3QZhuk23Cb+28RjQVmgUTTudJ+pnP4RzYejaMwBAAD1B0HNEBWZQUi+PoqUZieiD4QfcKQhIP/sa525IntdF3NCc0chUbSsU/SDyCiiK1NUh6n5nlMf1EX7Aw4PQPw1cVQ9/hS80tPR2eXCJL74t+RrB7YKVlLLoBLUU1tX896YkH9UOBsNgYCRTCRkoal8CJkq7Mtmedft18PqUwAAAKg2NHcNYc8y5DXPoFgDHgpIyDESvOZxJDzMDrJBVDC7nMOpjWTt5BRJpBNxJLp23bU/4HAAxJ9BtcljPRIkiWBzgqOgqGfi/aBBIgEuPffJisaBwgrNLzyiqrHa1mDYihEAADxKUKyFOmtkXvK37X1QrAEPGxyK7co82SV/1/vcUBg5nKKFDmJMZNtIJ1pCl+QfmXYH1B5A/B9BQHG0w8VBia1GCJr1XjAYcsfjMd7A4GgJLrdvgagDAICHBZL1sGyjOAWslYBHAQo9UlS4roijNj8cthXWIfky0i/L8+f/1o0sArIP0AIQf4BQgIOgqC+UEZ7KQ7koQD8DAACAHbrGcZCfAMB9sPPmYZsbikgHl+Z7yOE9Ah0DgNbrh639AdUDEH8A4AjBwfosQ8nCAIsCAAAAAAAAQPkoM+WhUq6lawiwAHodQAdA/AGAIwiHRYcFLA4AAAAAAAAANcIBU4ZUeChSJgD1AyD+AMARhk5IKiwQAAAAAAAAAIeLSmpqUYDuBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDL8f9DwCoJpoZhyAAAAAElFTkSuQmCC" alt="Hemlock Logo" class="header-logo">
        <h1>Hemlock Language Manual</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off" aria-label="Search documentation">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults" role="listbox" aria-label="Search results"></div>
        </div>
        <button class="search-toggle" id="searchToggle" aria-label="Toggle search">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)" aria-label="Select language">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" ></option>
<option value="docs-de.html" >Deutsch</option>
<option value="docs-es.html" >Espaol</option>
<option value="docs-fr.html" >Franais</option>
<option value="docs-it.html" selected>Italiano</option>
<option value="docs-ja.html" ></option>
<option value="docs-pt.html" >Portugus</option>
<option value="docs-ru.html" ></option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode" aria-label="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar" aria-label="Documentation navigation">
            <div class="nav-section">
<a href="#welcome" class="nav-link" data-page="welcome">Benvenuto</a>
</div>
<a href="#language-reference" class="nav-link" data-page="language-reference">Riferimento del Linguaggio</a>
<div class="nav-section">
<div class="nav-section-title">Primi Passi</div>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">Avvio Rapido</a>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">Installazione</a>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">Percorsi di Apprendimento</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">Tutorial</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Guida Al Linguaggio</div>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">Array</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">Flusso di Controllo</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">Funzioni</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">Gestione degli Errori</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">Gestione della Memoria</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">Moduli</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">Oggetti</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">Pattern Matching</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">Rune</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">Sintassi</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">Stringhe</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">Tipi</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Argomenti Avanzati</div>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">Argomenti da Riga di Comando</a>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">Async e Concorrenza</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">Esecuzione di Comandi</a>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">FFI</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File IO</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">Impacchettamento e Distribuzione</a>
<a href="#advanced-memory-ownership" class="nav-link" data-page="advanced-memory-ownership">Memory Ownership</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">Operazioni Atomiche</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">Profilazione</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">Segnali</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Riferimento API</div>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">API degli Array</a>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">API dei File</a>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">API della Memoria</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">API delle Stringhe</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">API di Concorrenza</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">Funzioni Integrate</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">Operatori</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">Sistema di Tipi</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Design E Filosofia</div>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">Filosofia</a>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">Implementazione</a>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">Sintassi delle Firme</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Contribuire</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">Linee Guida</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">Test</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Primi Passi</div>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">Avvio Rapido</a>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">Configurazione del Progetto</a>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">Installazione</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Guida Utente</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">Comandi</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">Configurazione</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">Risoluzione dei Problemi</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Sviluppo Pacchetti</div>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">Creazione di Pacchetti</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">Specifiche dei Pacchetti</a>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">Versionamento</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Riferimento</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">Architettura</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">Codici di Uscita</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"Benvenuto": {"id": "welcome", "content": "# Benvenuto in Hemlock\n\n> \"Un piccolo linguaggio non sicuro per scrivere cose non sicure in modo sicuro.\"\n\n**Hemlock**  un linguaggio di scripting di sistema che combina la potenza del C con l'ergonomia dei moderni linguaggi di scripting. Offre gestione manuale della memoria, controllo esplicito e concorrenza asincrona strutturata integrata.\n\n## Cos' Hemlock?\n\nHemlock  progettato per programmatori che vogliono:\n\n- **Controllo esplicito** sulla memoria e l'esecuzione\n- **Sintassi simile al C** con comodit moderne\n- **Nessun comportamento nascosto** o magia\n- **Vera concorrenza asincrona parallela** con concorrenza basata su pthread\n\nHemlock NON  un linguaggio a memoria sicura con garbage collection. Invece, ti fornisce gli strumenti per essere sicuro (`buffer`, annotazioni di tipo, controllo dei limiti) senza obbligarti a usarli (`ptr`, memoria manuale, operazioni non sicure).\n\n## Esempio Rapido\n\n```hemlock\n// Ciao, Hemlock!\nfn greet(name: string): string {\n    return `Ciao, ${name}!`;\n}\n\nlet message = greet(\"Mondo\");\nprint(message);\n\n// Gestione manuale della memoria\nlet buf = buffer(64);\nbuf[0] = 72;  // 'H'\nbuf[1] = 105; // 'i'\nprint(buf);\nfree(buf);\n```\n\n## Funzionalit in Breve\n\n| Funzionalit | Descrizione |\n|--------------|-------------|\n| **Sistema di Tipi** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |\n| **Memoria** | Gestione manuale con `alloc()`, `buffer()`, `free()` |\n| **Async** | `async`/`await` integrato con vero parallelismo pthread |\n| **FFI** | Chiamare funzioni C direttamente da librerie condivise |\n| **Libreria Standard** | 40 moduli inclusi crypto, http, sqlite, json e altro |\n\n## Primi Passi\n\nPronto a iniziare? Ecco come cominciare:\n\n1. **[Installazione](#getting-started-installation)** - Scarica e configura Hemlock\n2. **[Avvio Rapido](#getting-started-quick-start)** - Scrivi il tuo primo programma in pochi minuti\n3. **[Tutorial](#getting-started-tutorial)** - Impara Hemlock passo dopo passo\n\n## Sezioni della Documentazione\n\n- **Primi Passi** - Installazione, guida all'avvio rapido e tutorial\n- **Guida al Linguaggio** - Approfondimento su sintassi, tipi, funzioni e altro\n- **Argomenti Avanzati** - Programmazione asincrona, FFI, segnali e atomiche\n- **Riferimento API** - Riferimento completo per le funzioni integrate e la libreria standard\n- **Design e Filosofia** - Comprendere perch Hemlock  cos com'\n\n## Gestore di Pacchetti\n\nHemlock include **hpm**, un gestore di pacchetti per gestire le dipendenze:\n\n```bash\nhpm init mio-progetto\nhpm add un-pacchetto\nhpm run\n```\n\nConsulta le sezioni della documentazione di hpm per maggiori dettagli.\n\n---\n\nUsa la navigazione a sinistra per esplorare la documentazione, oppure usa la barra di ricerca per trovare argomenti specifici.\n"}, "Riferimento del Linguaggio": {"id": "language-reference", "content": "# Filosofia di Design del Linguaggio Hemlock\n\n> \"Un piccolo linguaggio non sicuro per scrivere cose non sicure in modo sicuro.\"\n\nQuesto documento fornisce una panoramica della filosofia di design di Hemlock e un riferimento rapido del linguaggio.\nEsplora le altre sezioni della documentazione per guide dettagliate e riferimenti API.\n\n---\n\n## Identit Fondamentale\n\nHemlock  un **linguaggio di scripting di sistema** con gestione manuale della memoria e controllo esplicito:\n- La potenza del C con l'ergonomia dei moderni linguaggi di scripting\n- Concorrenza asincrona strutturata integrata\n- Nessun comportamento nascosto o magia\n\n**Hemlock NON :** A memoria sicura, un linguaggio con GC, o nasconde complessit.\n**Hemlock :** Esplicito piuttosto che implicito, educativo, un \"livello di scripting C\" per lavoro di sistema.\n\n---\n\n## Principi di Design\n\n### 1. Esplicito Piuttosto che Implicito\n- Punto e virgola obbligatorio (nessun ASI)\n- Gestione manuale della memoria (alloc/free)\n- Annotazioni di tipo opzionali ma verificate a runtime\n\n### 2. Dinamico di Default, Tipizzato per Scelta\n- Ogni valore ha un tag di tipo a runtime\n- I letterali inferiscono i tipi: `42`  i32, `5000000000`  i64, `3.14`  f64\n- Annotazioni di tipo opzionali impongono controlli a runtime\n\n### 3. Non Sicuro  una Funzionalit\n- Aritmetica dei puntatori permessa (responsabilit dell'utente)\n- Nessun controllo dei limiti su `ptr` raw (usare `buffer` per sicurezza)\n- Double-free pu causare crash\n\n### 4. Concorrenza Strutturata di Prima Classe\n- `async`/`await` integrato con parallelismo basato su pthread\n- Canali per la comunicazione\n- `spawn`/`join`/`detach` per la gestione dei task\n\n### 5. Sintassi Simile al C\n- Blocchi `{}` sempre richiesti\n- Commenti: `// riga` e `/* blocco */`\n- Operatori come il C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`\n- Incremento/decremento: `++x`, `x++`, `--x`, `x--` (prefisso e postfisso)\n- Assegnazione composta: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\n- `/` restituisce sempre float (usare `divi()` per divisione intera)\n- Sintassi dei tipi: `let x: type = value;`\n\n---\n\n## Riferimento Rapido\n\n### Tipi\n```\nCon segno:   i8, i16, i32, i64\nSenza segno: u8, u16, u32, u64\nFloat:       f32, f64\nAltri:       bool, string, rune, array, ptr, buffer, null, object, file, task, channel\nAlias:       integer (i32), number (f64), byte (u8)\n```\n\n**Promozione dei tipi:** i8  i16  i32  i64  f32  f64 (i float vincono sempre, ma i64/u64 + f32  f64 per preservare la precisione)\n\n### Letterali\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64 (> max i32)\nlet hex = 0xDEADBEEF;    // letterale esadecimale\nlet bin = 0b1010;        // letterale binario\nlet oct = 0o777;         // letterale ottale\nlet sep = 1_000_000;     // separatori numerici permessi\nlet pi = 3.14;           // f64\nlet half = .5;           // f64 (senza zero iniziale)\nlet s = \"hello\";         // string\nlet esc = \"\\x41\\u{1F600}\"; // escape esadecimali e unicode\nlet ch = 'A';            // rune\nlet emoji = '';        // rune (Unicode)\nlet arr = [1, 2, 3];     // array\nlet obj = { x: 10 };     // object\n```\n\n### Conversione di Tipo\n```hemlock\n// Funzioni costruttore di tipo - parsano stringhe in tipi\nlet n = i32(\"42\");       // Parsa stringa a i32\nlet f = f64(\"3.14\");     // Parsa stringa a f64\nlet b = bool(\"true\");    // Parsa stringa a bool (\"true\" o \"false\")\n\n// Tutti i tipi numerici supportati\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// Numeri esadecimali e negativi\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// Anche gli alias di tipo funzionano\nlet x = integer(\"100\");  // Come i32(\"100\")\nlet y = number(\"1.5\");   // Come f64(\"1.5\")\nlet z = byte(\"200\");     // Come u8(\"200\")\n\n// Convertire tra tipi numerici\nlet big = i64(42);       // i32 a i64\nlet truncated = i32(3.99); // f64 a i32 (tronca a 3)\n\n// Le annotazioni di tipo validano i tipi (ma non parsano stringhe)\nlet f: f64 = 100;        // i32 a f64 via annotazione (coercizione numerica OK)\n// let n: i32 = \"42\";    // ERRORE - usare i32(\"42\") per parsare stringhe\n```\n\n### Introspezione\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5 (lunghezza stringa in byte)\nlen([1, 2, 3]);          // 3 (lunghezza array)\n```\n\n### Memoria\n```hemlock\nlet p = alloc(64);       // puntatore raw\nlet b = buffer(64);      // buffer sicuro (controllo limiti)\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // pulizia manuale richiesta\n```\n\n### Flusso di Controllo\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // ciclo infinito (pi pulito di while(true))\nswitch (x) { case 1: break; default: break; }  // fall-through stile C\ndefer cleanup();         // eseguito quando la funzione ritorna\n\n// Etichette di ciclo per break/continue mirati in cicli annidati\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // esce dal ciclo esterno\n        if (i == 3) { continue outer; }  // continua il ciclo esterno\n    }\n}\n```\n\n### Pattern Matching\n```hemlock\n// Espressione match - restituisce un valore\nlet result = match (value) {\n    0 => \"zero\",                    // Pattern letterale\n    1 | 2 | 3 => \"piccolo\",         // Pattern OR\n    n if n < 10 => \"medio\",         // Espressione guard\n    n => \"grande: \" + n             // Binding di variabile\n};\n\n// Pattern di tipo\nmatch (val) {\n    n: i32 => \"intero\",\n    s: string => \"stringa\",\n    _ => \"altro\"                    // Wildcard\n}\n\n// Destrutturazione di oggetti\nmatch (point) {\n    { x: 0, y: 0 } => \"origine\",\n    { x, y } => \"a \" + x + \",\" + y\n}\n\n// Destrutturazione di array con rest\nmatch (arr) {\n    [] => \"vuoto\",\n    [first, ...rest] => \"testa: \" + first,\n    _ => \"altro\"\n}\n\n// Pattern annidati\nmatch (user) {\n    { name, address: { city } } => name + \" in \" + city\n}\n```\n\nVedere `docs/language-guide/pattern-matching.md` per la documentazione completa.\n\n### Operatori di Null Coalescing\n```hemlock\n// Null coalescing (??) - restituisce sinistra se non-null, altrimenti destra\nlet name = user.name ?? \"Anonimo\";\nlet first = a ?? b ?? c ?? \"fallback\";\n\n// Assegnazione null coalescing (??=) - assegna solo se null\nlet config = null;\nconfig ??= { timeout: 30 };    // config  ora { timeout: 30 }\nconfig ??= { timeout: 60 };    // config invariato (non null)\n\n// Funziona con propriet e indici\nobj.field ??= \"default\";\narr[0] ??= \"primo\";\n\n// Navigazione sicura (?.) - restituisce null se l'oggetto  null\nlet city = user?.address?.city;  // null se qualsiasi parte  null\nlet upper = name?.to_upper();    // chiamata metodo sicura\nlet item = arr?.[0];             // indicizzazione sicura\n```\n\n### Funzioni\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Ciao\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // anonima/closure\n\n// Funzioni con corpo espressione (sintassi freccia)\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // anonima con corpo espressione\n\n// Modificatori di parametro\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // passaggio per riferimento\nfn print_all(const items: array) { for (i in items) { print(i); } }  // immutabile\n```\n\n### Argomenti Nominati\n```hemlock\n// Le funzioni possono essere chiamate con argomenti nominati\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" ha \" + age + \" anni\");\n}\n\n// Argomenti posizionali (tradizionali)\ncreate_user(\"Alice\", 25, false);\n\n// Argomenti nominati - possono essere in qualsiasi ordine\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// Salta parametri opzionali nominando ci che ti serve\ncreate_user(\"David\", active: false);  // Usa default age=18\n\n// Gli argomenti nominati devono venire dopo quelli posizionali\ncreate_user(\"Eve\", age: 21);          // OK: posizionale poi nominato\n// create_user(name: \"Bad\", 25);      // ERRORE: posizionale dopo nominato\n```\n\n**Regole:**\n- Gli argomenti nominati usano la sintassi `nome: valore`\n- Possono apparire in qualsiasi ordine dopo gli argomenti posizionali\n- Gli argomenti posizionali non possono seguire quelli nominati\n- Funziona con parametri default/opzionali\n- Nomi di parametri sconosciuti causano errori runtime\n\n### Oggetti e Enum\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// Sintassi shorthand per oggetti (stile ES6)\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // equivalente a { name: name, age: age }\n\n// Operatore spread per oggetti\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // copia defaults, sovrascrive size\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### Tipi Composti (Intersezione/Duck Types)\n```hemlock\n// Definisci tipi strutturali\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Tipo composto: l'oggetto deve soddisfare TUTTI i tipi\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Parametri di funzione con tipi composti\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" ha \" + p.age);\n}\n\n// Tre o pi tipi\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// Campi extra permessi (duck typing)\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Engineering\"  // OK - campi extra ignorati\n};\n```\n\nI tipi composti forniscono comportamento simile alle interfacce senza una parola chiave `interface` separata,\ncostruendo sui paradigmi `define` e duck typing esistenti.\n\n### Alias di Tipo\n```hemlock\n// Alias di tipo semplice\ntype Integer = i32;\ntype Text = string;\n\n// Alias di tipo funzione\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Alias di tipo composto (ottimo per interfacce riutilizzabili)\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Alias di tipo generico\ntype Pair<T> = { first: T, second: T };\n\n// Usare alias di tipo\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\nGli alias di tipo creano scorciatoie nominate per tipi complessi, migliorando leggibilit e manutenibilit.\n\n### Tipi di Funzione\n```hemlock\n// Annotazioni di tipo funzione per parametri\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Funzione di ordine superiore che restituisce una funzione\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Tipi di funzione async\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// Tipi di funzione con pi parametri\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Parametri Const\n```hemlock\n// Parametro const - immutabilit profonda\nfn print_all(const items: array) {\n    // items.push(4);  // ERRORE: non pu mutare parametro const\n    for (item in items) {\n        print(item);\n    }\n}\n\n// Const con oggetti - nessuna mutazione attraverso alcun percorso\nfn describe(const person: object) {\n    print(person.name);       // OK: lettura permessa\n    // person.name = \"Bob\";   // ERRORE: non pu mutare\n}\n\n// Accesso annidato permesso per lettura\nfn get_city(const user: object) {\n    return user.address.city;  // OK: lettura propriet annidate\n}\n```\n\nIl modificatore `const` previene qualsiasi mutazione del parametro, incluse propriet annidate.\nQuesto fornisce sicurezza a compile-time per funzioni che non dovrebbero modificare i loro input.\n\n### Parametri Ref (Passaggio per Riferimento)\n```hemlock\n// Parametro ref - la variabile del chiamante viene modificata direttamente\nfn increment(ref x: i32) {\n    x = x + 1;  // Modifica la variabile originale\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - l'originale  stato modificato\n\n// Classica funzione swap\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// Mescola parametri ref e regolari\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\nIl modificatore `ref` passa un riferimento alla variabile del chiamante, permettendo alla funzione di\nmodificarla direttamente. Senza `ref`, i primitivi sono passati per valore (copiati). Usa `ref` quando\ndevi mutare lo stato del chiamante senza restituire un valore.\n\n**Regole:**\n- I parametri `ref` devono ricevere variabili, non letterali o espressioni\n- Funziona con tutti i tipi (primitivi, array, oggetti)\n- Combina con annotazioni di tipo: `ref x: i32`\n- Non pu combinarsi con `const` (sono opposti)\n\n### Firme di Metodo in Define\n```hemlock\n// Define con firme di metodo (pattern interfaccia)\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // Firma di metodo richiesta\n}\n\n// Gli oggetti devono fornire il metodo richiesto\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Metodi opzionali con ?\ndefine Serializable {\n    fn serialize(): string,        // Richiesto\n    fn pretty?(): string           // Metodo opzionale\n}\n\n// Il tipo Self si riferisce al tipo che definisce\ndefine Cloneable {\n    fn clone(): Self   // Restituisce lo stesso tipo dell'oggetto\n}\n```\n\nLe firme di metodo nei blocchi `define` usano delimitatori virgola (come interfacce TypeScript),\nstabilendo contratti che gli oggetti devono soddisfare e abilitando pattern di programmazione\nsimili alle interfacce con il sistema duck typing di Hemlock.\n\n### Gestione degli Errori\n```hemlock\ntry { throw \"errore\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"irrecuperabile\");  // esce immediatamente, non catturabile\n```\n\n### Async/Concorrenza\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // oppure join(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**Ownership della memoria:** I task ricevono copie dei valori primitivi ma condividono i puntatori. Se passi un `ptr` a un task spawned, devi assicurarti che la memoria rimanga valida fino al completamento del task. Usa `join()` prima di `free()`, o usa i canali per segnalare il completamento.\n\n### Input Utente\n```hemlock\nlet name = read_line();          // Legge riga da stdin (blocca)\nprint(\"Ciao, \" + name);\neprint(\"Messaggio di errore\");   // Stampa su stderr\n\n// read_line() restituisce null su EOF\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Ricevuto:\", line);\n}\n```\n\n### I/O su File\n```hemlock\nlet f = open(\"file.txt\", \"r\");  // modi: r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"data\");\nf.seek(0);\nf.close();\n```\n\n### Segnali\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Interrotto\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## Metodi Stringa (19)\n\n`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,\n`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,\n`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`\n\nTemplate string: `` `Ciao ${name}!` ``\n\n**Mutabilit delle stringhe:** Le stringhe sono mutabili via assegnazione indice (`s[0] = 'H'`), ma tutti i metodi stringa restituiscono nuove stringhe senza modificare l'originale. Questo permette mutazione in-place quando necessario mantenendo il method chaining funzionale.\n\n**Propriet lunghezza stringa:**\n```hemlock\nlet s = \"ciao \";\nprint(s.length);       // 6 (conteggio caratteri/rune)\nprint(s.byte_length);  // 9 (conteggio byte - emoji  4 byte UTF-8)\n```\n\n## Metodi Array (18)\n\n`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,\n`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`\n\nArray tipizzati: `let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## Libreria Standard (40 moduli)\n\nImporta con prefisso `@stdlib/`:\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| Modulo | Descrizione |\n|--------|-------------|\n| `arena` | Allocatore di memoria arena (bump allocation) |\n| `args` | Parsing argomenti da riga di comando |\n| `assert` | Utilit di asserzione |\n| `async` | ThreadPool, parallel_map |\n| `async_fs` | Operazioni I/O file async |\n| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |\n| `compression` | gzip, gunzip, deflate |\n| `crypto` | aes_encrypt, rsa_sign, random_bytes |\n| `csv` | Parsing e generazione CSV |\n| `datetime` | Classe DateTime, formattazione, parsing |\n| `encoding` | base64_encode, hex_encode, url_encode |\n| `env` | getenv, setenv, exit, get_pid |\n| `fmt` | Utilit di formattazione stringhe |\n| `fs` | read_file, write_file, list_dir, exists |\n| `glob` | Pattern matching file |\n| `hash` | sha256, sha512, md5, djb2 |\n| `http` | http_get, http_post, http_request |\n| `ipc` | Comunicazione inter-processo |\n| `iter` | Utilit iteratore |\n| `json` | parse, stringify, pretty, get, set |\n| `logging` | Logger con livelli |\n| `math` | sin, cos, sqrt, pow, rand, PI, E |\n| `net` | TcpListener, TcpStream, UdpSocket |\n| `os` | platform, arch, cpu_count, hostname |\n| `path` | Manipolazione path file |\n| `process` | fork, exec, wait, kill |\n| `random` | Generazione numeri casuali |\n| `regex` | compile, test (POSIX ERE) |\n| `retry` | Logica retry con backoff |\n| `semver` | Semantic versioning |\n| `shell` | Utilit comandi shell |\n| `sqlite` | Database SQLite, query, exec, transazioni |\n| `strings` | pad_left, is_alpha, reverse, lines |\n| `terminal` | Colori e stili ANSI |\n| `testing` | describe, test, expect |\n| `time` | now, time_ms, sleep, clock |\n| `toml` | Parsing e generazione TOML |\n| `url` | Parsing e manipolazione URL |\n| `uuid` | Generazione UUID |\n| `websocket` | Client WebSocket |\n\nVedere `stdlib/docs/` per documentazione dettagliata dei moduli.\n\n---\n\n## FFI (Foreign Function Interface)\n\nDichiara e chiama funzioni C da librerie condivise:\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Ciao!\");  // 5\nlet pid = getpid();\n```\n\nEsporta funzioni FFI dai moduli:\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\nFFI dinamico (binding runtime):\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Ciao dal C!\");\nffi_close(lib);\n```\n\nTipi: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, ecc.\n\n---\n\n## Operazioni Atomiche\n\nProgrammazione concorrente lock-free con operazioni atomiche:\n\n```hemlock\n// Alloca memoria per i32 atomico\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// Load/store atomici\nlet val = atomic_load_i32(p);        // Legge atomicamente\natomic_store_i32(p, 42);             // Scrive atomicamente\n\n// Operazioni fetch-and-modify (restituiscono il valore VECCHIO)\nlet old = atomic_add_i32(p, 10);     // Aggiunge, restituisce vecchio\nold = atomic_sub_i32(p, 5);          // Sottrae, restituisce vecchio\nold = atomic_and_i32(p, 0xFF);       // AND bit a bit\nold = atomic_or_i32(p, 0x10);        // OR bit a bit\nold = atomic_xor_i32(p, 0x0F);       // XOR bit a bit\n\n// Compare-and-swap (CAS)\nlet success = atomic_cas_i32(p, 42, 100);  // Se *p == 42, imposta a 100\n// Restituisce true se lo swap ha successo, false altrimenti\n\n// Atomic exchange\nold = atomic_exchange_i32(p, 999);   // Scambia, restituisce vecchio\n\nfree(p);\n\n// Varianti i64 disponibili (atomic_load_i64, atomic_add_i64, ecc.)\n\n// Memory fence (barriera completa)\natomic_fence();\n```\n\nTutte le operazioni usano sequential consistency (`memory_order_seq_cst`).\n\n---\n\n## Struttura del Progetto\n\n```\nhemlock/\n src/\n    frontend/         # Condiviso: lexer, parser, AST, moduli\n    backends/\n       interpreter/  # hemlock: interprete tree-walking\n       compiler/     # hemlockc: generatore codice C\n    tools/\n       lsp/          # Language Server Protocol\n       bundler/      # Strumenti bundle/package\n runtime/              # Runtime programmi compilati (libhemlock_runtime.a)\n stdlib/               # Libreria standard (40 moduli)\n    docs/             # Documentazione moduli\n docs/                 # Documentazione completa\n    language-guide/   # Tipi, stringhe, array, ecc.\n    reference/        # Riferimenti API\n    advanced/         # Async, FFI, segnali, ecc.\n tests/                # 625+ test\n examples/             # Programmi esempio\n```\n\n---\n\n## Linee Guida per lo Stile del Codice\n\n### Costanti e Numeri Magici\n\nQuando aggiungi costanti numeriche al codebase C, segui queste linee guida:\n\n1. **Definisci le costanti in `include/hemlock_limits.h`** - Questo file  la posizione centrale per tutti i limiti compile-time e runtime, capacit e costanti nominate.\n\n2. **Usa nomi descrittivi con prefisso `HML_`** - Tutte le costanti dovrebbero avere prefisso `HML_` per chiarezza del namespace.\n\n3. **Evita numeri magici** - Sostituisci valori numerici hard-coded con costanti nominate. Esempi:\n   - Limiti range tipo: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`\n   - Capacit buffer: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - Conversioni tempo: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`\n   - Seed hash: `HML_DJB2_HASH_SEED`\n   - Valori ASCII: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`\n\n4. **Includi `hemlock_limits.h`** - I file sorgente dovrebbero includere questo header (spesso via `internal.h`) per accedere alle costanti.\n\n5. **Documenta lo scopo** - Aggiungi un commento che spiega cosa rappresenta ogni costante.\n\n---\n\n## Cosa NON Fare\n\n Aggiungere comportamento implicito (ASI, GC, auto-cleanup)\n Nascondere complessit (ottimizzazioni magiche, refcount nascosti)\n Rompere semantica esistente (punto e virgola, memoria manuale, stringhe mutabili)\n Perdere precisione in conversioni implicite\n Usare numeri magici - definisci costanti nominate in `hemlock_limits.h` invece\n\n---\n\n## Testing\n\n```bash\nmake test              # Esegui test interprete\nmake test-compiler     # Esegui test compilatore\nmake parity            # Esegui test parit (entrambi devono corrispondere)\nmake test-all          # Esegui tutte le suite di test\n```\n\n**Importante:** I test potrebbero bloccarsi per problemi async/concorrenza. Usa sempre un timeout quando esegui i test:\n```bash\ntimeout 60 make test   # 60 secondi timeout\ntimeout 120 make parity\n```\n\nCategorie test: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*\n\n---\n\n## Architettura Compilatore/Interprete\n\nHemlock ha due backend di esecuzione che condividono un frontend comune:\n\n```\nSorgente (.hml)\n    \n\n  FRONTEND CONDIVISO         \n  - Lexer (src/frontend/)    \n  - Parser (src/frontend/)   \n  - AST (src/frontend/)      \n\n                        \n    \n INTERPRETE      COMPILATORE\n (hemlock)       (hemlockc) \n                            \n Tree-walk       Type check \n evaluation      AST  C    \n                 gcc link   \n    \n```\n\n### Type Checking del Compilatore\n\nIl compilatore (`hemlockc`) include type checking compile-time, **abilitato di default**:\n\n```bash\nhemlockc program.hml -o program    # Type check, poi compila\nhemlockc --check program.hml       # Solo type check, non compila\nhemlockc --no-type-check prog.hml  # Disabilita type checking\nhemlockc --strict-types prog.hml   # Avvisa su tipi 'any' impliciti\n```\n\nIl type checker:\n- Valida le annotazioni di tipo a compile time\n- Tratta il codice non tipizzato come dinamico (tipo `any`) - sempre valido\n- Fornisce hint di ottimizzazione per unboxing\n- Usa conversioni numeriche permissive (range validato a runtime)\n\n### Struttura Directory\n\n```\nhemlock/\n src/\n    frontend/           # Condiviso: lexer, parser, AST, moduli\n       lexer.c\n       parser/\n       ast.c\n       module.c\n    backends/\n       interpreter/    # hemlock: interprete tree-walking\n          main.c\n          runtime/\n          builtins/\n       compiler/       # hemlockc: generatore codice C\n           main.c\n           codegen/\n    tools/\n       lsp/            # Language server\n       bundler/        # Strumenti bundle/package\n runtime/                # libhemlock_runtime.a per programmi compilati\n stdlib/                 # Libreria standard condivisa\n tests/\n     parity/             # Test che DEVONO passare entrambi i backend\n     interpreter/        # Test specifici interprete\n     compiler/           # Test specifici compilatore\n```\n\n---\n\n## Sviluppo Parity-First\n\n**Sia l'interprete che il compilatore devono produrre output identico per lo stesso input.**\n\n### Policy di Sviluppo\n\nQuando aggiungi o modifichi funzionalit del linguaggio:\n\n1. **Design** - Definisci il cambiamento AST/semantico nel frontend condiviso\n2. **Implementa interprete** - Aggiungi valutazione tree-walking\n3. **Implementa compilatore** - Aggiungi generazione codice C\n4. **Aggiungi test parit** - Scrivi test in `tests/parity/` con file `.expected`\n5. **Verifica** - Esegui `make parity` prima di merge\n\n### Struttura Test Parit\n\n```\ntests/parity/\n language/       # Funzionalit core linguaggio (control flow, closure, ecc.)\n builtins/       # Funzioni integrate (print, typeof, memory, ecc.)\n methods/        # Metodi stringa e array\n modules/        # Import/export, import stdlib\n```\n\nOgni test ha due file:\n- `feature.hml` - Il programma di test\n- `feature.expected` - Output atteso (deve corrispondere per entrambi i backend)\n\n### Risultati Test Parit\n\n| Stato | Significato |\n|-------|-------------|\n| ` PASSED` | Sia interprete che compilatore corrispondono all'output atteso |\n| ` INTERP_ONLY` | Interprete funziona, compilatore fallisce (necessita fix compilatore) |\n| ` COMPILER_ONLY` | Compilatore funziona, interprete fallisce (raro) |\n| ` FAILED` | Entrambi falliscono (bug test o implementazione) |\n\n### Cosa Richiede Parit\n\n- Tutti i costrutti del linguaggio (if, while, for, switch, defer, try/catch)\n- Tutti gli operatori (aritmetici, bit a bit, logici, confronto)\n- Tutte le funzioni integrate (print, typeof, alloc, ecc.)\n- Tutti i metodi stringa e array\n- Regole di coercizione e promozione tipo\n- Messaggi di errore per errori runtime\n\n### Cosa Pu Differire\n\n- Caratteristiche di performance\n- Dettagli layout memoria\n- Formato debug/stack trace\n- Errori di compilazione (il compilatore pu catturare di pi a compile time)\n\n### Aggiungere un Test Parit\n\n```bash\n# 1. Crea file test\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// Descrizione test\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. Genera output atteso dall'interprete\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. Verifica parit\nmake parity\n```\n\n---\n\n## Versione\n\n**v1.8.1** - Release corrente con:\n- **Pattern matching** (espressioni `match`) - Potente destrutturazione e flusso di controllo:\n  - Pattern letterali, wildcard e binding variabile\n  - Pattern OR (`1 | 2 | 3`)\n  - Espressioni guard (`n if n > 0`)\n  - Destrutturazione oggetti (`{ x, y }`)\n  - Destrutturazione array con rest (`[first, ...rest]`)\n  - Pattern tipo (`n: i32`)\n  - Parit completa tra interprete e compilatore\n- **Annotazioni helper compilatore** - 11 annotazioni di ottimizzazione per controllo GCC/Clang:\n  - `@inline`, `@noinline` - controllo inlining funzione\n  - `@hot`, `@cold` - hint predizione branch\n  - `@pure`, `@const` - annotazioni effetti collaterali\n  - `@flatten` - inline tutte le chiamate nella funzione\n  - `@optimize(level)` - livello ottimizzazione per funzione (\"0\", \"1\", \"2\", \"3\", \"s\", \"fast\")\n  - `@warn_unused` - avvisa su valori ritorno ignorati\n  - `@section(name)` - posizionamento sezione ELF custom (es. `@section(\".text.hot\")`)\n- **Funzioni con corpo espressione** (`fn double(x): i32 => x * 2;`) - sintassi concisa per funzioni a singola espressione\n- **Istruzioni singola riga** - sintassi `if`, `while`, `for` senza parentesi (es. `if (x > 0) print(x);`)\n- **Alias di tipo** (`type Name = Type;`) - scorciatoie nominate per tipi complessi\n- **Annotazioni tipo funzione** (`fn(i32): i32`) - tipi funzione di prima classe\n- **Parametri const** (`fn(const x: array)`) - immutabilit profonda per parametri\n- **Parametri ref** (`fn(ref x: i32)`) - passaggio per riferimento per mutazione diretta chiamante\n- **Firme metodo in define** (`fn method(): Type`) - contratti simili a interfacce (delimitati da virgola)\n- **Tipo Self** nelle firme metodo - si riferisce al tipo che definisce\n- **Keyword loop** (`loop { }`) - cicli infiniti pi puliti, sostituisce `while (true)`\n- **Etichette ciclo** (`outer: while`) - break/continue mirati per cicli annidati\n- **Shorthand oggetti** (`{ name }`) - sintassi propriet shorthand stile ES6\n- **Spread oggetti** (`{ ...obj }`) - copia e unisce campi oggetto\n- **Tipi duck composti** (`A & B & C`) - tipi intersezione per typing strutturale\n- **Argomenti nominati** per chiamate funzione (`foo(name: \"value\", age: 30)`)\n- **Operatori null coalescing** (`??`, `??=`, `?.`) per gestione null sicura\n- **Letterali ottali** (`0o777`, `0O123`)\n- **Separatori numerici** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)\n- **Commenti blocco** (`/* ... */`)\n- **Sequenze escape esadecimali** in stringhe/rune (`\\x41` = 'A')\n- **Sequenze escape unicode** in stringhe (`\\u{1F600}` = )\n- **Letterali float senza zero iniziale** (`.5`, `.123`, `.5e2`)\n- **Type checking compile-time** in hemlockc (abilitato di default)\n- **Integrazione LSP** con type checking per diagnostica real-time\n- **Operatori assegnazione composta** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)\n- **Operatori incremento/decremento** (`++x`, `x++`, `--x`, `x--`)\n- **Fix precisione tipo**: i64/u64 + f32  f64 per preservare precisione\n- Sistema tipi unificato con hint ottimizzazione unboxing\n- Sistema tipi completo (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)\n- Stringhe UTF-8 con 19 metodi\n- Array con 18 metodi inclusi map/filter/reduce\n- Gestione memoria manuale con `talloc()` e `sizeof()`\n- Async/await con vero parallelismo pthread\n- Operazioni atomiche per programmazione concorrente lock-free\n- 40 moduli stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)\n- FFI per interop C con `export extern fn` per wrapper libreria riutilizzabili\n- Supporto struct FFI nel compilatore (passa struct C per valore)\n- Helper puntatori FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)\n- defer, try/catch/finally/throw, panic\n- I/O File, gestione segnali, esecuzione comandi\n- Gestore pacchetti [hpm](https://github.com/hemlang/hpm) con registry basato su GitHub\n- Backend compilatore (generazione codice C) con 100% parit interprete\n- Server LSP con go-to-definition e find-references\n- Pass ottimizzazione AST e risoluzione variabili per lookup O(1)\n- Builtin apply() per chiamate funzione dinamiche\n- Canali unbuffered e supporto many-params\n- 159 test parit (100% pass rate)\n\n---\n\n## Filosofia\n\n> Ti diamo gli strumenti per essere sicuro (`buffer`, annotazioni tipo, controllo limiti) ma non ti obblighiamo a usarli (`ptr`, memoria manuale, operazioni non sicure).\n\n**Se non sei sicuro se una funzionalit si adatta a Hemlock, chiediti: \"Questo d al programmatore pi controllo esplicito, o nasconde qualcosa?\"**\n\nSe nasconde, probabilmente non appartiene a Hemlock.\n"}, "Primi Passi -> Avvio Rapido": {"id": "getting-started-quick-start", "content": "# Avvio Rapido\n\nInizia a usare Hemlock in pochi minuti!\n\n## Il Tuo Primo Programma\n\nCrea un file chiamato `hello.hml`:\n\n```hemlock\nprint(\"Ciao, Hemlock!\");\n```\n\nEsegui con l'interprete:\n\n```bash\n./hemlock hello.hml\n```\n\nOppure compila in un eseguibile nativo:\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\nOutput:\n```\nCiao, Hemlock!\n```\n\n### Interprete vs Compilatore\n\nHemlock fornisce due modi per eseguire i programmi:\n\n| Strumento | Caso d'Uso | Type Checking |\n|-----------|------------|---------------|\n| `hemlock` | Script veloci, REPL, sviluppo | Solo runtime |\n| `hemlockc` | Binari di produzione, prestazioni migliori | Compile-time (default) |\n\nIl compilatore (`hemlockc`) verifica i tipi del tuo codice prima di generare un eseguibile, catturando gli errori in anticipo.\n\n## Sintassi di Base\n\n### Variabili\n\n```hemlock\n// Le variabili sono dichiarate con 'let'\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Le annotazioni di tipo sono opzionali\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**Importante**: I punto e virgola sono **obbligatori** in Hemlock!\n\n### Tipi\n\nHemlock ha un sistema di tipi ricco:\n\n```hemlock\n// Interi\nlet small: i8 = 127;          // 8-bit con segno\nlet byte: u8 = 255;           // 8-bit senza segno\nlet num: i32 = 2147483647;    // 32-bit con segno (default)\nlet big: i64 = 9223372036854775807;  // 64-bit con segno\n\n// Float\nlet f: f32 = 3.14;            // float 32-bit\nlet d: f64 = 2.71828;         // float 64-bit (default)\n\n// Stringhe e caratteri\nlet text: string = \"Ciao\";    // stringa UTF-8\nlet emoji: rune = '';       // codepoint Unicode\n\n// Booleano e null\nlet flag: bool = true;\nlet empty = null;\n```\n\n### Flusso di Controllo\n\n```hemlock\n// Istruzioni if\nif (x > 0) {\n    print(\"positivo\");\n} else if (x < 0) {\n    print(\"negativo\");\n} else {\n    print(\"zero\");\n}\n\n// Cicli while\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// Cicli for\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### Funzioni\n\n```hemlock\n// Funzione nominata\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Funzione anonima\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## Lavorare con le Stringhe\n\nLe stringhe in Hemlock sono **mutabili** e **UTF-8**:\n\n```hemlock\nlet s = \"ciao\";\ns[0] = 'C';              // Ora \"Ciao\"\nprint(s);\n\n// Metodi stringa\nlet upper = s.to_upper();     // \"CIAO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"iao\"\n\n// Concatenazione\nlet greeting = \"Ciao\" + \", \" + \"Mondo!\";\nprint(greeting);  // \"Ciao, Mondo!\"\n```\n\n## Array\n\nArray dinamici con tipi misti:\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Metodi array\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Tipi misti permessi\nlet mixed = [1, \"due\", true, null];\n```\n\n## Oggetti\n\nOggetti in stile JavaScript:\n\n```hemlock\n// Letterale oggetto\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Modifica campo\n\n// Metodi con 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Gestione della Memoria\n\nHemlock usa **gestione manuale della memoria**:\n\n```hemlock\n// Buffer sicuro (raccomandato)\nlet buf = buffer(64);   // Alloca 64 byte\nbuf[0] = 65;            // Imposta primo byte a 'A'\nprint(buf[0]);          // 65\nfree(buf);              // Libera memoria\n\n// Puntatore raw (avanzato)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Riempi con zeri\nfree(ptr);\n```\n\n**Importante**: Devi fare `free()` di ci che `alloc()`!\n\n## Gestione degli Errori\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"divisione per zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Errore: \" + e);\n} finally {\n    print(\"Fatto\");\n}\n```\n\n## Argomenti da Riga di Comando\n\nAccedi agli argomenti del programma tramite l'array `args`:\n\n```hemlock\n// script.hml\nprint(\"Script:\", args[0]);\nprint(`Argomenti: ${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  arg ${i}: ${args[i]}`);\n    i = i + 1;\n}\n```\n\nEsegui con:\n```bash\n./hemlock script.hml ciao mondo\n```\n\nOutput:\n```\nScript: script.hml\nArgomenti: 2\n  arg 1: ciao\n  arg 2: mondo\n```\n\n## I/O su File\n\n```hemlock\n// Scrivi su file\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Ciao, File!\");\nf.close();\n\n// Leggi da file\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Ciao, File!\"\nf2.close();\n```\n\n## Cosa c' Dopo?\n\nOra che hai visto le basi, esplora di pi:\n\n- [Tutorial](#getting-started-tutorial) - Guida completa passo dopo passo\n- [Guida al Linguaggio](#language-guide-syntax) - Approfondimento su tutte le funzionalit\n- [Esempi](../../examples/) - Programmi esempio reali\n- [Riferimento API](#reference-builtins) - Documentazione API completa\n\n## Errori Comuni\n\n### Dimenticare i Punto e Virgola\n\n```hemlock\n//  ERRORE: Punto e virgola mancante\nlet x = 42\nlet y = 10\n\n//  CORRETTO\nlet x = 42;\nlet y = 10;\n```\n\n### Dimenticare di Liberare la Memoria\n\n```hemlock\n//  MEMORY LEAK\nlet buf = buffer(100);\n// ... usa buf ...\n// Dimenticato di chiamare free(buf)!\n\n//  CORRETTO\nlet buf = buffer(100);\n// ... usa buf ...\nfree(buf);\n```\n\n### Le Parentesi Graffe Sono Richieste\n\n```hemlock\n//  ERRORE: Parentesi graffe mancanti\nif (x > 0)\n    print(\"positivo\");\n\n//  CORRETTO\nif (x > 0) {\n    print(\"positivo\");\n}\n```\n\n## Ottenere Aiuto\n\n- Leggi la [documentazione completa](../README.md)\n- Controlla la [directory degli esempi](../../examples/)\n- Guarda i [file di test](../../tests/) per pattern d'uso\n- Segnala problemi su GitHub\n"}, "Primi Passi -> Installazione": {"id": "getting-started-installation", "content": "# Installazione\n\nQuesta guida ti aiuter a compilare e installare Hemlock sul tuo sistema.\n\n## Installazione Rapida (Raccomandata)\n\nIl modo pi semplice per installare Hemlock  usare lo script di installazione one-line:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\nQuesto scarica e installa l'ultimo binario pre-compilato per la tua piattaforma (Linux o macOS, x86_64 o arm64).\n\n### Opzioni di Installazione\n\n```bash\n# Installa in un prefisso personalizzato (default: ~/.local)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# Installa una versione specifica\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# Installa e aggiorna automaticamente il PATH della shell\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\nDopo l'installazione, verifica che funzioni:\n\n```bash\nhemlock --version\n```\n\n---\n\n## Compilazione da Sorgente\n\nSe preferisci compilare da sorgente o i binari pre-compilati non funzionano per il tuo sistema, segui le istruzioni qui sotto.\n\n## Prerequisiti\n\n### Dipendenze Richieste\n\nHemlock richiede le seguenti dipendenze per la compilazione:\n\n- **Compilatore C**: GCC o Clang (standard C11)\n- **Make**: GNU Make\n- **libffi**: Libreria Foreign Function Interface (per supporto FFI)\n- **OpenSSL**: Libreria crittografica (per funzioni hash: md5, sha1, sha256)\n- **libwebsockets**: Supporto client/server WebSocket e HTTP\n- **zlib**: Libreria di compressione\n\n### Installazione Dipendenze\n\n**macOS:**\n```bash\n# Installa Homebrew se non gi installato\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Installa Xcode Command Line Tools\nxcode-select --install\n\n# Installa dipendenze via Homebrew\nbrew install libffi openssl@3 libwebsockets\n```\n\n**Nota per utenti macOS**: Il Makefile rileva automaticamente le installazioni Homebrew e imposta i path corretti di include/librerie. Hemlock supporta sia architetture Intel (x86_64) che Apple Silicon (arm64).\n\n**Ubuntu/Debian:**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL:**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux:**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## Compilazione da Sorgente\n\n### 1. Clona il Repository\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. Compila Hemlock\n\n```bash\nmake\n```\n\nQuesto compiler l'interprete Hemlock e posizioner l'eseguibile nella directory corrente.\n\n### 3. Verifica l'Installazione\n\n```bash\n./hemlock --version\n```\n\nDovresti vedere le informazioni sulla versione di Hemlock.\n\n### 4. Testa la Compilazione\n\nEsegui la suite di test per assicurarti che tutto funzioni correttamente:\n\n```bash\nmake test\n```\n\nTutti i test dovrebbero passare. Se vedi fallimenti, segnalali come issue.\n\n## Installazione System-Wide (Opzionale)\n\nPer installare Hemlock system-wide (es. in `/usr/local/bin`):\n\n```bash\nsudo make install\n```\n\nQuesto ti permette di eseguire `hemlock` da qualsiasi posizione senza specificare il path completo.\n\n## Esecuzione di Hemlock\n\n### REPL Interattivo\n\nAvvia il Read-Eval-Print Loop:\n\n```bash\n./hemlock\n```\n\nVedrai un prompt dove puoi digitare codice Hemlock:\n\n```\nHemlock REPL\n> print(\"Ciao, Mondo!\");\nCiao, Mondo!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\nEsci dal REPL con `Ctrl+D` o `Ctrl+C`.\n\n### Esecuzione di Programmi\n\nEsegui uno script Hemlock:\n\n```bash\n./hemlock programma.hml\n```\n\nCon argomenti da riga di comando:\n\n```bash\n./hemlock programma.hml arg1 arg2 \"argomento con spazi\"\n```\n\n## Struttura delle Directory\n\nDopo la compilazione, la tua directory Hemlock apparir cos:\n\n```\nhemlock/\n hemlock           # Eseguibile interprete compilato\n src/              # Codice sorgente\n include/          # File header\n tests/            # Suite di test\n examples/         # Programmi esempio\n docs/             # Documentazione\n stdlib/           # Libreria standard\n Makefile          # Configurazione build\n README.md         # README del progetto\n```\n\n## Opzioni di Build\n\n### Build di Debug\n\nCompila con simboli di debug e senza ottimizzazione:\n\n```bash\nmake debug\n```\n\n### Build Pulita\n\nRimuovi tutti i file compilati:\n\n```bash\nmake clean\n```\n\nRicompila da zero:\n\n```bash\nmake clean && make\n```\n\n## Risoluzione Problemi\n\n### macOS: Errori Libreria Non Trovata\n\nSe ottieni errori su librerie mancanti (`-lcrypto`, `-lffi`, ecc.):\n\n1. Assicurati che le dipendenze Homebrew siano installate:\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. Verifica i path Homebrew:\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. Il Makefile dovrebbe auto-rilevare questi path. Se non lo fa, verifica che `brew` sia nel tuo PATH:\n   ```bash\n   which brew\n   ```\n\n### macOS: Errori di Tipo BSD (`u_int`, `u_char` non trovati)\n\nSe vedi errori su nomi di tipo sconosciuti come `u_int` o `u_char`:\n\n1. Questo  risolto in v1.0.0+ usando `_DARWIN_C_SOURCE` invece di `_POSIX_C_SOURCE`\n2. Assicurati di avere l'ultima versione del codice\n3. Pulisci e ricompila:\n   ```bash\n   make clean && make\n   ```\n\n### Linux: libffi Non Trovata\n\nSe ottieni errori su `ffi.h` mancante o `-lffi`:\n\n1. Assicurati che `libffi-dev` sia installato (vedi dipendenze sopra)\n2. Verifica se `pkg-config` pu trovarla:\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. Se non trovata, potresti dover impostare `PKG_CONFIG_PATH`:\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### Errori di Compilazione\n\nSe incontri errori di compilazione:\n\n1. Assicurati di avere un compilatore compatibile con C11\n2. Su macOS, prova a usare Clang (default):\n   ```bash\n   make CC=clang\n   ```\n3. Su Linux, prova a usare GCC:\n   ```bash\n   make CC=gcc\n   ```\n4. Verifica che tutte le dipendenze siano installate\n5. Prova a ricompilare da zero:\n   ```bash\n   make clean && make\n   ```\n\n### Fallimenti nei Test\n\nSe i test falliscono:\n\n1. Verifica di avere l'ultima versione del codice\n2. Prova a ricompilare da zero:\n   ```bash\n   make clean && make test\n   ```\n3. Su macOS, assicurati di avere gli ultimi Xcode Command Line Tools:\n   ```bash\n   xcode-select --install\n   ```\n4. Segnala il problema su GitHub con:\n   - La tua piattaforma (versione macOS / distro Linux)\n   - Architettura (x86_64 / arm64)\n   - Output dei test\n   - Output di `make -v` e `gcc --version` (o `clang --version`)\n\n## Prossimi Passi\n\n- [Guida all'Avvio Rapido](#getting-started-quick-start) - Scrivi il tuo primo programma Hemlock\n- [Tutorial](#getting-started-tutorial) - Impara Hemlock passo dopo passo\n- [Guida al Linguaggio](#language-guide-syntax) - Esplora le funzionalit di Hemlock\n"}, "Primi Passi -> Percorsi di Apprendimento": {"id": "getting-started-learning-paths", "content": "# Percorsi di Apprendimento\n\nObiettivi diversi richiedono conoscenze diverse. Scegli il percorso che corrisponde a ci che vuoi costruire.\n\n---\n\n## Percorso 1: Script Veloci e Automazione\n\n**Obiettivo:** Scrivere script per automatizzare attivit, elaborare file e portare a termine il lavoro.\n\n**Tempo per la produttivit:** Veloce - puoi iniziare a scrivere script utili immediatamente.\n\n### Cosa Imparerai\n\n1. **[Avvio Rapido](#getting-started-quick-start)** - Il tuo primo programma, sintassi base\n2. **[Stringhe](#language-guide-strings)** - Elaborazione testo, split, ricerca\n3. **[Array](#language-guide-arrays)** - Liste, filtraggio, trasformazione dati\n4. **[I/O File](#advanced-file-io)** - Lettura e scrittura file\n5. **[Argomenti Riga Comando](#advanced-command-line-args)** - Ottenere input dagli utenti\n\n### Salta Per Ora\n\n- Gestione memoria (automatica per gli script)\n- Async/concorrenza (eccessivo per script semplici)\n- FFI (necessario solo per interop C)\n\n### Progetto Esempio: Rinominatore File\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// Rinomina tutti i file .txt in .md\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`Rinominato: ${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## Percorso 2: Elaborazione e Analisi Dati\n\n**Obiettivo:** Parsare dati, trasformarli, generare report.\n\n**Tempo per la produttivit:** Veloce - I metodi stringa e array di Hemlock rendono questo facile.\n\n### Cosa Imparerai\n\n1. **[Avvio Rapido](#getting-started-quick-start)** - Basi\n2. **[Stringhe](#language-guide-strings)** - Parsing, split, formattazione\n3. **[Array](#language-guide-arrays)** - map, filter, reduce per trasformazione dati\n4. **[Oggetti](#language-guide-objects)** - Dati strutturati\n5. **Libreria Standard:**\n   - **[@stdlib/json](#stdlib-json)** - Parsing JSON\n   - **[@stdlib/csv](#stdlib-csv)** - File CSV\n   - **[@stdlib/fs](#stdlib-fs)** - Operazioni file\n\n### Progetto Esempio: Analizzatore CSV\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"vendite.csv\"));\n\n// Calcola vendite totali\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`Vendite totali: ${total}`);\n\n// Trova il top venditore\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`Vendita top: ${top.product} - ${top.amount}`);\n```\n\n---\n\n## Percorso 3: Programmazione Web e Network\n\n**Obiettivo:** Costruire client HTTP, lavorare con API, creare server.\n\n**Tempo per la produttivit:** Medio - richiede comprensione delle basi async.\n\n### Cosa Imparerai\n\n1. **[Avvio Rapido](#getting-started-quick-start)** - Basi\n2. **[Funzioni](#language-guide-functions)** - Callback e closure\n3. **[Gestione Errori](#language-guide-error-handling)** - try/catch per errori di rete\n4. **[Async e Concorrenza](#advanced-async-concurrency)** - spawn, await, canali\n5. **Libreria Standard:**\n   - **[@stdlib/http](#stdlib-http)** - Richieste HTTP\n   - **[@stdlib/json](#stdlib-json)** - JSON per API\n   - **[@stdlib/net](#stdlib-net)** - Socket TCP/UDP\n   - **[@stdlib/url](#stdlib-url)** - Parsing URL\n\n### Progetto Esempio: Client API\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// Richiesta GET\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name}: ${user.email}`);\n}\n\n// Richiesta POST\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`Creato utente con ID: ${parse(result.body).id}`);\n```\n\n---\n\n## Percorso 4: Programmazione di Sistema\n\n**Obiettivo:** Scrivere codice a basso livello, lavorare con la memoria, interfacciarsi con librerie C.\n\n**Tempo per la produttivit:** Pi lungo - richiede comprensione della gestione memoria.\n\n### Cosa Imparerai\n\n1. **[Avvio Rapido](#getting-started-quick-start)** - Basi\n2. **[Tipi](#language-guide-types)** - Comprendere i32, u8, ptr, ecc.\n3. **[Gestione Memoria](#language-guide-memory)** - alloc, free, buffer\n4. **[FFI](#advanced-ffi)** - Chiamare funzioni C\n5. **[Segnali](#advanced-signals)** - Gestione segnali\n\n### Concetti Chiave\n\n**Checklist Sicurezza Memoria:**\n- [ ] Ogni `alloc()` ha un `free()` corrispondente\n- [ ] Usa `buffer()` a meno che tu non abbia bisogno di `ptr` raw\n- [ ] Imposta i puntatori a `null` dopo aver liberato\n- [ ] Usa `try/finally` per garantire la pulizia\n\n**Mappatura Tipi per FFI:**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long` (64-bit) |\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### Progetto Esempio: Pool di Memoria Custom\n\n```hemlock\n// Semplice allocatore bump\nlet pool_size = 1024 * 1024;  // 1MB\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"Pool esaurito\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// Usalo\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();    // Riusa tutta la memoria\npool_destroy();  // Pulisci\n```\n\n---\n\n## Percorso 5: Programmi Paralleli e Concorrenti\n\n**Obiettivo:** Eseguire codice su pi core CPU, costruire applicazioni reattive.\n\n**Tempo per la produttivit:** Medio - la sintassi async  diretta, ma ragionare sul parallelismo richiede pratica.\n\n### Cosa Imparerai\n\n1. **[Avvio Rapido](#getting-started-quick-start)** - Basi\n2. **[Funzioni](#language-guide-functions)** - Closure (importanti per async)\n3. **[Async e Concorrenza](#advanced-async-concurrency)** - Approfondimento completo\n4. **[Atomiche](#advanced-atomics)** - Programmazione lock-free\n\n### Concetti Chiave\n\n**Modello async di Hemlock:**\n- `async fn` - Definisce una funzione che pu girare su un altro thread\n- `spawn(fn, args...)` - Inizia l'esecuzione, restituisce un handle task\n- `join(task)` o `await task` - Aspetta che finisca, ottieni il risultato\n- `channel(size)` - Crea una coda per inviare dati tra task\n\n**Importante:** I task ricevono *copie* dei valori. Se passi un puntatore, sei responsabile di assicurarti che la memoria rimanga valida fino al completamento del task.\n\n### Progetto Esempio: Processore File Parallelo\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// Processa tutti i file in parallelo\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// Raccogli risultati\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name}: ${count} righe`);\n    total_lines = total_lines + count;\n}\n\nprint(`Totale: ${total_lines} righe`);\n```\n\n---\n\n## Cosa Imparare Prima (Qualsiasi Percorso)\n\nIndipendentemente dal tuo obiettivo, inizia con questi fondamentali:\n\n### Settimana 1: Basi Fondamentali\n1. **[Avvio Rapido](#getting-started-quick-start)** - Scrivi ed esegui il tuo primo programma\n2. **[Sintassi](#language-guide-syntax)** - Variabili, operatori, flusso di controllo\n3. **[Funzioni](#language-guide-functions)** - Definisci e chiama funzioni\n\n### Settimana 2: Gestione Dati\n4. **[Stringhe](#language-guide-strings)** - Manipolazione testo\n5. **[Array](#language-guide-arrays)** - Collezioni e iterazione\n6. **[Oggetti](#language-guide-objects)** - Dati strutturati\n\n### Settimana 3: Robustezza\n7. **[Gestione Errori](#language-guide-error-handling)** - try/catch/throw\n8. **[Moduli](#language-guide-modules)** - Import/export, uso stdlib\n\n### Poi: Scegli il Tuo Percorso Sopra\n\n---\n\n## Cheat Sheet: Provenienza da Altri Linguaggi\n\n### Da Python\n\n| Python | Hemlock | Note |\n|--------|---------|------|\n| `x = 42` | `let x = 42;` | Punto e virgola richiesto |\n| `def fn():` | `fn name() { }` | Parentesi graffe richieste |\n| `if x:` | `if (x) { }` | Parentesi e graffe richieste |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Cicli for stile C |\n| `for item in list:` | `for (item in array) { }` | For-in funziona uguale |\n| `list.append(x)` | `array.push(x);` | Nome metodo diverso |\n| `len(s)` | `s.length` o `len(s)` | Entrambi funzionano |\n| Memoria automatica | Manuale per `ptr` | La maggior parte dei tipi auto-pulizia |\n\n### Da JavaScript\n\n| JavaScript | Hemlock | Note |\n|------------|---------|------|\n| `let x = 42` | `let x = 42;` | Uguale (punto e virgola richiesto) |\n| `const x = 42` | `let x = 42;` | Nessuna keyword const |\n| `function fn()` | `fn name() { }` | Keyword diversa |\n| `() => x` | `fn() { return x; }` | Nessuna arrow function |\n| `async/await` | `async/await` | Stessa sintassi |\n| `Promise` | `spawn/join` | Modello diverso |\n| GC automatico | Manuale per `ptr` | La maggior parte dei tipi auto-pulizia |\n\n### Da C/C++\n\n| C | Hemlock | Note |\n|---|---------|------|\n| `int x = 42;` | `let x: i32 = 42;` | Tipo dopo due punti |\n| `malloc(n)` | `alloc(n)` | Stesso concetto |\n| `free(p)` | `free(p)` | Uguale |\n| `char* s = \"hi\"` | `let s = \"hi\";` | Le stringhe sono gestite |\n| `#include` | `import { } from` | Import moduli |\n| Tutto manuale | Auto per la maggior parte dei tipi | Solo `ptr` richiede manuale |\n\n---\n\n## Ottenere Aiuto\n\n- **[Glossario](../glossary.md)** - Definizioni dei termini di programmazione\n- **[Esempi](../../examples/)** - Programmi funzionanti completi\n- **[Test](../../tests/)** - Vedi come vengono usate le funzionalit\n- **GitHub Issues** - Fai domande, segnala bug\n\n---\n\n## Livelli di Difficolt\n\nIn tutta la documentazione, vedrai questi marcatori:\n\n| Marcatore | Significato |\n|-----------|-------------|\n| **Principiante** | Nessuna esperienza di programmazione precedente necessaria |\n| **Intermedio** | Assume conoscenza base di programmazione |\n| **Avanzato** | Richiede comprensione di concetti di sistema |\n\nSe qualcosa marcato \"Principiante\" ti confonde, controlla il [Glossario](../glossary.md) per le definizioni dei termini.\n"}, "Primi Passi -> Tutorial": {"id": "getting-started-tutorial", "content": "# Tutorial Hemlock\n\nUna guida completa passo dopo passo per imparare Hemlock.\n\n## Indice\n\n1. [Hello World](#hello-world)\n2. [Variabili e Tipi](#variabili-e-tipi)\n3. [Aritmetica e Operazioni](#aritmetica-e-operazioni)\n4. [Flusso di Controllo](#flusso-di-controllo)\n5. [Funzioni](#funzioni)\n6. [Stringhe e Rune](#stringhe-e-rune)\n7. [Array](#array)\n8. [Oggetti](#oggetti)\n9. [Gestione della Memoria](#gestione-della-memoria)\n10. [Gestione degli Errori](#gestione-degli-errori)\n11. [I/O su File](#io-su-file)\n12. [Mettere Tutto Insieme](#mettere-tutto-insieme)\n\n## Hello World\n\nIniziamo con il tradizionale primo programma:\n\n```hemlock\nprint(\"Ciao, Mondo!\");\n```\n\nSalva questo come `hello.hml` ed esegui:\n\n```bash\n./hemlock hello.hml\n```\n\n**Punti Chiave:**\n- `print()`  una funzione integrata che scrive su stdout\n- Le stringhe sono racchiuse tra doppi apici\n- I punto e virgola sono **obbligatori**\n\n## Variabili e Tipi\n\n### Dichiarare Variabili\n\n```hemlock\n// Dichiarazione base di variabile\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### Annotazioni di Tipo\n\nMentre i tipi sono inferiti di default, puoi essere esplicito:\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### Inferenza di Tipo\n\nHemlock inferisce i tipi in base ai valori:\n\n```hemlock\nlet small = 42;              // i32 (entra in 32-bit)\nlet large = 5000000000;      // i64 (troppo grande per i32)\nlet decimal = 3.14;          // f64 (default per float)\nlet text = \"ciao\";           // string\nlet flag = true;             // bool\n```\n\n### Controllo dei Tipi\n\n```hemlock\n// Controlla i tipi con typeof()\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"ciao\"));    // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## Aritmetica e Operazioni\n\n### Aritmetica di Base\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (divisione intera)\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### Promozione dei Tipi\n\nQuando si mescolano tipi, Hemlock promuove al tipo pi grande/preciso:\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result  f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### Operazioni Bit a Bit\n\n```hemlock\nlet a = 12;  // 1100 in binario\nlet b = 10;  // 1010 in binario\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24 (shift sinistro)\nprint(a >> 1);  // 6  (shift destro)\nprint(~a);      // -13 (NOT)\n```\n\n## Flusso di Controllo\n\n### Istruzioni If\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positivo\");\n} else if (x < 0) {\n    print(\"negativo\");\n} else {\n    print(\"zero\");\n}\n```\n\n**Nota:** Le parentesi graffe sono **sempre richieste**, anche per singole istruzioni.\n\n### Cicli While\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`Conteggio: ${count}`);\n    count = count + 1;\n}\n```\n\n### Cicli For\n\n```hemlock\n// Ciclo for stile C\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// Ciclo for-in (array)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`Elemento: ${item}`);\n}\n```\n\n### Istruzioni Switch\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Luned\");\n        break;\n    case 2:\n        print(\"Marted\");\n        break;\n    case 3:\n        print(\"Mercoled\");\n        break;\n    default:\n        print(\"Altro giorno\");\n        break;\n}\n```\n\n### Break e Continue\n\n```hemlock\n// Break: esce dal ciclo in anticipo\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Stampa: 0, 1, 2, 3, 4\n\n// Continue: salta alla prossima iterazione\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Stampa: 0, 1, 3, 4\n```\n\n## Funzioni\n\n### Funzioni Nominate\n\n```hemlock\nfn greet(name: string): string {\n    return \"Ciao, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Ciao, Alice!\"\n```\n\n### Funzioni Anonime\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### Ricorsione\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Closure\n\nLe funzioni catturano il loro ambiente:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### Funzioni di Ordine Superiore\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## Stringhe e Rune\n\n### Basi delle Stringhe\n\nLe stringhe sono **mutabili** e **UTF-8**:\n\n```hemlock\nlet s = \"ciao\";\nprint(s.length);      // 4 (conteggio caratteri)\nprint(s.byte_length); // 4 (conteggio byte)\n\n// Mutazione\ns[0] = 'C';\nprint(s);  // \"Ciao\"\n```\n\n### Metodi Stringa\n\n```hemlock\nlet text = \"  Ciao, Mondo!  \";\n\n// Conversione maiuscole/minuscole\nprint(text.to_upper());  // \"  CIAO, MONDO!  \"\nprint(text.to_lower());  // \"  ciao, mondo!  \"\n\n// Trim\nprint(text.trim());      // \"Ciao, Mondo!\"\n\n// Estrazione sottostringa\nlet ciao = text.substr(2, 4);  // \"Ciao\"\nlet mondo = text.slice(8, 13); // \"Mondo\"\n\n// Ricerca\nlet pos = text.find(\"Mondo\");  // 8\nlet has = text.contains(\"o\");  // true\n\n// Split\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Sostituzione\nlet s = \"ciao mondo\".replace(\"mondo\", \"a tutti\");\nprint(s);  // \"ciao a tutti\"\n```\n\n### Rune (Codepoint Unicode)\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Concatenazione Rune + String\nlet msg = '>' + \" Importante\";\nprint(msg);  // \"> Importante\"\n\n// Conversione tra rune e intero\nlet code: i32 = ch;     // 65 (codice ASCII)\nlet r: rune = 128640;   // U+1F680 ()\n```\n\n## Array\n\n### Basi degli Array\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Modifica elementi\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### Metodi Array\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// Aggiungi/rimuovi alla fine\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr  ora [10, 20, 30]\n\n// Aggiungi/rimuovi all'inizio\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr  ora [10, 20, 30]\n\n// Inserisci/rimuovi all'indice\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Ricerca\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Slice\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Join in stringa\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### Iterazione\n\n```hemlock\nlet items = [\"mela\", \"banana\", \"ciliegia\"];\n\n// Ciclo for-in\nfor (let item in items) {\n    print(item);\n}\n\n// Iterazione manuale\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## Oggetti\n\n### Letterali Oggetto\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Aggiungi/modifica campi\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### Metodi e `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### Definizioni di Tipo (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Opzionale con default\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Duck typing valida la struttura\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (default applicato)\n```\n\n### Serializzazione JSON\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Object a JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON a Object\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## Gestione della Memoria\n\n### Buffer Sicuri (Raccomandato)\n\n```hemlock\n// Alloca buffer\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Imposta valori (controllo limiti)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Accedi valori\nprint(buf[0]);  // 65\n\n// Deve essere liberato quando finito\nfree(buf);\n```\n\n### Puntatori Raw (Avanzato)\n\n```hemlock\n// Alloca memoria raw\nlet ptr = alloc(100);\n\n// Riempi con zeri\nmemset(ptr, 0, 100);\n\n// Copia dati\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Libera entrambi\nfree(src);\nfree(ptr);\n```\n\n### Funzioni di Memoria\n\n```hemlock\n// Rialloca\nlet p = alloc(64);\np = realloc(p, 128);  // Ridimensiona a 128 byte\nfree(p);\n\n// Allocazione tipizzata (futuro)\n// let arr = talloc(i32, 100);  // Array di 100 i32\n```\n\n## Gestione degli Errori\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"divisione per zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Errore: \" + e);\n}\n// Output: Errore: divisione per zero\n```\n\n### Blocco Finally\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Errore: \" + e);\n} finally {\n    // Sempre eseguito\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### Lanciare Oggetti\n\n```hemlock\ntry {\n    throw { code: 404, message: \"Non trovato\" };\n} catch (e) {\n    print(`Errore ${e.code}: ${e.message}`);\n}\n// Output: Errore 404: Non trovato\n```\n\n### Panic (Errori Irrecuperabili)\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x deve essere non-negativo\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // Programma esce con: panic: x deve essere non-negativo\n```\n\n## I/O su File\n\n### Lettura File\n\n```hemlock\n// Leggi intero file\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Leggi numero specifico di byte\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // Leggi 100 byte\nf2.close();\n```\n\n### Scrittura File\n\n```hemlock\n// Scrivi testo\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Ciao, File!\\n\");\nf.write(\"Seconda riga\\n\");\nf.close();\n\n// Aggiungi a file\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Riga aggiunta\\n\");\nf2.close();\n```\n\n### I/O Binario\n\n```hemlock\n// Scrivi dati binari\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Leggi dati binari\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### Propriet File\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## Mettere Tutto Insieme\n\nCostruiamo un semplice programma conta-parole:\n\n```hemlock\n// wordcount.hml - Conta le parole in un file\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Dividi per spazi e conta\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Errore lettura file: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Programma principale\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`Conteggio parole: ${words}`);\n    }\n}\n```\n\nEsegui con:\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## Prossimi Passi\n\nCongratulazioni! Hai imparato le basi di Hemlock. Ecco cosa esplorare dopo:\n\n- [Async e Concorrenza](#advanced-async-concurrency) - Vero multi-threading\n- [FFI](#advanced-ffi) - Chiama funzioni C\n- [Gestione Segnali](#advanced-signals) - Segnali di processo\n- [Riferimento API](#reference-builtins) - Documentazione API completa\n- [Esempi](../../examples/) - Altri programmi reali\n\n## Esercizi Pratici\n\nProva a costruire questi programmi per esercitarti:\n\n1. **Calcolatrice**: Implementa una semplice calcolatrice con +, -, *, /\n2. **Copia File**: Copia un file in un altro\n3. **Fibonacci**: Genera numeri di Fibonacci\n4. **Parser JSON**: Leggi e parsa file JSON\n5. **Processore Testo**: Trova e sostituisci testo nei file\n\nBuona programmazione con Hemlock!\n"}, "Guida al Linguaggio -> Array": {"id": "language-guide-arrays", "content": "# Array\n\nHemlock fornisce **array dinamici** con metodi completi per la manipolazione e l'elaborazione dei dati. Gli array possono contenere tipi misti e crescono automaticamente secondo necessita.\n\n## Panoramica\n\n```hemlock\n// Letterali array\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Tipi misti consentiti\nlet mixed = [1, \"ciao\", true, null];\n\n// Dimensionamento dinamico\narr.push(6);           // Cresce automaticamente\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## Letterali array\n\n### Sintassi di base\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"mela\", \"banana\", \"ciliegia\"];\nlet booleans = [true, false, true];\n```\n\n### Array vuoti\n\n```hemlock\nlet arr = [];  // Array vuoto\n\n// Aggiungere elementi dopo\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### Tipi misti\n\nGli array possono contenere tipi diversi:\n\n```hemlock\nlet mixed = [\n    42,\n    \"ciao\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"ciao\"\nprint(mixed[4]);  // [1, 2, 3] (array annidato)\n```\n\n### Array annidati\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### Array tipizzati\n\nGli array possono avere annotazioni di tipo per imporre i tipi degli elementi:\n\n```hemlock\n// Sintassi array tipizzato\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// Verifica del tipo a runtime\nlet valid: array<i32> = [1, 2, 3];       // OK\nlet invalid: array<i32> = [1, \"due\", 3]; // Errore runtime: tipo non corrispondente\n\n// Array tipizzati annidati\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**Comportamento dell'annotazione di tipo:**\n- Gli elementi vengono verificati quando aggiunti all'array\n- Le incompatibilita di tipo causano errori a runtime\n- Senza annotazione di tipo, gli array accettano tipi misti\n\n## Indicizzazione\n\n### Lettura degli elementi\n\nAccesso con indice da zero:\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (primo elemento)\nprint(arr[4]);  // 50 (ultimo elemento)\n\n// Fuori dai limiti restituisce null (nessun errore)\nprint(arr[10]);  // null\n```\n\n### Scrittura degli elementi\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Modificare esistente\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Puo assegnare oltre la lunghezza attuale (fa crescere l'array)\narr[5] = 60;    // Crea [10, 20, 3, null, null, 60]\n```\n\n### Indici negativi\n\n**Non supportati** - Usa solo indici positivi:\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // ERRORE o comportamento indefinito\n\n// Usa length per l'ultimo elemento\nprint(arr[arr.length - 1]);  // 3\n```\n\n## Proprieta\n\n### Proprieta `.length`\n\nRestituisce il numero di elementi:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Array vuoto\nlet empty = [];\nprint(empty.length);  // 0\n\n// Dopo le modifiche\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## Metodi array\n\nHemlock fornisce 18 metodi array per una manipolazione completa.\n\n### Operazioni stack\n\n**`push(value)`** - Aggiunge elemento alla fine:\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - Rimuove e restituisce l'ultimo elemento:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Restituisce 5, arr e ora [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### Operazioni coda\n\n**`shift()`** - Rimuove e restituisce il primo elemento:\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Restituisce 1, arr e ora [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - Aggiunge elemento all'inizio:\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### Inserimento e rimozione\n\n**`insert(index, value)`** - Inserisce elemento all'indice:\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Inserisce 3 all'indice 2: [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Inserisce all'inizio: [0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - Rimuove e restituisce elemento all'indice:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Restituisce 3, arr e ora [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### Operazioni di ricerca\n\n**`find(value)`** - Trova la prima occorrenza:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (indice della prima occorrenza)\nlet idx2 = arr.find(99);     // -1 (non trovato)\n\n// Funziona con qualsiasi tipo\nlet words = [\"mela\", \"banana\", \"ciliegia\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - Verifica se l'array contiene il valore:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### Operazioni di estrazione\n\n**`slice(start, end)`** - Estrae sottoarray (end esclusivo):\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (indici 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Originale invariato\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - Ottiene il primo elemento (senza rimuovere):\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (senza rimuovere)\nprint(arr);                  // [1, 2, 3] (invariato)\n```\n\n**`last()`** - Ottiene l'ultimo elemento (senza rimuovere):\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (senza rimuovere)\nprint(arr);                  // [1, 2, 3] (invariato)\n```\n\n### Operazioni di trasformazione\n\n**`reverse()`** - Inverte l'array sul posto:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (modificato)\n```\n\n**`join(delimiter)`** - Unisce gli elementi in una stringa:\n```hemlock\nlet words = [\"ciao\", \"mondo\", \"foo\"];\nlet joined = words.join(\" \");  // \"ciao mondo foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Funziona con tipi misti\nlet mixed = [1, \"ciao\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | ciao | true | null\"\n```\n\n**`concat(other)`** - Concatena con un altro array:\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (nuovo array)\n\n// Originali invariati\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### Operazioni di utilita\n\n**`clear()`** - Rimuove tutti gli elementi:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## Concatenamento dei metodi\n\nI metodi che restituiscono array o valori consentono il concatenamento:\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"mela\", \"banana\", \"ciliegia\"]\n    .slice(0, 2)\n    .join(\" e \");  // \"mela e banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## Riferimento completo dei metodi\n\n| Metodo | Parametri | Restituisce | Muta | Descrizione |\n|--------|-----------|-------------|------|-------------|\n| `push(value)` | any | void | Si | Aggiunge elemento alla fine |\n| `pop()` | - | any | Si | Rimuove e restituisce l'ultimo |\n| `shift()` | - | any | Si | Rimuove e restituisce il primo |\n| `unshift(value)` | any | void | Si | Aggiunge elemento all'inizio |\n| `insert(index, value)` | i32, any | void | Si | Inserisce all'indice |\n| `remove(index)` | i32 | any | Si | Rimuove e restituisce all'indice |\n| `find(value)` | any | i32 | No | Trova prima occorrenza (-1 se non trovato) |\n| `contains(value)` | any | bool | No | Verifica se contiene il valore |\n| `slice(start, end)` | i32, i32 | array | No | Estrae sottoarray (nuovo array) |\n| `join(delimiter)` | string | string | No | Unisce in stringa |\n| `concat(other)` | array | array | No | Concatena (nuovo array) |\n| `reverse()` | - | void | Si | Inverte sul posto |\n| `first()` | - | any | No | Ottiene primo elemento |\n| `last()` | - | any | No | Ottiene ultimo elemento |\n| `clear()` | - | void | Si | Rimuove tutti gli elementi |\n| `map(callback)` | fn | array | No | Trasforma ogni elemento |\n| `filter(predicate)` | fn | array | No | Seleziona elementi corrispondenti |\n| `reduce(callback, initial)` | fn, any | any | No | Riduce a singolo valore |\n\n## Dettagli di implementazione\n\n### Modello di memoria\n\n- **Allocato nell'heap** - Capacita dinamica\n- **Crescita automatica** - Raddoppia la capacita quando superata\n- **Nessun restringimento automatico** - La capacita non diminuisce\n- **Nessun controllo dei limiti sull'indicizzazione** - Usa i metodi per la sicurezza\n\n### Gestione della capacita\n\n```hemlock\nlet arr = [];  // Capacita iniziale: 0\n\narr.push(1);   // Cresce a capacita 1\narr.push(2);   // Cresce a capacita 2\narr.push(3);   // Cresce a capacita 4 (raddoppia)\narr.push(4);   // Ancora capacita 4\narr.push(5);   // Cresce a capacita 8 (raddoppia)\n```\n\n### Confronto dei valori\n\n`find()` e `contains()` usano l'uguaglianza di valore:\n\n```hemlock\n// Primitivi: confronto per valore\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Stringhe: confronto per valore\nlet words = [\"ciao\", \"mondo\"];\nwords.contains(\"ciao\");  // true\n\n// Oggetti: confronto per riferimento\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (stesso riferimento)\narr2.contains(obj2);  // false (riferimento diverso)\n```\n\n## Pattern comuni\n\n### Operazioni funzionali (map/filter/reduce)\n\nGli array hanno metodi integrati `map`, `filter` e `reduce`:\n\n```hemlock\n// map - trasforma ogni elemento\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - seleziona elementi corrispondenti\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - accumula in singolo valore\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// Concatenamento di operazioni funzionali\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### Pattern: Array come stack\n\n```hemlock\nlet stack = [];\n\n// Push sullo stack\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop dallo stack\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### Pattern: Array come coda\n\n```hemlock\nlet queue = [];\n\n// Enqueue (aggiungi alla fine)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue (rimuovi dalla testa)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## Buone pratiche\n\n1. **Usa i metodi invece dell'indicizzazione diretta** - Controllo dei limiti e chiarezza\n2. **Controlla i limiti** - L'indicizzazione diretta non controlla i limiti\n3. **Preferisci operazioni immutabili** - Usa `slice()` e `concat()` invece della mutazione\n4. **Inizializza con capacita** - Se conosci la dimensione (non attualmente supportato)\n5. **Usa `contains()` per l'appartenenza** - Piu chiaro dei cicli manuali\n6. **Concatena i metodi** - Piu leggibile delle chiamate annidate\n\n## Trabocchetti comuni\n\n### Trabocchetto: Indice diretto fuori dai limiti\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Nessun controllo dei limiti!\narr[10] = 99;  // Crea array sparso con null\nprint(arr.length);  // 11 (non 3!)\n\n// Meglio: Usa push() o controlla la lunghezza\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### Trabocchetto: Mutazione vs. Nuovo array\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Muta l'originale\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Restituisce nuovo array\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (invariato)\nprint(sub);  // [3, 2]\n```\n\n### Trabocchetto: Uguaglianza per riferimento\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Stesso riferimento: true\narr.contains(obj);  // true\n\n// Riferimento diverso: false\narr.contains({ x: 10 });  // false (oggetto diverso)\n```\n\n### Trabocchetto: Array a lunga durata\n\n```hemlock\n// Gli array nello scope locale vengono liberati automaticamente, ma gli array globali/a lunga durata richiedono attenzione\nlet global_cache = [];  // Livello modulo, persiste fino alla fine del programma\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // Cresce indefinitamente\n}\n\n// Per dati a lunga durata, considera:\n// - Svuotare l'array periodicamente: global_cache.clear();\n// - Liberare anticipatamente quando finito: free(global_cache);\n```\n\n## Esempi\n\n### Esempio: Statistiche array\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### Esempio: Deduplicazione array\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### Esempio: Suddivisione in chunk\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### Esempio: Appiattimento array\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Array annidato - appiattiscilo\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### Esempio: Ordinamento (Bubble Sort)\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Scambia\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Modifica sul posto\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Limitazioni\n\nLimitazioni attuali:\n\n- **Nessun controllo dei limiti sull'indicizzazione** - L'accesso diretto non e controllato\n- **Uguaglianza per riferimento per gli oggetti** - `find()` e `contains()` usano confronto per riferimento\n- **Nessuna destrutturazione array** - Nessuna sintassi `let [a, b] = arr`\n- **Nessun operatore spread** - Nessuna sintassi `[...arr1, ...arr2]`\n\n**Nota:** Gli array sono conteggiati per riferimento e liberati automaticamente quando lo scope termina. Vedi [Gestione della memoria](memory.md#conteggio-interno-dei-riferimenti) per i dettagli.\n\n## Argomenti correlati\n\n- [Stringhe](#language-guide-strings) - Metodi stringa simili ai metodi array\n- [Oggetti](#language-guide-objects) - Gli array sono anche simili agli oggetti\n- [Funzioni](#language-guide-functions) - Funzioni di ordine superiore con array\n- [Flusso di controllo](#language-guide-control-flow) - Iterazione sugli array\n\n## Vedi anche\n\n- **Dimensionamento dinamico**: Gli array crescono automaticamente con raddoppio della capacita\n- **Metodi**: 18 metodi completi per la manipolazione inclusi map/filter/reduce\n- **Memoria**: Vedi [Memoria](#language-guide-memory) per i dettagli sull'allocazione degli array\n"}, "Guida al Linguaggio -> Flusso di Controllo": {"id": "language-guide-control-flow", "content": "# Flusso di Controllo\n\nHemlock fornisce un flusso di controllo familiare in stile C con parentesi graffe obbligatorie e sintassi esplicita. Questa guida copre condizionali, cicli, istruzioni switch e operatori.\n\n## Panoramica\n\nFunzionalita del flusso di controllo disponibili:\n\n- `if`/`else`/`else if` - Diramazioni condizionali\n- Cicli `while` - Iterazione basata su condizione\n- Cicli `for` - Stile C e iterazione for-in\n- `loop` - Cicli infiniti (piu pulito di `while (true)`)\n- Istruzioni `switch` - Diramazioni multiple\n- `break`/`continue` - Controllo dei cicli\n- Etichette dei cicli - break/continue mirati per cicli annidati\n- `defer` - Esecuzione differita (pulizia)\n- Operatori booleani: `&&`, `||`, `!`\n- Operatori di confronto: `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Operatori bit a bit: `&`, `|`, `^`, `<<`, `>>`, `~`\n\n## Istruzioni If\n\n### If/Else di Base\n\n```hemlock\nif (x > 10) {\n    print(\"grande\");\n} else {\n    print(\"piccolo\");\n}\n```\n\n**Regole:**\n- Le parentesi graffe sono **sempre obbligatorie** per tutti i rami\n- Le condizioni devono essere racchiuse tra parentesi tonde\n- Niente parentesi graffe opzionali (a differenza del C)\n\n### If Senza Else\n\n```hemlock\nif (x > 0) {\n    print(\"positivo\");\n}\n// Nessun ramo else necessario\n```\n\n### Catene Else-If\n\n```hemlock\nif (x > 100) {\n    print(\"molto grande\");\n} else if (x > 50) {\n    print(\"grande\");\n} else if (x > 10) {\n    print(\"medio\");\n} else {\n    print(\"piccolo\");\n}\n```\n\n**Nota:** `else if` e zucchero sintattico per istruzioni if annidate. Questi sono equivalenti:\n\n```hemlock\n// else if (zucchero sintattico)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// Equivalente if annidato\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### Istruzioni If Annidate\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"positivo a singola cifra\");\n    } else {\n        print(\"positivo a piu cifre\");\n    }\n} else {\n    print(\"non positivo\");\n}\n```\n\n## Cicli While\n\nIterazione basata su condizione:\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**Cicli infiniti (vecchio stile):**\n```hemlock\nwhile (true) {\n    // ... fai il lavoro\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Nota:** Per i cicli infiniti, preferisci la parola chiave `loop` (vedi sotto).\n\n## Loop (Ciclo Infinito)\n\nLa parola chiave `loop` fornisce una sintassi piu pulita per i cicli infiniti:\n\n```hemlock\nloop {\n    // ... fai il lavoro\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Equivalente a `while (true)` ma piu esplicito sull'intento.**\n\n### Loop Base con Break\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Stampa: 0, 1, 2, 3, 4\n```\n\n### Loop con Continue\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // Salta la stampa di 3\n    }\n    print(i);\n}\n// Stampa: 1, 2, 4, 5\n```\n\n### Cicli Annidati\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// Stampa: 0, 1, 2, 10, 11, 12\n```\n\n### Quando Usare Loop\n\n- **Usa `loop`** per cicli intenzionalmente infiniti che escono tramite `break`\n- **Usa `while`** quando c'e una condizione di terminazione naturale\n- **Usa `for`** quando iteri un numero noto di volte o su una collezione\n\n## Cicli For\n\n### For in Stile C\n\nClassico ciclo for a tre parti:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**Componenti:**\n- **Inizializzatore**: `let i = 0` - Eseguito una volta prima del ciclo\n- **Condizione**: `i < 10` - Controllata prima di ogni iterazione\n- **Aggiornamento**: `i = i + 1` - Eseguito dopo ogni iterazione\n\n**Scope:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i non e accessibile qui (scope del ciclo)\n```\n\n### Cicli For-In\n\nItera sugli elementi di un array:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Stampa ogni elemento\n}\n```\n\n**Con indice e valore:**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`Indice: ${i}, Valore: ${arr[i]}`);\n}\n```\n\n## Istruzioni Switch\n\nDiramazioni multiple basate sul valore:\n\n### Switch Base\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"uno\");\n        break;\n    case 2:\n        print(\"due\");\n        break;\n    case 3:\n        print(\"tre\");\n        break;\n}\n```\n\n### Switch con Default\n\n```hemlock\nlet color = \"blu\";\n\nswitch (color) {\n    case \"rosso\":\n        print(\"fermati\");\n        break;\n    case \"giallo\":\n        print(\"rallenta\");\n        break;\n    case \"verde\":\n        print(\"vai\");\n        break;\n    default:\n        print(\"colore sconosciuto\");\n        break;\n}\n```\n\n**Regole:**\n- `default` corrisponde quando nessun altro caso corrisponde\n- `default` puo apparire ovunque nel corpo dello switch\n- E permesso un solo caso default\n\n### Comportamento Fall-Through\n\nI casi senza `break` cadono nel caso successivo (comportamento in stile C). Questo e **intenzionale** e puo essere usato per raggruppare i casi:\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C o inferiore\");\n        break;\n}\n```\n\n**Esempio di fallthrough esplicito:**\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Giorno feriale\");\n        break;\n    case 6:\n    case 7:\n        print(\"Fine settimana\");\n        break;\n}\n```\n\n**Importante:** A differenza di alcuni linguaggi moderni, Hemlock NON richiede una parola chiave `fallthrough` esplicita. I casi cadono automaticamente nel successivo a meno che non siano terminati da `break`, `return` o `throw`. Usa sempre `break` per prevenire fallthrough non intenzionali.\n\n### Switch con Return\n\nNelle funzioni, `return` esce immediatamente dallo switch:\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Lunedi\";\n        case 2:\n            return \"Martedi\";\n        case 3:\n            return \"Mercoledi\";\n        default:\n            return \"Sconosciuto\";\n    }\n}\n```\n\n### Tipi di Valore nello Switch\n\nSwitch funziona con qualsiasi tipo di valore:\n\n```hemlock\n// Interi\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"uno\"); break;\n}\n\n// Stringhe\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleani\nswitch (flag) {\n    case true: print(\"acceso\"); break;\n    case false: print(\"spento\"); break;\n}\n```\n\n**Nota:** I casi sono confrontati usando l'uguaglianza di valore.\n\n## Break e Continue\n\n### Break\n\nEsce dal ciclo o switch piu interno:\n\n```hemlock\n// Nei cicli\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Esci dal ciclo\n    }\n    print(i);\n    i = i + 1;\n}\n\n// Nello switch\nswitch (x) {\n    case 1:\n        print(\"uno\");\n        break;  // Esci dallo switch\n    case 2:\n        print(\"due\");\n        break;\n}\n```\n\n### Continue\n\nSalta alla prossima iterazione del ciclo:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Salta l'iterazione quando i e 5\n    }\n    print(i);  // Stampa 0,1,2,3,4,6,7,8,9\n}\n```\n\n**Differenza:**\n- `break` - Esce completamente dal ciclo\n- `continue` - Salta alla prossima iterazione\n\n## Etichette dei Cicli\n\nLe etichette dei cicli permettono a `break` e `continue` di mirare cicli esterni specifici invece del solo ciclo piu interno. Questo e utile per cicli annidati dove devi controllare un ciclo esterno da uno interno.\n\n### Break con Etichetta\n\nEsci da un ciclo esterno da un ciclo interno:\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // Esci dal ciclo while esterno\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// Stampa: 0, 1, 2, 10 (si ferma a i=1, j=1)\n```\n\n### Continue con Etichetta\n\nSalta alla prossima iterazione di un ciclo esterno:\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // Salta il resto del ciclo interno, continua l'esterno\n        }\n        print(i * 10 + j);\n    }\n}\n// Quando i=2, j=1: salta alla prossima iterazione esterna\n```\n\n### Etichette con Cicli For\n\nLe etichette funzionano con tutti i tipi di ciclo:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### Etichette con Cicli For-In\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Etichette con la Parola Chiave Loop\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### Etichette Multiple\n\nPuoi avere etichette a diversi livelli di annidamento:\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // Salta alla prossima iterazione del ciclo medio\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // Esci dal ciclo piu esterno\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### Break/Continue Senza Etichetta con Cicli Etichettati\n\n`break` e `continue` senza etichetta funzionano normalmente (influenzando il ciclo piu interno), anche quando i cicli esterni hanno etichette:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // Interrompe solo il ciclo interno\n        }\n        print(x * 10 + y);\n    }\n}\n// Stampa: 0, 1, 10, 11, 20, 21\n```\n\n### Sintassi delle Etichette\n\n- Le etichette sono identificatori seguiti da due punti\n- Le etichette devono precedere immediatamente un'istruzione di ciclo (`while`, `for`, `loop`)\n- I nomi delle etichette seguono le regole degli identificatori (lettere, cifre, underscore)\n- Convenzioni comuni: `outer`, `inner`, `row`, `col`, nomi descrittivi\n\n## Istruzione Defer\n\nL'istruzione `defer` pianifica il codice da eseguire quando la funzione corrente ritorna. Questo e utile per operazioni di pulizia come chiudere file, liberare risorse o rilasciare lock.\n\n### Defer Base\n\n```hemlock\nfn example() {\n    print(\"inizio\");\n    defer print(\"pulizia\");  // Eseguito quando la funzione ritorna\n    print(\"fine\");\n}\n\nexample();\n// Output:\n// inizio\n// fine\n// pulizia\n```\n\n**Comportamento chiave:**\n- Le istruzioni differite vengono eseguite **dopo** che il corpo della funzione e completato\n- Le istruzioni differite vengono eseguite **prima** che la funzione ritorni al chiamante\n- Le istruzioni differite vengono sempre eseguite, anche se la funzione lancia un'eccezione\n\n### Defer Multipli (Ordine LIFO)\n\nQuando si usano piu istruzioni `defer`, vengono eseguite in **ordine inverso** (Last-In-First-Out):\n\n```hemlock\nfn example() {\n    defer print(\"primo\");   // Eseguito per ultimo\n    defer print(\"secondo\"); // Eseguito secondo\n    defer print(\"terzo\");   // Eseguito per primo\n    print(\"corpo\");\n}\n\nexample();\n// Output:\n// corpo\n// terzo\n// secondo\n// primo\n```\n\nQuesto ordine LIFO e intenzionale - corrisponde all'ordine naturale per la pulizia di risorse annidate (chiudi le risorse interne prima di quelle esterne).\n\n### Defer con Return\n\nLe istruzioni differite vengono eseguite prima che `return` trasferisca il controllo:\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"pulizia\");\n    print(\"prima del return\");\n    return 42;\n}\n\nlet result = get_value();\nprint(\"risultato:\", result);\n// Output:\n// prima del return\n// pulizia\n// risultato: 42\n```\n\n### Defer con Eccezioni\n\nLe istruzioni differite vengono eseguite anche quando viene lanciata un'eccezione:\n\n```hemlock\nfn risky() {\n    defer print(\"pulizia 1\");\n    defer print(\"pulizia 2\");\n    print(\"prima del throw\");\n    throw \"errore!\";\n    print(\"dopo il throw\");  // Mai raggiunto\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Catturato:\", e);\n}\n// Output:\n// prima del throw\n// pulizia 2\n// pulizia 1\n// Catturato: errore!\n```\n\n### Pattern per la Pulizia delle Risorse\n\nIl caso d'uso principale per `defer` e assicurare che le risorse vengano pulite:\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // Chiude sempre, anche in caso di errore\n\n    let content = file.read();\n    // ... elabora il contenuto ...\n\n    // Il file viene chiuso automaticamente quando la funzione ritorna\n}\n```\n\n**Senza defer (soggetto a errori):**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // Se questo lancia, file.close() non viene mai chiamato!\n    process(content);\n    file.close();\n}\n```\n\n### Defer con Closure\n\nDefer puo usare closure per catturare lo stato:\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Rilascio risorsa\");\n        release(resource);\n    }();  // Nota: espressione di funzione invocata immediatamente\n\n    use_resource(resource);\n}\n```\n\n### Quando Usare Defer\n\n**Usa defer per:**\n- Chiudere file e connessioni di rete\n- Liberare memoria allocata\n- Rilasciare lock e mutex\n- Pulizia in qualsiasi funzione che acquisisce risorse\n\n**Defer vs Finally:**\n- `defer` e piu semplice per la pulizia di una singola risorsa\n- `try/finally` e migliore per la gestione complessa degli errori con recupero\n\n### Best Practice\n\n1. **Posiziona defer immediatamente dopo l'acquisizione di una risorsa:**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... usa file ...\n   ```\n\n2. **Usa defer multipli per risorse multiple:**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // Entrambi i file saranno chiusi in ordine inverso\n   ```\n\n3. **Ricorda l'ordine LIFO per risorse dipendenti:**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // inner rilasciato prima di outer (ordine di dipendenza corretto)\n   ```\n\n## Operatori Booleani\n\n### AND Logico (`&&`)\n\nEntrambe le condizioni devono essere vere:\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"positivo a singola cifra\");\n}\n```\n\n**Valutazione short-circuit:**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() mai chiamata\n}\n```\n\n### OR Logico (`||`)\n\nAlmeno una condizione deve essere vera:\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"fuori range\");\n}\n```\n\n**Valutazione short-circuit:**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() mai chiamata\n}\n```\n\n### NOT Logico (`!`)\n\nNega il valore booleano:\n\n```hemlock\nif (!is_valid) {\n    print(\"non valido\");\n}\n\nif (!(x > 10)) {\n    // Uguale a: if (x <= 10)\n}\n```\n\n## Operatori di Confronto\n\n### Uguaglianza\n\n```hemlock\nif (x == 10) { }    // Uguale\nif (x != 10) { }    // Diverso\n```\n\nFunziona con tutti i tipi:\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### Relazionali\n\n```hemlock\nif (x < 10) { }     // Minore di\nif (x > 10) { }     // Maggiore di\nif (x <= 10) { }    // Minore o uguale\nif (x >= 10) { }    // Maggiore o uguale\n```\n\n**Si applica la promozione di tipo:**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 promosso a i64)\n```\n\n## Operatori Bit a Bit\n\nHemlock fornisce operatori bit a bit per la manipolazione degli interi. Questi funzionano **solo con tipi interi** (i8-i64, u8-u64).\n\n### Operatori Bit a Bit Binari\n\n**AND bit a bit (`&`)**\n```hemlock\nlet a = 12;  // 1100 in binario\nlet b = 10;  // 1010 in binario\nprint(a & b);   // 8 (1000)\n```\n\n**OR bit a bit (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**XOR bit a bit (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**Shift a sinistra (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - shift a sinistra di 2\n```\n\n**Shift a destra (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - shift a destra di 1\n```\n\n### Operatore Bit a Bit Unario\n\n**NOT bit a bit (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (complemento a due)\n\nlet c: u8 = 15;   // 00001111 in binario\nprint(~c);        // 240 (11110000) in u8\n```\n\n### Esempi Bit a Bit\n\n**Con tipi unsigned:**\n```hemlock\nlet c: u8 = 15;   // 00001111 in binario\nlet d: u8 = 7;    // 00000111 in binario\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - in u8\n```\n\n**Preservazione del tipo:**\n```hemlock\n// Le operazioni bit a bit preservano il tipo degli operandi\nlet x: u8 = 255;\nlet result = ~x;  // result e u8 con valore 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 e i32 con valore 400\n```\n\n**Pattern comuni:**\n```hemlock\n// Controlla se un bit e impostato\nif (flags & 0x04) {\n    print(\"bit 2 impostato\");\n}\n\n// Imposta un bit\nflags = flags | 0x08;\n\n// Cancella un bit\nflags = flags & ~0x02;\n\n// Inverte un bit\nflags = flags ^ 0x01;\n```\n\n### Precedenza degli Operatori\n\nGli operatori bit a bit seguono la precedenza in stile C:\n\n1. `~` (NOT unario) - piu alta, stesso livello di `!` e `-`\n2. `<<`, `>>` (shift) - piu alta dei confronti, piu bassa di `+`/`-`\n3. `&` (AND bit a bit) - piu alta di `^` e `|`\n4. `^` (XOR bit a bit) - tra `&` e `|`\n5. `|` (OR bit a bit) - piu bassa di `&` e `^`, piu alta di `&&`\n6. `&&`, `||` (logici) - precedenza piu bassa\n\n**Esempi:**\n```hemlock\n// & ha precedenza piu alta di |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Shift ha precedenza piu alta degli operatori bit a bit\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Usa le parentesi per chiarezza\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**Note importanti:**\n- Gli operatori bit a bit funzionano solo con tipi interi (non float, stringhe, ecc.)\n- La promozione di tipo segue le regole standard (tipi piu piccoli promossi a piu grandi)\n- Lo shift a destra (`>>`) e aritmetico per i tipi signed, logico per unsigned\n- Le quantita di shift non sono controllate per il range (il comportamento dipende dalla piattaforma per shift grandi)\n\n## Precedenza degli Operatori (Completa)\n\nDalla precedenza piu alta alla piu bassa:\n\n1. **Unari**: `!`, `-`, `~`\n2. **Moltiplicativi**: `*`, `/`, `%`\n3. **Additivi**: `+`, `-`\n4. **Shift**: `<<`, `>>`\n5. **Relazionali**: `<`, `>`, `<=`, `>=`\n6. **Uguaglianza**: `==`, `!=`\n7. **AND bit a bit**: `&`\n8. **XOR bit a bit**: `^`\n9. **OR bit a bit**: `|`\n10. **AND logico**: `&&`\n11. **OR logico**: `||`\n\n**Usa le parentesi per chiarezza:**\n```hemlock\n// Non chiaro\nif (a || b && c) { }\n\n// Chiaro\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## Pattern Comuni\n\n### Pattern: Validazione Input\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### Pattern: Controllo del Range\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"punteggio valido\");\n}\n```\n\n### Pattern: Macchina a Stati\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Avvio...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Fermato\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### Pattern: Iterazione con Filtro\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Stampa solo i numeri pari\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Salta i numeri dispari\n    }\n    print(arr[i]);\n}\n```\n\n### Pattern: Uscita Anticipata\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Uscita anticipata\n        }\n    }\n    return -1;  // Non trovato\n}\n```\n\n## Best Practice\n\n1. **Usa sempre le parentesi graffe** - Anche per blocchi a singola istruzione (imposto dalla sintassi)\n2. **Condizioni esplicite** - Usa `x == 0` invece di `!x` per chiarezza\n3. **Evita l'annidamento profondo** - Estrai condizioni annidate in funzioni\n4. **Usa return anticipati** - Riduci l'annidamento con clausole di guardia\n5. **Spezza condizioni complesse** - Dividi in variabili booleane con nome\n6. **Default nello switch** - Includi sempre un caso default\n7. **Commenta il fall-through** - Rendi esplicito il fall-through intenzionale\n\n## Insidie Comuni\n\n### Insidia: Assegnazione nella Condizione\n\n```hemlock\n// Questo NON e permesso (niente assegnazione nelle condizioni)\nif (x = 10) { }  // ERRORE: Errore di sintassi\n\n// Usa il confronto invece\nif (x == 10) { }  // OK\n```\n\n### Insidia: Break Mancante nello Switch\n\n```hemlock\n// Fall-through non intenzionale\nswitch (x) {\n    case 1:\n        print(\"uno\");\n        // Break mancante - cade nel successivo!\n    case 2:\n        print(\"due\");  // Eseguito sia per 1 che per 2\n        break;\n}\n\n// Corretto: Aggiungi break\nswitch (x) {\n    case 1:\n        print(\"uno\");\n        break;  // Ora corretto\n    case 2:\n        print(\"due\");\n        break;\n}\n```\n\n### Insidia: Scope della Variabile del Ciclo\n\n```hemlock\n// i ha scope nel ciclo\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // ERRORE: i non definito qui\n```\n\n## Esempi\n\n### Esempio: FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### Esempio: Controllo Numero Primo\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### Esempio: Sistema di Menu\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Avvia\");\n        print(\"2. Impostazioni\");\n        print(\"3. Esci\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Arrivederci!\");\n                return;\n            default:\n                print(\"Scelta non valida\");\n                break;\n        }\n    }\n}\n```\n\n## Argomenti Correlati\n\n- [Funzioni](#language-guide-functions) - Flusso di controllo con chiamate a funzione e return\n- [Gestione degli Errori](#language-guide-error-handling) - Flusso di controllo con eccezioni\n- [Tipi](#language-guide-types) - Conversioni di tipo nelle condizioni\n\n## Vedi Anche\n\n- **Sintassi**: Vedi [Sintassi](#language-guide-syntax) per dettagli sulla sintassi delle istruzioni\n- **Operatori**: Vedi [Tipi](#language-guide-types) per la promozione di tipo nelle operazioni\n"}, "Guida al Linguaggio -> Funzioni": {"id": "language-guide-functions", "content": "# Funzioni\n\nLe funzioni in Hemlock sono **valori di prima classe** che possono essere assegnate a variabili, passate come argomenti e restituite da altre funzioni. Questa guida copre la sintassi delle funzioni, le closure, la ricorsione e i pattern avanzati.\n\n## Panoramica\n\n```hemlock\n// Sintassi funzione con nome\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Funzione anonima\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Closure\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## Dichiarazione di funzione\n\n### Funzioni con nome\n\n```hemlock\nfn greet(name: string): string {\n    return \"Ciao, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Ciao, Alice\"\n```\n\n**Componenti:**\n- `fn` - Parola chiave funzione\n- `greet` - Nome della funzione\n- `(name: string)` - Parametri con tipi opzionali\n- `: string` - Tipo di ritorno opzionale\n- `{ ... }` - Corpo della funzione\n\n### Funzioni anonime\n\nFunzioni senza nome, assegnate a variabili:\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**Con nome vs. Anonima:**\n```hemlock\n// Queste due sono equivalenti:\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**Nota:** Le funzioni con nome si trasformano in assegnazioni di variabili con funzioni anonime.\n\n## Parametri\n\n### Parametri di base\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### Annotazioni di tipo\n\nAnnotazioni di tipo opzionali sui parametri:\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // La verifica dei tipi a runtime promuove a f64\n```\n\n**Verifica dei tipi:**\n- I tipi dei parametri vengono verificati alla chiamata se annotati\n- Le conversioni di tipo implicite seguono le regole di promozione standard\n- Le incompatibilita di tipo causano errori a runtime\n\n### Passaggio per valore\n\nTutti gli argomenti vengono **copiati** (passaggio per valore):\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Modifica solo la copia locale\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Ancora 10 (invariato)\n```\n\n**Nota:** Gli oggetti e gli array vengono passati per riferimento (il riferimento viene copiato), quindi il loro contenuto puo essere modificato:\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Modifica l'array originale\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (modificato)\n```\n\n## Valori di ritorno\n\n### Istruzione return\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### Annotazioni del tipo di ritorno\n\nAnnotazione di tipo opzionale per il valore di ritorno:\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**Verifica dei tipi:**\n- I tipi di ritorno vengono verificati quando la funzione ritorna (se annotati)\n- Le conversioni di tipo seguono le regole di promozione standard\n\n### Ritorno implicito\n\nLe funzioni senza annotazione del tipo di ritorno restituiscono implicitamente `null`:\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Restituisce implicitamente null\n}\n\nlet result = print_message(\"ciao\");  // result e null\n```\n\n### Ritorno anticipato\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Uscita anticipata\n        }\n    }\n    return -1;  // Non trovato\n}\n```\n\n### Ritorno senza valore\n\n`return;` senza valore restituisce `null`:\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Restituisce null\n    }\n    return value * 2;\n}\n```\n\n## Funzioni di prima classe\n\nLe funzioni possono essere assegnate, passate e restituite come qualsiasi altro valore.\n\n### Funzioni come variabili\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Riassegnare\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### Funzioni come argomenti\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### Funzioni come valori di ritorno\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## Closure\n\nLe funzioni catturano il loro ambiente di definizione (scope lessicale).\n\n### Closure di base\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**Come funziona:**\n- La funzione interna cattura `count` dallo scope esterno\n- `count` persiste attraverso le chiamate alla funzione restituita\n- Ogni chiamata a `makeCounter()` crea una nuova closure con il proprio `count`\n\n### Closure con parametri\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### Closure multiple\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### Scope lessicale\n\nLe funzioni possono accedere alle variabili dello scope esterno tramite lo scope lessicale:\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Puo leggere global e outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\nLe closure catturano le variabili per riferimento, permettendo la lettura e la modifica delle variabili dello scope esterno (come mostrato nell'esempio `makeCounter` sopra).\n\n## Ricorsione\n\nLe funzioni possono chiamare se stesse.\n\n### Ricorsione di base\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Ricorsione mutua\n\nLe funzioni possono chiamarsi a vicenda:\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### Elaborazione dati ricorsiva\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**Nota:** Nessuna ottimizzazione della ricorsione in coda ancora - la ricorsione profonda puo causare overflow dello stack.\n\n## Funzioni di ordine superiore\n\nFunzioni che prendono o restituiscono altre funzioni.\n\n### Pattern Map\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Pattern Filter\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Pattern Reduce\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### Composizione di funzioni\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## Pattern comuni\n\n### Pattern: Funzioni factory\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Ciao, sono \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Ciao, sono Alice\"\n```\n\n### Pattern: Funzioni callback\n\n```hemlock\nfn process_async(data, callback) {\n    // ... fare l'elaborazione\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Elaborazione completata: \" + result);\n});\n```\n\n### Pattern: Applicazione parziale\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### Pattern: Memoizzazione\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Molto piu veloce con la cache\n```\n\n## Semantica delle funzioni\n\n### Requisiti del tipo di ritorno\n\nLe funzioni con annotazione del tipo di ritorno **devono** restituire un valore:\n\n```hemlock\nfn get_value(): i32 {\n    // ERRORE: Istruzione return mancante\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### Verifica dei tipi\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Promuove a f64, restituisce f64\nadd(\"a\", \"b\");     // Errore runtime: tipo non corrispondente\n```\n\n### Regole di scope\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Puo accedere: inner_var, outer_var, global\n    }\n\n    // Puo accedere: outer_var, global\n    // Non puo accedere: inner_var\n}\n\n// Puo accedere: global\n// Non puo accedere: outer_var, inner_var\n```\n\n## Buone pratiche\n\n1. **Usa annotazioni di tipo** - Aiuta a catturare errori e documenta l'intenzione\n2. **Mantieni le funzioni piccole** - Ogni funzione dovrebbe fare una sola cosa\n3. **Preferisci le funzioni pure** - Evita gli effetti collaterali quando possibile\n4. **Nomina le funzioni chiaramente** - Usa nomi di verbi descrittivi\n5. **Ritorna presto** - Usa clausole di guardia per ridurre l'annidamento\n6. **Documenta le closure complesse** - Rendi esplicite le variabili catturate\n7. **Evita la ricorsione profonda** - Nessuna ottimizzazione della ricorsione in coda ancora\n\n## Trabocchetti comuni\n\n### Trabocchetto: Profondita della ricorsione\n\n```hemlock\n// La ricorsione profonda puo causare overflow dello stack\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // Potrebbe crashare con overflow dello stack\n```\n\n### Trabocchetto: Modifica delle variabili catturate\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Puo leggere e modificare le variabili catturate\n        return count;\n    };\n}\n```\n\n**Nota:** Questo funziona, ma sii consapevole che tutte le closure condividono lo stesso ambiente catturato.\n\n## Esempi\n\n### Esempio: Pipeline di funzioni\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### Esempio: Gestore di eventi\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clic: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### Esempio: Ordinamento con comparatore personalizzato\n\n```hemlock\nfn sort(arr, compare) {\n    // Bubble sort con comparatore personalizzato\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Parametri opzionali (argomenti predefiniti)\n\nLe funzioni possono avere parametri opzionali con valori predefiniti usando la sintassi `?:`:\n\n```hemlock\nfn greet(name, greeting?: \"Ciao\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Ciao Alice\"\nprint(greet(\"Bob\", \"Salve\"));    // \"Salve Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**Regole:**\n- I parametri opzionali devono venire dopo i parametri richiesti\n- I valori predefiniti possono essere qualsiasi espressione\n- Gli argomenti omessi usano il valore predefinito\n\n## Funzioni variadiche (parametri rest)\n\nLe funzioni possono accettare un numero variabile di argomenti usando i parametri rest (`...`):\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Avvio\", \"Esecuzione\", \"Terminato\");\n// INFO: Avvio\n// INFO: Esecuzione\n// INFO: Terminato\n```\n\n**Regole:**\n- Il parametro rest deve essere l'ultimo parametro\n- Il parametro rest raccoglie tutti gli argomenti rimanenti in un array\n- Puo essere combinato con parametri regolari e opzionali\n\n## Annotazioni di tipo funzione\n\nI tipi funzione permettono di specificare la firma esatta attesa per i parametri di funzione e i valori di ritorno:\n\n### Tipi funzione di base\n\n```hemlock\n// Sintassi tipo funzione: fn(param_types): return_type\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### Tipi funzione di ordine superiore\n\n```hemlock\n// Funzione che restituisce una funzione\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### Tipi funzione asincrona\n\n```hemlock\n// Tipo funzione asincrona\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Esecuzione asincrona!\");\n});\n```\n\n### Alias di tipo funzione\n\n```hemlock\n// Crea tipi funzione con nome per chiarezza\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Parametri const\n\nIl modificatore `const` impedisce che un parametro venga modificato nella funzione:\n\n### Parametri const di base\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // ERRORE: impossibile modificare parametro const\n    for (item in items) {\n        print(item);   // OK: la lettura e consentita\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### Immutabilita profonda\n\nI parametri const impongono immutabilita profonda - nessuna modifica attraverso alcun percorso:\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK: la lettura e consentita\n    // person.name = \"Bob\";   // ERRORE: impossibile modificare\n    // person.address.city = \"Roma\";  // ERRORE: const profondo\n}\n```\n\n### Cosa impedisce const\n\n| Tipo | Bloccato da const | Consentito |\n|------|-------------------|------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |\n| object | assegnazione campo | lettura campo |\n| buffer | assegnazione indice | lettura indice |\n| string | assegnazione indice | tutti i metodi (restituiscono nuove stringhe) |\n\n## Argomenti con nome\n\nLe funzioni possono essere chiamate con argomenti con nome per maggiore chiarezza e flessibilita:\n\n### Argomenti con nome di base\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" ha \" + age + \" anni\");\n}\n\n// Argomenti posizionali (tradizionale)\ncreate_user(\"Alice\", 25, false);\n\n// Argomenti con nome - possono essere in qualsiasi ordine\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### Mescolare posizionale e con nome\n\n```hemlock\n// Salta i parametri opzionali nominando cio di cui hai bisogno\ncreate_user(\"David\", active: false);  // Usa age predefinito=18\n\n// Gli argomenti con nome devono venire dopo i posizionali\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // ERRORE: posizionale dopo nominato\n```\n\n### Regole per gli argomenti con nome\n\n- Usa la sintassi `nome: valore` per gli argomenti con nome\n- Gli argomenti con nome possono apparire in qualsiasi ordine dopo gli argomenti posizionali\n- Gli argomenti posizionali non possono seguire gli argomenti con nome\n- Funziona con i parametri predefiniti/opzionali\n- I nomi di parametro sconosciuti causano errori a runtime\n\n## Limitazioni\n\nLimitazioni attuali da conoscere:\n\n- **Nessun passaggio per riferimento** - Parola chiave `ref` analizzata ma non implementata\n- **Nessun overloading di funzione** - Una funzione per nome\n- **Nessuna ottimizzazione della ricorsione in coda** - Ricorsione profonda limitata dalla dimensione dello stack\n\n## Argomenti correlati\n\n- [Flusso di controllo](#language-guide-control-flow) - Uso delle funzioni con le strutture di controllo\n- [Oggetti](#language-guide-objects) - I metodi sono funzioni memorizzate negli oggetti\n- [Gestione degli errori](#language-guide-error-handling) - Funzioni e gestione delle eccezioni\n- [Tipi](#language-guide-types) - Annotazioni di tipo e conversioni\n\n## Vedi anche\n\n- **Closure**: Vedi la sezione \"Functions\" di CLAUDE.md per la semantica delle closure\n- **Valori di prima classe**: Le funzioni sono valori come qualsiasi altro\n- **Scope lessicale**: Le funzioni catturano il loro ambiente di definizione\n"}, "Guida al Linguaggio -> Gestione degli Errori": {"id": "language-guide-error-handling", "content": "# Gestione degli Errori\n\nHemlock supporta la gestione degli errori basata su eccezioni con `try`, `catch`, `finally`, `throw` e `panic`. Questa guida copre gli errori recuperabili con le eccezioni e gli errori non recuperabili con panic.\n\n## Panoramica\n\n```hemlock\n// Gestione base degli errori\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Errore: \" + e);\n}\n\n// Con pulizia\ntry {\n    process_file();\n} catch (e) {\n    print(\"Fallito: \" + e);\n} finally {\n    cleanup();\n}\n\n// Lanciare errori\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"divisione per zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### Sintassi\n\n**Try/catch base:**\n```hemlock\ntry {\n    // codice rischioso\n} catch (e) {\n    // gestisci l'errore, e contiene il valore lanciato\n}\n```\n\n**Try/finally:**\n```hemlock\ntry {\n    // codice rischioso\n} finally {\n    // viene sempre eseguito, anche se viene lanciata un'eccezione\n}\n```\n\n**Try/catch/finally:**\n```hemlock\ntry {\n    // codice rischioso\n} catch (e) {\n    // gestisci l'errore\n} finally {\n    // codice di pulizia\n}\n```\n\n### Blocco Try\n\nIl blocco try esegue le istruzioni in sequenza:\n\n```hemlock\ntry {\n    print(\"Avvio...\");\n    risky_operation();\n    print(\"Successo!\");  // Solo se nessuna eccezione\n}\n```\n\n**Comportamento:**\n- Esegue le istruzioni in ordine\n- Se viene lanciata un'eccezione: salta a `catch` o `finally`\n- Se nessuna eccezione: esegue `finally` (se presente) poi continua\n\n### Blocco Catch\n\nIl blocco catch riceve il valore lanciato:\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Catturato: \" + error);  // error = \"oops\"\n    // error accessibile solo qui\n}\n// error non accessibile qui\n```\n\n**Parametro catch:**\n- Riceve il valore lanciato (qualsiasi tipo)\n- Ha scope nel blocco catch\n- Puo essere chiamato come vuoi (convenzionalmente `e`, `err` o `error`)\n\n**Cosa puoi fare nel catch:**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // Registra l'errore\n    print(\"Errore: \" + e);\n\n    // Rilancia lo stesso errore\n    throw e;\n\n    // Lancia un errore diverso\n    throw \"errore diverso\";\n\n    // Restituisci un valore di default\n    return null;\n\n    // Gestisci e continua\n    // (nessun rilancio)\n}\n```\n\n### Blocco Finally\n\nIl blocco finally **viene sempre eseguito**:\n\n```hemlock\ntry {\n    print(\"1: blocco try\");\n    throw \"errore\";\n} catch (e) {\n    print(\"2: blocco catch\");\n} finally {\n    print(\"3: blocco finally\");  // Eseguito sempre\n}\nprint(\"4: dopo try/catch/finally\");\n\n// Output: 1: blocco try, 2: blocco catch, 3: blocco finally, 4: dopo try/catch/finally\n```\n\n**Quando finally viene eseguito:**\n- Dopo il blocco try (se nessuna eccezione)\n- Dopo il blocco catch (se l'eccezione e stata catturata)\n- Anche se try/catch contiene `return`, `break` o `continue`\n- Prima che il flusso di controllo esca dal try/catch\n\n**Finally con return:**\n```hemlock\nfn example() {\n    try {\n        return 1;  // Restituisce 1 dopo l'esecuzione di finally\n    } finally {\n        print(\"pulizia\");  // Eseguito prima del return\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // Il return di finally sovrascrive - restituisce 2\n    }\n}\n```\n\n**Finally con flusso di controllo:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // Interrompe dopo l'esecuzione di finally\n        }\n    } finally {\n        print(\"pulizia \" + typeof(i));\n    }\n}\n```\n\n## Istruzione Throw\n\n### Throw Base\n\nLancia qualsiasi valore come eccezione:\n\n```hemlock\nthrow \"messaggio di errore\";\nthrow 404;\nthrow { code: 500, message: \"Errore interno\" };\nthrow null;\nthrow [\"errore\", \"dettagli\"];\n```\n\n**Esecuzione:**\n1. Valuta l'espressione\n2. Salta immediatamente al `catch` piu vicino\n3. Se non c'e `catch`, si propaga sullo stack delle chiamate\n\n### Lanciare Errori\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"L'eta non puo essere negativa\";\n    }\n    if (age > 150) {\n        throw \"L'eta non e realistica\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Errore di validazione: \" + e);\n}\n```\n\n### Lanciare Oggetti Errore\n\nCrea informazioni di errore strutturate:\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"Il file non esiste\"\n        };\n    }\n    // ... leggi il file\n}\n\ntry {\n    read_file(\"mancante.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File non trovato: \" + e.path);\n    }\n}\n```\n\n### Rilanciare\n\nCattura e rilancia errori:\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Registro errore: \" + e);\n        throw e;  // Rilancia al chiamante\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Catturato nel main: \" + e);\n}\n```\n\n## Eccezioni Non Catturate\n\nSe un'eccezione si propaga fino alla cima dello stack delle chiamate senza essere catturata:\n\n```hemlock\nfn foo() {\n    throw \"non catturata!\";\n}\n\nfoo();  // Crash con: Runtime error: non catturata!\n```\n\n**Comportamento:**\n- Il programma crasha\n- Stampa messaggio di errore su stderr\n- Esce con codice di stato non-zero\n- Stack trace da aggiungere nelle versioni future\n\n## Panic - Errori Non Recuperabili\n\n### Cos'e Panic?\n\n`panic()` e per **errori non recuperabili** che dovrebbero terminare immediatamente il programma:\n\n```hemlock\npanic();                    // Messaggio default: \"panic!\"\npanic(\"messaggio custom\");  // Messaggio personalizzato\npanic(42);                  // Valori non-stringa vengono stampati\n```\n\n**Semantica:**\n- **Esce immediatamente** dal programma con codice di uscita 1\n- Stampa messaggio di errore su stderr: `panic: <messaggio>`\n- **NON catturabile** con try/catch\n- Usa per bug ed errori non recuperabili\n\n### Panic vs Throw\n\n```hemlock\n// throw - Errore recuperabile (puo essere catturato)\ntry {\n    throw \"errore recuperabile\";\n} catch (e) {\n    print(\"Catturato: \" + e);  // Catturato con successo\n}\n\n// panic - Errore non recuperabile (non puo essere catturato)\ntry {\n    panic(\"errore non recuperabile\");  // Il programma esce immediatamente\n} catch (e) {\n    print(\"Questo non viene mai eseguito\");  // Mai eseguito\n}\n```\n\n### Quando Usare Panic\n\n**Usa panic per:**\n- **Bug**: Codice non raggiungibile e stato raggiunto\n- **Stato non valido**: Rilevata corruzione della struttura dati\n- **Errori non recuperabili**: Risorsa critica non disponibile\n- **Fallimenti di asserzione**: Quando `assert()` non e sufficiente\n\n**Esempi:**\n```hemlock\n// Codice non raggiungibile\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"pronto\";\n    } else if (state == 2) {\n        return \"in esecuzione\";\n    } else if (state == 3) {\n        return \"fermato\";\n    } else {\n        panic(\"stato non valido: \" + typeof(state));  // Non dovrebbe mai succedere\n    }\n}\n\n// Controllo risorsa critica\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json non trovato - impossibile avviare\");\n    }\n    // ...\n}\n\n// Invariante della struttura dati\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() chiamato su stack vuoto\");\n    }\n    return stack.pop();\n}\n```\n\n### Quando NON Usare Panic\n\n**Usa throw invece per:**\n- Validazione input utente\n- File non trovato\n- Errori di rete\n- Condizioni di errore attese\n\n```hemlock\n// MALE: Panic per errori attesi\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"divisione per zero\");  // Troppo drastico\n    }\n    return a / b;\n}\n\n// BENE: Throw per errori attesi\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"divisione per zero\";  // Recuperabile\n    }\n    return a / b;\n}\n```\n\n## Interazioni con il Flusso di Controllo\n\n### Return Dentro Try/Catch/Finally\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // Restituisce 1 dopo l'esecuzione di finally\n    } finally {\n        print(\"pulizia\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // Il return di finally sovrascrive il return di try - restituisce 2\n    }\n}\n```\n\n**Regola:** I valori di return del blocco finally sovrascrivono i valori di return di try/catch.\n\n### Break/Continue Dentro Try/Catch/Finally\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // Interrompe dopo l'esecuzione di finally\n    } finally {\n        print(\"pulizia \" + typeof(i));\n    }\n}\n```\n\n**Regola:** Break/continue vengono eseguiti dopo il blocco finally.\n\n### Try/Catch Annidati\n\n```hemlock\ntry {\n    try {\n        throw \"interno\";\n    } catch (e) {\n        print(\"Catturato: \" + e);  // Stampa: Catturato: interno\n        throw \"esterno\";  // Rilancia errore diverso\n    }\n} catch (e) {\n    print(\"Catturato: \" + e);  // Stampa: Catturato: esterno\n}\n```\n\n**Regola:** I blocchi try/catch annidati funzionano come previsto, i catch interni vengono eseguiti prima.\n\n## Pattern Comuni\n\n### Pattern: Pulizia Risorse\n\nUsa sempre `finally` per la pulizia:\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Errore nell'elaborazione del file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Chiude sempre, anche in caso di errore\n        }\n    }\n}\n```\n\n### Pattern: Wrapping degli Errori\n\nAvvolgi errori di livello inferiore con contesto:\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Impossibile caricare config da \" + path + \": \" + e;\n    }\n}\n```\n\n### Pattern: Recupero dagli Errori\n\nFornisci un fallback in caso di errore:\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"divisione per zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Errore: \" + e);\n        return null;  // Valore di fallback\n    }\n}\n```\n\n### Pattern: Validazione\n\nUsa le eccezioni per la validazione:\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Nome obbligatorio\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Eta non valida\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Email non valida\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"non_valida\" });\n} catch (e) {\n    print(\"Validazione fallita: \" + e);\n}\n```\n\n### Pattern: Tipi di Errore Multipli\n\nUsa oggetti errore per distinguere i tipi di errore:\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"I dati sono null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Atteso array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"L'array e vuoto\" };\n    }\n\n    // ... elabora\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"Nessun dato fornito\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Tipo di dato errato: \" + e.message);\n    } else {\n        print(\"Errore: \" + e.message);\n    }\n}\n```\n\n## Best Practice\n\n1. **Usa le eccezioni per casi eccezionali** - Non per il flusso di controllo normale\n2. **Lancia errori significativi** - Usa stringhe o oggetti con contesto\n3. **Usa sempre finally per la pulizia** - Assicura che le risorse vengano liberate\n4. **Non catturare e ignorare** - Almeno registra l'errore\n5. **Rilancia quando appropriato** - Lascia gestire al chiamante se non puoi\n6. **Panic per i bug** - Usa panic per errori non recuperabili\n7. **Documenta le eccezioni** - Rendi chiaro cosa possono lanciare le funzioni\n\n## Insidie Comuni\n\n### Insidia: Ingoiare gli Errori\n\n```hemlock\n// MALE: Fallimento silenzioso\ntry {\n    risky_operation();\n} catch (e) {\n    // Errore ignorato - fallimento silenzioso\n}\n\n// BENE: Registra o gestisci\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operazione fallita: \" + e);\n    // Gestisci appropriatamente\n}\n```\n\n### Insidia: Override di Finally\n\n```hemlock\n// MALE: Finally sovrascrive il return\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // Restituisce 0, non 42!\n    }\n}\n\n// BENE: Non fare return nel finally\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Solo pulizia, nessun return\n    }\n}\n```\n\n### Insidia: Dimenticare la Pulizia\n\n```hemlock\n// MALE: Il file potrebbe non essere chiuso in caso di errore\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // Potrebbe lanciare\n    file.close();  // Mai raggiunto se c'e errore\n}\n\n// BENE: Usa finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### Insidia: Usare Panic per Errori Attesi\n\n```hemlock\n// MALE: Panic per errore atteso\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"File di config non trovato\");  // Troppo drastico\n    }\n    return read_file(path);\n}\n\n// BENE: Throw per errore atteso\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"File di config non trovato: \" + path;  // Recuperabile\n    }\n    return read_file(path);\n}\n```\n\n## Esempi\n\n### Esempio: Gestione Errori Base\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"divisione per zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Errore: \" + e);  // Stampa: Errore: divisione per zero\n}\n```\n\n### Esempio: Gestione Risorse\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copiato con successo\");\n    } catch (e) {\n        print(\"Impossibile copiare il file: \" + e);\n        throw e;  // Rilancia\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### Esempio: Gestione Errori Annidata\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Impossibile elaborare utente: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Elaborati: \" + typeof(success_count) + \" successi, \" + typeof(error_count) + \" errori\");\n}\n```\n\n### Esempio: Tipi di Errore Personalizzati\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a deve essere un numero\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b deve essere un numero\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Impossibile dividere per zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Dettagli: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### Esempio: Logica di Retry\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // Successo!\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operazione fallita dopo \" + typeof(max_attempts) + \" tentativi: \" + e;\n            }\n            print(\"Tentativo \" + typeof(attempt) + \" fallito, riprovo...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // Operazione inaffidabile simulata\n    if (random() < 0.7) {\n        throw \"Operazione fallita\";\n    }\n    return \"Successo\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"Tutti i tentativi falliti: \" + e);\n}\n```\n\n## Ordine di Esecuzione\n\nComprendere l'ordine di esecuzione:\n\n```hemlock\ntry {\n    print(\"1: inizio blocco try\");\n    throw \"errore\";\n    print(\"2: mai raggiunto\");\n} catch (e) {\n    print(\"3: blocco catch\");\n} finally {\n    print(\"4: blocco finally\");\n}\nprint(\"5: dopo try/catch/finally\");\n\n// Output:\n// 1: inizio blocco try\n// 3: blocco catch\n// 4: blocco finally\n// 5: dopo try/catch/finally\n```\n\n## Limitazioni Attuali\n\n- **Nessuno stack trace** - Le eccezioni non catturate non mostrano lo stack trace (pianificato)\n- **Alcune funzioni built-in chiamano exit** - Alcune funzioni built-in ancora chiamano `exit()` invece di lanciare (da rivedere)\n- **Nessun tipo di eccezione personalizzato** - Qualsiasi valore puo essere lanciato, ma non c'e una gerarchia formale di eccezioni\n\n## Argomenti Correlati\n\n- [Funzioni](#language-guide-functions) - Eccezioni e return delle funzioni\n- [Flusso di Controllo](#language-guide-control-flow) - Come le eccezioni influenzano il flusso di controllo\n- [Memoria](#language-guide-memory) - Usare finally per la pulizia della memoria\n\n## Vedi Anche\n\n- **Semantica delle Eccezioni**: Vedi la sezione \"Error Handling\" in CLAUDE.md\n- **Panic vs Throw**: Casi d'uso diversi per tipi di errore diversi\n- **Garanzia di Finally**: Viene sempre eseguito, anche con return/break/continue\n"}, "Guida al Linguaggio -> Gestione della Memoria": {"id": "language-guide-memory", "content": "# Gestione della Memoria\n\nHemlock abbraccia la **gestione manuale della memoria** con controllo esplicito sull'allocazione e deallocazione. Questa guida copre il modello di memoria di Hemlock, i due tipi di puntatore e l'API completa per la memoria.\n\n---\n\n## Memoria 101: Le Basi\n\n**Nuovo alla programmazione?** Inizia da qui. Se conosci gia la gestione della memoria, vai a [Filosofia](#filosofia).\n\n### Cos'e la Gestione della Memoria?\n\nQuando il tuo programma deve memorizzare dati (testo, numeri, liste), ha bisogno di spazio dove metterli. Quello spazio viene dalla memoria del tuo computer (RAM). La gestione della memoria riguarda:\n\n1. **Ottenere spazio** - chiedere memoria quando ne hai bisogno\n2. **Usare lo spazio** - leggere e scrivere i tuoi dati\n3. **Restituirlo** - restituire la memoria quando hai finito\n\n### Perche e Importante?\n\nImmagina una biblioteca con libri limitati:\n- Se continui a prendere in prestito libri e non li restituisci mai, alla fine non ce ne sono piu\n- Se provi a leggere un libro che hai gia restituito, ti confondi o causi problemi\n\nLa memoria funziona allo stesso modo. Se dimentichi di restituire la memoria, il tuo programma usa lentamente sempre di piu (un \"memory leak\"). Se provi a usare la memoria dopo averla restituita, succedono cose brutte.\n\n### La Buona Notizia\n\n**La maggior parte delle volte, non devi pensarci!**\n\nHemlock pulisce automaticamente i tipi piu comuni:\n\n```hemlock\nfn example() {\n    let name = \"Alice\";       // Hemlock gestisce questo\n    let numbers = [1, 2, 3];  // E questo\n    let person = { age: 30 }; // E anche questo\n\n    // Quando la funzione termina, tutto questo viene pulito automaticamente!\n}\n```\n\n### Quando DEVI Pensarci\n\nHai bisogno della gestione manuale della memoria solo quando usi:\n\n1. **`alloc()`** - allocazione di memoria grezza (restituisce `ptr`)\n2. **`buffer()`** - quando vuoi liberare in anticipo (opzionale - si libera automaticamente alla fine dello scope)\n\n```hemlock\n// Questo richiede pulizia manuale:\nlet raw = alloc(100);   // Memoria grezza - TU devi liberarla\n// ... usa raw ...\nfree(raw);              // Obbligatorio! Altrimenti hai un memory leak\n\n// Questo si pulisce automaticamente (ma PUOI liberare in anticipo):\nlet buf = buffer(100);  // Buffer sicuro\n// ... usa buf ...\n// free(buf);           // Opzionale - si libera automaticamente quando lo scope termina\n```\n\n### La Regola Semplice\n\n> **Se chiami `alloc()`, devi chiamare `free()`.**\n>\n> Tutto il resto e gestito per te.\n\n### Quale Dovresti Usare?\n\n| Situazione | Usa Questo | Perche |\n|-----------|----------|-----|\n| **Appena iniziato** | `buffer()` | Sicuro, con controllo dei limiti, pulizia automatica |\n| **Serve memorizzazione di byte** | `buffer()` | Sicuro e facile |\n| **Lavori con librerie C (FFI)** | `alloc()` / `ptr` | Richiesto per l'interoperabilita C |\n| **Massime prestazioni** | `alloc()` / `ptr` | Nessun overhead per il controllo dei limiti |\n| **Non sei sicuro** | `buffer()` | Sempre la scelta piu sicura |\n\n### Esempio Rapido: Sicuro vs Grezzo\n\n```hemlock\n// CONSIGLIATO: Buffer sicuro\nfn safe_example() {\n    let data = buffer(10);\n    data[0] = 65;           // OK\n    data[5] = 66;           // OK\n    // data[100] = 67;      // ERRORE - Hemlock ti ferma (controllo limiti)\n    free(data);             // Pulizia\n}\n\n// AVANZATO: Puntatore grezzo (solo quando serve)\nfn raw_example() {\n    let data = alloc(10);\n    *data = 65;             // OK\n    *(data + 5) = 66;       // OK\n    *(data + 100) = 67;     // PERICOLO - Nessun controllo limiti, corrompe la memoria!\n    free(data);             // Pulizia\n}\n```\n\n**Inizia con `buffer()`. Usa `alloc()` solo quando hai specificamente bisogno di puntatori grezzi.**\n\n---\n\n## Filosofia\n\nHemlock segue il principio della gestione esplicita della memoria con default sensati:\n- Nessun garbage collection (nessuna pausa imprevedibile)\n- Reference counting interno per i tipi comuni (string, array, object, buffer)\n- I puntatori grezzi (`ptr`) richiedono `free()` manuale\n\nQuesto approccio ibrido ti da il controllo completo quando necessario (puntatori grezzi) mentre previene bug comuni per i casi d'uso tipici (tipi con reference count liberati automaticamente all'uscita dallo scope).\n\n## Reference Counting Interno\n\nIl runtime usa il **reference counting interno** per gestire la durata degli oggetti. Per la maggior parte delle variabili locali di tipi con reference count, la pulizia e automatica e deterministica.\n\n### Cosa Gestisce il Reference Counting\n\nIl runtime gestisce automaticamente i conteggi dei riferimenti quando:\n\n1. **Le variabili vengono riassegnate** - il vecchio valore viene rilasciato:\n   ```hemlock\n   let x = \"primo\";   // ref_count = 1\n   x = \"secondo\";     // \"primo\" rilasciato internamente, \"secondo\" ref_count = 1\n   ```\n\n2. **Gli scope terminano** - le variabili locali vengono rilasciate:\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // arr rilasciato quando la funzione ritorna\n   ```\n\n3. **I container vengono liberati** - gli elementi vengono rilasciati:\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // obj1 e obj2 ottengono i loro ref_count decrementati\n   ```\n\n### Quando Serve `free()` vs Quando e Automatico\n\n**Automatico (nessun `free()` necessario):** Le variabili locali di tipi con reference count vengono liberate quando lo scope termina:\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... usali ...\n}  // Tutto liberato automaticamente quando la funzione ritorna - nessun free() necessario\n```\n\n**`free()` manuale richiesto:**\n\n1. **Puntatori grezzi** - `alloc()` non ha reference counting:\n   ```hemlock\n   let p = alloc(64);\n   // ... usa p ...\n   free(p);  // Sempre richiesto - altrimenti leak\n   ```\n\n2. **Pulizia anticipata** - libera prima della fine dello scope per rilasciare memoria prima:\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... finito con big ...\n       free(big);  // Libera ora, non aspettare che la funzione ritorni\n       // ... altro lavoro che non ha bisogno di big ...\n   }\n   ```\n\n3. **Dati a lunga vita** - globali o dati memorizzati in strutture persistenti:\n   ```hemlock\n   let cache = {};  // A livello di modulo, vive fino all'uscita del programma a meno che non venga liberato\n\n   fn cleanup() {\n       free(cache);  // Pulizia manuale per dati a lunga vita\n   }\n   ```\n\n### Reference Counting vs Garbage Collection\n\n| Aspetto | Reference Counting di Hemlock | Garbage Collection |\n|--------|---------------------|-------------------|\n| Tempistica pulizia | Deterministica (immediata quando ref arriva a 0) | Non deterministica (il GC decide quando) |\n| Responsabilita utente | Deve chiamare `free()` | Completamente automatico |\n| Pause del runtime | Nessuna | Pause \"stop the world\" |\n| Visibilita | Dettaglio implementativo nascosto | Di solito invisibile |\n| Cicli | Gestiti con tracciamento visited-set | Gestiti dal tracing |\n\n### Quali Tipi Hanno il Reference Counting\n\n| Tipo | Reference Counted | Note |\n|------|------------|-------|\n| `ptr` | No | Richiede sempre `free()` manuale |\n| `buffer` | Si | Liberato automaticamente all'uscita dallo scope; `free()` manuale per pulizia anticipata |\n| `array` | Si | Liberato automaticamente all'uscita dallo scope; `free()` manuale per pulizia anticipata |\n| `object` | Si | Liberato automaticamente all'uscita dallo scope; `free()` manuale per pulizia anticipata |\n| `string` | Si | Completamente automatico, nessun `free()` necessario |\n| `function` | Si | Completamente automatico (ambienti delle closure) |\n| `task` | Si | Reference counting atomico thread-safe |\n| `channel` | Si | Reference counting atomico thread-safe |\n| Primitivi | No | Allocati sullo stack, nessuna allocazione heap |\n\n### Perche Questo Design?\n\nQuesto approccio ibrido ti da:\n- **Controllo esplicito** - Tu decidi quando deallocare\n- **Sicurezza dai bug di scope** - La riassegnazione non causa leak\n- **Prestazioni prevedibili** - Nessuna pausa GC\n- **Supporto closure** - Le funzioni possono catturare variabili in sicurezza\n\nLa filosofia rimane: sei tu al controllo, ma il runtime aiuta a prevenire bug comuni come leak alla riassegnazione o double-free nei container.\n\n## I Due Tipi di Puntatore\n\nHemlock fornisce due tipi di puntatore distinti, ognuno con diverse caratteristiche di sicurezza:\n\n### `ptr` - Puntatore Grezzo (Pericoloso)\n\nI puntatori grezzi sono **solo indirizzi** con garanzie di sicurezza minime:\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Devi ricordarti di liberare\n```\n\n**Caratteristiche:**\n- Solo un indirizzo di 8 byte\n- Nessun controllo dei limiti\n- Nessun tracciamento della lunghezza\n- L'utente gestisce interamente la durata\n- Per esperti e FFI\n\n**Casi d'uso:**\n- Programmazione di sistema a basso livello\n- Foreign Function Interface (FFI)\n- Codice critico per le prestazioni\n- Quando hai bisogno di controllo completo\n\n**Pericoli:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Molto oltre il limite dell'allocazione - permesso ma pericoloso\nfree(p);\nlet x = *p;       // Puntatore dangling - comportamento indefinito\nfree(p);          // Double-free - crashera\n```\n\n### `buffer` - Wrapper Sicuro (Consigliato)\n\nI buffer forniscono **accesso con controllo dei limiti** richiedendo comunque deallocazione manuale:\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // controllo limiti\nprint(b.length);        // 64\nfree(b);                // sempre manuale\n```\n\n**Caratteristiche:**\n- Puntatore + lunghezza + capacita\n- Controllo dei limiti all'accesso\n- Richiede comunque `free()` manuale\n- Default migliore per la maggior parte del codice\n\n**Proprieta:**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (dimensione attuale)\nprint(buf.capacity);    // 100 (capacita allocata)\n```\n\n**Controllo dei limiti:**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // ERRORE: Indice fuori dai limiti\n```\n\n## API della Memoria\n\n### Allocazione Base\n\n**`alloc(bytes)` - Alloca memoria grezza**\n```hemlock\nlet p = alloc(1024);  // Alloca 1KB, restituisce ptr\n// ... usa la memoria\nfree(p);\n```\n\n**`buffer(size)` - Alloca buffer sicuro**\n```hemlock\nlet buf = buffer(256);  // Alloca buffer di 256 byte\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - Libera memoria**\n```hemlock\nlet p = alloc(100);\nfree(p);  // Devi liberare per evitare memory leak\n\nlet buf = buffer(100);\nfree(buf);  // Funziona sia con ptr che con buffer\n```\n\n**Importante:** `free()` funziona sia con tipi `ptr` che `buffer`.\n\n### Operazioni sulla Memoria\n\n**`memset(ptr, byte, size)` - Riempi memoria**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // Azzera 100 byte\nmemset(p, 65, 10);     // Riempi i primi 10 byte con 'A'\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - Copia memoria**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // Copia 50 byte da src a dst\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - Ridimensiona allocazione**\n```hemlock\nlet p = alloc(100);\n// ... usa 100 byte\np = realloc(p, 200);   // Ridimensiona a 200 byte\n// ... usa 200 byte\nfree(p);\n```\n\n**Nota:** Dopo `realloc()`, il vecchio puntatore potrebbe essere invalido. Usa sempre il puntatore restituito.\n\n### Allocazione Tipizzata\n\nHemlock fornisce helper di allocazione tipizzata per comodita:\n\n```hemlock\nlet arr = talloc(i32, 100);  // Alloca 100 valori i32 (400 byte)\nlet size = sizeof(i32);      // Restituisce 4 (byte)\n```\n\n**`sizeof(type)`** restituisce la dimensione in byte di un tipo:\n- `sizeof(i8)` / `sizeof(u8)` -> 1\n- `sizeof(i16)` / `sizeof(u16)` -> 2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8\n- `sizeof(ptr)` -> 8 (su sistemi a 64 bit)\n\n**`talloc(type, count)`** alloca `count` elementi di `type`:\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 byte per 10 valori i32\nlet floats = talloc(f64, 5);  // 40 byte per 5 valori f64\nfree(ints);\nfree(floats);\n```\n\n## Pattern Comuni\n\n### Pattern: Alloca, Usa, Libera\n\nIl pattern base per la gestione della memoria:\n\n```hemlock\n// 1. Alloca\nlet data = alloc(1024);\n\n// 2. Usa\nmemset(data, 0, 1024);\n// ... fai il lavoro\n\n// 3. Libera\nfree(data);\n```\n\n### Pattern: Uso Sicuro del Buffer\n\nPreferisci i buffer per accesso con controllo dei limiti:\n\n```hemlock\nlet buf = buffer(256);\n\n// Iterazione sicura\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### Pattern: Gestione Risorse con try/finally\n\nAssicura la pulizia anche in caso di errori:\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... operazioni rischiose\n    process(data);\n} finally {\n    free(data);  // Sempre liberato, anche in caso di errore\n}\n```\n\n## Considerazioni sulla Sicurezza della Memoria\n\n### Double-Free\n\n**Permesso ma crashera:**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: Double-free rilevato\n```\n\n**Prevenzione:**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Imposta a null dopo aver liberato\n\nif (p != null) {\n    free(p);  // Non verra eseguito\n}\n```\n\n### Puntatori Dangling\n\n**Permesso ma comportamento indefinito:**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // INDEFINITO: Lettura di memoria liberata\n```\n\n**Prevenzione:** Non accedere alla memoria dopo averla liberata.\n\n### Memory Leak\n\n**Facili da creare, difficili da debuggare:**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Dimenticato di liberare!\n    return;  // Memoria persa\n}\n```\n\n**Prevenzione:** Abbina sempre `alloc()` con `free()`:\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... usa p\n    } finally {\n        free(p);  // Sempre liberato\n    }\n}\n```\n\n### Aritmetica dei Puntatori\n\n**Permessa ma pericolosa:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Molto oltre il limite dell'allocazione\n*q = 42;          // INDEFINITO: Scrittura fuori dai limiti\nfree(p);\n```\n\n**Usa i buffer per il controllo dei limiti:**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // ERRORE: Il controllo dei limiti previene l'overflow\n```\n\n## Best Practice\n\n1. **Default a `buffer`** - Usa `buffer` a meno che tu non abbia specificamente bisogno di `ptr` grezzo\n2. **Abbina alloc/free** - Ogni `alloc()` dovrebbe avere esattamente un `free()`\n3. **Usa try/finally** - Assicura la pulizia con la gestione delle eccezioni\n4. **Null dopo free** - Imposta i puntatori a `null` dopo averli liberati per catturare use-after-free\n5. **Controllo dei limiti** - Usa l'indicizzazione dei buffer per il controllo automatico dei limiti\n6. **Documenta la proprieta** - Rendi chiaro quale codice possiede e libera ogni allocazione\n\n## Esempi\n\n### Esempio: Costruttore di Stringhe Dinamico\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // Il chiamante deve liberare\n}\n\nlet msg = build_message(5);\n// ... usa msg\nfree(msg);\n```\n\n### Esempio: Operazioni Sicure su Array\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Riempi l'array\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Elabora\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Pulizia sempre\n    }\n}\n```\n\n### Esempio: Pattern Memory Pool\n\n```hemlock\n// Memory pool semplice (semplificato)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool esaurito\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Usa il pool\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Libera l'intero pool in una volta\nfree(pool);\n```\n\n## Limitazioni\n\nLimitazioni attuali di cui essere consapevoli:\n\n- **I puntatori grezzi richiedono free manuale** - `alloc()` restituisce `ptr` senza reference counting\n- **Nessun allocatore personalizzato** - Solo malloc/free di sistema\n\n**Nota:** I tipi con reference count (string, array, object, buffer) SONO liberati automaticamente quando lo scope termina. Solo i `ptr` grezzi da `alloc()` richiedono `free()` esplicito.\n\n## Argomenti Correlati\n\n- [Stringhe](#language-guide-strings) - Gestione della memoria delle stringhe e codifica UTF-8\n- [Array](#language-guide-arrays) - Array dinamici e loro caratteristiche di memoria\n- [Oggetti](#language-guide-objects) - Allocazione e durata degli oggetti\n- [Gestione degli Errori](#language-guide-error-handling) - Usare try/finally per la pulizia\n\n## Vedi Anche\n\n- **Filosofia di Design**: Vedi la sezione \"Memory Management\" in CLAUDE.md\n- **Sistema di Tipi**: Vedi [Tipi](#language-guide-types) per i dettagli sui tipi `ptr` e `buffer`\n- **FFI**: I puntatori grezzi sono essenziali per la Foreign Function Interface\n"}, "Guida al Linguaggio -> Moduli": {"id": "language-guide-modules", "content": "# Sistema di Moduli di Hemlock\n\nQuesto documento descrive il sistema di moduli import/export in stile ES6 implementato per Hemlock.\n\n## Panoramica\n\nHemlock supporta un sistema di moduli basato su file con sintassi import/export in stile ES6. I moduli sono:\n- **Singleton**: Ogni modulo viene caricato una volta e memorizzato in cache\n- **Basati su file**: I moduli corrispondono a file .hml su disco\n- **Importati esplicitamente**: Le dipendenze sono dichiarate con istruzioni import\n- **Eseguiti topologicamente**: Le dipendenze vengono eseguite prima dei dipendenti\n\nPer la gestione dei pacchetti e le dipendenze di terze parti, vedi [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).\n\n## Sintassi\n\n### Istruzioni Export\n\n**Export con nome inline:**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**Lista di export:**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**Export Extern (Funzioni FFI):**\n```hemlock\nimport \"libc.so.6\";\n\n// Esporta funzioni FFI per l'uso in altri moduli\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\nVedi [Documentazione FFI](../advanced/ffi.md#exporting-ffi-functions) per maggiori dettagli sull'esportazione di funzioni FFI.\n\n**Export Define (Tipi Struct):**\n```hemlock\n// Esporta definizioni di tipi struct\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**Importante:** I tipi struct esportati vengono registrati globalmente quando il modulo viene caricato. Diventano disponibili automaticamente quando importi qualcosa dal modulo - NON devi (e non puoi) importarli esplicitamente per nome:\n\n```hemlock\n// BENE - i tipi struct sono auto-disponibili dopo qualsiasi import\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // Funziona!\n\n// MALE - non puoi importare esplicitamente i tipi struct\nimport { Vector2 } from \"./my_module.hml\";  // Errore: Variabile 'Vector2' non definita\n```\n\nVedi [Documentazione FFI](../advanced/ffi.md#exporting-struct-types) per maggiori dettagli sull'esportazione di tipi struct.\n\n**Re-export:**\n```hemlock\n// Re-esporta da un altro modulo\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Istruzioni Import\n\n**Import con nome:**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**Import namespace:**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**Aliasing:**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## Risoluzione dei Moduli\n\n### Tipi di Percorso\n\n**Percorsi relativi:**\n```hemlock\nimport { foo } from \"./module.hml\";       // Stessa directory\nimport { bar } from \"../parent.hml\";      // Directory padre\nimport { baz } from \"./sub/nested.hml\";   // Sottodirectory\n```\n\n**Percorsi assoluti:**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**Gestione dell'estensione:**\n- L'estensione `.hml` puo essere omessa - verra aggiunta automaticamente\n- `./math` viene risolto in `./math.hml`\n\n## Funzionalita\n\n### Rilevamento delle Dipendenze Circolari\n\nIl sistema di moduli rileva le dipendenze circolari e riporta un errore:\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### Cache dei Moduli\n\nI moduli vengono caricati una volta e memorizzati in cache. Import multipli dello stesso modulo restituiscono la stessa istanza:\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Stessa istanza!\nprint(count);  // Ancora 1 (stato condiviso)\n```\n\n### Immutabilita degli Import\n\nI binding importati non possono essere riassegnati:\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // ERRORE: impossibile riassegnare binding importato\n```\n\n## Dettagli Implementativi\n\n### Architettura\n\n**File:**\n- `include/module.h` - API del sistema di moduli\n- `src/module.c` - Caricamento, caching ed esecuzione dei moduli\n- Supporto parser in `src/parser.c`\n- Supporto runtime in `src/interpreter/runtime.c`\n\n**Componenti chiave:**\n1. **ModuleCache**: Mantiene i moduli caricati indicizzati per percorso assoluto\n2. **Module**: Rappresenta un modulo caricato con il suo AST e gli export\n3. **Risoluzione percorsi**: Risolve percorsi relativi/assoluti in percorsi canonici\n4. **Esecuzione topologica**: Esegue i moduli in ordine di dipendenza\n\n### Processo di Caricamento dei Moduli\n\n1. **Fase di parsing**: Tokenizza e analizza il file del modulo\n2. **Risoluzione delle dipendenze**: Carica ricorsivamente i moduli importati\n3. **Rilevamento cicli**: Controlla se il modulo e gia in fase di caricamento\n4. **Caching**: Memorizza il modulo in cache per percorso assoluto\n5. **Fase di esecuzione**: Esegue in ordine topologico (dipendenze prima)\n\n### API\n\n```c\n// API ad alto livello\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// API a basso livello\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## Testing\n\nI moduli di test si trovano in `tests/modules/` e `tests/parity/modules/`:\n\n- `math.hml` - Modulo base con export\n- `test_import_named.hml` - Test import con nome\n- `test_import_namespace.hml` - Test import namespace\n- `test_import_alias.hml` - Test aliasing degli import\n- `export_extern.hml` - Test export extern per funzioni FFI (Linux)\n\n## Import di Pacchetti (hpm)\n\nCon [hpm](https://github.com/hemlang/hpm) installato, puoi importare pacchetti di terze parti da GitHub:\n\n```hemlock\n// Import dalla root del pacchetto (usa \"main\" da package.json)\nimport { app, router } from \"hemlang/sprout\";\n\n// Import da sottopercorso\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Libreria standard (integrata in Hemlock)\nimport { HashMap } from \"@stdlib/collections\";\n```\n\nI pacchetti vengono installati in `hem_modules/` e risolti usando la sintassi GitHub `owner/repo`.\n\n```bash\n# Installa un pacchetto\nhpm install hemlang/sprout\n\n# Installa con vincolo di versione\nhpm install hemlang/sprout@^1.0.0\n```\n\nVedi la [documentazione hpm](https://github.com/hemlang/hpm) per tutti i dettagli.\n\n## Limitazioni Attuali\n\n1. **Nessun import dinamico**: `import()` come funzione runtime non e supportato\n2. **Nessun export condizionale**: Gli export devono essere al livello superiore\n3. **Percorsi libreria statici**: Gli import di librerie FFI usano percorsi statici (specifici per piattaforma)\n\n## Lavoro Futuro\n\n- Import dinamici con la funzione `import()`\n- Export condizionali\n- Metadati del modulo (`import.meta`)\n- Tree shaking ed eliminazione del codice morto\n\n## Esempi\n\nVedi `tests/modules/` per esempi funzionanti del sistema di moduli.\n\nStruttura di esempio del modulo:\n```\nproject/\n main.hml\n lib/\n    math.hml\n    string.hml\n    index.hml (barrel module)\n utils/\n     helpers.hml\n```\n\nEsempio di utilizzo:\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "Guida al Linguaggio -> Oggetti": {"id": "language-guide-objects", "content": "# Oggetti\n\nHemlock implementa oggetti in stile JavaScript con allocazione nell'heap, campi dinamici, metodi e duck typing. Gli oggetti sono strutture dati flessibili che combinano dati e comportamento.\n\n## Panoramica\n\n```hemlock\n// Oggetto anonimo\nlet person = { name: \"Alice\", age: 30, city: \"Roma\" };\nprint(person.name);  // \"Alice\"\n\n// Oggetto con metodi\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Letterali oggetto\n\n### Sintassi di base\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"Roma\"\n};\n```\n\n**Sintassi:**\n- Le parentesi graffe `{}` racchiudono l'oggetto\n- Coppie chiave-valore separate da virgole\n- Le chiavi sono identificatori (non servono virgolette)\n- I valori possono essere di qualsiasi tipo\n\n### Oggetti vuoti\n\n```hemlock\nlet obj = {};  // Oggetto vuoto\n\n// Aggiungi campi dopo\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### Oggetti annidati\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### Tipi di valore misti\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"ciao\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### Sintassi abbreviata delle proprieta\n\nQuando il nome di una variabile corrisponde al nome della proprieta, usa la sintassi abbreviata:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// Abbreviazione: { name } e equivalente a { name: name }\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**Mescola abbreviazione con proprieta normali:**\n```hemlock\nlet city = \"Roma\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### Operatore spread\n\nL'operatore spread (`...`) copia tutti i campi da un oggetto in un altro:\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**Sovrascrivere valori con spread:**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\" (sovrascritto)\nprint(custom.size);   // \"medium\" (dai defaults)\nprint(custom.debug);  // false (dai defaults)\n```\n\n**Spread multipli (gli spread successivi sovrascrivono i precedenti):**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// Lo spread successivo sovrascrive il precedente\nlet first = { val: \"primo\" };\nlet second = { val: \"secondo\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"secondo\"\n```\n\n**Combina abbreviazione e spread:**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Elemento\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Elemento\"\nprint(full.status);  // \"active\"\n```\n\n**Pattern di override della configurazione:**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**Nota:** Lo spread esegue una copia superficiale. Gli oggetti annidati condividono i riferimenti:\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42 (stesso riferimento di nested.inner)\n```\n\n## Accesso ai campi\n\n### Notazione punto\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Leggi campo\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Modifica campo\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### Aggiunta dinamica di campi\n\nAggiungi nuovi campi a runtime:\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Aggiungi nuovo campo\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### Eliminazione dei campi\n\n**Nota:** L'eliminazione dei campi non e attualmente supportata. Imposta a `null` invece:\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// Non puoi eliminare campi (non supportato)\n// obj.x = undefined;  // Nessun 'undefined' in Hemlock\n\n// Workaround: Imposta a null\nobj.x = null;\n```\n\n## Metodi e `self`\n\n### Definire metodi\n\nI metodi sono funzioni memorizzate nei campi dell'oggetto:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### La parola chiave `self`\n\nQuando una funzione viene chiamata come metodo, `self` viene automaticamente associato all'oggetto:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self si riferisce a counter\n    }\n};\n\ncounter.increment();  // self e associato a counter\nprint(counter.count);  // 1\n```\n\n**Come funziona:**\n- Le chiamate di metodo vengono rilevate verificando se l'espressione funzione e un accesso a proprieta\n- `self` viene automaticamente associato all'oggetto al momento della chiamata\n- `self` e di sola lettura (non puoi riassegnare `self` stesso)\n\n### Rilevamento della chiamata di metodo\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Chiamato come metodo - self e associato\nprint(obj.method());  // 10\n\n// Chiamato come funzione - self e null (errore)\nlet f = obj.method;\nprint(f());  // ERRORE: self non e definito\n```\n\n### Metodi con parametri\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## Definizioni di tipo con `define`\n\n### Definizione di tipo di base\n\nDefinisci le forme degli oggetti con `define`:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Crea oggetto e assegna a variabile tipizzata\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Il duck typing valida la struttura\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**Cosa fa `define`:**\n- Dichiara un tipo con campi richiesti\n- Abilita la validazione duck typing\n- Imposta il nome del tipo dell'oggetto per `typeof()`\n\n### Duck Typing\n\nGli oggetti vengono validati contro `define` usando la **compatibilita strutturale**:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Ha tutti i campi richiesti\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Campi extra consentiti\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"Roma\",\n    active: true\n};\n\n// ERRORE: Campo richiesto 'age' mancante\nlet p3: Person = { name: \"Carol\" };\n\n// ERRORE: Tipo sbagliato per 'age'\nlet p4: Person = { name: \"Dave\", age: \"trenta\" };\n```\n\n**Regole del duck typing:**\n- Tutti i campi richiesti devono essere presenti\n- I tipi dei campi devono corrispondere\n- I campi extra sono consentiti e preservati\n- La validazione avviene al momento dell'assegnazione\n\n### Campi opzionali\n\nI campi possono essere opzionali con valori predefiniti:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Opzionale con valore predefinito\n    nickname?: string,   // Opzionale, predefinito a null\n}\n\n// Oggetto con solo campi richiesti\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (predefinito applicato)\nprint(typed_p.nickname);  // null (nessun predefinito)\n\n// Puo sovrascrivere i campi opzionali\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (sovrascritto)\n```\n\n**Sintassi dei campi opzionali:**\n- `campo?: valore_predefinito` - Opzionale con predefinito\n- `campo?: tipo` - Opzionale con annotazione di tipo, predefinito a null\n- I campi opzionali vengono aggiunti durante il duck typing se mancanti\n\n### Verifica del tipo\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // La verifica del tipo avviene qui\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (l'originale e ancora anonimo)\n```\n\n**Quando avviene la verifica del tipo:**\n- Al momento dell'assegnazione alla variabile tipizzata\n- Valida che tutti i campi richiesti siano presenti\n- Valida che i tipi dei campi corrispondano (con conversioni implicite)\n- Imposta il nome del tipo dell'oggetto\n\n## Firme di metodo in Define\n\nI blocchi define possono specificare firme di metodo, creando contratti simili alle interfacce:\n\n### Metodi richiesti\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // Firma di metodo richiesta\n}\n\n// Gli oggetti devono fornire il metodo richiesto\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### Metodi opzionali\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // Richiesto\n    fn pretty?(): string;         // Metodo opzionale (puo essere assente)\n}\n```\n\n### Il tipo `Self`\n\n`Self` si riferisce al tipo che viene definito, consentendo definizioni di tipo ricorsive:\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // Restituisce lo stesso tipo dell'oggetto\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // Prende lo stesso tipo come parametro\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### Campi e metodi misti\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## Tipi composti (Tipi intersezione)\n\nI tipi composti usano `&` per richiedere che un oggetto soddisfi piu definizioni di tipo:\n\n### Tipi composti di base\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// Tipo composto: l'oggetto deve soddisfare TUTTI i tipi\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### Parametri di funzione con tipi composti\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" ha \" + p.age + \" anni\");\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"Roma\" });  // Campi extra OK\n```\n\n### Tre o piu tipi\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### Alias di tipo per tipi composti\n\n```hemlock\n// Crea un alias con nome per un tipo composto\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**Duck typing con composti:** I campi extra sono sempre consentiti - l'oggetto deve solo avere almeno i campi richiesti da tutti i tipi componenti.\n\n## Serializzazione JSON\n\n### Serializzare in JSON\n\nConverti oggetti in stringhe JSON:\n\n```hemlock\n// obj.serialize() - Converti oggetto in stringa JSON\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Oggetti annidati\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### Deserializzare da JSON\n\nAnalizza stringhe JSON in oggetti:\n\n```hemlock\n// json.deserialize() - Analizza stringa JSON in oggetto\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### Rilevamento dei cicli\n\nI riferimenti circolari vengono rilevati e causano errori:\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Crea riferimento circolare\n\nobj.serialize();  // ERRORE: serialize() ha rilevato riferimento circolare\n```\n\n### Tipi supportati\n\nLa serializzazione JSON supporta:\n\n- **Numeri**: i8-i32, u8-u32, f32, f64\n- **Booleani**: true, false\n- **Stringhe**: Con sequenze di escape\n- **Null**: valore null\n- **Oggetti**: Oggetti annidati\n- **Array**: Array annidati\n\n**Non supportati:**\n- Funzioni (omesse silenziosamente)\n- Puntatori (errore)\n- Buffer (errore)\n\n### Gestione degli errori\n\nLa serializzazione e deserializzazione possono generare errori:\n\n```hemlock\n// JSON non valido genera un errore\ntry {\n    let bad = \"json non valido\".deserialize();\n} catch (e) {\n    print(\"Errore di parsing:\", e);\n}\n\n// I puntatori non possono essere serializzati\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Errore di serializzazione:\", e);\n}\n```\n\n### Esempio round-trip\n\nEsempio completo di serializzazione e deserializzazione:\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// Crea e serializza\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// Deserializza\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## Funzioni integrate\n\n### `typeof(value)`\n\nRestituisce il nome del tipo come stringa:\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**Valori restituiti:**\n- Oggetti anonimi: `\"object\"`\n- Oggetti tipizzati: Nome del tipo personalizzato (es. `\"Person\"`)\n\n## Dettagli di implementazione\n\n### Modello di memoria\n\n- **Allocato nell'heap** - Tutti gli oggetti sono allocati nell'heap\n- **Copia superficiale** - L'assegnazione copia il riferimento, non l'oggetto\n- **Campi dinamici** - Memorizzati come array dinamici di coppie nome/valore\n- **Conteggiati per riferimento** - Gli oggetti vengono liberati automaticamente quando lo scope termina\n\n### Semantica dei riferimenti\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Copia superficiale (stesso riferimento)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (entrambi si riferiscono allo stesso oggetto)\n```\n\n### Memorizzazione dei metodi\n\nI metodi sono semplicemente funzioni memorizzate nei campi:\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method e una funzione memorizzata in obj.method\nprint(typeof(obj.method));  // \"function\"\n```\n\n## Pattern comuni\n\n### Pattern: Funzione costruttore\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Ciao, sono \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Ciao, sono Alice\"\n```\n\n### Pattern: Object builder\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Abilita il concatenamento\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### Pattern: Oggetto stato\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### Pattern: Oggetto configurazione\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## Buone pratiche\n\n1. **Usa `define` per la struttura** - Documenta le forme degli oggetti attese\n2. **Preferisci le funzioni factory** - Crea oggetti con costruttori\n3. **Mantieni gli oggetti semplici** - Non annidare troppo profondamente\n4. **Documenta l'uso di `self`** - Rendi chiaro il comportamento dei metodi\n5. **Valida all'assegnazione** - Usa il duck typing per catturare gli errori presto\n6. **Evita i riferimenti circolari** - Causeranno errori di serializzazione\n7. **Usa i campi opzionali** - Fornisci valori predefiniti sensati\n\n## Trabocchetti comuni\n\n### Trabocchetto: Riferimento vs. Valore\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Copia superficiale\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (sorpresa! entrambi sono cambiati)\n\n// Per evitare: Crea nuovo oggetto\nlet obj3 = { x: obj1.x };  // Copia profonda (manuale)\n```\n\n### Trabocchetto: `self` in chiamate non-metodo\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Funziona: Chiamato come metodo\nprint(obj.method());  // 10\n\n// ERRORE: Chiamato come funzione\nlet f = obj.method;\nprint(f());  // ERRORE: self non e definito\n```\n\n### Trabocchetto: Puntatori raw negli oggetti\n\n```hemlock\n// Gli oggetti vengono liberati automaticamente, ma i puntatori raw dentro NON lo sono\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // ptr raw richiede free manuale\n    // obj viene liberato automaticamente quando lo scope termina, ma obj.data perde memoria!\n}\n\n// Soluzione: Libera i puntatori raw prima che lo scope termini\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... usa obj.data ...\n    free(obj.data);  // Libera esplicitamente il puntatore raw\n}  // obj stesso viene liberato automaticamente\n```\n\n### Trabocchetto: Confusione di tipo\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// ERRORE: Campo richiesto 'y' mancante\nlet p: Point = obj;\n```\n\n## Esempi\n\n### Esempio: Matematica vettoriale\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### Esempio: Database semplice\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### Esempio: Emettitore di eventi\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Ricevuto: \" + data);\n});\n\nemitter.emit(\"message\", \"Ciao!\");\n```\n\n## Limitazioni\n\nLimitazioni attuali:\n\n- **Nessuna copia profonda** - Devi copiare manualmente gli oggetti annidati (spread e superficiale)\n- **Nessun passaggio per valore** - Gli oggetti vengono sempre passati per riferimento\n- **Nessuna proprieta calcolata** - Nessuna sintassi `{[key]: value}`\n- **`self` e di sola lettura** - Non puoi riassegnare `self` nei metodi\n- **Nessuna eliminazione di proprieta** - Non puoi rimuovere i campi una volta aggiunti\n\n**Nota:** Gli oggetti sono conteggiati per riferimento e liberati automaticamente quando lo scope termina. Vedi [Gestione della memoria](memory.md#conteggio-interno-dei-riferimenti) per i dettagli.\n\n## Argomenti correlati\n\n- [Funzioni](#language-guide-functions) - I metodi sono funzioni memorizzate negli oggetti\n- [Array](#language-guide-arrays) - Gli array sono anche simili agli oggetti\n- [Tipi](#language-guide-types) - Duck typing e definizioni di tipo\n- [Gestione degli errori](#language-guide-error-handling) - Lanciare oggetti errore\n\n## Vedi anche\n\n- **Duck Typing**: Vedi sezione \"Objects\" di CLAUDE.md per i dettagli sul duck typing\n- **JSON**: Vedi CLAUDE.md per i dettagli sulla serializzazione JSON\n- **Memoria**: Vedi [Memoria](#language-guide-memory) per l'allocazione degli oggetti\n"}, "Guida al Linguaggio -> Pattern Matching": {"id": "language-guide-pattern-matching", "content": "# Pattern Matching\n\nHemlock fornisce un potente pattern matching tramite le espressioni `match`, offrendo un modo conciso per destrutturare valori, controllare tipi e gestire casi multipli.\n\n## Sintassi Base\n\n```hemlock\nlet result = match (value) {\n    pattern1 => expression1,\n    pattern2 => expression2,\n    _ => default_expression\n};\n```\n\nLe espressioni match valutano `value` rispetto a ogni pattern in ordine, restituendo il risultato dell'espressione del primo ramo che corrisponde.\n\n## Tipi di Pattern\n\n### Pattern Letterali\n\nConfronta con valori esatti:\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"zero\",\n    1 => \"uno\",\n    42 => \"la risposta\",\n    _ => \"altro\"\n};\nprint(msg);  // \"la risposta\"\n```\n\nLetterali supportati:\n- **Interi**: `0`, `42`, `-5`\n- **Float**: `3.14`, `-0.5`\n- **Stringhe**: `\"hello\"`, `\"world\"`\n- **Booleani**: `true`, `false`\n- **Null**: `null`\n\n### Pattern Wildcard (`_`)\n\nCorrisponde a qualsiasi valore senza binding:\n\n```hemlock\nlet x = \"qualsiasi cosa\";\nlet result = match (x) {\n    \"specifico\" => \"trovato\",\n    _ => \"wildcard corrispondente\"\n};\n```\n\n### Pattern con Binding di Variabile\n\nAssocia il valore corrispondente a una variabile:\n\n```hemlock\nlet x = 100;\nlet result = match (x) {\n    0 => \"zero\",\n    n => \"il valore e \" + n  // n viene associato a 100\n};\nprint(result);  // \"il valore e 100\"\n```\n\n### Pattern OR (`|`)\n\nCorrisponde a alternative multiple:\n\n```hemlock\nlet x = 2;\nlet size = match (x) {\n    1 | 2 | 3 => \"piccolo\",\n    4 | 5 | 6 => \"medio\",\n    _ => \"grande\"\n};\n\n// Funziona anche con le stringhe\nlet cmd = \"quit\";\nlet action = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"esco\",\n    \"help\" | \"h\" | \"?\" => \"mostro aiuto\",\n    _ => \"sconosciuto\"\n};\n```\n\n### Espressioni Guard (`if`)\n\nAggiungi condizioni ai pattern:\n\n```hemlock\nlet x = 15;\nlet category = match (x) {\n    n if n < 0 => \"negativo\",\n    n if n == 0 => \"zero\",\n    n if n < 10 => \"piccolo\",\n    n if n < 100 => \"medio\",\n    n => \"grande: \" + n\n};\nprint(category);  // \"medio\"\n\n// Guard complesse\nlet y = 12;\nlet result = match (y) {\n    n if n % 2 == 0 && n > 10 => \"pari e maggiore di 10\",\n    n if n % 2 == 0 => \"pari\",\n    n => \"dispari\"\n};\n```\n\n### Pattern di Tipo\n\nControlla e associa in base al tipo:\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"intero: \" + num,\n    str: string => \"stringa: \" + str,\n    flag: bool => \"booleano: \" + flag,\n    _ => \"altro tipo\"\n};\nprint(desc);  // \"intero: 42\"\n```\n\nTipi supportati: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`\n\n## Pattern di Destrutturazione\n\n### Destrutturazione di Oggetti\n\nEstrai campi dagli oggetti:\n\n```hemlock\nlet point = { x: 10, y: 20 };\nlet result = match (point) {\n    { x, y } => \"punto a \" + x + \",\" + y\n};\nprint(result);  // \"punto a 10,20\"\n\n// Con valori di campo letterali\nlet origin = { x: 0, y: 0 };\nlet name = match (origin) {\n    { x: 0, y: 0 } => \"origine\",\n    { x: 0, y } => \"sull'asse y a \" + y,\n    { x, y: 0 } => \"sull'asse x a \" + x,\n    { x, y } => \"punto a \" + x + \",\" + y\n};\nprint(name);  // \"origine\"\n```\n\n### Destrutturazione di Array\n\nConfronta struttura ed elementi dell'array:\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"vuoto\",\n    [x] => \"singolo: \" + x,\n    [x, y] => \"coppia: \" + x + \",\" + y,\n    [x, y, z] => \"tripla: \" + x + \",\" + y + \",\" + z,\n    _ => \"molti elementi\"\n};\nprint(desc);  // \"tripla: 1,2,3\"\n\n// Con valori letterali\nlet pair = [1, 2];\nlet result = match (pair) {\n    [0, 0] => \"entrambi zero\",\n    [1, x] => \"inizia con 1, secondo e \" + x,\n    [x, 1] => \"finisce con 1\",\n    _ => \"altro\"\n};\nprint(result);  // \"inizia con 1, secondo e 2\"\n```\n\n### Pattern Rest per Array (`...`)\n\nCattura gli elementi rimanenti:\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// Testa e coda\nlet result = match (nums) {\n    [first, ...rest] => \"primo: \" + first,\n    [] => \"vuoto\"\n};\nprint(result);  // \"primo: 1\"\n\n// Primi due elementi\nlet result2 = match (nums) {\n    [a, b, ...rest] => \"primi due: \" + a + \",\" + b,\n    _ => \"troppo corto\"\n};\nprint(result2);  // \"primi due: 1,2\"\n```\n\n### Destrutturazione Annidata\n\nCombina pattern per dati complessi:\n\n```hemlock\nlet user = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet result = match (user) {\n    { name, address: { city, zip } } => name + \" vive a \" + city,\n    _ => \"sconosciuto\"\n};\nprint(result);  // \"Alice vive a NYC\"\n\n// Oggetto che contiene array\nlet data = { items: [1, 2, 3], count: 3 };\nlet result2 = match (data) {\n    { items: [first, ...rest], count } => \"primo: \" + first + \", totale: \" + count,\n    _ => \"nessun elemento\"\n};\nprint(result2);  // \"primo: 1, totale: 3\"\n```\n\n## Match come Espressione\n\nMatch e un'espressione che restituisce un valore:\n\n```hemlock\n// Assegnazione diretta\nlet grade = 85;\nlet letter = match (grade) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// In concatenazione di stringhe\nlet msg = \"Voto: \" + match (grade) {\n    n if n >= 70 => \"sufficiente\",\n    _ => \"insufficiente\"\n};\n\n// Nel return di funzione\nfn classify(n: i32): string {\n    return match (n) {\n        0 => \"zero\",\n        n if n > 0 => \"positivo\",\n        _ => \"negativo\"\n    };\n}\n```\n\n## Best Practice per il Pattern Matching\n\n1. **L'ordine conta**: I pattern vengono controllati dall'alto in basso; metti i pattern specifici prima di quelli generali\n2. **Usa wildcard per la completezza**: Includi sempre un fallback `_` a meno che tu non sia certo che tutti i casi siano coperti\n3. **Preferisci guard a condizioni annidate**: Le guard rendono l'intento piu chiaro\n4. **Usa la destrutturazione invece dell'accesso manuale ai campi**: Piu conciso e sicuro\n\n```hemlock\n// Bene: Guard per il controllo del range\nmatch (score) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"sotto B\"\n}\n\n// Bene: Destruttura invece di accedere ai campi\nmatch (point) {\n    { x: 0, y: 0 } => \"origine\",\n    { x, y } => \"a \" + x + \",\" + y\n}\n\n// Evita: Pattern annidati eccessivamente complessi\n// Considera invece di suddividere in match multipli o usare guard\n```\n\n## Confronto con Altri Linguaggi\n\n| Funzionalita | Hemlock | Rust | JavaScript |\n|---------|---------|------|------------|\n| Matching base | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| Destrutturazione | Si | Si | Parziale (switch non destruttura) |\n| Guard | `n if n > 0 =>` | `n if n > 0 =>` | N/D |\n| Pattern OR | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| Pattern rest | `[a, ...rest]` | `[a, rest @ ..]` | N/D |\n| Pattern di tipo | `n: i32` | Tipo tramite ramo `match` | N/D |\n| Restituisce valore | Si | Si | No (istruzione) |\n\n## Note Implementative\n\nIl pattern matching e implementato sia nel backend dell'interprete che in quello del compilatore con piena parita - entrambi producono risultati identici per lo stesso input. La funzionalita e disponibile in Hemlock v1.8.0+.\n"}, "Guida al Linguaggio -> Rune": {"id": "language-guide-runes", "content": "# Rune\n\nLe rune rappresentano **codepoint Unicode** (da U+0000 a U+10FFFF) come tipo distinto per la manipolazione dei caratteri in Hemlock. A differenza dei byte (u8), le rune sono caratteri Unicode completi che possono rappresentare qualsiasi carattere in qualsiasi lingua o emoji.\n\n## Panoramica\n\n```hemlock\nlet ch = 'A';           // Letterale rune\nlet emoji = '';       // Carattere multi-byte come singola rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // Concatenazione stringa + rune\nlet r = '>' + \" msg\";   // Concatenazione rune + stringa\n```\n\n## Cos'e una Rune?\n\nUna rune e un **valore a 32 bit** che rappresenta un codepoint Unicode:\n\n- **Range:** da 0 a 0x10FFFF (1.114.111 codepoint validi)\n- **Non e un tipo numerico** - Usata per la rappresentazione dei caratteri\n- **Distinta da u8/char** - Le rune sono Unicode completo, u8 sono solo byte\n- **Restituita dall'indicizzazione delle stringhe** - `str[0]` restituisce una rune, non un byte\n\n**Perche le rune?**\n- Le stringhe di Hemlock sono codificate in UTF-8\n- Un singolo carattere Unicode puo essere da 1 a 4 byte in UTF-8\n- Le rune permettono di lavorare con caratteri completi, non byte parziali\n\n## Letterali Rune\n\n### Sintassi Base\n\nGli apici singoli denotano letterali rune:\n\n```hemlock\nlet a = 'A';            // Carattere ASCII\nlet b = '0';            // Carattere cifra\nlet c = '!';            // Punteggiatura\nlet d = ' ';            // Spazio\n```\n\n### Caratteri UTF-8 Multi-byte\n\nLe rune possono rappresentare qualsiasi carattere Unicode:\n\n```hemlock\n// Emoji\nlet rocket = '';      // Emoji (U+1F680)\nlet heart = '';        // Cuore (U+2764)\nlet smile = '';       // Faccina sorridente (U+1F600)\n\n// Caratteri CJK\nlet chinese = '';     // Cinese (U+4E2D)\nlet japanese = '';    // Hiragana (U+3042)\nlet korean = '';      // Hangul (U+D55C)\n\n// Simboli\nlet check = '';        // Segno di spunta (U+2713)\nlet arrow = '';        // Freccia destra (U+2192)\n```\n\n### Sequenze di Escape\n\nSequenze di escape comuni per caratteri speciali:\n\n```hemlock\nlet newline = '\\n';     // Newline (U+000A)\nlet tab = '\\t';         // Tab (U+0009)\nlet backslash = '\\\\';   // Backslash (U+005C)\nlet quote = '\\'';       // Apice singolo (U+0027)\nlet dquote = '\"';       // Doppio apice (U+0022)\nlet null_char = '\\0';   // Carattere null (U+0000)\nlet cr = '\\r';          // Ritorno a capo (U+000D)\n```\n\n**Sequenze di escape disponibili:**\n- `\\n` - Newline (line feed)\n- `\\t` - Tab orizzontale\n- `\\r` - Ritorno a capo\n- `\\0` - Carattere null\n- `\\\\` - Backslash\n- `\\'` - Apice singolo\n- `\\\"` - Doppio apice\n\n### Escape Unicode\n\nUsa la sintassi `\\u{XXXXXX}` per i codepoint Unicode (fino a 6 cifre esadecimali):\n\n```hemlock\nlet rocket = '\\u{1F680}';   //  Emoji tramite escape Unicode\nlet heart = '\\u{2764}';     //  Cuore\nlet ascii = '\\u{41}';       // 'A' tramite escape\nlet max = '\\u{10FFFF}';     // Codepoint Unicode massimo\n\n// Zeri iniziali opzionali\nlet a = '\\u{41}';           // Uguale a '\\u{0041}'\nlet b = '\\u{0041}';\n```\n\n**Regole:**\n- Range: da `\\u{0}` a `\\u{10FFFF}`\n- Cifre esadecimali: da 1 a 6 cifre\n- Case insensitive: `\\u{1F680}` o `\\u{1f680}`\n- Valori fuori dal range Unicode valido causano errore\n\n## Concatenazione Stringa + Rune\n\nLe rune possono essere concatenate con le stringhe:\n\n```hemlock\n// Stringa + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Testo\" + '';      // \"Testo\"\n\n// Rune + stringa\nlet prefix = '>' + \" Messaggio\";    // \"> Messaggio\"\nlet bullet = '' + \" Elemento\";     // \" Elemento\"\n\n// Concatenazioni multiple\nlet msg = \"Ciao \" + '' + \" Mondo \" + '';  // \"Ciao  Mondo \"\n\n// Il method chaining funziona\nlet result = ('>' + \" Importante\").to_upper();  // \"> IMPORTANTE\"\n```\n\n**Come funziona:**\n- Le rune vengono automaticamente codificate in UTF-8\n- Convertite in stringhe durante la concatenazione\n- L'operatore di concatenazione delle stringhe gestisce questo in modo trasparente\n\n## Conversioni di Tipo\n\nLe rune possono essere convertite da/verso altri tipi.\n\n### Intero <-> Rune\n\nConverti tra interi e rune per lavorare con i valori dei codepoint:\n\n```hemlock\n// Intero a rune (valore del codepoint)\nlet code: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;  // U+1F680 ()\n\n// Rune a intero (ottieni il valore del codepoint)\nlet r = 'Z';\nlet value: i32 = r;             // 90 (valore ASCII)\n\nlet rocket = '';\nlet code: i32 = rocket;         // 128640 (U+1F680)\n```\n\n**Controllo del range:**\n- Intero a rune: Deve essere in [0, 0x10FFFF]\n- Valori fuori range causano errore a runtime\n- Rune a intero: Sempre successo (restituisce il codepoint)\n\n### Rune -> Stringa\n\nLe rune possono essere convertite esplicitamente in stringhe:\n\n```hemlock\n// Conversione esplicita\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '';       // \"\"\n\n// Automatica durante la concatenazione\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8 (Byte) -> Rune\n\nQualsiasi valore u8 (0-255) puo essere convertito in rune:\n\n```hemlock\n// Range ASCII (0-127)\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// ASCII esteso / Latin-1 (128-255)\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 ()\n\n// Nota: I valori 0-127 sono ASCII, 128-255 sono Latin-1\n```\n\n### Conversioni Concatenate\n\nLe conversioni di tipo possono essere concatenate:\n\n```hemlock\n// i32 -> rune -> stringa\nlet code: i32 = 128512;         // Codepoint faccina sorridente\nlet r: rune = code;             // \nlet s: string = r;              // \"\"\n\n// Tutto in un'unica espressione\nlet emoji: string = 128640;     // i32 -> rune -> stringa implicito ()\n```\n\n## Operazioni sulle Rune\n\n### Stampa\n\nCome vengono visualizzate le rune dipende dal codepoint:\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (quotato, ASCII stampabile)\n\nlet emoji = '';\nprint(emoji);                   // U+1F680 (notazione Unicode per non-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (non stampabile come hex)\n\nlet space = ' ';\nprint(space);                   // ' ' (stampabile)\n```\n\n**Formato di stampa:**\n- ASCII stampabile (32-126): Carattere quotato `'A'`\n- Non stampabile o Unicode: Notazione hex `U+XXXX`\n\n### Controllo del Tipo\n\nUsa `typeof()` per controllare se un valore e una rune:\n\n```hemlock\nlet r = '';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"testo\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (l'indicizzazione restituisce rune)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### Confronto\n\nLe rune possono essere confrontate per uguaglianza:\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Case sensitive\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Le rune possono essere confrontate con interi (valori dei codepoint)\nprint(a == 65);                 // true (conversione implicita)\nprint('' == 128640);          // true\n```\n\n**Operatori di confronto:**\n- `==` - Uguale\n- `!=` - Diverso\n- `<`, `>`, `<=`, `>=` - Ordine dei codepoint\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```\n\n## Lavorare con l'Indicizzazione delle Stringhe\n\nL'indicizzazione delle stringhe restituisce rune, non byte:\n\n```hemlock\nlet s = \"Hello\";\nlet h = s[0];                   // 'H' (rune)\nlet rocket = s[5];              // '' (rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// Converti in stringa se necessario\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"\"\n```\n\n**Importante:** L'indicizzazione delle stringhe usa posizioni dei codepoint, non offset dei byte:\n\n```hemlock\nlet text = \"Ciao!\";\n// Posizioni codepoint: 0='C', 1='i', 2='a', 3='o', 4='', 5='!'\n// Posizioni byte:      0='C', 1='i', 2='a', 3='o', 4-7='', 8='!'\n\nlet r = text[4];                // '' (codepoint 4)\nprint(typeof(r));               // \"rune\"\n```\n\n## Esempi\n\n### Esempio: Classificazione dei Caratteri\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### Esempio: Conversione di Caso\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // Converti in maiuscolo (sottrai 32)\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // Converti in minuscolo (aggiungi 32)\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### Esempio: Iterazione sui Caratteri\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Posizione \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Ciao\");\n// Posizione 0: 'C'\n// Posizione 1: 'i'\n// Posizione 2: 'a'\n// Posizione 3: 'o'\n// Posizione 4: U+1F680\n```\n\n### Esempio: Costruire Stringhe dalle Rune\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('', 5); // \"\"\n```\n\n## Pattern Comuni\n\n### Pattern: Filtro di Caratteri\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### Pattern: Conteggio Caratteri\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## Best Practice\n\n1. **Usa le rune per le operazioni sui caratteri** - Non provare a lavorare con i byte per il testo\n2. **L'indicizzazione delle stringhe restituisce rune** - Ricorda che `str[i]` ti da una rune\n3. **Confronti consapevoli di Unicode** - Le rune gestiscono qualsiasi carattere Unicode\n4. **Converti quando necessario** - Le rune si convertono facilmente in stringhe e interi\n5. **Testa con emoji** - Testa sempre le operazioni sui caratteri con caratteri multi-byte\n\n## Insidie Comuni\n\n### Insidia: Confusione Rune vs. Byte\n\n```hemlock\n// NON FARE: Trattare le rune come byte\nlet r: rune = '';\nlet b: u8 = r;              // ERRORE: Il codepoint rune 128640 non entra in u8\n\n// FARE: Usa conversioni appropriate\nlet r: rune = '';\nlet code: i32 = r;          // OK: 128640\n```\n\n### Insidia: Indicizzazione per Byte delle Stringhe\n\n```hemlock\n// NON FARE: Assumere l'indicizzazione per byte\nlet s = \"\";\nlet byte = s.byte_at(0);    // 240 (primo byte UTF-8, non il carattere completo)\n\n// FARE: Usa l'indicizzazione per codepoint\nlet s = \"\";\nlet rune = s[0];            // '' (carattere completo)\nlet rune2 = s.char_at(0);   // '' (metodo esplicito)\n```\n\n## Argomenti Correlati\n\n- [Stringhe](#language-guide-strings) - Operazioni sulle stringhe e gestione UTF-8\n- [Tipi](#language-guide-types) - Sistema di tipi e conversioni\n- [Flusso di Controllo](#language-guide-control-flow) - Usare le rune nei confronti\n\n## Vedi Anche\n\n- **Standard Unicode**: I codepoint Unicode sono definiti dall'Unicode Consortium\n- **Codifica UTF-8**: Vedi [Stringhe](#language-guide-strings) per i dettagli su UTF-8\n- **Conversioni di Tipo**: Vedi [Tipi](#language-guide-types) per le regole di conversione\n"}, "Guida al Linguaggio -> Sintassi": {"id": "language-guide-syntax", "content": "# Panoramica della sintassi\n\nQuesto documento illustra le regole fondamentali della sintassi e la struttura dei programmi Hemlock.\n\n## Regole di sintassi di base\n\n### I punti e virgola sono obbligatori\n\nA differenza di JavaScript o Python, i punti e virgola sono **sempre richiesti** alla fine delle istruzioni:\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**Questo causera un errore:**\n```hemlock\nlet x = 42  // ERRORE: Punto e virgola mancante\nlet y = 10  // ERRORE: Punto e virgola mancante\n```\n\n### Le parentesi graffe sono sempre richieste\n\nTutti i blocchi di flusso di controllo devono utilizzare le parentesi graffe, anche per le istruzioni singole:\n\n```hemlock\n// CORRETTO\nif (x > 0) {\n    print(\"positivo\");\n}\n\n// ERRORE: Parentesi graffe mancanti\nif (x > 0)\n    print(\"positivo\");\n```\n\n### Commenti\n\n```hemlock\n// Questo e un commento su una singola riga\n\n/*\n   Questo e un\n   commento multi-riga\n*/\n\nlet x = 42;  // Commento in linea\n```\n\n## Variabili\n\n### Dichiarazione\n\nLe variabili vengono dichiarate con `let`:\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### Annotazioni di tipo (opzionali)\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"ciao\";\n```\n\n### Costanti\n\nUsare `const` per i valori immutabili:\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\nTentare di riassegnare una costante causera un errore di esecuzione: \"Cannot assign to const variable\".\n\n## Espressioni\n\n### Operatori aritmetici\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - Addizione\nprint(a - b);   // 7  - Sottrazione\nprint(a * b);   // 30 - Moltiplicazione\nprint(a / b);   // 3  - Divisione (intera)\n```\n\n### Operatori di confronto\n\n```hemlock\nprint(a == b);  // false - Uguale\nprint(a != b);  // true  - Diverso\nprint(a > b);   // true  - Maggiore di\nprint(a < b);   // false - Minore di\nprint(a >= b);  // true  - Maggiore o uguale\nprint(a <= b);  // false - Minore o uguale\n```\n\n### Operatori logici\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - AND\nprint(x || y);  // true  - OR\nprint(!x);      // false - NOT\n```\n\n### Operatori bitwise\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - AND bit a bit\nprint(a | b);   // 14 - OR bit a bit\nprint(a ^ b);   // 6  - XOR bit a bit\nprint(a << 2);  // 48 - Shift a sinistra\nprint(a >> 1);  // 6  - Shift a destra\nprint(~a);      // -13 - NOT bit a bit\n```\n\n### Precedenza degli operatori\n\nDalla piu alta alla piu bassa:\n\n1. `()` - Raggruppamento\n2. `!`, `~`, `-` (unario) - Operatori unari\n3. `*`, `/` - Moltiplicazione, Divisione\n4. `+`, `-` - Addizione, Sottrazione\n5. `<<`, `>>` - Shift bit a bit\n6. `<`, `<=`, `>`, `>=` - Confronti\n7. `==`, `!=` - Uguaglianza\n8. `&` - AND bit a bit\n9. `^` - XOR bit a bit\n10. `|` - OR bit a bit\n11. `&&` - AND logico\n12. `||` - OR logico\n\n**Esempi:**\n```hemlock\nlet x = 2 + 3 * 4;      // 14 (non 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## Flusso di controllo\n\n### Istruzioni If\n\n```hemlock\nif (condizione) {\n    // corpo\n}\n\nif (condizione) {\n    // ramo then\n} else {\n    // ramo else\n}\n\nif (condizione1) {\n    // ramo 1\n} else if (condizione2) {\n    // ramo 2\n} else {\n    // ramo predefinito\n}\n```\n\n### Cicli While\n\n```hemlock\nwhile (condizione) {\n    // corpo\n}\n```\n\n**Esempio:**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### Cicli For\n\n**Stile C:**\n```hemlock\nfor (inizializzatore; condizione; incremento) {\n    // corpo\n}\n```\n\n**Esempio:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in (array):**\n```hemlock\nfor (let item in array) {\n    // corpo\n}\n```\n\n**Esempio:**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Istruzioni Switch\n\n```hemlock\nswitch (espressione) {\n    case valore1:\n        // corpo\n        break;\n    case valore2:\n        // corpo\n        break;\n    default:\n        // corpo predefinito\n        break;\n}\n```\n\n**Esempio:**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Lunedi\");\n        break;\n    case 2:\n        print(\"Martedi\");\n        break;\n    case 3:\n        print(\"Mercoledi\");\n        break;\n    default:\n        print(\"Altro\");\n        break;\n}\n```\n\n### Break e Continue\n\n```hemlock\n// Break: uscire dal ciclo\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue: passare all'iterazione successiva\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## Funzioni\n\n### Funzioni con nome\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // corpo\n    return value;\n}\n```\n\n**Esempio:**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Funzioni anonime\n\n```hemlock\nlet func = fn(params) {\n    // corpo\n};\n```\n\n**Esempio:**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### Annotazioni di tipo (opzionali)\n\n```hemlock\n// Senza annotazioni (tipi inferiti)\nfn greet(name) {\n    return \"Ciao, \" + name;\n}\n\n// Con annotazioni (verificate a runtime)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## Oggetti\n\n### Letterali oggetto\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**Esempio:**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### Metodi\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**Esempio:**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### Definizioni di tipo\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**Esempio:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## Array\n\n### Letterali array\n\n```hemlock\nlet arr = [elemento1, elemento2, elemento3];\n```\n\n**Esempio:**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"due\", true, null];\nlet empty = [];\n```\n\n### Indicizzazione array\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // Modificare un elemento\n```\n\n## Gestione degli errori\n\n### Try/Catch\n\n```hemlock\ntry {\n    // codice rischioso\n} catch (e) {\n    // gestire l'errore\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // codice rischioso\n} finally {\n    // viene sempre eseguito\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // codice rischioso\n} catch (e) {\n    // gestire l'errore\n} finally {\n    // pulizia\n}\n```\n\n### Throw\n\n```hemlock\nthrow espressione;\n```\n\n**Esempio:**\n```hemlock\nif (x < 0) {\n    throw \"x deve essere positivo\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(messaggio);\n```\n\n**Esempio:**\n```hemlock\npanic(\"errore irreversibile\");\n```\n\n## Moduli (sperimentale)\n\n### Istruzioni di export\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### Istruzioni di import\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## Async (sperimentale)\n\n### Funzioni asincrone\n\n```hemlock\nasync fn function_name(params): return_type {\n    // corpo\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### Canali (Channels)\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI (Interfaccia di funzione esterna)\n\n### Importare una libreria condivisa\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### Dichiarare una funzione esterna\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**Esempio:**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## Letterali\n\n### Letterali interi\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // Automaticamente i64\n\n// Esadecimale (prefisso 0x)\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// Binario (prefisso 0b)\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// Ottale (prefisso 0o)\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// Separatori numerici per la leggibilita\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### Letterali in virgola mobile\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // Notazione scientifica\nlet sci2 = 2.5E+3;       // La E maiuscola funziona\nlet no_lead = .5;        // Senza zero iniziale (0.5)\nlet sep = 3.14_159_265;  // Separatori numerici\n```\n\n### Letterali stringa\n\n```hemlock\nlet s = \"ciao\";\nlet escaped = \"riga1\\nriga2\\ttabulazione\";\nlet quote = \"Ha detto \\\"ciao\\\"\";\n\n// Sequenze di escape esadecimali\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Sequenze di escape Unicode\nlet emoji = \"\\u{1F600}\";               // faccina sorridente\nlet heart = \"\\u{2764}\";                // cuore\nlet mixed = \"Ciao \\u{1F30D}!\";         // Ciao mondo!\n```\n\n**Sequenze di escape:**\n- `\\n` - nuova riga\n- `\\t` - tabulazione\n- `\\r` - ritorno a capo\n- `\\\\` - barra rovesciata\n- `\\\"` - virgolette doppie\n- `\\'` - virgolette singole\n- `\\0` - carattere nullo\n- `\\xNN` - escape esadecimale (2 cifre)\n- `\\u{XXXX}` - escape unicode (1-6 cifre)\n\n### Letterali rune\n\n```hemlock\nlet ch = 'A';\nlet emoji = 'rocket';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### Letterali booleani\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Letterale null\n\n```hemlock\nlet nothing = null;\n```\n\n## Regole di scope\n\n### Scope di blocco\n\nLe variabili sono limitate al blocco contenitore piu vicino:\n\n```hemlock\nlet x = 1;  // Scope esterno\n\nif (true) {\n    let x = 2;  // Scope interno (nasconde quello esterno)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### Scope di funzione\n\nLe funzioni creano il proprio scope:\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // Puo leggere lo scope esterno\n}\n\nfoo();\n// print(local);  // ERRORE: 'local' non definito qui\n```\n\n### Scope delle closure\n\nLe closure catturano le variabili dallo scope contenitore:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Cattura 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## Spazi bianchi e formattazione\n\n### Indentazione\n\nHemlock non impone un'indentazione specifica, ma sono raccomandati 4 spazi:\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indentato\");\n    }\n}\n```\n\n### Interruzioni di riga\n\nLe istruzioni possono estendersi su piu righe:\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Istruzione Loop\n\nLa parola chiave `loop` fornisce una sintassi piu chiara per i cicli infiniti:\n\n```hemlock\nloop {\n    // ... eseguire il lavoro\n    if (done) {\n        break;\n    }\n}\n```\n\nQuesto e equivalente a `while (true)` ma rende l'intenzione piu chiara.\n\n## Parole chiave riservate\n\nLe seguenti parole chiave sono riservate in Hemlock:\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## Prossimi passi\n\n- [Sistema dei tipi](#language-guide-types) - Scopri il sistema dei tipi di Hemlock\n- [Flusso di controllo](#language-guide-control-flow) - Approfondisci le strutture di controllo\n- [Funzioni](#language-guide-functions) - Padroneggia le funzioni e le closure\n- [Gestione della memoria](#language-guide-memory) - Comprendi i puntatori e i buffer\n"}, "Guida al Linguaggio -> Stringhe": {"id": "language-guide-strings", "content": "# Stringhe\n\nLe stringhe Hemlock sono **sequenze mutabili di prima classe UTF-8** con supporto completo Unicode e un ricco set di metodi per l'elaborazione del testo. A differenza di molti linguaggi, le stringhe Hemlock sono mutabili e lavorano nativamente con i codepoint Unicode.\n\n## Panoramica\n\n```hemlock\nlet s = \"ciao\";\ns[0] = 'C';             // muta con rune (ora \"Ciao\")\nprint(s.length);        // 4 (conteggio codepoint)\nlet c = s[0];           // restituisce rune (codepoint Unicode)\nlet msg = s + \" mondo\"; // concatenazione\nlet emoji = \"\";\nprint(emoji.length);    // 1 (un codepoint)\nprint(emoji.byte_length); // 4 (quattro byte UTF-8)\n```\n\n## Proprieta\n\nLe stringhe Hemlock hanno queste caratteristiche chiave:\n\n- **Codifica UTF-8** - Supporto completo Unicode (da U+0000 a U+10FFFF)\n- **Mutabili** - A differenza delle stringhe Python, JavaScript e Java\n- **Indicizzazione basata su codepoint** - Restituisce `rune` (codepoint Unicode), non byte\n- **Allocate nell'heap** - Con tracciamento interno della capacita\n- **Due proprieta di lunghezza**:\n  - `.length` - Conteggio codepoint (numero di caratteri)\n  - `.byte_length` - Conteggio byte (dimensione codifica UTF-8)\n\n## Comportamento UTF-8\n\nTutte le operazioni sulle stringhe lavorano con i **codepoint** (caratteri), non con i byte:\n\n```hemlock\nlet text = \"CiaoMondo\";\nprint(text.length);        // 10 (codepoint)\nprint(text.byte_length);   // 14 (byte, emoji e 4 byte)\n\n// L'indicizzazione usa i codepoint\nlet c = text[0];           // 'C' (rune)\nlet rocket = text[4];      // '' (rune)\n```\n\n**I caratteri multi-byte contano come uno:**\n```hemlock\n\"Ciao\".length;       // 4\n\"\".length;         // 1 (una emoji)\n\"\".length;       // 2 (due caratteri cinesi)\n\"cafe\".length;       // 4 (e e un codepoint)\n```\n\n## Letterali stringa\n\n```hemlock\n// Stringhe di base\nlet s1 = \"ciao\";\nlet s2 = \"mondo\";\n\n// Con sequenze di escape\nlet s3 = \"Riga 1\\nRiga 2\\ttabulata\";\nlet s4 = \"Virgolette: \\\"Ciao\\\"\";\nlet s5 = \"Barra rovesciata: \\\\\";\n\n// Caratteri Unicode\nlet s6 = \" Emoji\";\nlet s7 = \"\";\n```\n\n## Stringhe template (Interpolazione di stringhe)\n\nUsa i backtick per le stringhe template con espressioni incorporate:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// Interpolazione di base\nlet greeting = `Ciao, ${name}!`;           // \"Ciao, Alice!\"\nlet info = `${name} ha ${age} anni`;       // \"Alice ha 30 anni\"\n\n// Espressioni nell'interpolazione\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;        // \"5 + 10 = 15\"\n\n// Chiamate di metodo\nlet upper = `Nome: ${name.to_upper()}`;    // \"Nome: ALICE\"\n\n// Oggetti annidati\nlet person = { name: \"Bob\", city: \"Roma\" };\nlet desc = `${person.name} vive a ${person.city}`;  // \"Bob vive a Roma\"\n\n// Multi-riga (preserva le nuove righe)\nlet multi = `Riga 1\nRiga 2\nRiga 3`;\n```\n\n**Caratteristiche delle stringhe template:**\n- Le espressioni dentro `${...}` vengono valutate e convertite in stringhe\n- Qualsiasi espressione valida puo essere usata (variabili, chiamate di funzione, aritmetica)\n- Le stringhe con backtick supportano le stesse sequenze di escape delle stringhe normali\n- Utili per costruire stringhe dinamiche senza concatenazione\n\n### Escape nelle stringhe template\n\nPer includere un letterale `${` in una stringa template, esegui l'escape del simbolo del dollaro:\n\n```hemlock\nlet price = 100;\nlet text = `Prezzo: \\${price} o ${price}`;\n// \"Prezzo: ${price} o 100\"\n\n// Backtick letterale\nlet code = `Usa \\` per le stringhe template`;\n// \"Usa ` per le stringhe template\"\n```\n\n### Espressioni complesse\n\nLe stringhe template possono contenere qualsiasi espressione valida:\n\n```hemlock\n// Espressioni tipo ternario\nlet age = 25;\nlet status = `Stato: ${age >= 18 ? \"adulto\" : \"minore\"}`;\n\n// Accesso array\nlet items = [\"mela\", \"banana\", \"ciliegia\"];\nlet first = `Primo elemento: ${items[0]}`;\n\n// Chiamate di funzione con argomenti\nfn format_price(p) { return p + \" euro\"; }\nlet msg = `Totale: ${format_price(99.99)}`;  // \"Totale: 99.99 euro\"\n\n// Chiamate di metodo concatenate\nlet name = \"alice\";\nlet formatted = `Ciao, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Ciao, Alice!\"\n```\n\n### Stringhe template vs Concatenazione\n\nLe stringhe template sono spesso piu pulite della concatenazione:\n\n```hemlock\n// Concatenazione (piu difficile da leggere)\nlet msg1 = \"Ciao, \" + name + \"! Hai \" + count + \" messaggi.\";\n\n// Stringa template (piu facile da leggere)\nlet msg2 = `Ciao, ${name}! Hai ${count} messaggi.`;\n```\n\n## Indicizzazione e mutazione\n\n### Lettura dei caratteri\n\nL'indicizzazione restituisce una `rune` (codepoint Unicode):\n\n```hemlock\nlet s = \"Ciao\";\nlet first = s[0];      // 'C' (rune)\nlet last = s[3];       // 'o' (rune)\n\n// Esempio UTF-8\nlet emoji = \"Hi!\";\nlet rocket = emoji[2];  // '' (rune all'indice codepoint 2)\n```\n\n### Scrittura dei caratteri\n\nLe stringhe sono mutabili - puoi modificare i singoli caratteri:\n\n```hemlock\nlet s = \"ciao\";\ns[0] = 'C';            // Ora \"Ciao\"\ns[3] = '!';            // Ora \"Cia!\"\n\n// Con Unicode\nlet msg = \"Vai!\";\nmsg[0] = '';         // Ora \"ai!\"\n```\n\n## Concatenazione\n\nUsa `+` per concatenare le stringhe:\n\n```hemlock\nlet greeting = \"Ciao\" + \" \" + \"Mondo\";  // \"Ciao Mondo\"\n\n// Con variabili\nlet name = \"Alice\";\nlet msg = \"Ciao, \" + name + \"!\";  // \"Ciao, Alice!\"\n\n// Con rune (vedi documentazione Rune)\nlet s = \"Ciao\" + '!';              // \"Ciao!\"\n```\n\n## Metodi stringa\n\nHemlock fornisce 19 metodi stringa per una manipolazione completa del testo.\n\n### Sottostringa e Slicing\n\n**`substr(start, length)`** - Estrae sottostringa per posizione e lunghezza:\n```hemlock\nlet s = \"ciao mondo\";\nlet sub = s.substr(5, 5);       // \"mondo\" (inizia a 5, lunghezza 5)\nlet first = s.substr(0, 4);     // \"ciao\"\n\n// Esempio UTF-8\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\" (posizione 2, lunghezza 1)\n```\n\n**`slice(start, end)`** - Estrae sottostringa per intervallo (end esclusivo):\n```hemlock\nlet s = \"ciao mondo\";\nlet slice = s.slice(0, 4);      // \"ciao\" (indice da 0 a 3)\nlet slice2 = s.slice(5, 10);    // \"mondo\"\n```\n\n**Differenza:**\n- `substr(start, length)` - Usa parametro lunghezza\n- `slice(start, end)` - Usa indice finale (esclusivo)\n\n### Ricerca e Trova\n\n**`find(needle)`** - Trova la prima occorrenza:\n```hemlock\nlet s = \"ciao mondo\";\nlet pos = s.find(\"mondo\");      // 5 (indice della prima occorrenza)\nlet pos2 = s.find(\"foo\");       // -1 (non trovato)\nlet pos3 = s.find(\"o\");         // 3 (primo 'o')\n```\n\n**`contains(needle)`** - Verifica se la stringa contiene la sottostringa:\n```hemlock\nlet s = \"ciao mondo\";\nlet has = s.contains(\"mondo\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### Split e Trim\n\n**`split(delimiter)`** - Divide in array di stringhe:\n```hemlock\nlet csv = \"mela,banana,ciliegia\";\nlet parts = csv.split(\",\");     // [\"mela\", \"banana\", \"ciliegia\"]\n\nlet words = \"uno due tre\".split(\" \");  // [\"uno\", \"due\", \"tre\"]\n\n// Delimitatore vuoto divide per carattere\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - Rimuove spazi bianchi iniziali/finali:\n```hemlock\nlet s = \"  ciao  \";\nlet clean = s.trim();           // \"ciao\"\n\nlet s2 = \"\\t\\ntesto\\n\\t\";\nlet clean2 = s2.trim();         // \"testo\"\n```\n\n### Conversione maiuscole/minuscole\n\n**`to_upper()`** - Converte in maiuscolo:\n```hemlock\nlet s = \"ciao mondo\";\nlet upper = s.to_upper();       // \"CIAO MONDO\"\n\n// Preserva non-ASCII\nlet s2 = \"cafe\";\nlet upper2 = s2.to_upper();     // \"CAFE\"\n```\n\n**`to_lower()`** - Converte in minuscolo:\n```hemlock\nlet s = \"CIAO MONDO\";\nlet lower = s.to_lower();       // \"ciao mondo\"\n```\n\n### Controllo prefisso/suffisso\n\n**`starts_with(prefix)`** - Verifica se inizia con il prefisso:\n```hemlock\nlet s = \"ciao mondo\";\nlet starts = s.starts_with(\"ciao\");  // true\nlet starts2 = s.starts_with(\"mondo\"); // false\n```\n\n**`ends_with(suffix)`** - Verifica se finisce con il suffisso:\n```hemlock\nlet s = \"ciao mondo\";\nlet ends = s.ends_with(\"mondo\");      // true\nlet ends2 = s.ends_with(\"ciao\");      // false\n```\n\n### Sostituzione\n\n**`replace(old, new)`** - Sostituisce la prima occorrenza:\n```hemlock\nlet s = \"ciao mondo\";\nlet s2 = s.replace(\"mondo\", \"amico\");      // \"ciao amico\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (solo il primo)\n```\n\n**`replace_all(old, new)`** - Sostituisce tutte le occorrenze:\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"ciao mondo, mondo!\";\nlet s4 = s3.replace_all(\"mondo\", \"hemlock\"); // \"ciao hemlock, hemlock!\"\n```\n\n### Ripetizione\n\n**`repeat(count)`** - Ripete la stringa n volte:\n```hemlock\nlet s = \"ah\";\nlet laugh = s.repeat(3);        // \"ahahah\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### Accesso a caratteri e byte\n\n**`char_at(index)`** - Ottiene il codepoint Unicode all'indice (restituisce rune):\n```hemlock\nlet s = \"ciao\";\nlet char = s.char_at(0);        // 'c' (rune)\n\n// Esempio UTF-8\nlet emoji = \"\";\nlet rocket = emoji.char_at(0);  // Restituisce rune U+1F680\n```\n\n**`chars()`** - Converte in array di rune (codepoint):\n```hemlock\nlet s = \"ciao\";\nlet chars = s.chars();          // ['c', 'i', 'a', 'o'] (array di rune)\n\n// Esempio UTF-8\nlet text = \"Hi\";\nlet chars2 = text.chars();      // ['H', 'i', '']\n```\n\n**`byte_at(index)`** - Ottiene il valore byte all'indice (restituisce u8):\n```hemlock\nlet s = \"ciao\";\nlet byte = s.byte_at(0);        // 99 (valore ASCII di 'c')\n\n// Esempio UTF-8\nlet emoji = \"\";\nlet first_byte = emoji.byte_at(0);  // 240 (primo byte UTF-8)\n```\n\n**`bytes()`** - Converte in array di byte (valori u8):\n```hemlock\nlet s = \"ciao\";\nlet bytes = s.bytes();          // [99, 105, 97, 111] (array di u8)\n\n// Esempio UTF-8\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 byte UTF-8)\n```\n\n**`to_bytes()`** - Converte in buffer per accesso a basso livello:\n```hemlock\nlet s = \"ciao\";\nlet buf = s.to_bytes();         // Restituisce buffer con byte UTF-8\nprint(buf.length);              // 4\nfree(buf);                      // Ricorda di liberare\n```\n\n## Concatenamento dei metodi\n\nTutti i metodi stringa restituiscono nuove stringhe, consentendo il concatenamento:\n\n```hemlock\nlet result = \"  Ciao Mondo  \"\n    .trim()\n    .to_lower()\n    .replace(\"mondo\", \"hemlock\");  // \"ciao hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## Riferimento completo dei metodi\n\n| Metodo | Parametri | Restituisce | Descrizione |\n|--------|-----------|-------------|-------------|\n| `substr(start, length)` | i32, i32 | string | Estrae sottostringa per posizione e lunghezza |\n| `slice(start, end)` | i32, i32 | string | Estrae sottostringa per intervallo (end esclusivo) |\n| `find(needle)` | string | i32 | Trova prima occorrenza (-1 se non trovato) |\n| `contains(needle)` | string | bool | Verifica se contiene sottostringa |\n| `split(delimiter)` | string | array | Divide in array di stringhe |\n| `trim()` | - | string | Rimuove spazi bianchi iniziali/finali |\n| `to_upper()` | - | string | Converte in maiuscolo |\n| `to_lower()` | - | string | Converte in minuscolo |\n| `starts_with(prefix)` | string | bool | Verifica se inizia con prefisso |\n| `ends_with(suffix)` | string | bool | Verifica se finisce con suffisso |\n| `replace(old, new)` | string, string | string | Sostituisce prima occorrenza |\n| `replace_all(old, new)` | string, string | string | Sostituisce tutte le occorrenze |\n| `repeat(count)` | i32 | string | Ripete stringa n volte |\n| `char_at(index)` | i32 | rune | Ottiene codepoint all'indice |\n| `byte_at(index)` | i32 | u8 | Ottiene valore byte all'indice |\n| `chars()` | - | array | Converte in array di rune |\n| `bytes()` | - | array | Converte in array di byte u8 |\n| `to_bytes()` | - | buffer | Converte in buffer (deve essere liberato) |\n\n## Esempi\n\n### Esempio: Elaborazione del testo\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Normalizza gli spazi bianchi\n}\n\nlet input = \"  CIAO   MONDO  \";\nlet clean = process_input(input);  // \"ciao mondo\"\n```\n\n### Esempio: Parser CSV\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"mela, banana , ciliegia\";\nlet fields = parse_csv_line(csv);  // [\"mela\", \"banana\", \"ciliegia\"]\n```\n\n### Esempio: Contatore di parole\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"La volpe veloce e marrone\";\nlet count = count_words(sentence);  // 5\n```\n\n### Esempio: Validazione stringa\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## Gestione della memoria\n\nLe stringhe sono allocate nell'heap con conteggio interno dei riferimenti:\n\n- **Creazione**: Allocate nell'heap con tracciamento della capacita\n- **Concatenazione**: Crea nuova stringa (stringhe vecchie invariate)\n- **Metodi**: La maggior parte dei metodi restituisce nuove stringhe\n- **Ciclo di vita**: Le stringhe sono conteggiate per riferimento e liberate automaticamente quando lo scope termina\n\n**Pulizia automatica:**\n```hemlock\nfn create_strings() {\n    let s = \"ciao\";\n    let s2 = s + \" mondo\";  // Nuova allocazione\n}  // Sia s che s2 vengono liberati automaticamente quando la funzione ritorna\n```\n\n**Nota:** Le variabili stringa locali vengono pulite automaticamente quando escono dallo scope. Usa `free()` solo per la pulizia anticipata prima della fine dello scope o per dati globali/a lunga durata. Vedi [Gestione della memoria](memory.md#conteggio-interno-dei-riferimenti) per i dettagli.\n\n## Buone pratiche\n\n1. **Usa l'indicizzazione per codepoint** - Le stringhe usano posizioni codepoint, non offset di byte\n2. **Testa con Unicode** - Testa sempre le operazioni sulle stringhe con caratteri multi-byte\n3. **Preferisci operazioni immutabili** - Usa metodi che restituiscono nuove stringhe piuttosto che la mutazione\n4. **Controlla i limiti** - L'indicizzazione delle stringhe non controlla i limiti (restituisce null/errore su indice non valido)\n5. **Normalizza l'input** - Usa `trim()` e `to_lower()` per l'input utente\n\n## Trabocchetti comuni\n\n### Trabocchetto: Confusione byte vs. codepoint\n\n```hemlock\nlet emoji = \"\";\nprint(emoji.length);        // 1 (codepoint)\nprint(emoji.byte_length);   // 4 (byte)\n\n// Non mescolare operazioni su byte e codepoint\nlet byte = emoji.byte_at(0);  // 240 (primo byte)\nlet char = emoji.char_at(0);  // '' (codepoint completo)\n```\n\n### Trabocchetto: Sorprese nella mutazione\n\n```hemlock\nlet s1 = \"ciao\";\nlet s2 = s1;       // Copia superficiale\ns1[0] = 'C';       // Muta s1\nprint(s2);         // Ancora \"ciao\" (le stringhe sono tipi valore)\n```\n\n## Argomenti correlati\n\n- [Rune](#language-guide-runes) - Tipo codepoint Unicode usato nell'indicizzazione delle stringhe\n- [Array](#language-guide-arrays) - I metodi stringa spesso restituiscono o lavorano con array\n- [Tipi](#language-guide-types) - Dettagli sul tipo stringa e conversioni\n\n## Vedi anche\n\n- **Codifica UTF-8**: Vedi sezione \"Strings\" di CLAUDE.md\n- **Conversioni di tipo**: Vedi [Tipi](#language-guide-types) per le conversioni di stringa\n- **Memoria**: Vedi [Memoria](#language-guide-memory) per i dettagli sull'allocazione delle stringhe\n"}, "Guida al Linguaggio -> Tipi": {"id": "language-guide-types", "content": "# Sistema dei tipi\n\nHemlock presenta un **sistema di tipi dinamico** con annotazioni di tipo opzionali e verifica dei tipi a runtime.\n\n---\n\n## Guida alla selezione dei tipi: Quale tipo devo usare?\n\n**Nuovo ai tipi?** Inizia qui. Se hai familiarita con i sistemi di tipi, vai a [Filosofia](#filosofia).\n\n### La risposta breve\n\n**Lascia che Hemlock lo capisca da solo:**\n\n```hemlock\nlet count = 42;        // Hemlock sa che questo e un intero\nlet price = 19.99;     // Hemlock sa che questo e un decimale\nlet name = \"Alice\";    // Hemlock sa che questo e testo\nlet active = true;     // Hemlock sa che questo e si/no\n```\n\nHemlock sceglie automaticamente il tipo giusto per i tuoi valori. Non *devi* specificare i tipi.\n\n### Quando aggiungere annotazioni di tipo\n\nAggiungi i tipi quando vuoi:\n\n1. **Essere specifico sulla dimensione** - `i8` vs `i64` conta per la memoria o FFI\n2. **Documentare il codice** - I tipi mostrano cosa si aspetta una funzione\n3. **Catturare errori presto** - Hemlock verifica i tipi a runtime\n\n```hemlock\n// Senza tipi (funziona bene):\nfn add(a, b) {\n    return a + b;\n}\n\n// Con tipi (piu esplicito):\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Riferimento rapido: Scelta dei tipi numerici\n\n| Cosa stai memorizzando | Tipo suggerito | Esempio |\n|------------------------|----------------|---------|\n| Numeri interi normali | `i32` (predefinito) | `let count = 42;` |\n| Numeri molto grandi | `i64` | `let population = 8000000000;` |\n| Conteggi mai negativi | `u32` | `let items: u32 = 100;` |\n| Byte (0-255) | `u8` | `let pixel: u8 = 255;` |\n| Decimali/frazioni | `f64` (predefinito) | `let price = 19.99;` |\n| Decimali critici per le prestazioni | `f32` | `let x: f32 = 1.5;` |\n\n### Riferimento rapido: Tutti i tipi\n\n| Categoria | Tipi | Quando usare |\n|-----------|------|--------------|\n| **Numeri interi** | `i8`, `i16`, `i32`, `i64` | Conteggi, ID, eta, ecc. |\n| **Numeri solo positivi** | `u8`, `u16`, `u32`, `u64` | Byte, dimensioni, lunghezze di array |\n| **Decimali** | `f32`, `f64` | Denaro, misurazioni, matematica |\n| **Si/No** | `bool` | Flag, condizioni |\n| **Testo** | `string` | Nomi, messaggi, qualsiasi testo |\n| **Singolo carattere** | `rune` | Singole lettere, emoji |\n| **Liste** | `array` | Collezioni di valori |\n| **Campi con nome** | `object` | Raggruppamento di dati correlati |\n| **Memoria raw** | `ptr`, `buffer` | Programmazione a basso livello |\n| **Nulla** | `null` | Assenza di un valore |\n\n### Scenari comuni\n\n**\"Ho solo bisogno di un numero\"**\n```hemlock\nlet x = 42;  // Fatto! Hemlock sceglie i32\n```\n\n**\"Ho bisogno di decimali\"**\n```hemlock\nlet price = 19.99;  // Fatto! Hemlock sceglie f64\n```\n\n**\"Sto lavorando con byte (file, rete)\"**\n```hemlock\nlet byte: u8 = 255;  // Intervallo 0-255\n```\n\n**\"Ho bisogno di numeri veramente grandi\"**\n```hemlock\nlet big = 9000000000000;  // Hemlock sceglie automaticamente i64 (> max i32)\n// Oppure sii esplicito:\nlet big: i64 = 9000000000000;\n```\n\n**\"Sto memorizzando denaro\"**\n```hemlock\n// Opzione 1: Float (semplice, ma ha limiti di precisione)\nlet price: f64 = 19.99;\n\n// Opzione 2: Memorizza come centesimi (piu preciso)\nlet price_cents: i32 = 1999;  // 19.99 euro come centesimi interi\n```\n\n**\"Sto passando dati al codice C (FFI)\"**\n```hemlock\n// Fai corrispondere esattamente i tipi C\nlet c_int: i32 = 100;      // C 'int'\nlet c_long: i64 = 100;     // C 'long' (su 64-bit)\nlet c_char: u8 = 65;       // C 'char'\nlet c_double: f64 = 3.14;  // C 'double'\n```\n\n### Cosa succede quando i tipi si mescolano?\n\nQuando combini tipi diversi, Hemlock promuove al tipo \"piu grande\":\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // result e f64 (12.5)\n// L'intero e diventato automaticamente un decimale\n```\n\n**Regola generale:** I float \"vincono\" sempre - mescolare qualsiasi intero con un float ti da un float.\n\n### Errori di tipo\n\nSe provi a usare il tipo sbagliato, Hemlock te lo dice a runtime:\n\n```hemlock\nlet age: i32 = \"trenta\";  // ERRORE: tipo non corrispondente - atteso i32, ottenuto string\n```\n\nPer convertire i tipi, usa le funzioni costruttore di tipo:\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // Analizza stringa in intero: 42\nlet back = text + \"\";     // Gia una stringa\n```\n\n---\n\n## Filosofia\n\n- **Dinamico per impostazione predefinita** - Ogni valore ha un tag di tipo a runtime\n- **Tipizzato per scelta** - Le annotazioni di tipo opzionali impongono controlli a runtime\n- **Conversioni esplicite** - Le conversioni implicite seguono regole di promozione chiare\n- **Onesto sui tipi** - `typeof()` dice sempre la verita\n\n## Tipi primitivi\n\n### Tipi interi\n\n**Interi con segno:**\n```hemlock\nlet tiny: i8 = 127;              // 8-bit  (-128 a 127)\nlet small: i16 = 32767;          // 16-bit (-32768 a 32767)\nlet normal: i32 = 2147483647;    // 32-bit (predefinito)\nlet large: i64 = 9223372036854775807;  // 64-bit\n```\n\n**Interi senza segno:**\n```hemlock\nlet byte: u8 = 255;              // 8-bit  (0 a 255)\nlet word: u16 = 65535;           // 16-bit (0 a 65535)\nlet dword: u32 = 4294967295;     // 32-bit (0 a 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64-bit\n```\n\n**Alias di tipo:**\n```hemlock\nlet i: integer = 42;   // Alias per i32\nlet b: byte = 255;     // Alias per u8\n```\n\n### Tipi in virgola mobile\n\n```hemlock\nlet f: f32 = 3.14159;        // float 32-bit\nlet d: f64 = 2.718281828;    // float 64-bit (predefinito)\nlet n: number = 1.618;       // Alias per f64\n```\n\n### Tipo booleano\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### Tipo stringa\n\n```hemlock\nlet text: string = \"Ciao, Mondo!\";\nlet empty: string = \"\";\n```\n\nLe stringhe sono **mutabili**, **codificate UTF-8** e **allocate nell'heap**.\n\nVedi [Stringhe](#language-guide-strings) per i dettagli completi.\n\n### Tipo rune\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nLe rune rappresentano **codepoint Unicode** (da U+0000 a U+10FFFF).\n\nVedi [Rune](#language-guide-runes) per i dettagli completi.\n\n### Tipo null\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null` e un tipo proprio con un singolo valore.\n\n## Tipi composti\n\n### Tipo array\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"due\", true, null];  // Tipi misti consentiti\nlet empty: array = [];\n```\n\nVedi [Array](#language-guide-arrays) per i dettagli completi.\n\n### Tipo oggetto\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\nVedi [Oggetti](#language-guide-objects) per i dettagli completi.\n\n### Tipi puntatore\n\n**Puntatore raw:**\n```hemlock\nlet p: ptr = alloc(64);\n// Nessun controllo dei limiti, gestione manuale del ciclo di vita\nfree(p);\n```\n\n**Buffer sicuro:**\n```hemlock\nlet buf: buffer = buffer(64);\n// Controllo dei limiti, tiene traccia di lunghezza e capacita\nfree(buf);\n```\n\nVedi [Gestione della memoria](#language-guide-memory) per i dettagli completi.\n\n## Tipi enum\n\nGli enum definiscono un insieme di costanti con nome:\n\n### Enum di base\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// Confronto\nif (c == Color.RED) {\n    print(\"E rosso!\");\n}\n\n// Switch su enum\nswitch (c) {\n    case Color.RED:\n        print(\"Stop\");\n        break;\n    case Color.GREEN:\n        print(\"Vai\");\n        break;\n    case Color.BLUE:\n        print(\"Blu?\");\n        break;\n}\n```\n\n### Enum con valori\n\nGli enum possono avere valori interi espliciti:\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### Valori auto-incrementanti\n\nSenza valori espliciti, gli enum auto-incrementano da 0:\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// Puoi mescolare valori espliciti e automatici\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### Pattern di utilizzo degli enum\n\n```hemlock\n// Come parametri di funzione\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Urgente!\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// Negli oggetti\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Correggere bug\",\n    priority: Priority.HIGH\n};\n```\n\n## Tipi speciali\n\n### Tipo file\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\nRappresenta un handle di file aperto.\n\n### Tipo task\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\nRappresenta un handle di task asincrono.\n\n### Tipo channel\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\nRappresenta un canale di comunicazione tra task.\n\n### Tipo void\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\nUsato per funzioni che non restituiscono un valore (solo FFI).\n\n## Inferenza di tipo\n\n### Inferenza dei letterali interi\n\nHemlock inferisce i tipi interi in base all'intervallo di valori:\n\n```hemlock\nlet a = 42;              // i32 (entra in 32-bit)\nlet b = 5000000000;      // i64 (> max i32)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (annotazione esplicita)\n```\n\n**Regole:**\n- Valori nell'intervallo i32 (da -2147483648 a 2147483647): inferiti come `i32`\n- Valori fuori dall'intervallo i32 ma dentro i64: inferiti come `i64`\n- Usa annotazioni esplicite per altri tipi (i8, i16, u8, u16, u32, u64)\n\n### Inferenza dei letterali float\n\n```hemlock\nlet x = 3.14;        // f64 (predefinito)\nlet y: f32 = 3.14;   // f32 (esplicito)\n```\n\n### Notazione scientifica\n\nHemlock supporta la notazione scientifica per i letterali numerici:\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // Maiuscolo/minuscolo irrilevante\nlet f = 1e+5;        // Esponente positivo esplicito\n```\n\n**Nota:** Qualsiasi letterale che usa la notazione scientifica e sempre inferito come `f64`.\n\n### Altra inferenza di tipo\n\n```hemlock\nlet s = \"ciao\";      // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## Annotazioni di tipo\n\n### Annotazioni di variabile\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### Annotazioni dei parametri di funzione\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Ciao, \" + name + \"!\");\n}\n```\n\n### Annotazioni del tipo di ritorno delle funzioni\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Annotazioni di tipo oggetto (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## Verifica dei tipi\n\n### Verifica dei tipi a runtime\n\nLe annotazioni di tipo vengono verificate a **runtime**, non a tempo di compilazione:\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Errore runtime: tipo non corrispondente\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"ciao\");      // Errore runtime: tipo non corrispondente\n```\n\n### Query di tipo\n\nUsa `typeof()` per verificare i tipi dei valori:\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"ciao\"));     // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## Conversioni di tipo\n\n### Promozione di tipo implicita\n\nQuando si mescolano tipi nelle operazioni, Hemlock promuove al tipo \"superiore\":\n\n**Gerarchia di promozione (dal piu basso al piu alto):**\n```\ni8  i16  i32  u32  i64  u64  f32  f64\n                \n     u8    u16\n```\n\n**Il float vince sempre:**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result e f64 (13.5)\n```\n\n**La dimensione maggiore vince:**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum e i64 (300)\n```\n\n**Preservazione della precisione:** Quando si mescolano interi a 64-bit con f32, Hemlock promuove\na f64 per evitare perdita di precisione (f32 ha solo mantissa a 24-bit, insufficiente per i64/u64):\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // result e f64, non f32!\n```\n\n**Esempi:**\n```hemlock\nu8 + i32   i32\ni32 + i64  i64\nu32 + u64  u64\ni32 + f32  f32    // f32 sufficiente per i32\ni64 + f32  f64    // f64 necessario per preservare precisione i64\ni64 + f64  f64\ni8 + f64   f64\n```\n\n### Conversione di tipo esplicita\n\n**Intero  Float:**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32  f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64  i32 (3, troncato)\n```\n\n**Intero  Rune:**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32  rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune  i32 (90)\n```\n\n**Rune  Stringa:**\n```hemlock\nlet ch: rune = '';\nlet s: string = ch;   // rune  string (\"\")\n```\n\n**u8  Rune:**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8  rune ('A')\n```\n\n### Funzioni costruttore di tipo\n\nI nomi dei tipi possono essere usati come funzioni per convertire o analizzare valori:\n\n**Analisi di stringhe in numeri:**\n```hemlock\nlet n = i32(\"42\");       // Analizza stringa in i32: 42\nlet f = f64(\"3.14159\");  // Analizza stringa in f64: 3.14159\nlet b = bool(\"true\");    // Analizza stringa in bool: true\n\n// Tutti i tipi numerici supportati\nlet a = i8(\"-128\");      // Analizza in i8\nlet c = u8(\"255\");       // Analizza in u8\nlet d = i16(\"1000\");     // Analizza in i16\nlet e = u16(\"50000\");    // Analizza in u16\nlet g = i64(\"9000000000000\"); // Analizza in i64\nlet h = u64(\"18000000000000\"); // Analizza in u64\nlet j = f32(\"1.5\");      // Analizza in f32\n```\n\n**Numeri esadecimali e negativi:**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10 (binario)\n```\n\n**Funzionano anche gli alias di tipo:**\n```hemlock\nlet x = integer(\"100\");  // Uguale a i32(\"100\")\nlet y = number(\"1.5\");   // Uguale a f64(\"1.5\")\nlet z = byte(\"200\");     // Uguale a u8(\"200\")\n```\n\n**Conversione tra tipi numerici:**\n```hemlock\nlet big = i64(42);           // i32 a i64\nlet truncated = i32(3.99);   // f64 a i32 (tronca a 3)\nlet promoted = f64(100);     // i32 a f64 (100.0)\nlet narrowed = i8(127);      // i32 a i8\n```\n\n**Le annotazioni di tipo eseguono coercizione numerica (ma NON analisi di stringhe):**\n```hemlock\nlet f: f64 = 100;        // i32 a f64 via annotazione (OK)\nlet s: string = 'A';     // Rune a string via annotazione (OK)\nlet code: i32 = 'A';     // Rune a i32 via annotazione (ottiene codepoint, OK)\n\n// L'analisi di stringhe richiede costruttori di tipo espliciti:\nlet n = i32(\"42\");       // Usa costruttore di tipo per analisi stringa\n// let x: i32 = \"42\";    // ERRORE - le annotazioni di tipo non analizzano stringhe\n```\n\n**Gestione degli errori:**\n```hemlock\n// Stringhe non valide generano errori quando si usano costruttori di tipo\nlet bad = i32(\"ciao\");   // Errore runtime: impossibile analizzare \"ciao\" come i32\nlet overflow = u8(\"256\"); // Errore runtime: 256 fuori intervallo per u8\n```\n\n**Analisi booleana:**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"si\");    // Errore runtime: deve essere \"true\" o \"false\"\n```\n\n## Verifica degli intervalli\n\nLe annotazioni di tipo impongono controlli di intervallo all'assegnazione:\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // ERRORE: fuori intervallo per u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // ERRORE: fuori intervallo per i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // ERRORE: u64 non puo essere negativo\n```\n\n## Esempi di promozione di tipo\n\n### Tipi interi misti\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### Intero + Float\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### Espressioni complesse\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Valutazione: b * c  f64(60.0)\n//              a + f64(60.0)  f64(70.0)\n```\n\n## Duck Typing (Oggetti)\n\nGli oggetti usano il **typing strutturale** (duck typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Ha tutti i campi richiesti\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Campi extra consentiti\nlet p2: Person = { name: \"Bob\", age: 25, city: \"Milano\" };\n\n// ERRORE: Campo 'age' mancante\nlet p3: Person = { name: \"Carol\" };\n\n// ERRORE: Tipo sbagliato per 'age'\nlet p4: Person = { name: \"Dave\", age: \"trenta\" };\n```\n\n**La verifica del tipo avviene all'assegnazione:**\n- Verifica che tutti i campi richiesti siano presenti\n- Verifica che i tipi dei campi corrispondano\n- I campi extra sono consentiti e preservati\n- Imposta il nome del tipo dell'oggetto per `typeof()`\n\n## Campi opzionali\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Opzionale con default\n    timeout?: i32,     // Opzionale, predefinito a null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (predefinito)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (sovrascritto)\n```\n\n## Alias di tipo\n\nHemlock supporta alias di tipo personalizzati usando la parola chiave `type`:\n\n### Alias di tipo di base\n\n```hemlock\n// Alias di tipo semplice\ntype Integer = i32;\ntype Text = string;\n\n// Uso dell'alias\nlet x: Integer = 42;\nlet msg: Text = \"ciao\";\n```\n\n### Alias di tipo funzione\n\n```hemlock\n// Alias di tipo funzione\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Uso degli alias di tipo funzione\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### Alias di tipo composto\n\n```hemlock\n// Combina piu define in un tipo\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### Alias di tipo generico\n\n```hemlock\n// Alias di tipo generico\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Uso degli alias generici\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Nota:** Gli alias di tipo sono trasparenti - `typeof()` restituisce il nome del tipo sottostante, non l'alias.\n\n## Limitazioni del sistema dei tipi\n\nLimitazioni attuali:\n\n- **Nessun generico sulle funzioni** - Parametri di tipo delle funzioni non ancora supportati\n- **Nessun tipo union** - Impossibile esprimere \"A o B\"\n- **Nessun tipo nullable** - Tutti i tipi possono essere null (usa suffisso `?` per nullabilita esplicita)\n\n**Nota:** Il compilatore (`hemlockc`) fornisce verifica dei tipi a tempo di compilazione. L'interprete esegue solo verifica dei tipi a runtime. Vedi la [documentazione del compilatore](#design-implementation) per i dettagli.\n\n## Buone pratiche\n\n### Quando usare le annotazioni di tipo\n\n**USA le annotazioni quando:**\n- Il tipo preciso conta (es. `u8` per valori byte)\n- Documenti interfacce di funzione\n- Imponi vincoli (es. controlli di intervallo)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // Implementazione\n}\n```\n\n**NON usare le annotazioni quando:**\n- Il tipo e ovvio dal letterale\n- Dettagli di implementazione interni\n- Cerimonia non necessaria\n\n```hemlock\n// Non necessario\nlet x: i32 = 42;\n\n// Meglio\nlet x = 42;\n```\n\n### Pattern di sicurezza dei tipi\n\n**Verifica prima dell'uso:**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Sicuro usare come i32\n}\n```\n\n**Valida gli argomenti delle funzioni:**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"gli argomenti devono essere interi\";\n    }\n    if (b == 0) {\n        throw \"divisione per zero\";\n    }\n    return a / b;\n}\n```\n\n**Usa il duck typing per flessibilita:**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## Prossimi passi\n\n- [Stringhe](#language-guide-strings) - Tipo stringa UTF-8 e operazioni\n- [Rune](#language-guide-runes) - Tipo codepoint Unicode\n- [Array](#language-guide-arrays) - Tipo array dinamico\n- [Oggetti](#language-guide-objects) - Letterali oggetto e duck typing\n- [Memoria](#language-guide-memory) - Tipi puntatore e buffer\n"}, "Argomenti Avanzati -> Argomenti da Riga di Comando": {"id": "advanced-command-line-args", "content": "# Argomenti da Riga di Comando in Hemlock\n\nI programmi Hemlock possono accedere agli argomenti da riga di comando tramite un **array `args` built-in** che viene automaticamente popolato all'avvio del programma.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [L'Array args](#larray-args)\n- [Proprieta](#proprieta)\n- [Pattern di Iterazione](#pattern-di-iterazione)\n- [Casi d'Uso Comuni](#casi-duso-comuni)\n- [Pattern di Parsing degli Argomenti](#pattern-di-parsing-degli-argomenti)\n- [Migliori Pratiche](#migliori-pratiche)\n- [Esempi Completi](#esempi-completi)\n\n## Panoramica\n\nL'array `args` fornisce accesso agli argomenti da riga di comando passati al tuo programma Hemlock:\n\n- **Sempre disponibile** - Variabile globale built-in in tutti i programmi Hemlock\n- **Nome script incluso** - `args[0]` contiene sempre il percorso/nome dello script\n- **Array di stringhe** - Tutti gli argomenti sono stringhe\n- **Indicizzato da zero** - Indicizzazione standard degli array (0, 1, 2, ...)\n\n## L'Array args\n\n### Struttura Base\n\n```hemlock\n// args[0] e sempre il nome del file script\n// args[1] fino a args[n-1] sono gli argomenti effettivi\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Numero totale di argomenti (incluso nome script)\n```\n\n### Esempio di Utilizzo\n\n**Comando:**\n```bash\n./hemlock script.hml ciao mondo \"test 123\"\n```\n\n**In script.hml:**\n```hemlock\nprint(\"Nome script: \" + args[0]);     // \"script.hml\"\nprint(\"Totale args: \" + typeof(args.length));  // \"4\"\nprint(\"Primo arg: \" + args[1]);       // \"ciao\"\nprint(\"Secondo arg: \" + args[2]);     // \"mondo\"\nprint(\"Terzo arg: \" + args[3]);       // \"test 123\"\n```\n\n### Riferimento Indici\n\n| Indice | Contiene | Valore Esempio |\n|--------|----------|----------------|\n| `args[0]` | Percorso/nome script | `\"script.hml\"` o `\"./script.hml\"` |\n| `args[1]` | Primo argomento | `\"ciao\"` |\n| `args[2]` | Secondo argomento | `\"mondo\"` |\n| `args[3]` | Terzo argomento | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | Ultimo argomento | (varia) |\n\n## Proprieta\n\n### Sempre Presente\n\n`args` e un array globale disponibile in **tutti** i programmi Hemlock:\n\n```hemlock\n// Nessun bisogno di dichiarare o importare\nprint(args.length);  // Funziona immediatamente\n```\n\n### Nome Script Incluso\n\n`args[0]` contiene sempre il percorso/nome dello script:\n\n```hemlock\nprint(\"In esecuzione: \" + args[0]);\n```\n\n**Possibili valori per args[0]:**\n- `\"script.hml\"` - Solo il nome del file\n- `\"./script.hml\"` - Percorso relativo\n- `\"/home/utente/script.hml\"` - Percorso assoluto\n- Dipende da come lo script e stato invocato\n\n### Tipo: Array di Stringhe\n\nTutti gli argomenti sono memorizzati come stringhe:\n\n```hemlock\n// Argomenti: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (stringa, non numero)\nprint(args[2]);  // \"3.14\" (stringa, non numero)\nprint(args[3]);  // \"true\" (stringa, non booleano)\n\n// Converti se necessario:\nlet num = 42;  // Parsa manualmente se necessario\n```\n\n### Lunghezza Minima\n\nSempre almeno 1 (il nome dello script):\n\n```hemlock\nprint(args.length);  // Minimo: 1\n```\n\n**Anche senza argomenti:**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// In script.hml:\nprint(args.length);  // 1 (solo nome script)\n```\n\n### Comportamento REPL\n\nNel REPL, `args.length` e 0 (array vuoto):\n\n```hemlock\n# Sessione REPL\n> print(args.length);\n0\n```\n\n## Pattern di Iterazione\n\n### Iterazione Base\n\nSalta `args[0]` (nome script) ed elabora gli argomenti effettivi:\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argomento \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**Output per: `./hemlock script.hml pippo pluto paperino`**\n```\nArgomento 1: pippo\nArgomento 2: pluto\nArgomento 3: paperino\n```\n\n### Iterazione For-In (Incluso Nome Script)\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**Output:**\n```\nscript.hml\npippo\npluto\npaperino\n```\n\n### Controllo del Conteggio Argomenti\n\n```hemlock\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <argomento>\");\n    // exit o return\n} else {\n    let arg = args[1];\n    // elabora arg\n}\n```\n\n### Elaborazione di Tutti gli Argomenti Tranne il Nome Script\n\n```hemlock\nlet args_effettivi = args.slice(1, args.length);\n\nfor (let arg in args_effettivi) {\n    print(\"Elaborazione: \" + arg);\n}\n```\n\n## Casi d'Uso Comuni\n\n### 1. Elaborazione Semplice di Argomenti\n\nControllo per argomento richiesto:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <nomefile>\");\n} else {\n    let nomefile = args[1];\n    print(\"Elaborazione file: \" + nomefile);\n    // ... elabora file\n}\n```\n\n**Utilizzo:**\n```bash\n./hemlock script.hml dati.txt\n# Output: Elaborazione file: dati.txt\n```\n\n### 2. Argomenti Multipli\n\n```hemlock\nif (args.length < 3) {\n    print(\"Uso: \" + args[0] + \" <input> <output>\");\n} else {\n    let file_input = args[1];\n    let file_output = args[2];\n\n    print(\"Input: \" + file_input);\n    print(\"Output: \" + file_output);\n\n    // Elabora file...\n}\n```\n\n**Utilizzo:**\n```bash\n./hemlock converti.hml input.txt output.txt\n```\n\n### 3. Numero Variabile di Argomenti\n\nElabora tutti gli argomenti forniti:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Elaborazione \" + typeof(args.length - 1) + \" file:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        elabora_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**Utilizzo:**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. Messaggio di Aiuto\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Uso: \" + args[0] + \" [OPZIONI] <file>\");\n    print(\"Opzioni:\");\n    print(\"  -h, --help     Mostra questo messaggio di aiuto\");\n    print(\"  -v, --verbose  Abilita output verboso\");\n} else {\n    // Elabora normalmente\n}\n```\n\n### 5. Validazione degli Argomenti\n\n```hemlock\nfn valida_file(nomefile: string): bool {\n    // Controlla se il file esiste (esempio)\n    return nomefile != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Errore: Nessun nome file fornito\");\n} else if (!valida_file(args[1])) {\n    print(\"Errore: File non valido: \" + args[1]);\n} else {\n    print(\"Elaborazione: \" + args[1]);\n}\n```\n\n## Pattern di Parsing degli Argomenti\n\n### Argomenti con Nome (Flag)\n\nPattern semplice per argomenti con nome:\n\n```hemlock\nlet verboso = false;\nlet file_output = \"\";\nlet file_input = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verboso = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            file_output = args[i];\n        }\n    } else {\n        file_input = args[i];\n    }\n    i = i + 1;\n}\n\nif (verboso) {\n    print(\"Modalita verbosa abilitata\");\n}\nprint(\"Input: \" + file_input);\nprint(\"Output: \" + file_output);\n```\n\n**Utilizzo:**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### Flag Booleani\n\n```hemlock\nlet debug = false;\nlet verboso = false;\nlet forza = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verboso = true;\n    } else if (args[i] == \"--force\") {\n        forza = true;\n    }\n    i = i + 1;\n}\n```\n\n### Argomenti con Valore\n\n```hemlock\nlet file_config = \"default.conf\";\nlet porta = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            file_config = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            porta = 8080;  // Dovrebbe parsare la stringa in int\n        }\n    }\n    i = i + 1;\n}\n```\n\n### Argomenti Posizionali e con Nome Misti\n\n```hemlock\nlet file_input = \"\";\nlet file_output = \"\";\nlet verboso = false;\n\nlet i = 1;\nlet posizionali = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verboso = true;\n    } else {\n        // Tratta come argomento posizionale\n        posizionali.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Assegna argomenti posizionali\nif (posizionali.length > 0) {\n    file_input = posizionali[0];\n}\nif (posizionali.length > 1) {\n    file_output = posizionali[1];\n}\n```\n\n### Funzione Helper per Parser di Argomenti\n\n```hemlock\nfn parsa_args() {\n    let opzioni = {\n        verboso: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            opzioni.verboso = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                opzioni.output = args[i];\n            }\n        } else {\n            // Argomento posizionale\n            opzioni.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return opzioni;\n}\n\nlet opts = parsa_args();\nprint(\"Verboso: \" + typeof(opts.verboso));\nprint(\"Output: \" + opts.output);\nprint(\"File: \" + typeof(opts.files.length));\n```\n\n## Migliori Pratiche\n\n### 1. Controllare Sempre il Conteggio degli Argomenti\n\n```hemlock\n// Bene\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <file>\");\n} else {\n    elabora_file(args[1]);\n}\n\n// Male - potrebbe crashare se nessun argomento\nelabora_file(args[1]);  // Errore se args.length == 1\n```\n\n### 2. Fornire Informazioni di Utilizzo\n\n```hemlock\nfn mostra_uso() {\n    print(\"Uso: \" + args[0] + \" [OPZIONI] <file>\");\n    print(\"Opzioni:\");\n    print(\"  -h, --help     Mostra aiuto\");\n    print(\"  -v, --verbose  Output verboso\");\n}\n\nif (args.length < 2) {\n    mostra_uso();\n}\n```\n\n### 3. Validare gli Argomenti\n\n```hemlock\nfn valida_args() {\n    if (args.length < 2) {\n        print(\"Errore: Argomento richiesto mancante\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Errore: Argomento vuoto\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!valida_args()) {\n    // exit o mostra uso\n}\n```\n\n### 4. Usare Nomi di Variabili Descrittivi\n\n```hemlock\n// Bene\nlet nome_file_input = args[1];\nlet nome_file_output = args[2];\nlet max_iterazioni = args[3];\n\n// Male\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. Gestire Argomenti tra Virgolette con Spazi\n\nLa shell gestisce questo automaticamente:\n\n```bash\n./hemlock script.hml \"file con spazi.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file con spazi.txt\"\n```\n\n### 6. Creare Oggetti Argomento\n\n```hemlock\nfn ottieni_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet argomenti = ottieni_args();\nprint(\"Input: \" + argomenti.input);\n```\n\n## Esempi Completi\n\n### Esempio 1: Elaboratore di File\n\n```hemlock\n// Uso: ./hemlock elabora.hml <input> <output>\n\nfn mostra_uso() {\n    print(\"Uso: \" + args[0] + \" <file_input> <file_output>\");\n}\n\nif (args.length < 3) {\n    mostra_uso();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Elaborazione \" + input + \" -> \" + output);\n\n    // Elabora file\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let contenuto = f_in.read();\n        let elaborato = contenuto.to_upper();  // Elaborazione di esempio\n        f_out.write(elaborato);\n\n        print(\"Fatto!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### Esempio 2: Elaboratore Batch di File\n\n```hemlock\n// Uso: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Elaborazione \" + typeof(args.length - 1) + \" file:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let nomefile = args[i];\n        print(\"  Elaborazione: \" + nomefile);\n\n        try {\n            let f = open(nomefile, \"r\");\n            let contenuto = f.read();\n            f.close();\n\n            // Elabora contenuto...\n            print(\"    \" + typeof(contenuto.length) + \" byte\");\n        } catch (e) {\n            print(\"    Errore: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Fatto!\");\n}\n```\n\n### Esempio 3: Parser di Argomenti Avanzato\n\n```hemlock\n// Uso: ./hemlock app.hml [OPZIONI] <files...>\n// Opzioni:\n//   --verbose, -v     Abilita output verboso\n//   --output, -o FILE Imposta file di output\n//   --help, -h        Mostra aiuto\n\nfn parsa_argomenti() {\n    let config = {\n        verboso: false,\n        output: \"output.txt\",\n        aiuto: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verboso = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Errore: --output richiede un valore\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.aiuto = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Errore: Opzione sconosciuta: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn mostra_aiuto() {\n    print(\"Uso: \" + args[0] + \" [OPZIONI] <files...>\");\n    print(\"Opzioni:\");\n    print(\"  --verbose, -v     Abilita output verboso\");\n    print(\"  --output, -o FILE Imposta file di output\");\n    print(\"  --help, -h        Mostra questo aiuto\");\n}\n\nlet config = parsa_argomenti();\n\nif (config.aiuto) {\n    mostra_aiuto();\n} else if (config.files.length == 0) {\n    print(\"Errore: Nessun file di input specificato\");\n    mostra_aiuto();\n} else {\n    if (config.verboso) {\n        print(\"Modalita verbosa abilitata\");\n        print(\"File di output: \" + config.output);\n        print(\"File di input: \" + typeof(config.files.length));\n    }\n\n    // Elabora file\n    for (let file in config.files) {\n        if (config.verboso) {\n            print(\"Elaborazione: \" + file);\n        }\n        // ... elabora file\n    }\n}\n```\n\n### Esempio 4: Strumento di Configurazione\n\n```hemlock\n// Uso: ./hemlock config.hml <azione> [argomenti]\n// Azioni:\n//   get <chiave>\n//   set <chiave> <valore>\n//   list\n\nfn mostra_uso() {\n    print(\"Uso: \" + args[0] + \" <azione> [argomenti]\");\n    print(\"Azioni:\");\n    print(\"  get <chiave>         Ottieni valore di configurazione\");\n    print(\"  set <chiave> <valore> Imposta valore di configurazione\");\n    print(\"  list                 Lista tutta la configurazione\");\n}\n\nif (args.length < 2) {\n    mostra_uso();\n} else {\n    let azione = args[1];\n\n    if (azione == \"get\") {\n        if (args.length < 3) {\n            print(\"Errore: 'get' richiede una chiave\");\n        } else {\n            let chiave = args[2];\n            print(\"Ottenimento: \" + chiave);\n            // ... ottieni da config\n        }\n    } else if (azione == \"set\") {\n        if (args.length < 4) {\n            print(\"Errore: 'set' richiede chiave e valore\");\n        } else {\n            let chiave = args[2];\n            let valore = args[3];\n            print(\"Impostazione \" + chiave + \" = \" + valore);\n            // ... imposta in config\n        }\n    } else if (azione == \"list\") {\n        print(\"Lista di tutta la configurazione:\");\n        // ... lista config\n    } else {\n        print(\"Errore: Azione sconosciuta: \" + azione);\n        mostra_uso();\n    }\n}\n```\n\n## Riepilogo\n\nIl supporto agli argomenti da riga di comando di Hemlock fornisce:\n\n- Array `args` built-in disponibile globalmente\n- Semplice accesso basato su array agli argomenti\n- Nome script in `args[0]`\n- Tutti gli argomenti come stringhe\n- Metodi array disponibili (.length, .slice, ecc.)\n\nRicorda:\n- Controllare sempre `args.length` prima di accedere agli elementi\n- `args[0]` e il nome dello script\n- Gli argomenti effettivi iniziano da `args[1]`\n- Tutti gli argomenti sono stringhe - converti se necessario\n- Fornire informazioni di utilizzo per strumenti user-friendly\n- Validare gli argomenti prima dell'elaborazione\n\nPattern comuni:\n- Argomenti posizionali semplici\n- Argomenti con nome/flag (--flag)\n- Argomenti con valore (--opzione valore)\n- Messaggi di aiuto (--help)\n- Validazione degli argomenti\n"}, "Argomenti Avanzati -> Async e Concorrenza": {"id": "advanced-async-concurrency", "content": "# Async e Concorrenza in Hemlock\n\nHemlock fornisce **concorrenza strutturata** con sintassi async/await, creazione di task e canali per la comunicazione. L'implementazione utilizza thread POSIX (pthread) per **VERO parallelismo multi-thread**.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [Modello di Threading](#modello-di-threading)\n- [Funzioni Async](#funzioni-async)\n- [Creazione di Task](#creazione-di-task)\n- [Canali](#canali)\n- [Propagazione delle Eccezioni](#propagazione-delle-eccezioni)\n- [Dettagli di Implementazione](#dettagli-di-implementazione)\n- [Migliori Pratiche](#migliori-pratiche)\n- [Caratteristiche di Prestazione](#caratteristiche-di-prestazione)\n- [Limitazioni Attuali](#limitazioni-attuali)\n\n## Panoramica\n\n**Cosa significa:**\n- **Thread del sistema operativo reali** - Ogni task creato viene eseguito su un pthread separato (thread POSIX)\n- **Vero parallelismo** - I task vengono eseguiti simultaneamente su piu core della CPU\n- **Schedulato dal kernel** - Lo scheduler del sistema operativo distribuisce i task sui core disponibili\n- **Canali thread-safe** - Utilizza mutex pthread e variabili di condizione per la sincronizzazione\n\n**Cosa NON e:**\n- **NON green thread** - Non e multitasking cooperativo in spazio utente\n- **NON coroutine async/await** - Non e un event loop single-thread come JavaScript/Python asyncio\n- **NON concorrenza emulata** - Non e parallelismo simulato\n\nQuesto e lo **stesso modello di threading di C, C++ e Rust** quando si usano thread del sistema operativo. Si ottiene vera esecuzione parallela su piu core.\n\n## Modello di Threading\n\n### Threading 1:1\n\nHemlock utilizza un **modello di threading 1:1**, dove:\n- Ogni task creato crea un thread dedicato del sistema operativo tramite `pthread_create()`\n- Il kernel del sistema operativo schedula i thread sui core CPU disponibili\n- Multitasking preemptivo - il sistema operativo puo interrompere e passare tra i thread\n- **Nessun GIL** - A differenza di Python, non c'e un Global Interpreter Lock che limita il parallelismo\n\n### Meccanismi di Sincronizzazione\n\n- **Mutex** - I canali usano `pthread_mutex_t` per accesso thread-safe\n- **Variabili di condizione** - send/recv bloccanti usano `pthread_cond_t` per attesa efficiente\n- **Operazioni lock-free** - Le transizioni di stato dei task sono atomiche\n\n## Funzioni Async\n\nLe funzioni possono essere dichiarate come `async` per indicare che sono progettate per l'esecuzione concorrente:\n\n```hemlock\nasync fn calcola(n: i32): i32 {\n    let somma = 0;\n    let i = 0;\n    while (i < n) {\n        somma = somma + i;\n        i = i + 1;\n    }\n    return somma;\n}\n```\n\n### Punti Chiave\n\n- `async fn` dichiara una funzione asincrona\n- Le funzioni async possono essere create come task concorrenti usando `spawn()`\n- Le funzioni async possono anche essere chiamate direttamente (eseguite sincronamente nel thread corrente)\n- Quando create con spawn, ogni task viene eseguito sul **proprio thread del sistema operativo** (non una coroutine!)\n- La parola chiave `await` e riservata per uso futuro\n\n### Esempio: Chiamata Diretta vs Spawn\n\n```hemlock\nasync fn fattoriale(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * fattoriale(n - 1);\n}\n\n// Chiamata diretta - eseguita sincronamente\nlet risultato1 = fattoriale(5);  // 120\n\n// Task creato - eseguito su thread separato\nlet task = spawn(fattoriale, 5);\nlet risultato2 = join(task);  // 120\n```\n\n## Creazione di Task\n\nUsa `spawn()` per eseguire funzioni async **in parallelo su thread separati del sistema operativo**:\n\n```hemlock\nasync fn fattoriale(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * fattoriale(n - 1);\n}\n\n// Crea piu task - questi vengono eseguiti IN PARALLELO su diversi core della CPU!\nlet t1 = spawn(fattoriale, 5);  // Thread 1\nlet t2 = spawn(fattoriale, 6);  // Thread 2\nlet t3 = spawn(fattoriale, 7);  // Thread 3\n\n// Tutti e tre stanno calcolando simultaneamente in questo momento!\n\n// Attendi i risultati\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### Funzioni Built-in\n\n#### spawn(funzione_async, arg1, arg2, ...)\n\nCrea un nuovo task su un nuovo pthread, restituisce un handle del task.\n\n**Parametri:**\n- `funzione_async` - La funzione async da eseguire\n- `arg1, arg2, ...` - Argomenti da passare alla funzione\n\n**Restituisce:** Handle del task (valore opaco usato con `join()` o `detach()`)\n\n**Esempio:**\n```hemlock\nasync fn elabora(dati: string, conteggio: i32): i32 {\n    // ... logica di elaborazione\n    return conteggio * 2;\n}\n\nlet task = spawn(elabora, \"test\", 42);\n```\n\n#### join(task)\n\nAttende il completamento del task (blocca fino al termine del thread), restituisce il risultato.\n\n**Parametri:**\n- `task` - Handle del task restituito da `spawn()`\n\n**Restituisce:** Il valore restituito dalla funzione async\n\n**Esempio:**\n```hemlock\nlet task = spawn(calcola, 1000);\nlet risultato = join(task);  // Blocca fino al completamento di calcola()\nprint(risultato);\n```\n\n**Importante:** Ogni task puo essere joinato solo una volta. Join successivi daranno errore.\n\n#### detach(task)\n\nEsecuzione fire-and-forget (il thread viene eseguito indipendentemente, join non consentito).\n\n**Parametri:**\n- `task` - Handle del task restituito da `spawn()`\n\n**Restituisce:** `null`\n\n**Esempio:**\n```hemlock\nasync fn lavoro_in_background() {\n    // Task in background a lunga esecuzione\n    // ...\n}\n\nlet task = spawn(lavoro_in_background);\ndetach(task);  // Il task viene eseguito indipendentemente, non si puo fare join\n```\n\n**Importante:** I task detached non possono essere joinati. Sia il pthread che la struttura Task vengono automaticamente puliti quando il task viene completato.\n\n## Canali\n\nI canali forniscono comunicazione thread-safe tra task usando un buffer limitato con semantica bloccante.\n\n### Creazione di Canali\n\n```hemlock\nlet ch = channel(10);  // Crea canale con dimensione buffer di 10\n```\n\n**Parametri:**\n- `capacita` (i32) - Numero massimo di valori che il canale puo contenere\n\n**Restituisce:** Oggetto canale\n\n### Metodi del Canale\n\n#### send(valore)\n\nInvia valore al canale (blocca se pieno).\n\n```hemlock\nasync fn produttore(ch, conteggio: i32) {\n    let i = 0;\n    while (i < conteggio) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(produttore, ch, 5);\n```\n\n**Comportamento:**\n- Se il canale ha spazio, il valore viene aggiunto immediatamente\n- Se il canale e pieno, il mittente si blocca fino a quando lo spazio diventa disponibile\n- Se il canale e chiuso, lancia un'eccezione\n\n#### recv()\n\nRiceve valore dal canale (blocca se vuoto).\n\n```hemlock\nasync fn consumatore(ch, conteggio: i32): i32 {\n    let somma = 0;\n    let i = 0;\n    while (i < conteggio) {\n        let val = ch.recv();\n        somma = somma + val;\n        i = i + 1;\n    }\n    return somma;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumatore, ch, 5);\n```\n\n**Comportamento:**\n- Se il canale ha valori, restituisce immediatamente il prossimo valore\n- Se il canale e vuoto, il ricevitore si blocca fino a quando un valore e disponibile\n- Se il canale e chiuso e vuoto, restituisce `null`\n\n#### close()\n\nChiude il canale (recv su canale chiuso restituisce null).\n\n```hemlock\nch.close();\n```\n\n**Comportamento:**\n- Impedisce ulteriori operazioni `send()` (lanceranno eccezione)\n- Permette alle operazioni `recv()` in sospeso di completarsi\n- Una volta vuoto, `recv()` restituisce `null`\n\n### Multiplexing con select()\n\nLa funzione `select()` permette di attendere su piu canali simultaneamente, restituendo quando qualsiasi canale ha dati disponibili.\n\n**Firma:**\n```hemlock\nselect(canali: array, timeout_ms?: i32): object | null\n```\n\n**Parametri:**\n- `canali` - Array di valori canale\n- `timeout_ms` (opzionale) - Timeout in millisecondi (-1 o omettere per attesa infinita)\n\n**Restituisce:**\n- `{ channel, value }` - Oggetto con il canale che aveva dati e il valore ricevuto\n- `null` - Su timeout (se il timeout e stato specificato)\n\n**Esempio:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Task produttori\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"dal canale 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"dal canale 2\");\n});\n\n// Attende il primo risultato (ch2 dovrebbe essere piu veloce)\nlet risultato = select([ch1, ch2]);\nprint(risultato.value);  // \"dal canale 2\"\n\n// Attende il secondo risultato\nlet risultato2 = select([ch1, ch2]);\nprint(risultato2.value);  // \"dal canale 1\"\n```\n\n**Con timeout:**\n```hemlock\nlet ch = channel(1);\n\n// Nessun mittente, andra in timeout\nlet risultato = select([ch], 100);  // timeout 100ms\nif (risultato == null) {\n    print(\"Timeout scaduto!\");\n}\n```\n\n**Casi d'uso:**\n- Attendere il piu veloce tra piu sorgenti di dati\n- Implementare timeout sulle operazioni del canale\n- Pattern di event loop con piu sorgenti di eventi\n- Fan-in: unire piu canali in uno\n\n**Pattern fan-in:**\n```hemlock\nfn fan_in(canali: array, output: channel) {\n    while (true) {\n        let risultato = select(canali);\n        if (risultato == null) {\n            break;  // Tutti i canali chiusi\n        }\n        output.send(risultato.value);\n    }\n    output.close();\n}\n```\n\n### Esempio Completo Produttore-Consumatore\n\n```hemlock\nasync fn produttore(ch, conteggio: i32) {\n    let i = 0;\n    while (i < conteggio) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumatore(ch, conteggio: i32): i32 {\n    let somma = 0;\n    let i = 0;\n    while (i < conteggio) {\n        let val = ch.recv();\n        somma = somma + val;\n        i = i + 1;\n    }\n    return somma;\n}\n\n// Crea canale con dimensione buffer\nlet ch = channel(10);\n\n// Crea produttore e consumatore\nlet p = spawn(produttore, ch, 5);\nlet c = spawn(consumatore, ch, 5);\n\n// Attende il completamento\njoin(p);\nlet totale = join(c);  // 100 (0+10+20+30+40)\nprint(totale);\n```\n\n### Multi-Produttore, Multi-Consumatore\n\nI canali possono essere condivisi in sicurezza tra piu produttori e consumatori:\n\n```hemlock\nasync fn produttore(id: i32, ch, conteggio: i32) {\n    let i = 0;\n    while (i < conteggio) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumatore(id: i32, ch, conteggio: i32): i32 {\n    let somma = 0;\n    let i = 0;\n    while (i < conteggio) {\n        let val = ch.recv();\n        somma = somma + val;\n        i = i + 1;\n    }\n    return somma;\n}\n\nlet ch = channel(20);\n\n// Piu produttori\nlet p1 = spawn(produttore, 1, ch, 5);\nlet p2 = spawn(produttore, 2, ch, 5);\n\n// Piu consumatori\nlet c1 = spawn(consumatore, 1, ch, 5);\nlet c2 = spawn(consumatore, 2, ch, 5);\n\n// Attende tutti\njoin(p1);\njoin(p2);\nlet somma1 = join(c1);\nlet somma2 = join(c2);\nprint(somma1 + somma2);\n```\n\n## Propagazione delle Eccezioni\n\nLe eccezioni lanciate nei task creati vengono propagate quando si fa join:\n\n```hemlock\nasync fn operazione_rischiosa(deve_fallire: i32): i32 {\n    if (deve_fallire == 1) {\n        throw \"Task fallito!\";\n    }\n    return 42;\n}\n\nlet t = spawn(operazione_rischiosa, 1);\ntry {\n    let risultato = join(t);\n} catch (e) {\n    print(\"Catturato: \" + e);  // \"Catturato: Task fallito!\"\n}\n```\n\n### Pattern di Gestione delle Eccezioni\n\n**Pattern 1: Gestire nel task**\n```hemlock\nasync fn task_sicuro() {\n    try {\n        // operazione rischiosa\n    } catch (e) {\n        print(\"Errore nel task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(task_sicuro);\njoin(task);  // Nessuna eccezione propagata\n```\n\n**Pattern 2: Propagare al chiamante**\n```hemlock\nasync fn task_che_lancia() {\n    throw \"errore\";\n}\n\nlet task = spawn(task_che_lancia);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Catturato dal task: \" + e);\n}\n```\n\n**Pattern 3: Task detached con eccezioni**\n```hemlock\nasync fn task_detached() {\n    try {\n        // lavoro\n    } catch (e) {\n        // Deve gestire internamente - non puo propagare\n        print(\"Errore: \" + e);\n    }\n}\n\nlet task = spawn(task_detached);\ndetach(task);  // Non si possono catturare eccezioni da task detached\n```\n\n## Dettagli di Implementazione\n\n### Architettura di Threading\n\n- **Threading 1:1** - Ogni task creato crea un thread dedicato del sistema operativo tramite `pthread_create()`\n- **Schedulato dal kernel** - Il kernel del sistema operativo schedula i thread sui core CPU disponibili\n- **Multitasking preemptivo** - Il sistema operativo puo interrompere e passare tra i thread\n- **Nessun GIL** - A differenza di Python, non c'e un Global Interpreter Lock che limita il parallelismo\n\n### Implementazione dei Canali\n\nI canali usano un buffer circolare con sincronizzazione pthread:\n\n```\nStruttura Canale:\n- buffer[] - Array di dimensione fissa di valori\n- capacita - Numero massimo di elementi\n- dimensione - Numero attuale di elementi\n- testa - Posizione di lettura\n- coda - Posizione di scrittura\n- mutex - pthread_mutex_t per accesso thread-safe\n- non_vuoto - pthread_cond_t per recv bloccante\n- non_pieno - pthread_cond_t per send bloccante\n- chiuso - Flag booleano\n- refcount - Conteggio riferimenti per pulizia\n```\n\n**Comportamento bloccante:**\n- `send()` su canale pieno: attende sulla variabile di condizione `non_pieno`\n- `recv()` su canale vuoto: attende sulla variabile di condizione `non_vuoto`\n- Entrambi sono segnalati quando appropriato dall'operazione opposta\n\n### Memoria e Pulizia\n\n- **Task joinati:** Automaticamente puliti dopo che `join()` restituisce\n- **Task detached:** Automaticamente puliti quando il task viene completato\n- **Canali:** Conteggio riferimenti e liberati quando non piu usati\n\n## Migliori Pratiche\n\n### 1. Chiudere Sempre i Canali\n\n```hemlock\nasync fn produttore(ch) {\n    // ... invia valori\n    ch.close();  // Importante: segnala che non ci sono piu valori\n}\n```\n\n### 2. Usare Concorrenza Strutturata\n\nCreare task e fare join nello stesso scope:\n\n```hemlock\nfn elabora_dati(dati) {\n    // Crea task\n    let t1 = spawn(worker, dati);\n    let t2 = spawn(worker, dati);\n\n    // Sempre fare join prima di ritornare\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. Gestire le Eccezioni Appropriatamente\n\n```hemlock\nasync fn task() {\n    try {\n        // operazione rischiosa\n    } catch (e) {\n        // Log errore\n        throw e;  // Rilancia se il chiamante deve sapere\n    }\n}\n```\n\n### 4. Usare Capacita del Canale Appropriata\n\n- **Piccola capacita (1-10):** Per coordinazione/segnalazione\n- **Media capacita (10-100):** Per produttore-consumatore generale\n- **Grande capacita (100+):** Per scenari ad alto throughput\n\n```hemlock\nlet canale_segnale = channel(1);      // Coordinazione\nlet canale_lavoro = channel(50);      // Coda di lavoro\nlet canale_buffer = channel(1000);    // Alto throughput\n```\n\n### 5. Detach Solo Quando Necessario\n\nPreferire `join()` rispetto a `detach()` per una migliore gestione delle risorse:\n\n```hemlock\n// Buono: Join e ottieni risultato\nlet task = spawn(lavoro);\nlet risultato = join(task);\n\n// Usare detach solo per vero fire-and-forget\nlet task_bg = spawn(logging_in_background);\ndetach(task_bg);  // Verra eseguito indipendentemente\n```\n\n## Caratteristiche di Prestazione\n\n### Vero Parallelismo\n\n- **N task creati possono utilizzare N core CPU simultaneamente**\n- Speedup provato - test di stress mostrano 8-9x tempo CPU vs tempo wall (piu core lavorano)\n- Scalabilita lineare con il numero di core (fino al conteggio thread)\n\n### Overhead dei Thread\n\n- Ogni task ha ~8KB di stack + overhead pthread\n- Costo di creazione thread: ~10-20us\n- Costo di context switch: ~1-5us\n\n### Quando Usare Async\n\n**Buoni casi d'uso:**\n- Calcoli CPU-intensivi che possono essere parallelizzati\n- Operazioni I/O-bound (anche se l'I/O e ancora bloccante)\n- Elaborazione concorrente di dati indipendenti\n- Architetture pipeline con canali\n\n**Non ideale per:**\n- Task molto brevi (l'overhead del thread domina)\n- Task con sincronizzazione pesante (overhead di contesa)\n- Sistemi single-core (nessun beneficio dal parallelismo)\n\n### I/O Bloccante e Sicuro\n\nLe operazioni bloccanti in un task non bloccano gli altri:\n\n```hemlock\nasync fn lettore(nomefile: string) {\n    let f = open(nomefile, \"r\");  // Blocca solo questo thread\n    let contenuto = f.read();     // Blocca solo questo thread\n    f.close();\n    return contenuto;\n}\n\n// Entrambi leggono concorrentemente (su thread diversi)\nlet t1 = spawn(lettore, \"file1.txt\");\nlet t2 = spawn(lettore, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## Modello di Thread Safety\n\nHemlock usa un modello di concorrenza **message-passing** dove i task comunicano tramite canali piuttosto che stato mutabile condiviso.\n\n### Isolamento degli Argomenti\n\nQuando crei un task con spawn, **gli argomenti vengono copiati in profondita** per prevenire data race:\n\n```hemlock\nasync fn modifica_array(arr: array): array {\n    arr.push(999);    // Modifica la COPIA, non l'originale\n    arr[0] = -1;\n    return arr;\n}\n\nlet originale = [1, 2, 3];\nlet task = spawn(modifica_array, originale);\nlet modificato = join(task);\n\nprint(originale.length);  // 3 - invariato!\nprint(modificato.length);  // 4 - ha nuovo elemento\n```\n\n**Cosa viene copiato in profondita:**\n- Array (e tutti gli elementi ricorsivamente)\n- Oggetti (e tutti i campi ricorsivamente)\n- Stringhe\n- Buffer\n\n**Cosa viene condiviso (riferimento mantenuto):**\n- Canali (il meccanismo di comunicazione - intenzionalmente condiviso)\n- Handle dei task (per coordinazione)\n- Funzioni (il codice e immutabile)\n- Handle dei file (il sistema operativo gestisce l'accesso concorrente)\n- Handle dei socket (il sistema operativo gestisce l'accesso concorrente)\n\n**Cosa non puo essere passato:**\n- Puntatori raw (`ptr`) - usare `buffer` invece\n\n### Perche Message-Passing?\n\nQuesto segue la filosofia \"esplicito piuttosto che implicito\" di Hemlock:\n\n```hemlock\n// MALE: Stato mutabile condiviso (causerebbe data race)\nlet contatore = { valore: 0 };\nlet t1 = spawn(fn() { contatore.valore = contatore.valore + 1; });  // Race!\nlet t2 = spawn(fn() { contatore.valore = contatore.valore + 1; });  // Race!\n\n// BENE: Message-passing tramite canali\nasync fn incrementa(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(incrementa, ch);\njoin(t1);\nlet risultato = ch.recv();  // 1 - nessuna race condition\n```\n\n### Thread Safety del Conteggio Riferimenti\n\nTutte le operazioni di conteggio riferimenti usano **operazioni atomiche** per prevenire bug use-after-free:\n- `string_retain/release` - atomico\n- `array_retain/release` - atomico\n- `object_retain/release` - atomico\n- `buffer_retain/release` - atomico\n- `function_retain/release` - atomico\n- `channel_retain/release` - atomico\n- `task_retain/release` - atomico\n\nQuesto garantisce gestione sicura della memoria anche quando i valori sono condivisi tra thread.\n\n### Accesso all'Ambiente Closure\n\nI task hanno accesso all'ambiente closure per:\n- Funzioni built-in (`print`, `len`, ecc.)\n- Definizioni di funzioni globali\n- Costanti e variabili\n\nL'ambiente closure e protetto da un mutex per-ambiente, rendendo\nletture e scritture concorrenti thread-safe:\n\n```hemlock\nlet x = 10;\n\nasync fn leggi_closure(): i32 {\n    return x;  // OK: lettura variabile closure (thread-safe)\n}\n\nasync fn modifica_closure() {\n    x = 20;  // OK: scrittura variabile closure (sincronizzata con mutex)\n}\n```\n\n**Nota:** Mentre l'accesso concorrente e sincronizzato, modificare stato condiviso da\npiu task puo ancora portare a race condition logiche (ordinamento non deterministico).\nPer comportamento prevedibile, usare canali per comunicazione tra task o\nvalori di ritorno dai task.\n\nSe hai bisogno di restituire dati da un task, usa il valore di ritorno o i canali.\n\n## Limitazioni Attuali\n\n### 1. Nessuno Scheduler Work-Stealing\n\nUsa 1 thread per task, che puo essere inefficiente per molti task brevi.\n\n**Attuale:** 1000 task = 1000 thread (overhead pesante)\n\n**Pianificato:** Thread pool con work stealing per migliore efficienza\n\n### 3. Nessuna Integrazione I/O Asincrono\n\nLe operazioni su file/rete bloccano ancora il thread:\n\n```hemlock\nasync fn leggi_file(percorso: string) {\n    let f = open(percorso, \"r\");\n    let contenuto = f.read();  // Blocca il thread\n    f.close();\n    return contenuto;\n}\n```\n\n**Workaround:** Usare piu thread per operazioni I/O concorrenti\n\n### 4. Capacita del Canale Fissa\n\nLa capacita del canale e impostata alla creazione e non puo essere ridimensionata:\n\n```hemlock\nlet ch = channel(10);\n// Non si puo ridimensionare dinamicamente a 20\n```\n\n### 5. Dimensione del Canale e Fissa\n\nLa dimensione del buffer del canale non puo essere cambiata dopo la creazione.\n\n## Pattern Comuni\n\n### Map Parallelo\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_trasforma) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let risultato = fn_trasforma(val);\n        ch_out.send(risultato);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(dati, fn_trasforma, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Crea workers\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_trasforma));\n        i = i + 1;\n    }\n\n    // Invia dati\n    let i = 0;\n    while (i < dati.length) {\n        ch_in.send(dati[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Raccogli risultati\n    let risultati = [];\n    let i = 0;\n    while (i < dati.length) {\n        risultati.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Attendi i workers\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return risultati;\n}\n```\n\n### Architettura Pipeline\n\n```hemlock\nasync fn fase1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn fase2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Crea pipeline\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(fase1, ch1, ch2);\nlet s2 = spawn(fase2, ch2, ch3);\n\n// Alimenta input\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Raccogli output\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### Fan-Out, Fan-In\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Elabora valore\n        let risultato = val * id;\n        output_ch.send(risultato);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out: Piu workers\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Invia lavoro\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in: Raccogli tutti i risultati\nlet risultati = [];\nlet i = 0;\nwhile (i < 10) {\n    risultati.push(output.recv());\n    i = i + 1;\n}\n\n// Attendi tutti i workers\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## Riepilogo\n\nIl modello async/concorrenza di Hemlock fornisce:\n\n- Vero parallelismo multi-thread usando thread del sistema operativo\n- Primitive di concorrenza semplici e strutturate\n- Canali thread-safe per la comunicazione\n- Propagazione delle eccezioni tra task\n- Prestazioni provate su sistemi multi-core\n- **Isolamento degli argomenti** - copia profonda previene data race\n- **Conteggio riferimenti atomico** - gestione sicura della memoria tra thread\n\nQuesto rende Hemlock adatto per:\n- Calcoli paralleli\n- Operazioni I/O concorrenti\n- Architetture pipeline\n- Pattern produttore-consumatore\n\nEvitando la complessita di:\n- Gestione manuale dei thread\n- Primitive di sincronizzazione di basso livello\n- Design basati su lock soggetti a deadlock\n- Bug di stato mutabile condiviso\n"}, "Argomenti Avanzati -> Esecuzione di Comandi": {"id": "advanced-command-execution", "content": "# Esecuzione di Comandi in Hemlock\n\nHemlock fornisce la **funzione built-in `exec()`** per eseguire comandi shell e catturare il loro output.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [La Funzione exec()](#la-funzione-exec)\n- [Oggetto Risultato](#oggetto-risultato)\n- [Uso Base](#uso-base)\n- [Esempi Avanzati](#esempi-avanzati)\n- [Gestione degli Errori](#gestione-degli-errori)\n- [Dettagli di Implementazione](#dettagli-di-implementazione)\n- [Considerazioni sulla Sicurezza](#considerazioni-sulla-sicurezza)\n- [Limitazioni](#limitazioni)\n- [Casi d'Uso](#casi-duso)\n- [Migliori Pratiche](#migliori-pratiche)\n- [Esempi Completi](#esempi-completi)\n\n## Panoramica\n\nLa funzione `exec()` permette ai programmi Hemlock di:\n- Eseguire comandi shell\n- Catturare lo standard output (stdout)\n- Controllare i codici di stato di uscita\n- Usare funzionalita della shell (pipe, redirect, ecc.)\n- Integrarsi con utilita di sistema\n\n**Importante:** I comandi vengono eseguiti tramite `/bin/sh`, fornendo capacita complete della shell ma introducendo anche considerazioni sulla sicurezza.\n\n## La Funzione exec()\n\n### Firma\n\n```hemlock\nexec(comando: string): object\n```\n\n**Parametri:**\n- `comando` (string) - Comando shell da eseguire\n\n**Restituisce:** Un oggetto con due campi:\n- `output` (string) - L'output stdout del comando\n- `exit_code` (i32) - Il codice di stato di uscita del comando\n\n### Esempio Base\n\n```hemlock\nlet risultato = exec(\"echo ciao\");\nprint(risultato.output);      // \"ciao\\n\"\nprint(risultato.exit_code);   // 0\n```\n\n## Oggetto Risultato\n\nL'oggetto restituito da `exec()` ha la seguente struttura:\n\n```hemlock\n{\n    output: string,      // Stdout del comando (output catturato)\n    exit_code: i32       // Stato di uscita del processo (0 = successo)\n}\n```\n\n### Campo output\n\nContiene tutto il testo scritto su stdout dal comando.\n\n**Proprieta:**\n- Stringa vuota se il comando non produce output\n- Include newline e spazi cosi come sono\n- Output multi-linea preservato\n- Nessun limite di dimensione (allocato dinamicamente)\n\n**Esempi:**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Lista directory con newline\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (stringa vuota)\n```\n\n### Campo exit_code\n\nIl codice di stato di uscita del comando.\n\n**Valori:**\n- `0` tipicamente indica successo\n- `1-255` indicano errori (la convenzione varia per comando)\n- `-1` se il comando non ha potuto essere eseguito o e terminato in modo anomalo\n\n**Esempi:**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (successo)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (fallimento)\n\nlet r3 = exec(\"ls /inesistente\");\nprint(r3.exit_code);  // 2 (file non trovato, varia per comando)\n```\n\n## Uso Base\n\n### Comando Semplice\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Codice di uscita: \" + typeof(r.exit_code));\n```\n\n### Controllo Stato di Uscita\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Trovato: \" + r.output);\n} else {\n    print(\"Pattern non trovato\");\n}\n```\n\n### Comandi con Pipe\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### Comandi Multipli\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### Sostituzione di Comando\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Data corrente\n```\n\n## Esempi Avanzati\n\n### Gestione dei Fallimenti\n\n```hemlock\nlet r = exec(\"ls /inesistente\");\nif (r.exit_code != 0) {\n    print(\"Comando fallito con codice: \" + typeof(r.exit_code));\n    print(\"Output errore: \" + r.output);  // Nota: stderr non catturato\n}\n```\n\n### Elaborazione di Output Multi-Linea\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet righe = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < righe.length) {\n    print(\"Riga \" + typeof(i) + \": \" + righe[i]);\n    i = i + 1;\n}\n```\n\n### Concatenamento di Comandi\n\n**Con && (AND):**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup completato\");\n}\n```\n\n**Con || (OR):**\n```hemlock\nlet r = exec(\"comando1 || comando2\");\n// Esegue comando2 solo se comando1 fallisce\n```\n\n**Con ; (sequenza):**\n```hemlock\nlet r = exec(\"comando1; comando2\");\n// Esegue entrambi indipendentemente da successo/fallimento\n```\n\n### Uso di Pipe\n\n```hemlock\nlet r = exec(\"echo 'dati' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**Pipeline complesse:**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### Pattern di Codici di Uscita\n\nDiversi codici di uscita indicano condizioni diverse:\n\n```hemlock\nlet r = exec(\"test -f miofile.txt\");\nif (r.exit_code == 0) {\n    print(\"Il file esiste\");\n} else if (r.exit_code == 1) {\n    print(\"Il file non esiste\");\n} else {\n    print(\"Comando test fallito: \" + typeof(r.exit_code));\n}\n```\n\n### Redirect dell'Output\n\n```hemlock\n// Redirect stdout su file (all'interno della shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// Redirect stderr su stdout (Nota: stderr comunque non catturato da Hemlock)\nlet r2 = exec(\"comando 2>&1\");\n```\n\n### Variabili d'Ambiente\n\n```hemlock\nlet r = exec(\"export VAR=valore && echo $VAR\");\nprint(r.output);  // \"valore\\n\"\n```\n\n### Cambi di Directory di Lavoro\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## Gestione degli Errori\n\n### Quando exec() Lancia Eccezioni\n\nLa funzione `exec()` lancia un'eccezione se il comando non puo essere eseguito:\n\n```hemlock\ntry {\n    let r = exec(\"comando_inesistente_xyz\");\n} catch (e) {\n    print(\"Esecuzione fallita: \" + e);\n}\n```\n\n**Eccezioni lanciate quando:**\n- `popen()` fallisce (es. impossibile creare pipe)\n- Limiti delle risorse di sistema superati\n- Fallimenti nell'allocazione di memoria\n\n### Quando exec() NON Lancia\n\n```hemlock\n// Il comando viene eseguito ma restituisce codice di uscita non zero\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (non un'eccezione)\n\n// Il comando non produce output\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (non un'eccezione)\n\n// Comando non trovato dalla shell\nlet r3 = exec(\"cmd_inesistente\");\nprint(r3.exit_code);  // 127 (non un'eccezione)\n```\n\n### Pattern di Esecuzione Sicura\n\n```hemlock\nfn esecuzione_sicura(comando: string) {\n    try {\n        let r = exec(comando);\n        if (r.exit_code != 0) {\n            print(\"Attenzione: Comando fallito con codice \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Errore nell'esecuzione del comando: \" + e);\n        return \"\";\n    }\n}\n\nlet output = esecuzione_sicura(\"ls -la\");\n```\n\n## Dettagli di Implementazione\n\n### Come Funziona\n\n**Internamente:**\n- Usa `popen()` per eseguire comandi tramite `/bin/sh`\n- Cattura solo stdout (stderr non viene catturato)\n- Output bufferizzato dinamicamente (inizia a 4KB, cresce se necessario)\n- Stato di uscita estratto usando macro `WIFEXITED()` e `WEXITSTATUS()`\n- Stringa output correttamente terminata con null\n\n**Flusso del processo:**\n1. `popen(comando, \"r\")` crea pipe e fa fork del processo\n2. Il processo figlio esegue `/bin/sh -c \"comando\"`\n3. Il processo padre legge stdout tramite pipe in un buffer che cresce\n4. `pclose()` attende il figlio e restituisce lo stato di uscita\n5. Lo stato di uscita viene estratto e memorizzato nell'oggetto risultato\n\n### Considerazioni sulle Prestazioni\n\n**Costi:**\n- Crea un nuovo processo shell per ogni chiamata (~1-5ms di overhead)\n- Output memorizzato interamente in memoria (non in streaming)\n- Nessun supporto streaming (attende il completamento del comando)\n- Adatto per comandi con dimensioni di output ragionevoli\n\n**Ottimizzazioni:**\n- Il buffer inizia a 4KB e raddoppia quando pieno (uso efficiente della memoria)\n- Singolo ciclo di lettura minimizza le chiamate di sistema\n- Nessuna copia aggiuntiva di stringhe\n\n**Quando usare:**\n- Comandi di breve durata (< 1 secondo)\n- Dimensione output moderata (< 10MB)\n- Operazioni batch con intervalli ragionevoli\n\n**Quando NON usare:**\n- Daemon o servizi a lunga esecuzione\n- Comandi che producono gigabyte di output\n- Elaborazione dati in streaming in tempo reale\n- Esecuzione ad alta frequenza (> 100 chiamate/secondo)\n\n## Considerazioni sulla Sicurezza\n\n### Rischio di Shell Injection\n\n**CRITICO:** I comandi vengono eseguiti dalla shell (`/bin/sh`), il che significa che **l'iniezione shell e possibile**.\n\n**Codice vulnerabile:**\n```hemlock\n// PERICOLOSO - NON FARLO\nlet nomefile = args[1];  // Input utente\nlet r = exec(\"cat \" + nomefile);  // Shell injection!\n```\n\n**Attacco:**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# Esegue: cat ; rm -rf /; echo pwned\n```\n\n### Pratiche Sicure\n\n**1. Mai usare input utente non sanitizzato:**\n```hemlock\n// Male\nlet input_utente = args[1];\nlet r = exec(\"elabora \" + input_utente);  // PERICOLOSO\n\n// Bene - valida prima\nfn e_nomefile_sicuro(nome: string): bool {\n    // Permetti solo alfanumerici, trattino, underscore, punto\n    let i = 0;\n    while (i < nome.length) {\n        let c = nome[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet nomefile = args[1];\nif (e_nomefile_sicuro(nomefile)) {\n    let r = exec(\"cat \" + nomefile);\n} else {\n    print(\"Nome file non valido\");\n}\n```\n\n**2. Usare allowlist, non denylist:**\n```hemlock\n// Bene - allowlist rigorosa\nlet comandi_permessi = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet trovato = false;\nfor (let permesso in comandi_permessi) {\n    if (cmd == permesso) {\n        trovato = true;\n        break;\n    }\n}\n\nif (trovato) {\n    exec(\"service miaapp \" + cmd);\n} else {\n    print(\"Comando non valido\");\n}\n```\n\n**3. Eseguire escape dei caratteri speciali:**\n```hemlock\nfn shell_escape(s: string): string {\n    // Escape semplice - racchiudi in apici singoli ed esegui escape degli apici singoli\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet file_utente = args[1];\nlet sicuro = shell_escape(file_utente);\nlet r = exec(\"cat \" + sicuro);\n```\n\n**4. Evitare exec() per operazioni sui file:**\n```hemlock\n// Male - usa exec per operazioni sui file\nlet r = exec(\"cat file.txt\");\n\n// Bene - usa l'API file di Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet contenuto = f.read();\nf.close();\n```\n\n### Considerazioni sui Permessi\n\nI comandi vengono eseguiti con gli stessi permessi del processo Hemlock:\n\n```hemlock\n// Se Hemlock viene eseguito come root, i comandi exec() vengono eseguiti come root!\nlet r = exec(\"rm -rf /importante\");  // PERICOLOSO se eseguito come root\n```\n\n**Migliore pratica:** Eseguire Hemlock con il minimo privilegio necessario.\n\n## Limitazioni\n\n### 1. Nessuna Cattura di stderr\n\nViene catturato solo stdout, stderr va al terminale:\n\n```hemlock\nlet r = exec(\"ls /inesistente\");\n// r.output e vuoto\n// Messaggio di errore appare sul terminale, non catturato\n```\n\n**Workaround - redirect stderr su stdout:**\n```hemlock\nlet r = exec(\"ls /inesistente 2>&1\");\n// Ora i messaggi di errore sono in r.output\n```\n\n### 2. Nessuno Streaming\n\nDeve attendere il completamento del comando:\n\n```hemlock\nlet r = exec(\"comando_lungo\");\n// Blocca fino al termine del comando\n// Impossibile elaborare output in modo incrementale\n```\n\n### 3. Nessun Timeout\n\nI comandi possono essere eseguiti indefinitamente:\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Blocca per 1000 secondi\n// Nessun modo per fare timeout o annullare\n```\n\n**Workaround - usa comando timeout:**\n```hemlock\nlet r = exec(\"timeout 5 comando_lungo\");\n// Fara timeout dopo 5 secondi\n```\n\n### 4. Nessuna Gestione Segnali\n\nImpossibile inviare segnali ai comandi in esecuzione:\n\n```hemlock\nlet r = exec(\"comando_lungo\");\n// Impossibile inviare SIGINT, SIGTERM, ecc. al comando\n```\n\n### 5. Nessun Controllo del Processo\n\nImpossibile interagire con il comando dopo l'avvio:\n\n```hemlock\nlet r = exec(\"programma_interattivo\");\n// Impossibile inviare input al programma\n// Impossibile controllare l'esecuzione\n```\n\n## Casi d'Uso\n\n### Buoni Casi d'Uso\n\n**1. Esecuzione di utilita di sistema:**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /percorso -name '*.txt'\");\n```\n\n**2. Elaborazione rapida di dati con strumenti Unix:**\n```hemlock\nlet r = exec(\"cat dati.txt | sort | uniq | wc -l\");\nprint(\"Righe uniche: \" + r.output);\n```\n\n**3. Controllo stato del sistema:**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Uso disco:\\n\" + r.output);\n```\n\n**4. Controlli esistenza file:**\n```hemlock\nlet r = exec(\"test -f miofile.txt\");\nif (r.exit_code == 0) {\n    print(\"Il file esiste\");\n}\n```\n\n**5. Generazione di report:**\n```hemlock\nlet r = exec(\"ps aux | grep miaapp | wc -l\");\nlet conteggio = r.output.trim();\nprint(\"Istanze in esecuzione: \" + conteggio);\n```\n\n**6. Script di automazione:**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Commit automatico'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push fallito\");\n}\n```\n\n### Non Raccomandato Per\n\n**1. Servizi a lunga esecuzione:**\n```hemlock\n// Male\nlet r = exec(\"nginx\");  // Blocca per sempre\n```\n\n**2. Comandi interattivi:**\n```hemlock\n// Male - impossibile fornire input\nlet r = exec(\"ssh utente@host\");\n```\n\n**3. Comandi che producono output enorme:**\n```hemlock\n// Male - carica intero output in memoria\nlet r = exec(\"cat file_10GB.log\");\n```\n\n**4. Streaming in tempo reale:**\n```hemlock\n// Male - impossibile elaborare output in modo incrementale\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. Gestione errori mission-critical:**\n```hemlock\n// Male - stderr non catturato\nlet r = exec(\"operazione_critica\");\n// Impossibile vedere messaggi di errore dettagliati\n```\n\n## Migliori Pratiche\n\n### 1. Controllare Sempre i Codici di Uscita\n\n```hemlock\nlet r = exec(\"comando_importante\");\nif (r.exit_code != 0) {\n    print(\"Comando fallito!\");\n    // Gestisci errore\n}\n```\n\n### 2. Rimuovere Spazi dall'Output Quando Necessario\n\n```hemlock\nlet r = exec(\"echo test\");\nlet pulito = r.output.trim();  // Rimuove newline finale\nprint(pulito);  // \"test\" (senza newline)\n```\n\n### 3. Validare Prima di Eseguire\n\n```hemlock\nfn e_comando_valido(cmd: string): bool {\n    // Valida che il comando sia sicuro\n    return true;  // La tua logica di validazione\n}\n\nif (e_comando_valido(cmd_utente)) {\n    exec(cmd_utente);\n}\n```\n\n### 4. Usare try/catch per Operazioni Critiche\n\n```hemlock\ntry {\n    let r = exec(\"comando_critico\");\n    if (r.exit_code != 0) {\n        throw \"Comando fallito\";\n    }\n} catch (e) {\n    print(\"Errore: \" + e);\n    // Pulizia o recovery\n}\n```\n\n### 5. Preferire API Hemlock a exec()\n\n```hemlock\n// Male - usa exec per operazioni sui file\nlet r = exec(\"cat file.txt\");\n\n// Bene - usa l'API File di Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet contenuto = f.read();\nf.close();\n```\n\n### 6. Catturare stderr Quando Necessario\n\n```hemlock\n// Redirect stderr su stdout\nlet r = exec(\"comando 2>&1\");\n// Ora r.output contiene sia stdout che stderr\n```\n\n### 7. Usare Funzionalita Shell con Saggezza\n\n```hemlock\n// Usa pipe per efficienza\nlet r = exec(\"cat grande.txt | grep pattern | head -n 10\");\n\n// Usa sostituzione di comando\nlet r = exec(\"echo Utente corrente: $(whoami)\");\n\n// Usa esecuzione condizionale\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## Esempi Completi\n\n### Esempio 1: Raccoglitore di Informazioni di Sistema\n\n```hemlock\nfn ottieni_info_sistema() {\n    print(\"=== Informazioni Sistema ===\");\n\n    // Hostname\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // Uptime\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // Uso disco\n    let r3 = exec(\"df -h /\");\n    print(\"\\nUso Disco:\");\n    print(r3.output);\n\n    // Uso memoria\n    let r4 = exec(\"free -h\");\n    print(\"Uso Memoria:\");\n    print(r4.output);\n}\n\nottieni_info_sistema();\n```\n\n### Esempio 2: Analizzatore di Log\n\n```hemlock\nfn analizza_log(file_log: string) {\n    print(\"Analisi log: \" + file_log);\n\n    // Conta righe totali\n    let r1 = exec(\"wc -l \" + file_log);\n    print(\"Righe totali: \" + r1.output.trim());\n\n    // Conta errori\n    let r2 = exec(\"grep -c ERROR \" + file_log + \" 2>/dev/null\");\n    let errori = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errori: \" + errori);\n    } else {\n        print(\"Errori: 0\");\n    }\n\n    // Conta avvisi\n    let r3 = exec(\"grep -c WARN \" + file_log + \" 2>/dev/null\");\n    let avvisi = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Avvisi: \" + avvisi);\n    } else {\n        print(\"Avvisi: 0\");\n    }\n\n    // Errori recenti\n    print(\"\\nErrori recenti:\");\n    let r4 = exec(\"grep ERROR \" + file_log + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <file_log>\");\n} else {\n    analizza_log(args[1]);\n}\n```\n\n### Esempio 3: Helper Git\n\n```hemlock\nfn stato_git() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Errore: Non e un repository git\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Directory di lavoro pulita\");\n    } else {\n        print(\"Modifiche:\");\n        print(r.output);\n    }\n}\n\nfn commit_veloce_git(messaggio: string) {\n    print(\"Aggiunta di tutte le modifiche...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Errore nell'aggiunta dei file\");\n        return;\n    }\n\n    print(\"Commit in corso...\");\n    let msg_sicuro = messaggio.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + msg_sicuro + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Errore nel commit\");\n        return;\n    }\n\n    print(\"Commit eseguito con successo\");\n    print(r2.output);\n}\n\n// Utilizzo\nstato_git();\nif (args.length > 1) {\n    commit_veloce_git(args[1]);\n}\n```\n\n### Esempio 4: Script di Backup\n\n```hemlock\nfn backup_directory(sorgente: string, destinazione: string) {\n    print(\"Backup di \" + sorgente + \" in \" + destinazione);\n\n    // Crea directory di backup\n    let r1 = exec(\"mkdir -p \" + destinazione);\n    if (r1.exit_code != 0) {\n        print(\"Errore nella creazione della directory di backup\");\n        return false;\n    }\n\n    // Crea tarball con timestamp\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let file_backup = destinazione + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creazione archivio: \" + file_backup);\n    let r3 = exec(\"tar -czf \" + file_backup + \" \" + sorgente + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Errore nella creazione del backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completato con successo\");\n\n    // Mostra dimensione backup\n    let r4 = exec(\"du -h \" + file_backup);\n    print(\"Dimensione backup: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Uso: \" + args[0] + \" <sorgente> <destinazione>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## Riepilogo\n\nLa funzione `exec()` di Hemlock fornisce:\n\n- Semplice esecuzione di comandi shell\n- Cattura dell'output (stdout)\n- Controllo dei codici di uscita\n- Accesso completo alle funzionalita della shell (pipe, redirect, ecc.)\n- Integrazione con utilita di sistema\n\nRicorda:\n- Controllare sempre i codici di uscita\n- Essere consapevoli delle implicazioni di sicurezza (shell injection)\n- Validare l'input utente prima di usarlo nei comandi\n- Preferire le API Hemlock a exec() quando disponibili\n- stderr non viene catturato (usa `2>&1` per il redirect)\n- I comandi bloccano fino al completamento\n- Usare per utilita di breve durata, non per servizi a lunga esecuzione\n\n**Checklist di sicurezza:**\n- Mai usare input utente non sanitizzato\n- Validare tutto l'input\n- Usare allowlist per i comandi\n- Eseguire escape dei caratteri speciali quando necessario\n- Eseguire con il minimo privilegio\n- Preferire le API Hemlock ai comandi shell\n"}, "Argomenti Avanzati -> FFI": {"id": "advanced-ffi", "content": "# FFI (Interfaccia Funzioni Esterne) in Hemlock\n\nHemlock fornisce **FFI (Foreign Function Interface)** per chiamare funzioni C da librerie condivise usando libffi, consentendo l'integrazione con librerie C esistenti e API di sistema.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [Stato Attuale](#stato-attuale)\n- [Tipi Supportati](#tipi-supportati)\n- [Concetti Base](#concetti-base)\n- [Esportazione di Funzioni FFI](#esportazione-di-funzioni-ffi)\n- [Casi d'Uso](#casi-duso)\n- [Sviluppi Futuri](#sviluppi-futuri)\n- [Callback FFI](#callback-ffi)\n- [Struct FFI](#struct-ffi)\n- [Esportazione di Tipi Struct](#esportazione-di-tipi-struct)\n- [Limitazioni Attuali](#limitazioni-attuali)\n- [Migliori Pratiche](#migliori-pratiche)\n\n## Panoramica\n\nL'Interfaccia Funzioni Esterne (FFI) permette ai programmi Hemlock di:\n- Chiamare funzioni C da librerie condivise (.so, .dylib, .dll)\n- Usare librerie C esistenti senza scrivere codice wrapper\n- Accedere direttamente alle API di sistema\n- Integrarsi con librerie native di terze parti\n- Collegare Hemlock con funzionalita di sistema a basso livello\n\n**Capacita principali:**\n- Caricamento dinamico di librerie\n- Binding di funzioni C\n- Conversione automatica dei tipi tra Hemlock e tipi C\n- Supporto per tutti i tipi primitivi\n- Implementazione basata su libffi per portabilita\n\n## Stato Attuale\n\nIl supporto FFI e disponibile in Hemlock con le seguenti funzionalita:\n\n**Implementato:**\n- Chiamare funzioni C da librerie condivise\n- Supporto per tutti i tipi primitivi (interi, float, puntatori)\n- Conversione automatica dei tipi\n- Implementazione basata su libffi\n- Caricamento dinamico di librerie\n- **Callback con puntatori a funzione** - Passare funzioni Hemlock a C\n- **Esportazione di funzioni extern** - Condividere binding FFI tra moduli\n- **Passaggio e restituzione di struct** - Passare struct compatibili con C per valore\n- **Helper per puntatori completi** - Lettura/scrittura di tutti i tipi (i8-i64, u8-u64, f32, f64, ptr)\n- **Conversione buffer/puntatore** - `buffer_ptr()`, `ptr_to_buffer()`\n- **Dimensioni tipi FFI** - `ffi_sizeof()` per dimensioni tipi consapevoli della piattaforma\n- **Tipi di piattaforma** - Supporto `size_t`, `usize`, `isize`, `intptr_t`\n\n**In Sviluppo:**\n- Helper per marshaling di stringhe\n- Miglioramenti nella gestione degli errori\n\n**Copertura Test:**\n- Test FFI passati inclusi test callback\n- Chiamata funzioni base verificata\n- Conversione tipi testata\n- Integrazione callback qsort testata\n\n## Tipi Supportati\n\n### Tipi Primitivi\n\nI seguenti tipi Hemlock possono essere passati a/da funzioni C:\n\n| Tipo Hemlock | Tipo C | Dimensione | Note |\n|--------------|--------|------------|------|\n| `i8` | `int8_t` | 1 byte | Intero con segno a 8 bit |\n| `i16` | `int16_t` | 2 byte | Intero con segno a 16 bit |\n| `i32` | `int32_t` | 4 byte | Intero con segno a 32 bit |\n| `i64` | `int64_t` | 8 byte | Intero con segno a 64 bit |\n| `u8` | `uint8_t` | 1 byte | Intero senza segno a 8 bit |\n| `u16` | `uint16_t` | 2 byte | Intero senza segno a 16 bit |\n| `u32` | `uint32_t` | 4 byte | Intero senza segno a 32 bit |\n| `u64` | `uint64_t` | 8 byte | Intero senza segno a 64 bit |\n| `f32` | `float` | 4 byte | Virgola mobile a 32 bit |\n| `f64` | `double` | 8 byte | Virgola mobile a 64 bit |\n| `ptr` | `void*` | 8 byte | Puntatore raw |\n\n### Conversione dei Tipi\n\n**Conversioni automatiche:**\n- Interi Hemlock -> Interi C (con controllo range)\n- Float Hemlock -> Float C\n- Puntatori Hemlock -> Puntatori C\n- Valori di ritorno C -> Valori Hemlock\n\n**Esempio di mappatura tipi:**\n```hemlock\n// Hemlock -> C\nlet i: i32 = 42;         // -> int32_t (4 byte)\nlet f: f64 = 3.14;       // -> double (8 byte)\nlet p: ptr = alloc(64);  // -> void* (8 byte)\n\n// C -> Hemlock (valori di ritorno)\n// int32_t foo() -> i32\n// double bar() -> f64\n// void* baz() -> ptr\n```\n\n## Concetti Base\n\n### Librerie Condivise\n\nFFI funziona con librerie condivise compilate:\n\n**Linux:** file `.so`\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** file `.dylib`\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** file `.dll`\n```\nexample.dll\nkernel32.dll\n```\n\n### Firme delle Funzioni\n\nLe funzioni C devono avere firme note perche FFI funzioni correttamente:\n\n```c\n// Esempi di firme funzioni C\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\nQueste possono essere chiamate da Hemlock una volta che la libreria e caricata e le funzioni sono legate.\n\n### Compatibilita di Piattaforma\n\nFFI usa **libffi** per la portabilita:\n- Funziona su x86, x86-64, ARM, ARM64\n- Gestisce automaticamente le convenzioni di chiamata\n- Astrae i dettagli ABI specifici della piattaforma\n- Supporta Linux, macOS, Windows (con libffi appropriato)\n\n## Esportazione di Funzioni FFI\n\nLe funzioni FFI dichiarate con `extern fn` possono essere esportate dai moduli, permettendo di creare wrapper di librerie riutilizzabili che possono essere condivisi tra piu file.\n\n### Sintassi di Esportazione Base\n\n```hemlock\n// string_utils.hml - Un modulo libreria che wrappa funzioni stringa C\nimport \"libc.so.6\";\n\n// Esporta direttamente la funzione extern\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// Puoi anche esportare funzioni wrapper insieme a funzioni extern\nexport fn lunghezza_stringa(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn stringhe_uguali(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### Importazione di Funzioni FFI Esportate\n\n```hemlock\n// main.hml - Uso delle funzioni FFI esportate\nimport { strlen, lunghezza_stringa, stringhe_uguali } from \"./string_utils.hml\";\n\nlet msg = \"Ciao, Mondo!\";\nprint(strlen(msg));              // 12 - chiamata extern diretta\nprint(lunghezza_stringa(msg));   // 12 - funzione wrapper\n\nprint(stringhe_uguali(\"pippo\", \"pippo\"));  // true\nprint(stringhe_uguali(\"pippo\", \"pluto\"));  // false\n```\n\n### Casi d'Uso per Export Extern\n\n**1. Astrazione di Piattaforma**\n```hemlock\n// platform.hml - Astrae differenze di piattaforma\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. Wrapper di Librerie**\n```hemlock\n// crypto_lib.hml - Wrappa funzioni libreria crypto\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// Aggiungi wrapper Hemlock-friendly\nexport fn sha256_stringa(s: string): string {\n    // Implementazione usando la funzione extern\n}\n```\n\n**3. Dichiarazioni FFI Centralizzate**\n```hemlock\n// libc.hml - Modulo centrale per binding libc\nimport \"libc.so.6\";\n\n// Funzioni stringa\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// Funzioni memoria\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// Funzioni processo\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\nPoi usalo in tutto il progetto:\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n### Combinare con Esportazioni Regolari\n\nPuoi mischiare funzioni extern esportate con esportazioni di funzioni regolari:\n\n```hemlock\n// math_extended.hml\nimport \"libm.so.6\";\n\n// Esporta funzioni C raw\nexport extern fn sin(x: f64): f64;\nexport extern fn cos(x: f64): f64;\nexport extern fn tan(x: f64): f64;\n\n// Esporta funzioni Hemlock che le usano\nexport fn gradi_a_radianti(gradi: f64): f64 {\n    return gradi * 3.14159265359 / 180.0;\n}\n\nexport fn sin_gradi(gradi: f64): f64 {\n    return sin(gradi_a_radianti(gradi));\n}\n```\n\n### Librerie Specifiche per Piattaforma\n\nQuando esporti funzioni extern, ricorda che i nomi delle librerie differiscono per piattaforma:\n\n```hemlock\n// Per Linux\nimport \"libc.so.6\";\n\n// Per macOS (approccio diverso necessario)\nimport \"libSystem.B.dylib\";\n```\n\nAttualmente, la sintassi `import \"libreria\"` di Hemlock usa percorsi di libreria statici, quindi potrebbero essere necessari moduli specifici per piattaforma per codice FFI cross-platform.\n\n## Casi d'Uso\n\n### 1. Librerie di Sistema\n\nAccedi alle funzioni della libreria C standard:\n\n**Funzioni matematiche:**\n```hemlock\n// Chiama sqrt da libm\nlet risultato = sqrt(16.0);  // 4.0\n```\n\n**Allocazione memoria:**\n```hemlock\n// Chiama malloc/free da libc\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. Librerie di Terze Parti\n\nUsa librerie C esistenti:\n\n**Esempio: Elaborazione immagini**\n```hemlock\n// Carica libpng o libjpeg\n// Elabora immagini usando funzioni libreria C\n```\n\n**Esempio: Crittografia**\n```hemlock\n// Usa OpenSSL o libsodium\n// Crittografia/decrittografia tramite FFI\n```\n\n### 3. API di Sistema\n\nChiamate di sistema dirette:\n\n**Esempio: API POSIX**\n```hemlock\n// Chiama getpid, getuid, ecc.\n// Accedi a funzionalita di sistema a basso livello\n```\n\n### 4. Codice Critico per le Prestazioni\n\nChiama implementazioni C ottimizzate:\n\n```hemlock\n// Usa librerie C altamente ottimizzate\n// Operazioni SIMD, codice vettorizzato\n// Funzioni accelerate hardware\n```\n\n### 5. Accesso Hardware\n\nInterfaccia con librerie hardware:\n\n```hemlock\n// Controllo GPIO su sistemi embedded\n// Comunicazione dispositivi USB\n// Accesso porta seriale\n```\n\n### 6. Integrazione Codice Legacy\n\nRiusa codebase C esistenti:\n\n```hemlock\n// Chiama funzioni da applicazioni C legacy\n// Migra gradualmente a Hemlock\n// Preserva codice C funzionante\n```\n\n## Sviluppi Futuri\n\n### Funzionalita Pianificate\n\n**1. Supporto Struct**\n```hemlock\n// Futuro: Passa/restituisci struct C\ndefine Punto {\n    x: f64,\n    y: f64,\n}\n\nlet p = Punto { x: 1.0, y: 2.0 };\nfunzione_c_con_struct(p);\n```\n\n**2. Gestione Array/Buffer**\n```hemlock\n// Futuro: Migliore passaggio array\nlet arr = [1, 2, 3, 4, 5];\nelabora_array(arr);  // Passa a funzione C\n```\n\n**3. Callback con Puntatori a Funzione** (Implementato!)\n```hemlock\n// Passa funzioni Hemlock a C come callback\nfn mio_confronto(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// Crea un puntatore a funzione chiamabile da C\nlet cmp = callback(mio_confronto, [\"ptr\", \"ptr\"], \"i32\");\n\n// Usa con qsort o qualsiasi funzione C che si aspetta un callback\nqsort(arr, conteggio, dim_elem, cmp);\n\n// Pulisci quando finito\ncallback_free(cmp);\n```\n\n**4. Marshaling Stringhe**\n```hemlock\n// Futuro: Conversione automatica stringhe\nlet s = \"ciao\";\nfunzione_stringa_c(s);  // Auto-converti in stringa C\n```\n\n**5. Gestione Errori**\n```hemlock\n// Futuro: Migliore reporting errori\ntry {\n    let risultato = funzione_c_rischiosa();\n} catch (e) {\n    print(\"Errore FFI: \" + e);\n}\n```\n\n**6. Type Safety**\n```hemlock\n// Futuro: Annotazioni di tipo per FFI\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet risultato = sqrt(16.0);  // Type-checked\n```\n\n### Funzionalita\n\n**v1.0:**\n- FFI base con tipi primitivi\n- Caricamento dinamico librerie\n- Chiamata funzioni\n- Supporto callback tramite closure libffi\n\n**Futuro:**\n- Supporto struct\n- Miglioramenti gestione array\n- Generazione automatica binding\n\n## Callback FFI\n\nHemlock supporta il passaggio di funzioni a codice C come callback usando closure libffi. Questo abilita l'integrazione con API C che si aspettano puntatori a funzione, come `qsort`, event loop e librerie basate su callback.\n\n### Creazione di Callback\n\nUsa `callback()` per creare un puntatore a funzione chiamabile da C da una funzione Hemlock:\n\n```hemlock\n// callback(funzione, tipi_param, tipo_ritorno) -> ptr\nlet cb = callback(mia_funzione, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**Parametri:**\n- `funzione`: Una funzione Hemlock da wrappare\n- `tipi_param`: Array di stringhe nomi tipo (es. `[\"ptr\", \"i32\"]`)\n- `tipo_ritorno`: Stringa tipo ritorno (es. `\"i32\"`, `\"void\"`)\n\n**Tipi callback supportati:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Interi con segno\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Interi senza segno\n- `\"f32\"`, `\"f64\"` - Virgola mobile\n- `\"ptr\"` - Puntatore\n- `\"void\"` - Nessun valore di ritorno\n- `\"bool\"` - Booleano\n\n### Esempio: qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Funzione di confronto per interi (ordine crescente)\nfn confronta_interi(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// Alloca array di 5 interi\nlet arr = alloc(20);  // 5 * 4 byte\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// Crea callback e ordina\nlet cmp = callback(confronta_interi, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// L'array e ora ordinato: [1, 2, 5, 8, 9]\n\n// Pulisci\ncallback_free(cmp);\nfree(arr);\n```\n\n### Funzioni Helper per Puntatori\n\nHemlock fornisce funzioni helper complete per lavorare con puntatori raw. Queste sono essenziali per callback FFI e manipolazione diretta della memoria.\n\n#### Helper per Tipi Interi\n\n| Funzione | Descrizione |\n|----------|-------------|\n| `ptr_deref_i8(ptr)` | Dereferenzia puntatore, leggi i8 |\n| `ptr_deref_i16(ptr)` | Dereferenzia puntatore, leggi i16 |\n| `ptr_deref_i32(ptr)` | Dereferenzia puntatore, leggi i32 |\n| `ptr_deref_i64(ptr)` | Dereferenzia puntatore, leggi i64 |\n| `ptr_deref_u8(ptr)` | Dereferenzia puntatore, leggi u8 |\n| `ptr_deref_u16(ptr)` | Dereferenzia puntatore, leggi u16 |\n| `ptr_deref_u32(ptr)` | Dereferenzia puntatore, leggi u32 |\n| `ptr_deref_u64(ptr)` | Dereferenzia puntatore, leggi u64 |\n| `ptr_write_i8(ptr, valore)` | Scrivi i8 nella locazione puntatore |\n| `ptr_write_i16(ptr, valore)` | Scrivi i16 nella locazione puntatore |\n| `ptr_write_i32(ptr, valore)` | Scrivi i32 nella locazione puntatore |\n| `ptr_write_i64(ptr, valore)` | Scrivi i64 nella locazione puntatore |\n| `ptr_write_u8(ptr, valore)` | Scrivi u8 nella locazione puntatore |\n| `ptr_write_u16(ptr, valore)` | Scrivi u16 nella locazione puntatore |\n| `ptr_write_u32(ptr, valore)` | Scrivi u32 nella locazione puntatore |\n| `ptr_write_u64(ptr, valore)` | Scrivi u64 nella locazione puntatore |\n\n#### Helper per Tipi Float\n\n| Funzione | Descrizione |\n|----------|-------------|\n| `ptr_deref_f32(ptr)` | Dereferenzia puntatore, leggi f32 (float) |\n| `ptr_deref_f64(ptr)` | Dereferenzia puntatore, leggi f64 (double) |\n| `ptr_write_f32(ptr, valore)` | Scrivi f32 nella locazione puntatore |\n| `ptr_write_f64(ptr, valore)` | Scrivi f64 nella locazione puntatore |\n\n#### Helper per Tipi Puntatore\n\n| Funzione | Descrizione |\n|----------|-------------|\n| `ptr_deref_ptr(ptr)` | Dereferenzia puntatore-a-puntatore |\n| `ptr_write_ptr(ptr, valore)` | Scrivi puntatore nella locazione puntatore |\n| `ptr_offset(ptr, indice, dimensione)` | Calcola offset: `ptr + indice * dimensione` |\n| `ptr_read_i32(ptr)` | Leggi i32 attraverso puntatore-a-puntatore (per callback qsort) |\n| `ptr_null()` | Ottieni costante puntatore null |\n\n#### Helper Conversione Buffer\n\n| Funzione | Descrizione |\n|----------|-------------|\n| `buffer_ptr(buffer)` | Ottieni puntatore raw da un buffer |\n| `ptr_to_buffer(ptr, dimensione)` | Copia dati da puntatore in un nuovo buffer |\n\n#### Funzioni Utilita FFI\n\n| Funzione | Descrizione |\n|----------|-------------|\n| `ffi_sizeof(nome_tipo)` | Ottieni dimensione in byte di un tipo FFI |\n\n**Nomi tipo supportati per `ffi_sizeof`:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Interi con segno (1, 2, 4, 8 byte)\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Interi senza segno (1, 2, 4, 8 byte)\n- `\"f32\"`, `\"f64\"` - Float (4, 8 byte)\n- `\"ptr\"` - Puntatore (8 byte su 64 bit)\n- `\"size_t\"`, `\"usize\"` - Tipo dimensione dipendente dalla piattaforma\n- `\"intptr_t\"`, `\"isize\"` - Tipo puntatore con segno dipendente dalla piattaforma\n\n#### Esempio: Lavorare con Tipi Diversi\n\n```hemlock\nlet p = alloc(64);\n\n// Scrivi e leggi interi\nptr_write_i8(p, 42);\nprint(ptr_deref_i8(p));  // 42\n\nptr_write_i64(ptr_offset(p, 1, 8), 9000000000);\nprint(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000\n\n// Scrivi e leggi float\nptr_write_f64(p, 3.14159);\nprint(ptr_deref_f64(p));  // 3.14159\n\n// Puntatore-a-puntatore\nlet interno = alloc(4);\nptr_write_i32(interno, 999);\nptr_write_ptr(p, interno);\nlet recuperato = ptr_deref_ptr(p);\nprint(ptr_deref_i32(recuperato));  // 999\n\n// Ottieni dimensioni tipi\nprint(ffi_sizeof(\"i64\"));  // 8\nprint(ffi_sizeof(\"ptr\"));  // 8 (su 64 bit)\n\n// Conversione buffer\nlet buf = buffer(64);\nptr_write_i32(buffer_ptr(buf), 12345);\nprint(ptr_deref_i32(buffer_ptr(buf)));  // 12345\n\nfree(interno);\nfree(p);\n```\n\n### Liberazione dei Callback\n\n**Importante:** Liberare sempre i callback quando finito per prevenire memory leak:\n\n```hemlock\nlet cb = callback(mia_fn, [\"ptr\"], \"void\");\n// ... usa callback ...\ncallback_free(cb);  // Libera quando finito\n```\n\nI callback vengono anche automaticamente liberati quando il programma termina.\n\n### Closure nei Callback\n\nI callback catturano il loro ambiente closure, quindi possono accedere a variabili dello scope esterno:\n\n```hemlock\nlet moltiplicatore = 10;\n\nfn scala(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // Puo accedere a 'moltiplicatore' dallo scope esterno\n    return (va * moltiplicatore) - (vb * moltiplicatore);\n}\n\nlet cmp = callback(scala, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### Thread Safety\n\nLe invocazioni callback sono serializzate con un mutex per garantire thread safety, poiche l'interprete Hemlock non e completamente thread-safe. Questo significa:\n- Solo un callback puo essere eseguito alla volta\n- Sicuro da usare con librerie C multi-thread\n- Potrebbe impattare le prestazioni se i callback vengono chiamati molto frequentemente da piu thread\n\n### Gestione Errori nei Callback\n\nLe eccezioni lanciate nei callback non possono propagarsi al codice C. Invece:\n- Un avviso viene stampato su stderr\n- Il callback restituisce un valore predefinito (0 o NULL)\n- L'eccezione viene loggata ma non propagata\n\n```hemlock\nfn callback_rischioso(a: ptr): i32 {\n    throw \"Qualcosa e andato storto\";  // Avviso stampato, restituisce 0\n}\n```\n\nPer gestione errori robusta, valida gli input ed evita di lanciare eccezioni nei callback.\n\n## Struct FFI\n\nHemlock supporta il passaggio di struct per valore a funzioni C. I tipi struct vengono automaticamente registrati per FFI quando li definisci con annotazioni di tipo.\n\n### Definizione di Struct Compatibili con FFI\n\nUna struct e compatibile con FFI quando tutti i campi hanno annotazioni di tipo esplicite usando tipi compatibili con FFI:\n\n```hemlock\n// Struct compatibile con FFI\ndefine Punto {\n    x: f64,\n    y: f64,\n}\n\n// Struct compatibile con FFI con piu tipi di campo\ndefine Rettangolo {\n    in_alto_sinistra: Punto,      // Struct annidata\n    larghezza: f64,\n    altezza: f64,\n}\n\n// NON compatibile con FFI (campo senza annotazione di tipo)\ndefine OggettoDinamico {\n    nome,                 // Nessun tipo - non usabile in FFI\n    valore,\n}\n```\n\n### Uso di Struct in FFI\n\nDichiara funzioni extern che usano tipi struct:\n\n```hemlock\n// Definisci il tipo struct\ndefine Vettore2D {\n    x: f64,\n    y: f64,\n}\n\n// Importa la libreria C\nimport \"libmath.so\";\n\n// Dichiara funzione extern che prende/restituisce struct\nextern fn vettore_somma(a: Vettore2D, b: Vettore2D): Vettore2D;\nextern fn vettore_lunghezza(v: Vettore2D): f64;\n\n// Usala naturalmente\nlet a: Vettore2D = { x: 3.0, y: 0.0 };\nlet b: Vettore2D = { x: 0.0, y: 4.0 };\nlet risultato = vettore_somma(a, b);\nprint(risultato.x);  // 3.0\nprint(risultato.y);  // 4.0\n\nlet lun = vettore_lunghezza(risultato);\nprint(lun);          // 5.0\n```\n\n### Tipi di Campo Supportati\n\nI campi struct devono usare questi tipi compatibili con FFI:\n\n| Tipo Hemlock | Tipo C | Dimensione |\n|--------------|--------|------------|\n| `i8` | `int8_t` | 1 byte |\n| `i16` | `int16_t` | 2 byte |\n| `i32` | `int32_t` | 4 byte |\n| `i64` | `int64_t` | 8 byte |\n| `u8` | `uint8_t` | 1 byte |\n| `u16` | `uint16_t` | 2 byte |\n| `u32` | `uint32_t` | 4 byte |\n| `u64` | `uint64_t` | 8 byte |\n| `f32` | `float` | 4 byte |\n| `f64` | `double` | 8 byte |\n| `ptr` | `void*` | 8 byte |\n| `string` | `char*` | 8 byte |\n| `bool` | `int` | varia |\n| Struct annidata | struct | varia |\n\n### Layout Struct\n\nHemlock usa le regole di layout struct native della piattaforma (corrispondente all'ABI C):\n- I campi sono allineati secondo il loro tipo\n- Padding inserito se necessario\n- Dimensione totale con padding per allineare il membro piu grande\n\n```hemlock\n// Esempio: layout compatibile con C\ndefine Misto {\n    a: i8,    // offset 0, dimensione 1\n              // 3 byte padding\n    b: i32,   // offset 4, dimensione 4\n}\n// Dimensione totale: 8 byte (con padding)\n\ndefine Punto3D {\n    x: f64,   // offset 0, dimensione 8\n    y: f64,   // offset 8, dimensione 8\n    z: f64,   // offset 16, dimensione 8\n}\n// Dimensione totale: 24 byte (nessun padding necessario)\n```\n\n### Struct Annidate\n\nLe struct possono contenere altre struct:\n\n```hemlock\ndefine Interno {\n    x: i32,\n    y: i32,\n}\n\ndefine Esterno {\n    interno: Interno,\n    z: i32,\n}\n\nimport \"mialibrary.so\";\nextern fn elabora_annidata(data: Esterno): i32;\n\nlet obj: Esterno = {\n    interno: { x: 1, y: 2 },\n    z: 3,\n};\nlet risultato = elabora_annidata(obj);\n```\n\n### Valori di Ritorno Struct\n\nLe funzioni C possono restituire struct:\n\n```hemlock\ndefine Punto {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn ottieni_origine(): Punto;\n\nlet p = ottieni_origine();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### Limitazioni\n\n- **I campi struct devono avere annotazioni di tipo** - campi senza tipo non sono compatibili con FFI\n- **Nessun array nelle struct** - usa puntatori invece\n- **Nessuna union** - solo tipi struct sono supportati\n- **I callback non possono restituire struct** - usa puntatori per valori di ritorno callback\n\n### Esportazione di Tipi Struct\n\nPuoi esportare definizioni di tipi struct da un modulo usando `export define`:\n\n```hemlock\n// geometria.hml\nexport define Vettore2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rettangolo {\n    x: f32,\n    y: f32,\n    larghezza: f32,\n    altezza: f32,\n}\n\nexport fn crea_rett(x: f32, y: f32, l: f32, a: f32): Rettangolo {\n    return { x: x, y: y, larghezza: l, altezza: a };\n}\n```\n\n**Importante:** I tipi struct esportati sono registrati **globalmente** quando il modulo viene caricato. Diventano disponibili automaticamente quando importi qualcosa dal modulo. NON devi (e non puoi) importarli esplicitamente per nome:\n\n```hemlock\n// main.hml\n\n// BENE - i tipi struct sono auto-disponibili dopo qualsiasi import dal modulo\nimport { crea_rett } from \"./geometria.hml\";\nlet v: Vettore2 = { x: 1.0, y: 2.0 };      // Funziona - Vettore2 e globalmente disponibile\nlet r: Rettangolo = crea_rett(0.0, 0.0, 100.0, 50.0);  // Funziona\n\n// MALE - non puoi importare esplicitamente tipi struct per nome\nimport { Vettore2 } from \"./geometria.hml\";  // Errore: Variabile 'Vettore2' non definita\n```\n\nQuesto comportamento esiste perche i tipi struct sono registrati nel registro tipi globale quando il modulo viene caricato, piuttosto che essere memorizzati come valori nell'ambiente export del modulo. Il tipo diventa disponibile a tutto il codice che importa dal modulo.\n\n## Limitazioni Attuali\n\nFFI ha le seguenti limitazioni:\n\n**1. Conversione Tipi Manuale**\n- Devi gestire manualmente le conversioni stringa\n- Nessuna conversione automatica stringa Hemlock <-> stringa C\n\n**2. Gestione Errori Limitata**\n- Reporting errori base\n- Le eccezioni nei callback non possono propagarsi a C\n\n**3. Caricamento Librerie Manuale**\n- Devi caricare manualmente le librerie\n- Nessuna generazione automatica di binding\n\n**4. Codice Specifico per Piattaforma**\n- I percorsi delle librerie differiscono per piattaforma\n- Devi gestire .so vs .dylib vs .dll\n\n## Migliori Pratiche\n\nMentre la documentazione FFI completa e ancora in sviluppo, ecco le migliori pratiche generali:\n\n### 1. Type Safety\n\n```hemlock\n// Sii esplicito sui tipi\nlet x: i32 = 42;\nlet risultato: f64 = funzione_c(x);\n```\n\n### 2. Gestione Memoria\n\n```hemlock\n// Ricorda di liberare la memoria allocata\nlet ptr = c_malloc(1024);\n// ... usa ptr\nc_free(ptr);\n```\n\n### 3. Controllo Errori\n\n```hemlock\n// Controlla i valori di ritorno\nlet risultato = funzione_c();\nif (risultato == null) {\n    print(\"Funzione C fallita\");\n}\n```\n\n### 4. Compatibilita di Piattaforma\n\n```hemlock\n// Gestisci differenze di piattaforma\n// Usa estensioni libreria appropriate (.so, .dylib, .dll)\n```\n\n## Esempi\n\nPer esempi funzionanti, riferisciti a:\n- Test callback: `/tests/ffi_callbacks/` - esempi callback qsort\n- Uso FFI stdlib: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`\n- Programmi esempio: `/examples/` (se disponibili)\n\n## Ottenere Aiuto\n\nFFI e una funzionalita piu recente in Hemlock. Per domande o problemi:\n\n1. Controlla la suite di test per esempi funzionanti\n2. Riferisciti alla documentazione libffi per dettagli di basso livello\n3. Segnala bug o richiedi funzionalita tramite le issue del progetto\n\n## Riepilogo\n\nL'FFI di Hemlock fornisce:\n\n- Chiamata funzioni C da librerie condivise\n- Supporto tipi primitivi (i8-i64, u8-u64, f32, f64, ptr)\n- Conversione automatica dei tipi\n- Portabilita basata su libffi\n- Base per integrazione librerie native\n- **Callback con puntatori a funzione** - passa funzioni Hemlock a C\n- **Esportazione funzioni extern** - condividi binding FFI tra moduli\n- **Passaggio e ritorno struct** - passa struct compatibili C per valore\n- **Export define** - condividi definizioni tipi struct tra moduli (auto-importati globalmente)\n- **Helper puntatori completi** - lettura/scrittura tutti i tipi (i8-i64, u8-u64, f32, f64, ptr)\n- **Conversione buffer/puntatore** - `buffer_ptr()`, `ptr_to_buffer()` per marshaling dati\n- **Dimensioni tipi FFI** - `ffi_sizeof()` per dimensioni tipi consapevoli della piattaforma\n- **Tipi piattaforma** - supporto `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`\n\n**Stato attuale:** FFI completamente funzionale con tipi primitivi, struct, callback, esportazioni modulo e funzioni helper puntatori complete\n\n**Futuro:** Helper marshaling stringhe\n\n**Casi d'uso:** Librerie di sistema, librerie terze parti, qsort, event loop, API basate su callback, wrapper librerie riutilizzabili\n\n## Contribuire\n\nLa documentazione FFI e in espansione. Se lavori con FFI:\n- Documenta i tuoi casi d'uso\n- Condividi codice esempio\n- Segnala problemi o limitazioni\n- Suggerisci miglioramenti\n\nIl sistema FFI e progettato per essere pratico e sicuro fornendo accesso a basso livello quando necessario, seguendo la filosofia di Hemlock di \"esplicito piuttosto che implicito\" e \"unsafe e una funzionalita, non un bug.\"\n"}, "Argomenti Avanzati -> File IO": {"id": "advanced-file-io", "content": "# I/O su File in Hemlock\n\nHemlock fornisce un'**API oggetto File** per operazioni sui file con gestione appropriata degli errori e gestione delle risorse.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [Apertura di File](#apertura-di-file)\n- [Metodi File](#metodi-file)\n- [Proprieta File](#proprieta-file)\n- [Gestione degli Errori](#gestione-degli-errori)\n- [Gestione delle Risorse](#gestione-delle-risorse)\n- [Riferimento API Completo](#riferimento-api-completo)\n- [Pattern Comuni](#pattern-comuni)\n- [Migliori Pratiche](#migliori-pratiche)\n\n## Panoramica\n\nL'API oggetto File fornisce:\n\n- **Gestione esplicita delle risorse** - I file devono essere chiusi manualmente\n- **Modalita di apertura multiple** - Lettura, scrittura, append, lettura/scrittura\n- **Operazioni testo e binarie** - Lettura/scrittura sia di dati testo che binari\n- **Supporto seeking** - Accesso casuale all'interno dei file\n- **Messaggi di errore completi** - Reporting errori consapevole del contesto\n\n**Importante:** I file non vengono chiusi automaticamente. Devi chiamare `f.close()` per evitare leak di file descriptor.\n\n## Apertura di File\n\nUsa `open(percorso, modalita?)` per aprire un file:\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");     // Modalita lettura (predefinita)\nlet f2 = open(\"output.txt\", \"w\");  // Modalita scrittura (tronca)\nlet f3 = open(\"log.txt\", \"a\");     // Modalita append\nlet f4 = open(\"dati.bin\", \"r+\");   // Modalita lettura/scrittura\n```\n\n### Modalita di Apertura\n\n| Modalita | Descrizione | File Deve Esistere | Tronca | Posizione |\n|----------|-------------|-------------------|--------|-----------|\n| `\"r\"` | Lettura (predefinita) | Si | No | Inizio |\n| `\"w\"` | Scrittura | No (crea) | Si | Inizio |\n| `\"a\"` | Append | No (crea) | No | Fine |\n| `\"r+\"` | Lettura e scrittura | Si | No | Inizio |\n| `\"w+\"` | Lettura e scrittura | No (crea) | Si | Inizio |\n| `\"a+\"` | Lettura e append | No (crea) | No | Fine |\n\n### Esempi\n\n**Lettura di un file esistente:**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// o semplicemente:\nlet f = open(\"config.json\");  // \"r\" e predefinito\n```\n\n**Creazione di un nuovo file per scrittura:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Crea o tronca\n```\n\n**Append a un file:**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Crea se non esiste\n```\n\n**Modalita lettura e scrittura:**\n```hemlock\nlet f = open(\"dati.bin\", \"r+\");  // File esistente, puo leggere/scrivere\n```\n\n## Metodi File\n\n### Lettura\n\n#### read(dimensione?: i32): string\n\nLegge testo dal file (parametro dimensione opzionale).\n\n**Senza dimensione (leggi tutto):**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nlet tutto = f.read();  // Legge dalla posizione corrente a EOF\nf.close();\n```\n\n**Con dimensione (leggi byte specifici):**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nlet chunk = f.read(1024);  // Legge fino a 1024 byte\nlet successivo = f.read(1024);   // Legge i successivi 1024 byte\nf.close();\n```\n\n**Restituisce:** Stringa contenente i dati letti, o stringa vuota se a EOF\n\n**Esempio - Lettura file intero:**\n```hemlock\nlet f = open(\"poesia.txt\", \"r\");\nlet contenuto = f.read();\nprint(contenuto);\nf.close();\n```\n\n**Esempio - Lettura a chunk:**\n```hemlock\nlet f = open(\"grande.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // Chunk da 4KB\n    if (chunk == \"\") { break; }  // EOF raggiunto\n    elabora(chunk);\n}\nf.close();\n```\n\n#### read_bytes(dimensione: i32): buffer\n\nLegge dati binari (restituisce buffer).\n\n**Parametri:**\n- `dimensione` (i32) - Numero di byte da leggere\n\n**Restituisce:** Buffer contenente i byte letti\n\n```hemlock\nlet f = open(\"immagine.png\", \"r\");\nlet binario = f.read_bytes(256);  // Legge 256 byte\nprint(binario.length);  // 256 (o meno se EOF)\n\n// Accedi a byte individuali\nlet primo_byte = binario[0];\nprint(primo_byte);\n\nf.close();\n```\n\n**Esempio - Lettura file binario intero:**\n```hemlock\nlet f = open(\"dati.bin\", \"r\");\nlet dimensione = 10240;  // Dimensione attesa\nlet dati = f.read_bytes(dimensione);\nf.close();\n\n// Elabora dati binari\nlet i = 0;\nwhile (i < dati.length) {\n    let byte = dati[i];\n    // ... elabora byte\n    i = i + 1;\n}\n```\n\n### Scrittura\n\n#### write(dati: string): i32\n\nScrive testo nel file (restituisce byte scritti).\n\n**Parametri:**\n- `dati` (string) - Testo da scrivere\n\n**Restituisce:** Numero di byte scritti (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet scritti = f.write(\"Ciao, Mondo!\\n\");\nprint(\"Scritti \" + typeof(scritti) + \" byte\");  // \"Scritti 14 byte\"\nf.close();\n```\n\n**Esempio - Scrittura righe multiple:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Riga 1\\n\");\nf.write(\"Riga 2\\n\");\nf.write(\"Riga 3\\n\");\nf.close();\n```\n\n**Esempio - Append a file di log:**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Applicazione avviata\\n\");\nf.write(\"[INFO] Utente connesso\\n\");\nf.close();\n```\n\n#### write_bytes(dati: buffer): i32\n\nScrive dati binari (restituisce byte scritti).\n\n**Parametri:**\n- `dati` (buffer) - Dati binari da scrivere\n\n**Restituisce:** Numero di byte scritti (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Crea dati binari\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet byte = f.write_bytes(buf);\nprint(\"Scritti \" + typeof(byte) + \" byte\");\n\nf.close();\n```\n\n**Esempio - Copia file binario:**\n```hemlock\nlet src = open(\"input.bin\", \"r\");\nlet dst = open(\"output.bin\", \"w\");\n\nlet dati = src.read_bytes(1024);\nwhile (dati.length > 0) {\n    dst.write_bytes(dati);\n    dati = src.read_bytes(1024);\n}\n\nsrc.close();\ndst.close();\n```\n\n### Seeking\n\n#### seek(posizione: i32): i32\n\nSposta a posizione specifica (restituisce nuova posizione).\n\n**Parametri:**\n- `posizione` (i32) - Offset in byte dall'inizio del file\n\n**Restituisce:** Nuova posizione (i32)\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\n// Sposta al byte 100\nf.seek(100);\n\n// Leggi dalla posizione 100\nlet dati = f.read(50);\n\n// Resetta all'inizio\nf.seek(0);\n\nf.close();\n```\n\n**Esempio - Accesso casuale:**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// Leggi record all'offset 1000\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// Leggi record all'offset 2000\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\nOttiene posizione corrente nel file.\n\n**Restituisce:** Offset byte corrente (i32)\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0 (all'inizio)\n\nf.read(100);\nlet pos2 = f.tell();  // 100 (dopo aver letto 100 byte)\n\nf.seek(500);\nlet pos3 = f.tell();  // 500 (dopo seeking)\n\nf.close();\n```\n\n**Esempio - Misurazione quantita letta:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\nlet inizio = f.tell();\nlet contenuto = f.read();\nlet fine = f.tell();\n\nlet byte_letti = fine - inizio;\nprint(\"Letti \" + typeof(byte_letti) + \" byte\");\n\nf.close();\n```\n\n### Chiusura\n\n#### close()\n\nChiude file (idempotente, puo essere chiamato piu volte).\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n// ... usa file\nf.close();\nf.close();  // Sicuro - nessun errore alla seconda chiusura\n```\n\n**Note importanti:**\n- Chiudere sempre i file quando finito per evitare leak di file descriptor\n- La chiusura e idempotente - puo essere chiamata piu volte in sicurezza\n- Dopo la chiusura, tutte le altre operazioni daranno errore\n- Usare blocchi `finally` per assicurarsi che i file siano chiusi anche in caso di errori\n\n## Proprieta File\n\nGli oggetti file hanno tre proprieta di sola lettura:\n\n### path: string\n\nIl percorso del file usato per aprirlo.\n\n```hemlock\nlet f = open(\"/percorso/al/file.txt\", \"r\");\nprint(f.path);  // \"/percorso/al/file.txt\"\nf.close();\n```\n\n### mode: string\n\nLa modalita con cui il file e stato aperto.\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\nSe il file e chiuso.\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**Esempio - Controllo se file e aperto:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\nif (!f.closed) {\n    let contenuto = f.read();\n    // ... elabora contenuto\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"Il file e ora chiuso\");\n}\n```\n\n## Gestione degli Errori\n\nTutte le operazioni sui file includono messaggi di errore appropriati con contesto.\n\n### Errori Comuni\n\n**File non trovato:**\n```hemlock\nlet f = open(\"mancante.txt\", \"r\");\n// Errore: Impossibile aprire 'mancante.txt': File o directory non esistente\n```\n\n**Lettura da file chiuso:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nf.close();\nf.read();\n// Errore: Impossibile leggere da file chiuso 'dati.txt'\n```\n\n**Scrittura su file di sola lettura:**\n```hemlock\nlet f = open(\"sololettura.txt\", \"r\");\nf.write(\"dati\");\n// Errore: Impossibile scrivere su file 'sololettura.txt' aperto in modalita sola lettura\n```\n\n**Lettura da file di sola scrittura:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Errore: Impossibile leggere da file 'output.txt' aperto in modalita sola scrittura\n```\n\n### Uso di try/catch\n\n```hemlock\ntry {\n    let f = open(\"dati.txt\", \"r\");\n    let contenuto = f.read();\n    f.close();\n    elabora(contenuto);\n} catch (e) {\n    print(\"Errore lettura file: \" + e);\n}\n```\n\n## Gestione delle Risorse\n\n### Pattern Base\n\nChiudere sempre i file esplicitamente:\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nlet contenuto = f.read();\nf.close();\n```\n\n### Con Gestione Errori (Raccomandato)\n\nUsare `finally` per assicurarsi che i file siano chiusi anche in caso di errori:\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\ntry {\n    let contenuto = f.read();\n    elabora(contenuto);\n} finally {\n    f.close();  // Chiude sempre, anche in caso di errore\n}\n```\n\n### File Multipli\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let contenuto = src.read();\n    dst.write(contenuto);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### Pattern Funzione Helper\n\n```hemlock\nfn con_file(percorso: string, modalita: string, callback) {\n    let f = open(percorso, modalita);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Utilizzo:\ncon_file(\"dati.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## Riferimento API Completo\n\n### Funzioni\n\n| Funzione | Parametri | Restituisce | Descrizione |\n|----------|-----------|-------------|-------------|\n| `open(percorso, modalita?)` | percorso: string, modalita?: string | File | Apre file (modalita predefinita \"r\") |\n\n### Metodi\n\n| Metodo | Parametri | Restituisce | Descrizione |\n|--------|-----------|-------------|-------------|\n| `read(dimensione?)` | dimensione?: i32 | string | Legge testo (tutto o byte specifici) |\n| `read_bytes(dimensione)` | dimensione: i32 | buffer | Legge dati binari |\n| `write(dati)` | dati: string | i32 | Scrive testo, restituisce byte scritti |\n| `write_bytes(dati)` | dati: buffer | i32 | Scrive dati binari, restituisce byte scritti |\n| `seek(posizione)` | posizione: i32 | i32 | Vai a posizione, restituisce nuova posizione |\n| `tell()` | - | i32 | Ottieni posizione corrente |\n| `close()` | - | null | Chiudi file (idempotente) |\n\n### Proprieta (sola lettura)\n\n| Proprieta | Tipo | Descrizione |\n|-----------|------|-------------|\n| `path` | string | Percorso file |\n| `mode` | string | Modalita apertura |\n| `closed` | bool | Se il file e chiuso |\n\n## Pattern Comuni\n\n### Lettura File Intero\n\n```hemlock\nfn leggi_file(percorso: string): string {\n    let f = open(percorso, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet contenuto = leggi_file(\"config.json\");\n```\n\n### Scrittura File Intero\n\n```hemlock\nfn scrivi_file(percorso: string, contenuto: string) {\n    let f = open(percorso, \"w\");\n    try {\n        f.write(contenuto);\n    } finally {\n        f.close();\n    }\n}\n\nscrivi_file(\"output.txt\", \"Ciao, Mondo!\");\n```\n\n### Append a File\n\n```hemlock\nfn appendi_file(percorso: string, contenuto: string) {\n    let f = open(percorso, \"a\");\n    try {\n        f.write(contenuto);\n    } finally {\n        f.close();\n    }\n}\n\nappendi_file(\"log.txt\", \"[INFO] Evento verificato\\n\");\n```\n\n### Lettura Righe\n\n```hemlock\nfn leggi_righe(percorso: string) {\n    let f = open(percorso, \"r\");\n    try {\n        let contenuto = f.read();\n        return contenuto.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet righe = leggi_righe(\"dati.txt\");\nlet i = 0;\nwhile (i < righe.length) {\n    print(\"Riga \" + typeof(i) + \": \" + righe[i]);\n    i = i + 1;\n}\n```\n\n### Elaborazione File Grandi a Chunk\n\n```hemlock\nfn elabora_file_grande(percorso: string) {\n    let f = open(percorso, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // Chunk da 4KB\n            if (chunk == \"\") { break; }\n\n            // Elabora chunk\n            elabora_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### Copia File Binario\n\n```hemlock\nfn copia_file(percorso_src: string, percorso_dst: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(percorso_src, \"r\");\n        dst = open(percorso_dst, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopia_file(\"input.dat\", \"output.dat\");\n```\n\n### Troncamento File\n\n```hemlock\nfn tronca_file(percorso: string) {\n    let f = open(percorso, \"w\");  // modalita \"w\" tronca\n    f.close();\n}\n\ntronca_file(\"svuotami.txt\");\n```\n\n### Lettura ad Accesso Casuale\n\n```hemlock\nfn leggi_a_offset(percorso: string, offset: i32, dimensione: i32): string {\n    let f = open(percorso, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(dimensione);\n    } finally {\n        f.close();\n    }\n}\n\nlet dati = leggi_a_offset(\"records.dat\", 1000, 100);\n```\n\n### Dimensione File\n\n```hemlock\nfn dimensione_file(percorso: string): i32 {\n    let f = open(percorso, \"r\");\n    try {\n        // Vai alla fine\n        let fine = f.seek(999999999);  // Numero grande\n        f.seek(0);  // Resetta\n        return fine;\n    } finally {\n        f.close();\n    }\n}\n\nlet dimensione = dimensione_file(\"dati.txt\");\nprint(\"Dimensione file: \" + typeof(dimensione) + \" byte\");\n```\n\n### Lettura/Scrittura Condizionale\n\n```hemlock\nfn aggiorna_file(percorso: string, condizione, nuovo_contenuto: string) {\n    let f = open(percorso, \"r+\");\n    try {\n        let contenuto = f.read();\n\n        if (condizione(contenuto)) {\n            f.seek(0);  // Resetta all'inizio\n            f.write(nuovo_contenuto);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n## Migliori Pratiche\n\n### 1. Usare Sempre try/finally\n\n```hemlock\n// Bene\nlet f = open(\"dati.txt\", \"r\");\ntry {\n    let contenuto = f.read();\n    elabora(contenuto);\n} finally {\n    f.close();\n}\n\n// Male - il file potrebbe non chiudersi in caso di errore\nlet f = open(\"dati.txt\", \"r\");\nlet contenuto = f.read();\nelabora(contenuto);  // Se questo lancia, il file ha leak\nf.close();\n```\n\n### 2. Controllare Stato del File Prima delle Operazioni\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\nif (!f.closed) {\n    let contenuto = f.read();\n    // ... usa contenuto\n}\n\nf.close();\n```\n\n### 3. Usare Modalita Appropriate\n\n```hemlock\n// Solo lettura? Usa \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// Sostituzione completa? Usa \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// Aggiunta alla fine? Usa \"a\"\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. Gestire gli Errori con Grazia\n\n```hemlock\nfn leggi_file_sicuro(percorso: string): string {\n    try {\n        let f = open(percorso, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Attenzione: Impossibile leggere \" + percorso + \": \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. Chiudere File in Ordine Inverso di Apertura\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... usa file\n} finally {\n    // Chiudi in ordine inverso\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. Evitare di Leggere File Grandi Interamente\n\n```hemlock\n// Male per file grandi\nlet f = open(\"enorme.log\", \"r\");\nlet contenuto = f.read();  // Carica intero file in memoria\nf.close();\n\n// Bene - elabora a chunk\nlet f = open(\"enorme.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        elabora_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## Riepilogo\n\nL'API I/O su File di Hemlock fornisce:\n\n- Operazioni sui file semplici ed esplicite\n- Supporto testo e binario\n- Accesso casuale con seek/tell\n- Messaggi di errore chiari con contesto\n- Operazione close idempotente\n\nRicorda:\n- Chiudere sempre i file manualmente\n- Usare try/finally per sicurezza delle risorse\n- Scegliere modalita di apertura appropriate\n- Gestire gli errori con grazia\n- Elaborare file grandi a chunk\n"}, "Argomenti Avanzati -> Impacchettamento e Distribuzione": {"id": "advanced-bundling-packaging", "content": "# Impacchettamento e Distribuzione\n\nHemlock fornisce strumenti integrati per impacchettare progetti multi-file in singoli file distribuibili e creare eseguibili autonomi.\n\n## Panoramica\n\n| Comando | Output | Caso d'Uso |\n|---------|--------|------------|\n| `--bundle` | `.hmlc` o `.hmlb` | Distribuire bytecode (richiede Hemlock per l'esecuzione) |\n| `--package` | Eseguibile | Binario standalone (nessuna dipendenza) |\n| `--compile` | `.hmlc` | Compila singolo file (nessuna risoluzione import) |\n\n## Bundling\n\nIl bundler risolve tutte le istruzioni `import` da un punto di ingresso e le appiattisce in un singolo file.\n\n### Uso Base\n\n```bash\n# Impacchetta app.hml e tutti i suoi import in app.hmlc\nhemlock --bundle app.hml\n\n# Specifica percorso di output\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# Crea bundle compresso (.hmlb) - dimensione file piu piccola\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# Output verboso (mostra i moduli risolti)\nhemlock --bundle app.hml --verbose\n```\n\n### Formati di Output\n\n**`.hmlc` (Non Compresso)**\n- Formato AST serializzato\n- Veloce da caricare ed eseguire\n- Formato di output predefinito\n\n**`.hmlb` (Compresso)**\n- `.hmlc` compresso con zlib\n- Dimensione file piu piccola (tipicamente riduzione del 50-70%)\n- Avvio leggermente piu lento a causa della decompressione\n\n### Esecuzione di File Impacchettati\n\n```bash\n# Esegui bundle non compresso\nhemlock app.hmlc\n\n# Esegui bundle compresso\nhemlock app.hmlb\n\n# Passa argomenti\nhemlock app.hmlc arg1 arg2\n```\n\n### Esempio: Progetto Multi-Modulo\n\n```\nmiaapp/\n main.hml\n lib/\n    math.hml\n    utils.hml\n config.hml\n```\n\n```hemlock\n// main.hml\nimport { somma, moltiplica } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSIONE } from \"./config.hml\";\n\nlog(`App v${VERSIONE}`);\nprint(somma(2, 3));\n```\n\n```bash\nhemlock --bundle miaapp/main.hml -o miaapp.hmlc\nhemlock miaapp.hmlc  # Esegue con tutte le dipendenze impacchettate\n```\n\n### Import della stdlib\n\nIl bundler risolve automaticamente gli import `@stdlib/`:\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\nQuando impacchettato, i moduli della stdlib sono inclusi nell'output.\n\n## Packaging\n\nIl packaging crea un eseguibile autonomo incorporando il bytecode impacchettato in una copia dell'interprete Hemlock.\n\n### Uso Base\n\n```bash\n# Crea eseguibile da app.hml\nhemlock --package app.hml\n\n# Specifica nome output\nhemlock --package app.hml -o miaapp\n\n# Salta compressione (avvio piu veloce, file piu grande)\nhemlock --package app.hml --no-compress\n\n# Output verboso\nhemlock --package app.hml --verbose\n```\n\n### Esecuzione di Eseguibili Impacchettati\n\n```bash\n# L'eseguibile impacchettato viene eseguito direttamente\n./miaapp\n\n# Gli argomenti vengono passati allo script\n./miaapp arg1 arg2\n```\n\n### Formato del Package\n\nGli eseguibili impacchettati usano il formato HMLP:\n\n```\n[binario hemlock][payload HMLB/HMLC][dimensione_payload:u64][magic HMLP:u32]\n```\n\nQuando un eseguibile impacchettato viene eseguito:\n1. Controlla la presenza di un payload incorporato alla fine del file\n2. Se trovato, decomprime ed esegue il payload\n3. Se non trovato, si comporta come un normale interprete Hemlock\n\n### Opzioni di Compressione\n\n| Flag | Formato | Avvio | Dimensione |\n|------|---------|-------|------------|\n| (predefinito) | HMLB | Normale | Piu piccola |\n| `--no-compress` | HMLC | Piu veloce | Piu grande |\n\nPer strumenti CLI dove il tempo di avvio e importante, usare `--no-compress`.\n\n## Ispezione dei Bundle\n\nUsa `--info` per ispezionare file impacchettati o compilati:\n\n```bash\nhemlock --info app.hmlc\n```\n\nOutput:\n```\n=== Info File: app.hmlc ===\nDimensione: 12847 byte\nFormato: HMLC (AST compilato)\nVersione: 1\nFlag: 0x0001 [DEBUG]\nStringhe: 42\nIstruzioni: 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\nOutput:\n```\n=== Info File: app.hmlb ===\nDimensione: 5234 byte\nFormato: HMLB (bundle compresso)\nVersione: 1\nNon compresso: 12847 byte\nCompresso: 5224 byte\nRapporto: riduzione del 59.3%\n```\n\n## Compilazione Nativa\n\nPer veri eseguibili nativi (senza interprete), usare il compilatore Hemlock:\n\n```bash\n# Compila in eseguibile nativo tramite C\nhemlockc app.hml -o app\n\n# Mantieni codice C generato\nhemlockc app.hml -o app --keep-c\n\n# Emetti solo C (non compilare)\nhemlockc app.hml -c -o app.c\n\n# Livello di ottimizzazione\nhemlockc app.hml -o app -O2\n```\n\nIl compilatore genera codice C e invoca GCC per produrre un binario nativo. Questo richiede:\n- La libreria runtime di Hemlock (`libhemlock_runtime`)\n- Un compilatore C (GCC per impostazione predefinita)\n\n### Opzioni del Compilatore\n\n| Opzione | Descrizione |\n|---------|-------------|\n| `-o <file>` | Nome eseguibile di output |\n| `-c` | Emetti solo codice C |\n| `--emit-c <file>` | Scrivi C nel file specificato |\n| `-k, --keep-c` | Mantieni C generato dopo la compilazione |\n| `-O<livello>` | Livello di ottimizzazione (0-3) |\n| `--cc <percorso>` | Compilatore C da usare |\n| `--runtime <percorso>` | Percorso alla libreria runtime |\n| `-v, --verbose` | Output verboso |\n\n## Confronto\n\n| Approccio | Portabilita | Avvio | Dimensione | Dipendenze |\n|-----------|-------------|-------|------------|------------|\n| `.hml` | Solo sorgente | Tempo di parsing | Piu piccola | Hemlock |\n| `.hmlc` | Solo Hemlock | Veloce | Piccola | Hemlock |\n| `.hmlb` | Solo Hemlock | Veloce | Piu piccola | Hemlock |\n| `--package` | Standalone | Veloce | Piu grande | Nessuna |\n| `hemlockc` | Nativo | Piu veloce | Variabile | Librerie runtime |\n\n## Migliori Pratiche\n\n1. **Sviluppo**: Esegui file `.hml` direttamente per iterazione rapida\n2. **Distribuzione (con Hemlock)**: Impacchetta con `--compress` per file piu piccoli\n3. **Distribuzione (standalone)**: Usa package per deployment senza dipendenze\n4. **Prestazioni critiche**: Usa `hemlockc` per compilazione nativa\n\n## Risoluzione Problemi\n\n### \"Impossibile trovare stdlib\"\n\nIl bundler cerca la stdlib in:\n1. `./stdlib` (relativo all'eseguibile)\n2. `../stdlib` (relativo all'eseguibile)\n3. `/usr/local/lib/hemlock/stdlib`\n\nAssicurati che Hemlock sia installato correttamente o esegui dalla directory sorgente.\n\n### Dipendenze Circolari\n\n```\nErrore: Dipendenza circolare rilevata durante il caricamento di 'percorso/al/modulo.hml'\n```\n\nRifattorizza i tuoi import per rompere il ciclo. Considera l'uso di un modulo condiviso per tipi comuni.\n\n### Dimensione Package Grande\n\n- Usa la compressione predefinita (non usare `--no-compress`)\n- La dimensione del package include l'intero interprete (~500KB-1MB base)\n- Per dimensione minima, usa `hemlockc` per compilazione nativa\n"}, "Argomenti Avanzati -> Memory Ownership": {"id": "advanced-memory-ownership", "content": "# Propriet della Memoria in Hemlock\n\n> \"Ti diamo gli strumenti per essere sicuro, ma non ti obblighiamo a usarli.\"\n\nQuesto documento descrive la semantica della propriet della memoria in Hemlock, coprendo sia la memoria gestita dal programmatore che i valori gestiti dal runtime.\n\n## Indice\n\n1. [Il Contratto](#il-contratto)\n2. [Memoria Gestita dal Programmatore](#memoria-gestita-dal-programmatore)\n3. [Valori Gestiti dal Runtime](#valori-gestiti-dal-runtime)\n4. [Punti di Trasferimento della Propriet](#punti-di-trasferimento-della-propriet)\n5. [Async e Concorrenza](#async-e-concorrenza)\n6. [Regole di Memoria FFI](#regole-di-memoria-ffi)\n7. [Sicurezza delle Eccezioni](#sicurezza-delle-eccezioni)\n8. [Best Practice](#best-practice)\n\n---\n\n## Il Contratto\n\nHemlock ha una chiara divisione delle responsabilit di gestione della memoria:\n\n| Tipo di Memoria | Gestito Da | Metodo di Pulizia |\n|-----------------|------------|-------------------|\n| Puntatori grezzi (`ptr`) | **Programmatore** | `free(ptr)` |\n| Buffer (`buffer`) | **Programmatore** | `free(buf)` |\n| String, Array, Oggetti | **Runtime** | Automatico (conteggio riferimenti) |\n| Funzioni, Closure | **Runtime** | Automatico (conteggio riferimenti) |\n| Task, Channel | **Runtime** | Automatico (conteggio riferimenti) |\n\n**Il principio fondamentale:** Se lo allochi esplicitamente, lo liberi esplicitamente. Tutto il resto viene gestito automaticamente.\n\n---\n\n## Memoria Gestita dal Programmatore\n\n### Puntatori Grezzi\n\n```hemlock\nlet p = alloc(64);       // Allocare 64 byte\nmemset(p, 0, 64);        // Inizializzare\n// ... usare la memoria ...\nfree(p);                 // Responsabilit tua!\n```\n\n**Regole:**\n- `alloc()` restituisce memoria che possiedi tu\n- Devi chiamare `free()` quando hai finito\n- Il double-free causer un crash (intenzionalmente)\n- L'use-after-free  comportamento indefinito\n- L'aritmetica dei puntatori  permessa ma non verificata\n\n### Allocazione Tipizzata\n\n```hemlock\nlet arr = talloc(\"i32\", 100);  // Allocare 100 i32 (400 byte)\nptr_write_i32(arr, 0, 42);     // Scrivere all'indice 0\nlet val = ptr_read_i32(arr, 0); // Leggere dall'indice 0\nfree(arr);                      // Sempre responsabilit tua\n```\n\n### Buffer (Alternativa Sicura)\n\n```hemlock\nlet buf = buffer(64);    // Buffer con controllo dei limiti\nbuf[0] = 42;             // Indicizzazione sicura\n// buf[100] = 1;         // Errore runtime: fuori dai limiti\nfree(buf);               // Richiede ancora free esplicito\n```\n\n**Differenza chiave:** I buffer forniscono controllo dei limiti, i puntatori grezzi no.\n\n---\n\n## Valori Gestiti dal Runtime\n\n### Conteggio dei Riferimenti\n\nI valori allocati sull'heap usano conteggio dei riferimenti atomico:\n\n```hemlock\nlet s1 = \"hello\";        // String allocata, refcount = 1\nlet s2 = s1;             // s2 condivide s1, refcount = 2\n// Quando entrambi escono dallo scope, refcount  0, memoria liberata\n```\n\n**Tipi con conteggio dei riferimenti:**\n- `string` - Testo UTF-8\n- `array` - Array dinamici\n- `object` - Oggetti chiave-valore\n- `function` - Closure\n- `task` - Handle di task async\n- `channel` - Canali di comunicazione\n\n### Rilevamento dei Cicli\n\nIl runtime gestisce i cicli nei grafi di oggetti:\n\n```hemlock\nlet a = { ref: null };\nlet b = { ref: a };\na.ref = b;               // Ciclo: a  b  a\n// Il runtime usa insiemi visitati per rilevare e spezzare i cicli durante la pulizia\n```\n\n---\n\n## Punti di Trasferimento della Propriet\n\n### Binding di Variabili\n\n```hemlock\nlet x = [1, 2, 3];       // Array creato con refcount 1\n                         // x possiede il riferimento\n```\n\n### Ritorni di Funzioni\n\n```hemlock\nfn make_array() {\n    return [1, 2, 3];    // La propriet dell'array si trasferisce al chiamante\n}\nlet arr = make_array();  // arr ora possiede il riferimento\n```\n\n### Assegnazione\n\n```hemlock\nlet a = \"hello\";\nlet b = a;               // Riferimento condiviso (refcount incrementato)\nb = \"world\";             // a ha ancora \"hello\", b ha \"world\"\n```\n\n### Operazioni sui Channel\n\n```hemlock\nlet ch = channel(10);\nch.send(\"message\");      // Valore copiato nel buffer del channel\n                         // L'originale rimane valido\n\nlet msg = ch.recv();     // Riceve la propriet dal channel\n```\n\n### Spawning di Task\n\n```hemlock\nlet data = { x: 1 };\nlet task = spawn(worker, data);  // data viene COPIATO IN PROFONDIT per isolamento\ndata.x = 2;                       // Sicuro - il task ha la sua copia\nlet result = join(task);          // La propriet del result si trasferisce al chiamante\n```\n\n---\n\n## Async e Concorrenza\n\n### Isolamento dei Thread\n\nI task spawnati ricevono **copie profonde** degli argomenti mutabili:\n\n```hemlock\nasync fn worker(data) {\n    data.x = 100;        // Modifica solo la copia del task\n    return data;\n}\n\nlet obj = { x: 1 };\nlet task = spawn(worker, obj);\nobj.x = 2;               // Sicuro - non influenza il task\nlet result = join(task);\nprint(obj.x);            // 2 (invariato dal task)\nprint(result.x);         // 100 (copia modificata del task)\n```\n\n### Oggetti di Coordinazione Condivisi\n\nAlcuni tipi sono condivisi per riferimento (non copiati):\n- **Channel** - Per la comunicazione tra task\n- **Task** - Per la coordinazione (join/detach)\n\n```hemlock\nlet ch = channel(1);\nspawn(producer, ch);     // Stesso channel, non una copia\nspawn(consumer, ch);     // Entrambi i task condividono il channel\n```\n\n### Risultati dei Task\n\n```hemlock\nlet task = spawn(compute);\nlet result = join(task);  // Il chiamante possiede il risultato\n                          // Il riferimento del task viene rilasciato quando il task viene liberato\n```\n\n### Task Staccati\n\n```hemlock\ndetach(spawn(background_work));\n// Il task gira indipendentemente\n// Il risultato viene rilasciato automaticamente quando il task completa\n// Nessun leak anche se nessuno chiama join()\n```\n\n---\n\n## Regole di Memoria FFI\n\n### Passaggio a Funzioni C\n\n```hemlock\nextern fn strlen(s: string): i32;\n\nlet s = \"hello\";\nlet len = strlen(s);     // Hemlock mantiene la propriet\n                         // La string  valida durante la chiamata\n                         // La funzione C NON deve liberarla\n```\n\n### Ricezione da Funzioni C\n\n```hemlock\nextern fn strdup(s: string): ptr;\n\nlet copy = strdup(\"hello\");  // C ha allocato questa memoria\nfree(copy);                   // Responsabilit tua liberarla\n```\n\n### Passaggio di Struct (Solo Compilatore)\n\n```hemlock\n// Definire il layout della struct C\nffi_struct Point { x: f64, y: f64 }\n\nextern fn make_point(x: f64, y: f64): Point;\n\nlet p = make_point(1.0, 2.0);  // Restituito per valore, copiato\n                                // Nessuna pulizia necessaria per struct sullo stack\n```\n\n### Memoria dei Callback\n\n```hemlock\n// Quando C richiama Hemlock:\n// - Gli argomenti appartengono a C (non liberare)\n// - La propriet del valore di ritorno si trasferisce a C\n```\n\n---\n\n## Sicurezza delle Eccezioni\n\n### Garanzie\n\nIl runtime fornisce queste garanzie:\n\n1. **Nessun leak in uscita normale** - Tutti i valori gestiti dal runtime vengono puliti\n2. **Nessun leak in eccezione** - I temporanei vengono rilasciati durante lo stack unwinding\n3. **Defer esegue in eccezione** - Il codice di pulizia viene eseguito\n\n### Valutazione delle Espressioni\n\n```hemlock\n// Se questo lancia durante la creazione dell'array:\nlet arr = [f(), g(), h()];  // L'array parziale viene rilasciato\n\n// Se questo lancia durante la chiamata di funzione:\nfoo(a(), b(), c());         // Gli arg precedentemente valutati vengono rilasciati\n```\n\n### Defer per la Pulizia\n\n```hemlock\nfn process_file() {\n    let f = open(\"data.txt\", \"r\");\n    defer f.close();         // Esegue al return O all'eccezione\n\n    let data = f.read();\n    if (data == \"\") {\n        throw \"Empty file\";  // f.close() esegue comunque!\n    }\n    return data;\n}\n```\n\n---\n\n## Best Practice\n\n### 1. Preferisci i Tipi Gestiti dal Runtime\n\n```hemlock\n// Preferisci questo:\nlet data = [1, 2, 3, 4, 5];\n\n// A questo (a meno che tu non abbia bisogno di controllo a basso livello):\nlet data = talloc(\"i32\", 5);\n// ... devi ricordarti di liberare ...\n```\n\n### 2. Usa Defer per la Memoria Manuale\n\n```hemlock\nfn process() {\n    let buf = alloc(1024);\n    defer free(buf);        // Pulizia garantita\n\n    // ... usare buf ...\n    // Non serve liberare ad ogni punto di ritorno\n}\n```\n\n### 3. Evita i Puntatori Grezzi in Async\n\n```hemlock\n// SBAGLIATO - il puntatore potrebbe essere liberato prima che il task completi\nlet p = alloc(64);\nspawn(worker, p);          // Il task ottiene il valore del puntatore\nfree(p);                   // Ops! Il task lo sta ancora usando\n\n// CORRETTO - usa channel o copia i dati\nlet ch = channel(1);\nlet data = buffer(64);\n// ... riempire data ...\nch.send(data);             // Copia profonda\nspawn(worker, ch);\nfree(data);                // Sicuro - il task ha la sua copia\n```\n\n### 4. Chiudi i Channel Quando Hai Finito\n\n```hemlock\nlet ch = channel(10);\n// ... usare il channel ...\nch.close();                // Svuota e rilascia i valori nel buffer\n```\n\n### 5. Join o Detach i Task\n\n```hemlock\nlet task = spawn(work);\n\n// Opzione 1: Aspettare il risultato\nlet result = join(task);\n\n// Opzione 2: Fire and forget\n// detach(task);\n\n// NON: Lasciare che l'handle del task esca dallo scope senza join o detach\n// (Verr pulito, ma il risultato potrebbe avere leak)\n```\n\n---\n\n## Debug dei Problemi di Memoria\n\n### Abilitare ASAN\n\n```bash\nmake asan\nASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml\n```\n\n### Eseguire i Test di Regressione dei Leak\n\n```bash\nmake leak-regression       # Suite completa\nmake leak-regression-quick # Salta il test esaustivo\n```\n\n### Valgrind\n\n```bash\nmake valgrind-check FILE=script.hml\n```\n\n---\n\n## Riepilogo\n\n| Operazione | Comportamento Memoria |\n|------------|----------------------|\n| `alloc(n)` | Alloca, tu liberi |\n| `buffer(n)` | Alloca con controllo limiti, tu liberi |\n| `\"string\"` | Il runtime gestisce |\n| `[array]` | Il runtime gestisce |\n| `{object}` | Il runtime gestisce |\n| `spawn(fn)` | Copia profonda degli arg, il runtime gestisce il task |\n| `join(task)` | Il chiamante possiede il risultato |\n| `detach(task)` | Il runtime rilascia il risultato quando finito |\n| `ch.send(v)` | Copia il valore nel channel |\n| `ch.recv()` | Il chiamante possiede il valore ricevuto |\n| `ch.close()` | Svuota e rilascia i valori nel buffer |\n"}, "Argomenti Avanzati -> Operazioni Atomiche": {"id": "advanced-atomics", "content": "# Operazioni Atomiche\n\nHemlock fornisce operazioni atomiche per la **programmazione concorrente lock-free**. Queste operazioni consentono la manipolazione sicura della memoria condivisa tra piu thread senza l'uso di lock o mutex tradizionali.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [Quando Usare le Atomiche](#quando-usare-le-atomiche)\n- [Modello di Memoria](#modello-di-memoria)\n- [Load e Store Atomici](#load-e-store-atomici)\n- [Operazioni Fetch-and-Modify](#operazioni-fetch-and-modify)\n- [Compare-and-Swap (CAS)](#compare-and-swap-cas)\n- [Exchange Atomico](#exchange-atomico)\n- [Memory Fence](#memory-fence)\n- [Riferimento Funzioni](#riferimento-funzioni)\n- [Pattern Comuni](#pattern-comuni)\n- [Migliori Pratiche](#migliori-pratiche)\n- [Limitazioni](#limitazioni)\n\n---\n\n## Panoramica\n\nLe operazioni atomiche sono operazioni **indivisibili** che si completano senza la possibilita di interruzione. Quando un thread esegue un'operazione atomica, nessun altro thread puo osservare l'operazione in uno stato parzialmente completato.\n\n**Caratteristiche principali:**\n- Tutte le operazioni usano **consistenza sequenziale** (`memory_order_seq_cst`)\n- Tipi supportati: **i32** e **i64**\n- Le operazioni lavorano su puntatori raw allocati con `alloc()`\n- Thread-safe senza lock espliciti\n\n**Operazioni disponibili:**\n- Load/Store - Leggere e scrivere valori atomicamente\n- Add/Sub - Operazioni aritmetiche che restituiscono il vecchio valore\n- And/Or/Xor - Operazioni bitwise che restituiscono il vecchio valore\n- CAS - Compare-and-swap per aggiornamenti condizionali\n- Exchange - Scambiare valori atomicamente\n- Fence - Barriera di memoria completa\n\n---\n\n## Quando Usare le Atomiche\n\n**Usare le atomiche per:**\n- Contatori condivisi tra task (es. conteggio richieste, tracciamento progresso)\n- Flag e indicatori di stato\n- Strutture dati lock-free\n- Primitive di sincronizzazione semplici\n- Codice concorrente critico per le prestazioni\n\n**Usare i canali invece quando:**\n- Si passano dati complessi tra task\n- Si implementano pattern produttore-consumatore\n- Si ha bisogno di semantica message-passing\n\n**Esempio di caso d'uso - Contatore condiviso:**\n```hemlock\n// Alloca contatore condiviso\nlet contatore = alloc(4);\nptr_write_i32(contatore, 0);\n\nasync fn worker(contatore: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(contatore, 1);\n        i = i + 1;\n    }\n}\n\n// Crea piu workers\nlet t1 = spawn(worker, contatore, 1);\nlet t2 = spawn(worker, contatore, 2);\nlet t3 = spawn(worker, contatore, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// Il contatore sara esattamente 3000 (nessuna data race)\nprint(atomic_load_i32(contatore));\n\nfree(contatore);\n```\n\n---\n\n## Modello di Memoria\n\nTutte le operazioni atomiche di Hemlock usano **consistenza sequenziale** (`memory_order_seq_cst`), che fornisce le garanzie di ordinamento di memoria piu forti:\n\n1. **Atomicita**: Ogni operazione e indivisibile\n2. **Ordinamento totale**: Tutti i thread vedono lo stesso ordine delle operazioni\n3. **Nessun riordinamento**: Le operazioni non vengono riordinate dal compilatore o dalla CPU\n\nQuesto rende piu semplice il ragionamento sul codice concorrente, a costo di alcune potenziali prestazioni rispetto a ordinamenti di memoria piu deboli.\n\n---\n\n## Load e Store Atomici\n\n### atomic_load_i32 / atomic_load_i64\n\nLegge atomicamente un valore dalla memoria.\n\n**Firma:**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**Parametri:**\n- `ptr` - Puntatore alla locazione di memoria (deve essere allineato correttamente)\n\n**Restituisce:** Il valore nella locazione di memoria\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet valore = atomic_load_i32(p);\nprint(valore);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\nScrive atomicamente un valore in memoria.\n\n**Firma:**\n```hemlock\natomic_store_i32(ptr: ptr, valore: i32): null\natomic_store_i64(ptr: ptr, valore: i64): null\n```\n\n**Parametri:**\n- `ptr` - Puntatore alla locazione di memoria\n- `valore` - Valore da memorizzare\n\n**Restituisce:** `null`\n\n**Esempio:**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## Operazioni Fetch-and-Modify\n\nQueste operazioni modificano atomicamente un valore e restituiscono il valore **precedente** (vecchio).\n\n### atomic_add_i32 / atomic_add_i64\n\nAggiunge atomicamente a un valore.\n\n**Firma:**\n```hemlock\natomic_add_i32(ptr: ptr, valore: i32): i32\natomic_add_i64(ptr: ptr, valore: i64): i64\n```\n\n**Restituisce:** Il valore **precedente** (prima dell'addizione)\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet vecchio = atomic_add_i32(p, 10);\nprint(vecchio);                    // 100 (valore precedente)\nprint(atomic_load_i32(p));         // 110 (nuovo valore)\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\nSottrae atomicamente da un valore.\n\n**Firma:**\n```hemlock\natomic_sub_i32(ptr: ptr, valore: i32): i32\natomic_sub_i64(ptr: ptr, valore: i64): i64\n```\n\n**Restituisce:** Il valore **precedente** (prima della sottrazione)\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet vecchio = atomic_sub_i32(p, 25);\nprint(vecchio);                    // 100 (valore precedente)\nprint(atomic_load_i32(p));         // 75 (nuovo valore)\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\nEsegue atomicamente AND bitwise.\n\n**Firma:**\n```hemlock\natomic_and_i32(ptr: ptr, valore: i32): i32\natomic_and_i64(ptr: ptr, valore: i64): i64\n```\n\n**Restituisce:** Il valore **precedente** (prima dell'AND)\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // 255 in binario: 11111111\n\nlet vecchio = atomic_and_i32(p, 0x0F);  // AND con 00001111\nprint(vecchio);                    // 255 (valore precedente)\nprint(atomic_load_i32(p));         // 15 (0xFF & 0x0F = 0x0F)\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\nEsegue atomicamente OR bitwise.\n\n**Firma:**\n```hemlock\natomic_or_i32(ptr: ptr, valore: i32): i32\natomic_or_i64(ptr: ptr, valore: i64): i64\n```\n\n**Restituisce:** Il valore **precedente** (prima dell'OR)\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // 15 in binario: 00001111\n\nlet vecchio = atomic_or_i32(p, 0xF0);  // OR con 11110000\nprint(vecchio);                    // 15 (valore precedente)\nprint(atomic_load_i32(p));         // 255 (0x0F | 0xF0 = 0xFF)\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\nEsegue atomicamente XOR bitwise.\n\n**Firma:**\n```hemlock\natomic_xor_i32(ptr: ptr, valore: i32): i32\natomic_xor_i64(ptr: ptr, valore: i64): i64\n```\n\n**Restituisce:** Il valore **precedente** (prima dello XOR)\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // 170 in binario: 10101010\n\nlet vecchio = atomic_xor_i32(p, 0xFF);  // XOR con 11111111\nprint(vecchio);                    // 170 (valore precedente)\nprint(atomic_load_i32(p));         // 85 (0xAA ^ 0xFF = 0x55)\n\nfree(p);\n```\n\n---\n\n## Compare-and-Swap (CAS)\n\nL'operazione atomica piu potente. Confronta atomicamente il valore attuale con un valore atteso e, se corrispondono, lo sostituisce con un nuovo valore.\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**Firma:**\n```hemlock\natomic_cas_i32(ptr: ptr, atteso: i32, desiderato: i32): bool\natomic_cas_i64(ptr: ptr, atteso: i64, desiderato: i64): bool\n```\n\n**Parametri:**\n- `ptr` - Puntatore alla locazione di memoria\n- `atteso` - Valore che ci aspettiamo di trovare\n- `desiderato` - Valore da memorizzare se l'aspettativa corrisponde\n\n**Restituisce:**\n- `true` - Scambio riuscito (il valore era `atteso`, ora e `desiderato`)\n- `false` - Scambio fallito (il valore non era `atteso`, invariato)\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS riuscito: il valore e 100, scambia a 999\nlet successo1 = atomic_cas_i32(p, 100, 999);\nprint(successo1);                  // true\nprint(atomic_load_i32(p));         // 999\n\n// CAS fallito: il valore e 999, non 100\nlet successo2 = atomic_cas_i32(p, 100, 888);\nprint(successo2);                  // false\nprint(atomic_load_i32(p));         // 999 (invariato)\n\nfree(p);\n```\n\n**Casi d'uso:**\n- Implementazione di lock e semafori\n- Strutture dati lock-free\n- Controllo di concorrenza ottimistico\n- Aggiornamenti condizionali atomici\n\n---\n\n## Exchange Atomico\n\nScambia atomicamente un valore, restituendo il vecchio valore.\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**Firma:**\n```hemlock\natomic_exchange_i32(ptr: ptr, valore: i32): i32\natomic_exchange_i64(ptr: ptr, valore: i64): i64\n```\n\n**Parametri:**\n- `ptr` - Puntatore alla locazione di memoria\n- `valore` - Nuovo valore da memorizzare\n\n**Restituisce:** Il valore **precedente** (prima dello scambio)\n\n**Esempio:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet vecchio = atomic_exchange_i32(p, 200);\nprint(vecchio);                    // 100 (valore precedente)\nprint(atomic_load_i32(p));         // 200 (nuovo valore)\n\nfree(p);\n```\n\n---\n\n## Memory Fence\n\nUna barriera di memoria completa che assicura che tutte le operazioni di memoria prima della fence siano visibili a tutti i thread prima di qualsiasi operazione dopo la fence.\n\n### atomic_fence\n\n**Firma:**\n```hemlock\natomic_fence(): null\n```\n\n**Restituisce:** `null`\n\n**Esempio:**\n```hemlock\n// Assicura che tutte le scritture precedenti siano visibili\natomic_fence();\n```\n\n**Nota:** Nella maggior parte dei casi, non hai bisogno di fence esplicite perche tutte le operazioni atomiche gia usano consistenza sequenziale. Le fence sono utili quando hai bisogno di sincronizzare operazioni di memoria non atomiche.\n\n---\n\n## Riferimento Funzioni\n\n### Operazioni i32\n\n| Funzione | Firma | Restituisce | Descrizione |\n|----------|-------|-------------|-------------|\n| `atomic_load_i32` | `(ptr)` | `i32` | Carica valore atomicamente |\n| `atomic_store_i32` | `(ptr, valore)` | `null` | Memorizza valore atomicamente |\n| `atomic_add_i32` | `(ptr, valore)` | `i32` | Aggiunge e restituisce vecchio valore |\n| `atomic_sub_i32` | `(ptr, valore)` | `i32` | Sottrae e restituisce vecchio valore |\n| `atomic_and_i32` | `(ptr, valore)` | `i32` | AND bitwise e restituisce vecchio valore |\n| `atomic_or_i32` | `(ptr, valore)` | `i32` | OR bitwise e restituisce vecchio valore |\n| `atomic_xor_i32` | `(ptr, valore)` | `i32` | XOR bitwise e restituisce vecchio valore |\n| `atomic_cas_i32` | `(ptr, atteso, desiderato)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i32` | `(ptr, valore)` | `i32` | Scambia e restituisce vecchio valore |\n\n### Operazioni i64\n\n| Funzione | Firma | Restituisce | Descrizione |\n|----------|-------|-------------|-------------|\n| `atomic_load_i64` | `(ptr)` | `i64` | Carica valore atomicamente |\n| `atomic_store_i64` | `(ptr, valore)` | `null` | Memorizza valore atomicamente |\n| `atomic_add_i64` | `(ptr, valore)` | `i64` | Aggiunge e restituisce vecchio valore |\n| `atomic_sub_i64` | `(ptr, valore)` | `i64` | Sottrae e restituisce vecchio valore |\n| `atomic_and_i64` | `(ptr, valore)` | `i64` | AND bitwise e restituisce vecchio valore |\n| `atomic_or_i64` | `(ptr, valore)` | `i64` | OR bitwise e restituisce vecchio valore |\n| `atomic_xor_i64` | `(ptr, valore)` | `i64` | XOR bitwise e restituisce vecchio valore |\n| `atomic_cas_i64` | `(ptr, atteso, desiderato)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i64` | `(ptr, valore)` | `i64` | Scambia e restituisce vecchio valore |\n\n### Barriera di Memoria\n\n| Funzione | Firma | Restituisce | Descrizione |\n|----------|-------|-------------|-------------|\n| `atomic_fence` | `()` | `null` | Barriera di memoria completa |\n\n---\n\n## Pattern Comuni\n\n### Pattern: Contatore Atomico\n\n```hemlock\n// Contatore thread-safe\nlet contatore = alloc(4);\nptr_write_i32(contatore, 0);\n\nfn incrementa(): i32 {\n    return atomic_add_i32(contatore, 1);\n}\n\nfn decrementa(): i32 {\n    return atomic_sub_i32(contatore, 1);\n}\n\nfn ottieni_conteggio(): i32 {\n    return atomic_load_i32(contatore);\n}\n\n// Utilizzo\nincrementa();  // Restituisce 0 (vecchio valore)\nincrementa();  // Restituisce 1\nincrementa();  // Restituisce 2\nprint(ottieni_conteggio());  // 3\n\nfree(contatore);\n```\n\n### Pattern: Spinlock\n\n```hemlock\n// Implementazione semplice di spinlock\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = sbloccato, 1 = bloccato\n\nfn acquisisci() {\n    // Gira finche non riesce a impostare il lock da 0 a 1\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // Attesa attiva\n    }\n}\n\nfn rilascia() {\n    atomic_store_i32(lock, 0);\n}\n\n// Utilizzo\nacquisisci();\n// ... sezione critica ...\nrilascia();\n\nfree(lock);\n```\n\n### Pattern: Inizializzazione Una Tantum\n\n```hemlock\nlet inizializzato = alloc(4);\nptr_write_i32(inizializzato, 0);  // 0 = non inizializzato, 1 = inizializzato\n\nfn assicura_inizializzato() {\n    // Prova a essere quello che inizializza\n    if (atomic_cas_i32(inizializzato, 0, 1)) {\n        // Abbiamo vinto la gara, esegui l'inizializzazione\n        esegui_inizializzazione_costosa();\n    }\n    // Altrimenti, gia inizializzato\n}\n```\n\n### Pattern: Flag Atomico\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn imposta_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn resetta_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // Restituisce true se il flag era gia impostato\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn controlla_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### Pattern: Contatore Limitato\n\n```hemlock\nlet contatore = alloc(4);\nptr_write_i32(contatore, 0);\nlet valore_massimo = 100;\n\nfn prova_incrementa(): bool {\n    while (true) {\n        let corrente = atomic_load_i32(contatore);\n        if (corrente >= valore_massimo) {\n            return false;  // Al massimo\n        }\n        if (atomic_cas_i32(contatore, corrente, corrente + 1)) {\n            return true;  // Incrementato con successo\n        }\n        // CAS fallito, un altro thread ha modificato - riprova\n    }\n}\n```\n\n---\n\n## Migliori Pratiche\n\n### 1. Usare Allineamento Corretto\n\nI puntatori devono essere allineati correttamente per il tipo di dato:\n- i32: allineamento 4 byte\n- i64: allineamento 8 byte\n\nLa memoria da `alloc()` e tipicamente allineata correttamente.\n\n### 2. Preferire Astrazioni di Alto Livello\n\nQuando possibile, usare i canali per la comunicazione inter-task. Le atomiche sono di livello piu basso e richiedono ragionamento attento.\n\n```hemlock\n// Preferire questo:\nlet ch = channel(10);\nspawn(fn() { ch.send(risultato); });\nlet valore = ch.recv();\n\n// Invece di coordinazione atomica manuale quando appropriato\n```\n\n### 3. Essere Consapevoli del Problema ABA\n\nCAS puo soffrire del problema ABA: un valore cambia da A a B e torna ad A. Il tuo CAS ha successo, ma lo stato potrebbe essere cambiato nel frattempo.\n\n### 4. Inizializzare Prima di Condividere\n\nInizializzare sempre le variabili atomiche prima di creare task che le accedono:\n\n```hemlock\nlet contatore = alloc(4);\nptr_write_i32(contatore, 0);  // Inizializza PRIMA di fare spawn\n\nlet task = spawn(worker, contatore);\n```\n\n### 5. Liberare Dopo il Completamento di Tutti i Task\n\nNon liberare memoria atomica mentre i task potrebbero ancora accedervi:\n\n```hemlock\nlet contatore = alloc(4);\nptr_write_i32(contatore, 0);\n\nlet t1 = spawn(worker, contatore);\nlet t2 = spawn(worker, contatore);\n\njoin(t1);\njoin(t2);\n\n// Ora e sicuro liberare\nfree(contatore);\n```\n\n---\n\n## Limitazioni\n\n### Limitazioni Attuali\n\n1. **Solo i32 e i64 supportati** - Nessuna operazione atomica per altri tipi\n2. **Nessuna atomica per puntatori** - Non si possono caricare/memorizzare puntatori atomicamente\n3. **Solo consistenza sequenziale** - Nessun ordinamento di memoria piu debole disponibile\n4. **Nessuna atomica in virgola mobile** - Usare rappresentazione intera se necessario\n\n### Note sulla Piattaforma\n\n- Le operazioni atomiche usano C11 `<stdatomic.h>` internamente\n- Disponibile su tutte le piattaforme che supportano thread POSIX\n- Garantito essere lock-free su moderni sistemi a 64 bit\n\n---\n\n## Vedi Anche\n\n- [Async/Concorrenza](#advanced-async-concurrency) - Creazione di task e canali\n- [Gestione della Memoria](#language-guide-memory) - Allocazione di puntatori e buffer\n- [API Memoria](#reference-memory-api) - Funzioni di allocazione\n"}, "Argomenti Avanzati -> Profilazione": {"id": "advanced-profiling", "content": "# Profilazione\n\nHemlock include un profiler integrato per **analisi del tempo CPU**, **tracciamento della memoria** e **rilevamento leak**. Il profiler aiuta a identificare colli di bottiglia delle prestazioni e problemi di memoria nei tuoi programmi.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [Avvio Rapido](#avvio-rapido)\n- [Modalita di Profilazione](#modalita-di-profilazione)\n- [Formati di Output](#formati-di-output)\n- [Rilevamento Leak](#rilevamento-leak)\n- [Comprensione dei Report](#comprensione-dei-report)\n- [Generazione Flamegraph](#generazione-flamegraph)\n- [Migliori Pratiche](#migliori-pratiche)\n\n---\n\n## Panoramica\n\nIl profiler e accessibile tramite il sottocomando `profile`:\n\n```bash\nhemlock profile [OPZIONI] <FILE>\n```\n\n**Funzionalita principali:**\n- **Profilazione CPU** - Misura il tempo speso in ogni funzione (self-time e total-time)\n- **Profilazione memoria** - Traccia tutte le allocazioni con locazioni sorgente\n- **Rilevamento leak** - Identifica memoria mai liberata\n- **Formati output multipli** - Testo, JSON e output compatibile flamegraph\n- **Statistiche memoria per-funzione** - Vedi quali funzioni allocano piu memoria\n\n---\n\n## Avvio Rapido\n\n### Profila tempo CPU (predefinito)\n\n```bash\nhemlock profile script.hml\n```\n\n### Profila allocazioni memoria\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### Rileva memory leak\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### Genera dati flamegraph\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## Modalita di Profilazione\n\n### Profilazione CPU (predefinita)\n\nMisura il tempo speso in ogni funzione, distinguendo tra:\n- **Self time** - Tempo speso nell'esecuzione del codice proprio della funzione\n- **Total time** - Self time piu tempo speso nelle funzioni chiamate\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # Esplicito\n```\n\n**Esempio output:**\n```\n=== Report Profiler Hemlock ===\n\nTempo totale: 1.234ms\nFunzioni chiamate: 5 uniche\n\n--- Top 5 per Self Time ---\n\nFunzione                        Self      Total   Chiamate\n--------                        ----      -----   --------\ncalcolo_costoso             0.892ms    0.892ms     100  (72.3%)\nelabora_dati                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### Profilazione Memoria\n\nTraccia tutte le allocazioni di memoria (`alloc`, `buffer`, `talloc`, `realloc`) con locazioni sorgente.\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**Esempio output:**\n```\n=== Report Profiler Hemlock ===\n\nTempo totale: 0.543ms\nFunzioni chiamate: 3 uniche\nAllocazioni totali: 15 (4.2KB)\n\n--- Top 3 per Self Time ---\n\nFunzione                        Self      Total   Chiamate      Alloc      Conteggio\n--------                        ----      -----   --------      -----      ---------\nallocatore                  0.312ms    0.312ms      10      3.2KB         10  (57.5%)\noperazioni_buffer           0.156ms    0.156ms       5       1KB          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0B          0  (13.8%)\n\n--- Top 10 Siti di Allocazione ---\n\nLocazione                                     Totale    Conteggio\n---------                                     ------    ---------\nsrc/data.hml:42                               1.5KB        5\nsrc/data.hml:67                               1.0KB       10\nsrc/main.hml:15                               512B         1\n```\n\n---\n\n### Modalita Conteggio Chiamate\n\nModalita a overhead minimo che conta solo le chiamate a funzione (nessun timing).\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## Formati di Output\n\n### Testo (predefinito)\n\nRiepilogo leggibile con tabelle.\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\nFormato leggibile dalla macchina per integrazione con altri strumenti.\n\n```bash\nhemlock profile --json script.hml\n```\n\n**Esempio output:**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"calcolo_costoso\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### Flamegraph\n\nGenera formato stack collapsed compatibile con [flamegraph.pl](https://github.com/brendangregg/FlameGraph).\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# Genera SVG con flamegraph.pl\nflamegraph.pl profile.folded > profile.svg\n```\n\n**Esempio output folded:**\n```\nmain;elabora_dati;calcolo_costoso 892\nmain;elabora_dati;helper 67\nmain;elabora_dati 234\nmain 41\n```\n\n---\n\n## Rilevamento Leak\n\nIl flag `--leaks` mostra solo allocazioni mai liberate, rendendo facile identificare memory leak.\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**Esempio programma con leak:**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // Leak - mai liberato\n    let p2 = alloc(200);    // OK - liberato sotto\n    free(p2);\n}\n\nfn pulito() {\n    let b = buffer(64);\n    free(b);                // Liberato correttamente\n}\n\nleaky();\npulito();\n```\n\n**Output con --leaks:**\n```\n=== Report Profiler Hemlock ===\n\nTempo totale: 0.034ms\nFunzioni chiamate: 2 uniche\nAllocazioni totali: 3 (388B)\n\n--- Top 2 per Self Time ---\n\nFunzione                        Self      Total   Chiamate      Alloc      Conteggio\n--------                        ----      -----   --------      -----      ---------\nleaky                       0.021ms    0.021ms       1       300B          2  (61.8%)\npulito                      0.013ms    0.013ms       1        88B          1  (38.2%)\n\n--- Memory Leak (1 sito) ---\n\nLocazione                                    Leaked      Totale    Conteggio\n---------                                    ------      ------    ---------\nscript.hml:2                                   100B       100B        1\n```\n\nIl report leak mostra:\n- **Leaked** - Byte attualmente non liberati all'uscita del programma\n- **Totale** - Byte totali mai allocati in questo sito\n- **Conteggio** - Numero di allocazioni in questo sito\n\n---\n\n## Comprensione dei Report\n\n### Statistiche Funzioni\n\n| Colonna | Descrizione |\n|---------|-------------|\n| Funzione | Nome funzione |\n| Self | Tempo nella funzione escludendo funzioni chiamate |\n| Total | Tempo includendo tutte le funzioni chiamate |\n| Chiamate | Numero di volte che la funzione e stata chiamata |\n| Alloc | Byte totali allocati da questa funzione |\n| Conteggio | Numero di allocazioni da questa funzione |\n| (%) | Percentuale del tempo totale del programma |\n\n### Siti di Allocazione\n\n| Colonna | Descrizione |\n|---------|-------------|\n| Locazione | File sorgente e numero riga |\n| Totale | Byte totali allocati in questa locazione |\n| Conteggio | Numero di allocazioni |\n| Leaked | Byte ancora allocati all'uscita del programma (solo --leaks) |\n\n### Unita di Tempo\n\nIl profiler seleziona automaticamente le unita appropriate:\n- `ns` - Nanosecondi (< 1us)\n- `us` - Microsecondi (< 1ms)\n- `ms` - Millisecondi (< 1s)\n- `s` - Secondi\n\n---\n\n## Riferimento Comandi\n\n```\nhemlock profile [OPZIONI] <FILE>\n\nOPZIONI:\n    --cpu           Profilazione CPU/tempo (predefinito)\n    --memory        Profilazione allocazione memoria\n    --calls         Solo conteggio chiamate (overhead minimo)\n    --leaks         Mostra solo allocazioni non liberate (implica --memory)\n    --json          Output in formato JSON\n    --flamegraph    Output in formato compatibile flamegraph\n    --top N         Mostra top N voci (predefinito: 20)\n```\n\n---\n\n## Generazione Flamegraph\n\nI flamegraph visualizzano dove il tuo programma spende tempo, con barre piu larghe che indicano piu tempo speso.\n\n### Genera un Flamegraph\n\n1. Installa flamegraph.pl:\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. Profila il tuo programma:\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. Genera SVG:\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. Apri `profile.svg` in un browser per una visualizzazione interattiva.\n\n### Lettura dei Flamegraph\n\n- **Asse X**: Percentuale del tempo totale (larghezza = proporzione tempo)\n- **Asse Y**: Profondita stack chiamate (basso = punto di ingresso, alto = funzioni foglia)\n- **Colore**: Casuale, solo per distinzione visiva\n- **Click**: Zoom in una funzione per vedere le sue funzioni chiamate\n\n---\n\n## Migliori Pratiche\n\n### 1. Profilare Carichi di Lavoro Rappresentativi\n\nProfila con dati e pattern di utilizzo realistici. Casi di test piccoli potrebbero non rivelare veri colli di bottiglia.\n\n```bash\n# Bene: Profila con dati simili alla produzione\nhemlock profile --memory elabora_file_grande.hml grande_input.txt\n\n# Meno utile: Caso di test piccolo\nhemlock profile test_veloce.hml\n```\n\n### 2. Usare --leaks Durante lo Sviluppo\n\nEsegui rilevamento leak regolarmente per catturare memory leak presto:\n\n```bash\nhemlock profile --leaks mio_programma.hml\n```\n\n### 3. Confrontare Prima e Dopo\n\nProfila prima e dopo le ottimizzazioni per misurare l'impatto:\n\n```bash\n# Prima dell'ottimizzazione\nhemlock profile --json script.hml > prima.json\n\n# Dopo l'ottimizzazione\nhemlock profile --json script.hml > dopo.json\n\n# Confronta risultati\n```\n\n### 4. Usare --top per Programmi Grandi\n\nLimita l'output per concentrarti sulle funzioni piu significative:\n\n```bash\nhemlock profile --top 10 programma_grande.hml\n```\n\n### 5. Combinare con Flamegraph\n\nPer pattern di chiamata complessi, i flamegraph forniscono migliore visualizzazione rispetto all'output testuale:\n\n```bash\nhemlock profile --flamegraph app_complessa.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## Overhead del Profiler\n\nIl profiler aggiunge un po' di overhead all'esecuzione del programma:\n\n| Modalita | Overhead | Caso d'Uso |\n|----------|----------|------------|\n| `--calls` | Minimo | Solo conteggio chiamate funzione |\n| `--cpu` | Basso | Profilazione prestazioni generale |\n| `--memory` | Moderato | Analisi memoria e rilevamento leak |\n\nPer risultati piu accurati, profila piu volte e cerca pattern consistenti.\n\n---\n\n## Vedi Anche\n\n- [Gestione Memoria](#language-guide-memory) - Puntatori e buffer\n- [API Memoria](#reference-memory-api) - Funzioni alloc, free, buffer\n- [Async/Concorrenza](#advanced-async-concurrency) - Profilazione codice async\n"}, "Argomenti Avanzati -> Segnali": {"id": "advanced-signals", "content": "# Gestione dei Segnali in Hemlock\n\nHemlock fornisce **gestione dei segnali POSIX** per gestire segnali di sistema come SIGINT (Ctrl+C), SIGTERM e segnali personalizzati. Questo abilita il controllo di processo a basso livello e la comunicazione inter-processo.\n\n## Indice\n\n- [Panoramica](#panoramica)\n- [API Segnali](#api-segnali)\n- [Costanti dei Segnali](#costanti-dei-segnali)\n- [Gestione Base dei Segnali](#gestione-base-dei-segnali)\n- [Pattern Avanzati](#pattern-avanzati)\n- [Comportamento del Gestore di Segnali](#comportamento-del-gestore-di-segnali)\n- [Considerazioni sulla Sicurezza](#considerazioni-sulla-sicurezza)\n- [Casi d'Uso Comuni](#casi-duso-comuni)\n- [Esempi Completi](#esempi-completi)\n\n## Panoramica\n\nLa gestione dei segnali permette ai programmi di:\n- Rispondere a interruzioni dell'utente (Ctrl+C, Ctrl+Z)\n- Implementare shutdown graceful\n- Gestire richieste di terminazione\n- Usare segnali personalizzati per comunicazione inter-processo\n- Creare meccanismi di alarm/timer\n\n**Importante:** La gestione dei segnali e **intrinsecamente unsafe** nella filosofia di Hemlock. I gestori possono essere chiamati in qualsiasi momento, interrompendo l'esecuzione normale. L'utente e responsabile della corretta sincronizzazione.\n\n## API Segnali\n\n### signal(signum, funzione_gestore)\n\nRegistra una funzione gestore di segnali.\n\n**Parametri:**\n- `signum` (i32) - Numero del segnale (costante come SIGINT, SIGTERM)\n- `funzione_gestore` (funzione o null) - Funzione da chiamare quando il segnale viene ricevuto, o `null` per ripristinare il predefinito\n\n**Restituisce:** La precedente funzione gestore (o `null` se nessuna)\n\n**Esempio:**\n```hemlock\nfn mio_gestore(sig) {\n    print(\"Catturato segnale: \" + typeof(sig));\n}\n\nlet vecchio_gestore = signal(SIGINT, mio_gestore);\n```\n\n**Ripristino al predefinito:**\n```hemlock\nsignal(SIGINT, null);  // Ripristina SIGINT al comportamento predefinito\n```\n\n### raise(signum)\n\nInvia un segnale al processo corrente.\n\n**Parametri:**\n- `signum` (i32) - Numero del segnale da inviare\n\n**Restituisce:** `null`\n\n**Esempio:**\n```hemlock\nraise(SIGUSR1);  // Attiva il gestore SIGUSR1\n```\n\n## Costanti dei Segnali\n\nHemlock fornisce costanti di segnali POSIX standard come valori i32.\n\n### Interruzione e Terminazione\n\n| Costante | Valore | Descrizione | Trigger Comune |\n|----------|--------|-------------|----------------|\n| `SIGINT` | 2 | Interrupt da tastiera | Ctrl+C |\n| `SIGTERM` | 15 | Richiesta di terminazione | Comando `kill` |\n| `SIGQUIT` | 3 | Quit da tastiera | Ctrl+\\ |\n| `SIGHUP` | 1 | Hangup rilevato | Terminale chiuso |\n| `SIGABRT` | 6 | Segnale abort | Funzione `abort()` |\n\n**Esempi:**\n```hemlock\nsignal(SIGINT, gestisci_interrupt);   // Ctrl+C\nsignal(SIGTERM, gestisci_termina);    // Comando kill\nsignal(SIGHUP, gestisci_hangup);      // Terminale si chiude\n```\n\n### Segnali Definiti dall'Utente\n\n| Costante | Valore | Descrizione | Caso d'Uso |\n|----------|--------|-------------|------------|\n| `SIGUSR1` | 10 | Segnale definito dall'utente 1 | IPC personalizzato |\n| `SIGUSR2` | 12 | Segnale definito dall'utente 2 | IPC personalizzato |\n\n**Esempi:**\n```hemlock\n// Usa per comunicazione personalizzata\nsignal(SIGUSR1, ricarica_config);\nsignal(SIGUSR2, ruota_log);\n```\n\n### Controllo Processo\n\n| Costante | Valore | Descrizione | Note |\n|----------|--------|-------------|------|\n| `SIGALRM` | 14 | Timer alarm | Dopo `alarm()` |\n| `SIGCHLD` | 17 | Cambio stato processo figlio | Gestione processi |\n| `SIGCONT` | 18 | Continua se fermato | Riprendi dopo SIGSTOP |\n| `SIGSTOP` | 19 | Ferma processo | **Non puo essere catturato** |\n| `SIGTSTP` | 20 | Stop da terminale | Ctrl+Z |\n\n**Esempi:**\n```hemlock\nsignal(SIGALRM, gestisci_timeout);\nsignal(SIGCHLD, gestisci_uscita_figlio);\n```\n\n### Segnali I/O\n\n| Costante | Valore | Descrizione | Quando Inviato |\n|----------|--------|-------------|----------------|\n| `SIGPIPE` | 13 | Pipe rotta | Scrittura su pipe chiusa |\n| `SIGTTIN` | 21 | Lettura background da terminale | Processo BG legge TTY |\n| `SIGTTOU` | 22 | Scrittura background a terminale | Processo BG scrive TTY |\n\n**Esempi:**\n```hemlock\nsignal(SIGPIPE, gestisci_pipe_rotta);\n```\n\n## Gestione Base dei Segnali\n\n### Catturare Ctrl+C\n\n```hemlock\nlet interrotto = false;\n\nfn gestisci_interrupt(sig) {\n    print(\"Catturato SIGINT!\");\n    interrotto = true;\n}\n\nsignal(SIGINT, gestisci_interrupt);\n\n// Il programma continua l'esecuzione...\n// L'utente preme Ctrl+C -> gestisci_interrupt() viene chiamato\n\nwhile (!interrotto) {\n    // Fai lavoro...\n}\n\nprint(\"Uscita per interrupt\");\n```\n\n### Firma della Funzione Gestore\n\nI gestori di segnali ricevono un argomento: il numero del segnale (i32)\n\n```hemlock\nfn mio_gestore(signum) {\n    print(\"Ricevuto segnale: \" + typeof(signum));\n    // signum contiene il numero del segnale (es. 2 per SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"Questo e SIGINT\");\n    }\n}\n\nsignal(SIGINT, mio_gestore);\nsignal(SIGTERM, mio_gestore);  // Stesso gestore per segnali multipli\n```\n\n### Gestori di Segnali Multipli\n\nGestori diversi per segnali diversi:\n\n```hemlock\nfn gestisci_int(sig) {\n    print(\"SIGINT ricevuto\");\n}\n\nfn gestisci_term(sig) {\n    print(\"SIGTERM ricevuto\");\n}\n\nfn gestisci_usr1(sig) {\n    print(\"SIGUSR1 ricevuto\");\n}\n\nsignal(SIGINT, gestisci_int);\nsignal(SIGTERM, gestisci_term);\nsignal(SIGUSR1, gestisci_usr1);\n```\n\n### Ripristino al Comportamento Predefinito\n\nPassa `null` come gestore per ripristinare il comportamento predefinito:\n\n```hemlock\n// Registra gestore personalizzato\nsignal(SIGINT, mio_gestore);\n\n// Dopo, ripristina al predefinito (termina su SIGINT)\nsignal(SIGINT, null);\n```\n\n### Invio Manuale di Segnali\n\nInvia segnali al tuo stesso processo:\n\n```hemlock\nlet conteggio = 0;\n\nfn incrementa(sig) {\n    conteggio = conteggio + 1;\n}\n\nsignal(SIGUSR1, incrementa);\n\n// Attiva gestore manualmente\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(conteggio);  // 2\n```\n\n## Pattern Avanzati\n\n### Pattern Shutdown Graceful\n\nPattern comune per pulizia alla terminazione:\n\n```hemlock\nlet deve_uscire = false;\n\nfn gestisci_shutdown(sig) {\n    print(\"Shutdown graceful in corso...\");\n    deve_uscire = true;\n}\n\nsignal(SIGINT, gestisci_shutdown);\nsignal(SIGTERM, gestisci_shutdown);\n\n// Loop principale\nwhile (!deve_uscire) {\n    // Fai lavoro...\n    // Controlla flag deve_uscire periodicamente\n}\n\nprint(\"Pulizia completata\");\n```\n\n### Contatore di Segnali\n\nTraccia numero di segnali ricevuti:\n\n```hemlock\nlet conteggio_segnali = 0;\n\nfn conta_segnali(sig) {\n    conteggio_segnali = conteggio_segnali + 1;\n    print(\"Ricevuti \" + typeof(conteggio_segnali) + \" segnali\");\n}\n\nsignal(SIGUSR1, conta_segnali);\n\n// Dopo...\nprint(\"Segnali totali: \" + typeof(conteggio_segnali));\n```\n\n### Ricarica Configurazione su Segnale\n\n```hemlock\nlet config = carica_config();\n\nfn ricarica_config(sig) {\n    print(\"Ricarica configurazione in corso...\");\n    config = carica_config();\n    print(\"Configurazione ricaricata\");\n}\n\nsignal(SIGHUP, ricarica_config);  // Ricarica su SIGHUP\n\n// Invia SIGHUP al processo per ricaricare config\n// Da shell: kill -HUP <pid>\n```\n\n### Timeout Usando SIGALRM\n\n```hemlock\nlet scaduto = false;\n\nfn gestisci_alarm(sig) {\n    print(\"Timeout!\");\n    scaduto = true;\n}\n\nsignal(SIGALRM, gestisci_alarm);\n\n// Imposta alarm (non ancora implementato in Hemlock, solo esempio)\n// alarm(5);  // timeout 5 secondi\n\nwhile (!scaduto) {\n    // Fai lavoro con timeout\n}\n```\n\n### Macchina a Stati Basata su Segnali\n\n```hemlock\nlet stato = 0;\n\nfn stato_successivo(sig) {\n    stato = (stato + 1) % 3;\n    print(\"Stato: \" + typeof(stato));\n}\n\nfn stato_precedente(sig) {\n    stato = (stato - 1 + 3) % 3;\n    print(\"Stato: \" + typeof(stato));\n}\n\nsignal(SIGUSR1, stato_successivo);  // Avanza stato\nsignal(SIGUSR2, stato_precedente);  // Torna indietro\n\n// Controlla macchina a stati:\n// kill -USR1 <pid>  # Stato successivo\n// kill -USR2 <pid>  # Stato precedente\n```\n\n## Comportamento del Gestore di Segnali\n\n### Note Importanti\n\n**Esecuzione del Gestore:**\n- I gestori sono chiamati **sincronamente** quando il segnale viene ricevuto\n- I gestori vengono eseguiti nel contesto del processo corrente\n- I gestori di segnali condividono l'ambiente closure della funzione in cui sono definiti\n- I gestori possono accedere e modificare variabili dello scope esterno (come globali o variabili catturate)\n\n**Migliori Pratiche:**\n- Mantieni i gestori semplici e veloci - evita operazioni a lunga esecuzione\n- Imposta flag piuttosto che eseguire logica complessa\n- Evita di chiamare funzioni che potrebbero prendere lock\n- Sii consapevole che i gestori possono interrompere qualsiasi operazione\n\n### Quali Segnali Possono Essere Catturati\n\n**Possono essere catturati e gestiti:**\n- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT\n- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP\n- SIGPIPE, SIGTTIN, SIGTTOU\n- SIGABRT (ma il programma abortira dopo che il gestore ritorna)\n\n**Non possono essere catturati:**\n- `SIGKILL` (9) - Termina sempre il processo\n- `SIGSTOP` (19) - Ferma sempre il processo\n\n**Dipendenti dal sistema:**\n- Alcuni segnali hanno comportamenti predefiniti che possono differire per sistema\n- Controlla la documentazione dei segnali della tua piattaforma per specifiche\n\n### Limitazioni dei Gestori\n\n```hemlock\nfn gestore_complesso(sig) {\n    // Evita questi nei gestori di segnali:\n\n    //  Operazioni a lunga esecuzione\n    // elabora_file_grande();\n\n    //  I/O bloccante\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Segnale ricevuto\\n\");\n\n    //  Cambiamenti di stato complessi\n    // ricostruisci_intera_struttura_dati();\n\n    //  Semplice impostazione flag e sicura\n    let deve_fermarsi = true;\n\n    //  Semplici aggiornamenti contatore sono generalmente sicuri\n    let conteggio_segnali = conteggio_segnali + 1;\n}\n```\n\n## Considerazioni sulla Sicurezza\n\nLa gestione dei segnali e **intrinsecamente unsafe** nella filosofia di Hemlock.\n\n### Race Condition\n\nI gestori possono essere chiamati in qualsiasi momento, interrompendo l'esecuzione normale:\n\n```hemlock\nlet contatore = 0;\n\nfn incrementa(sig) {\n    contatore = contatore + 1;  // Race condition se chiamato durante aggiornamento contatore\n}\n\nsignal(SIGUSR1, incrementa);\n\n// Il codice principale modifica anche il contatore\ncontatore = contatore + 1;  // Potrebbe essere interrotto dal gestore di segnali\n```\n\n**Problema:** Se il segnale arriva mentre il codice principale sta aggiornando `contatore`, il risultato e imprevedibile.\n\n### Async-Signal-Safety\n\nHemlock **non** garantisce async-signal-safety:\n- I gestori possono chiamare qualsiasi codice Hemlock (a differenza delle funzioni C async-signal-safe limitate)\n- Questo fornisce flessibilita ma richiede cautela dell'utente\n- Race condition sono possibili se il gestore modifica stato condiviso\n\n### Migliori Pratiche per Gestione Segnali Sicura\n\n**1. Usa Flag Atomici**\n\nSemplici assegnazioni booleane sono generalmente sicure:\n\n```hemlock\nlet deve_uscire = false;\n\nfn gestore(sig) {\n    deve_uscire = true;  // Semplice assegnazione e sicura\n}\n\nsignal(SIGINT, gestore);\n\nwhile (!deve_uscire) {\n    // lavoro...\n}\n```\n\n**2. Minimizza Stato Condiviso**\n\n```hemlock\nlet conteggio_interrupt = 0;\n\nfn gestore(sig) {\n    // Modifica solo questa variabile\n    conteggio_interrupt = conteggio_interrupt + 1;\n}\n```\n\n**3. Rinvia Operazioni Complesse**\n\n```hemlock\nlet ricarica_pendente = false;\n\nfn segnala_ricarica(sig) {\n    ricarica_pendente = true;  // Solo imposta flag\n}\n\nsignal(SIGHUP, segnala_ricarica);\n\n// Nel loop principale:\nwhile (true) {\n    if (ricarica_pendente) {\n        ricarica_config();  // Fai lavoro complesso qui\n        ricarica_pendente = false;\n    }\n\n    // Lavoro normale...\n}\n```\n\n**4. Evita Problemi di Rientranza**\n\n```hemlock\nlet in_sezione_critica = false;\nlet dati = [];\n\nfn gestore_attento(sig) {\n    if (in_sezione_critica) {\n        // Non modificare dati mentre il codice principale li sta usando\n        return;\n    }\n    // Sicuro procedere\n}\n```\n\n## Casi d'Uso Comuni\n\n### 1. Shutdown Graceful del Server\n\n```hemlock\nlet in_esecuzione = true;\n\nfn shutdown(sig) {\n    print(\"Segnale shutdown ricevuto\");\n    in_esecuzione = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Loop principale server\nwhile (in_esecuzione) {\n    gestisci_richiesta_client();\n}\n\npulisci_risorse();\nprint(\"Server fermato\");\n```\n\n### 2. Ricarica Configurazione (Senza Riavvio)\n\n```hemlock\nlet config = carica_config(\"app.conf\");\nlet ricarica_necessaria = false;\n\nfn attiva_ricarica(sig) {\n    ricarica_necessaria = true;\n}\n\nsignal(SIGHUP, attiva_ricarica);\n\nwhile (true) {\n    if (ricarica_necessaria) {\n        print(\"Ricarica configurazione in corso...\");\n        config = carica_config(\"app.conf\");\n        ricarica_necessaria = false;\n    }\n\n    // Usa config...\n}\n```\n\n### 3. Rotazione Log\n\n```hemlock\nlet file_log = open(\"app.log\", \"a\");\nlet rotazione_necessaria = false;\n\nfn attiva_rotazione(sig) {\n    rotazione_necessaria = true;\n}\n\nsignal(SIGUSR1, attiva_rotazione);\n\nwhile (true) {\n    if (rotazione_necessaria) {\n        file_log.close();\n        // Rinomina vecchio log, apri nuovo\n        exec(\"mv app.log app.log.old\");\n        file_log = open(\"app.log\", \"a\");\n        rotazione_necessaria = false;\n    }\n\n    // Logging normale...\n    file_log.write(\"Voce log\\n\");\n}\n```\n\n### 4. Report di Stato\n\n```hemlock\nlet richieste_gestite = 0;\n\nfn riporta_stato(sig) {\n    print(\"Stato: \" + typeof(richieste_gestite) + \" richieste gestite\");\n}\n\nsignal(SIGUSR1, riporta_stato);\n\nwhile (true) {\n    gestisci_richiesta();\n    richieste_gestite = richieste_gestite + 1;\n}\n\n// Da shell: kill -USR1 <pid>\n```\n\n### 5. Toggle Modalita Debug\n\n```hemlock\nlet modalita_debug = false;\n\nfn toggle_debug(sig) {\n    modalita_debug = !modalita_debug;\n    if (modalita_debug) {\n        print(\"Modalita debug: ON\");\n    } else {\n        print(\"Modalita debug: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// Da shell: kill -USR2 <pid> per toggle\n```\n\n## Esempi Completi\n\n### Esempio 1: Gestore Interrupt con Pulizia\n\n```hemlock\nlet in_esecuzione = true;\nlet conteggio_segnali = 0;\n\nfn gestisci_segnale(signum) {\n    conteggio_segnali = conteggio_segnali + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt rilevato (Ctrl+C)\");\n        in_esecuzione = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"Segnale utente 1 ricevuto\");\n    }\n}\n\n// Registra gestori\nsignal(SIGINT, gestisci_segnale);\nsignal(SIGUSR1, gestisci_segnale);\n\n// Simula del lavoro\nlet i = 0;\nwhile (in_esecuzione && i < 100) {\n    print(\"Lavoro in corso... \" + typeof(i));\n\n    // Attiva SIGUSR1 ogni 10 iterazioni\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Segnali totali ricevuti: \" + typeof(conteggio_segnali));\n```\n\n### Esempio 2: Macchina a Stati Multi-Segnale\n\n```hemlock\nlet stato = \"idle\";\nlet conteggio_richieste = 0;\n\nfn inizia_elaborazione(sig) {\n    stato = \"elaborazione\";\n    print(\"Stato: \" + stato);\n}\n\nfn ferma_elaborazione(sig) {\n    stato = \"idle\";\n    print(\"Stato: \" + stato);\n}\n\nfn riporta_statistiche(sig) {\n    print(\"Stato: \" + stato);\n    print(\"Richieste: \" + typeof(conteggio_richieste));\n}\n\nsignal(SIGUSR1, inizia_elaborazione);\nsignal(SIGUSR2, ferma_elaborazione);\nsignal(SIGHUP, riporta_statistiche);\n\nwhile (true) {\n    if (stato == \"elaborazione\") {\n        // Fai lavoro\n        conteggio_richieste = conteggio_richieste + 1;\n    }\n\n    // Controlla ogni iterazione...\n}\n```\n\n### Esempio 3: Controller Pool di Worker\n\n```hemlock\nlet conteggio_worker = 4;\nlet deve_uscire = false;\n\nfn aumenta_worker(sig) {\n    conteggio_worker = conteggio_worker + 1;\n    print(\"Worker: \" + typeof(conteggio_worker));\n}\n\nfn diminuisci_worker(sig) {\n    if (conteggio_worker > 1) {\n        conteggio_worker = conteggio_worker - 1;\n    }\n    print(\"Worker: \" + typeof(conteggio_worker));\n}\n\nfn shutdown(sig) {\n    print(\"Shutdown in corso...\");\n    deve_uscire = true;\n}\n\nsignal(SIGUSR1, aumenta_worker);\nsignal(SIGUSR2, diminuisci_worker);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Il loop principale regola il pool worker basandosi su conteggio_worker\nwhile (!deve_uscire) {\n    // Gestisci worker basandoti su conteggio_worker\n    // ...\n}\n```\n\n### Esempio 4: Pattern Timeout\n\n```hemlock\nlet operazione_completata = false;\nlet scaduto = false;\n\nfn gestore_timeout(sig) {\n    scaduto = true;\n}\n\nsignal(SIGALRM, gestore_timeout);\n\n// Avvia operazione lunga\nasync fn operazione_lunga() {\n    // ... lavoro\n    operazione_completata = true;\n}\n\nlet task = spawn(operazione_lunga);\n\n// Attendi con timeout (controllo manuale)\nlet trascorso = 0;\nwhile (!operazione_completata && trascorso < 1000) {\n    // Sleep o controlla\n    trascorso = trascorso + 1;\n}\n\nif (!operazione_completata) {\n    print(\"Operazione scaduta\");\n    detach(task);  // Rinuncia ad aspettare\n} else {\n    join(task);\n    print(\"Operazione completata\");\n}\n```\n\n## Debug dei Gestori di Segnali\n\n### Aggiungi Print Diagnostici\n\n```hemlock\nfn gestore_debug(sig) {\n    print(\"Gestore chiamato per segnale: \" + typeof(sig));\n    print(\"Stack: (non ancora disponibile)\");\n\n    // La tua logica del gestore...\n}\n\nsignal(SIGINT, gestore_debug);\n```\n\n### Conta Chiamate al Gestore\n\n```hemlock\nlet chiamate_gestore = 0;\n\nfn gestore_contatore(sig) {\n    chiamate_gestore = chiamate_gestore + 1;\n    print(\"Chiamata gestore #\" + typeof(chiamate_gestore));\n\n    // La tua logica del gestore...\n}\n```\n\n### Testa con raise()\n\n```hemlock\nfn gestore_test(sig) {\n    print(\"Segnale test ricevuto: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, gestore_test);\n\n// Testa invocando manualmente\nraise(SIGUSR1);\nprint(\"Il gestore avrebbe dovuto essere chiamato\");\n```\n\n## Riepilogo\n\nLa gestione dei segnali di Hemlock fornisce:\n\n- Gestione segnali POSIX per controllo processo a basso livello\n- 15 costanti segnali standard\n- Semplice API signal() e raise()\n- Funzioni gestore flessibili con supporto closure\n- Segnali multipli possono condividere gestori\n\nRicorda:\n- La gestione dei segnali e intrinsecamente unsafe - usare con cautela\n- Mantieni i gestori semplici e veloci\n- Usa flag per cambiamenti di stato, non operazioni complesse\n- I gestori possono interrompere l'esecuzione in qualsiasi momento\n- Non si possono catturare SIGKILL o SIGSTOP\n- Testa i gestori accuratamente con raise()\n\nPattern comuni:\n- Shutdown graceful (SIGINT, SIGTERM)\n- Ricarica configurazione (SIGHUP)\n- Rotazione log (SIGUSR1)\n- Report di stato (SIGUSR1/SIGUSR2)\n- Toggle modalita debug (SIGUSR2)\n"}, "Riferimento API -> API degli Array": {"id": "reference-array-api", "content": "# Riferimento API degli Array\n\nRiferimento completo per il tipo array di Hemlock e tutti i suoi 18 metodi.\n\n---\n\n## Panoramica\n\nGli array in Hemlock sono sequenze **dinamiche, allocate nell'heap** che possono contenere tipi misti. Forniscono metodi completi per la manipolazione e l'elaborazione dei dati.\n\n**Caratteristiche Principali:**\n- Dimensionamento dinamico (crescita automatica)\n- Indicizzazione a base zero\n- Tipi misti consentiti\n- 18 metodi integrati\n- Allocati nell'heap con tracciamento della capacit\n\n---\n\n## Tipo Array\n\n**Tipo:** `array`\n\n**Propriet:**\n- `.length` - Numero di elementi (i32)\n\n**Sintassi Letterale:** Parentesi quadre `[elem1, elem2, ...]`\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Tipi misti\nlet misto = [1, \"ciao\", true, null];\nprint(misto.length);   // 4\n\n// Array vuoto\nlet vuoto = [];\nprint(vuoto.length);   // 0\n```\n\n---\n\n## Indicizzazione\n\nGli array supportano l'indicizzazione a base zero usando `[]`:\n\n**Accesso in Lettura:**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**Accesso in Scrittura:**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**Nota:** L'indicizzazione diretta non ha controllo dei limiti. Usa i metodi per maggiore sicurezza.\n\n---\n\n## Propriet degli Array\n\n### .length\n\nOttiene il numero di elementi nell'array.\n\n**Tipo:** `i32`\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet vuoto = [];\nprint(vuoto.length);   // 0\n\n// La lunghezza cambia dinamicamente\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## Metodi degli Array\n\n### Operazioni di Stack\n\n#### push\n\nAggiunge un elemento alla fine dell'array.\n\n**Firma:**\n```hemlock\narray.push(valore: any): null\n```\n\n**Parametri:**\n- `valore` - Elemento da aggiungere\n\n**Restituisce:** `null`\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"ciao\");      // [1, 2, 3, 4, 5, \"ciao\"]\n```\n\n---\n\n#### pop\n\nRimuove e restituisce l'ultimo elemento.\n\n**Firma:**\n```hemlock\narray.pop(): any\n```\n\n**Restituisce:** Ultimo elemento (rimosso dall'array)\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3];\nlet ultimo = arr.pop();  // 3\nprint(arr);              // [1, 2]\n\nlet ultimo2 = arr.pop(); // 2\nprint(arr);              // [1]\n```\n\n**Errore:** Errore a runtime se l'array  vuoto.\n\n---\n\n### Operazioni di Coda\n\n#### shift\n\nRimuove e restituisce il primo elemento.\n\n**Firma:**\n```hemlock\narray.shift(): any\n```\n\n**Restituisce:** Primo elemento (rimosso dall'array)\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3];\nlet primo = arr.shift();   // 1\nprint(arr);                // [2, 3]\n\nlet primo2 = arr.shift();  // 2\nprint(arr);                // [3]\n```\n\n**Errore:** Errore a runtime se l'array  vuoto.\n\n---\n\n#### unshift\n\nAggiunge un elemento all'inizio dell'array.\n\n**Firma:**\n```hemlock\narray.unshift(valore: any): null\n```\n\n**Parametri:**\n- `valore` - Elemento da aggiungere\n\n**Restituisce:** `null`\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### Inserimento e Rimozione\n\n#### insert\n\nInserisce un elemento a un indice specifico.\n\n**Firma:**\n```hemlock\narray.insert(indice: i32, valore: any): null\n```\n\n**Parametri:**\n- `indice` - Posizione di inserimento (base 0)\n- `valore` - Elemento da inserire\n\n**Restituisce:** `null`\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Inserisci alla fine\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**Comportamento:** Sposta gli elementi dall'indice in poi verso destra.\n\n---\n\n#### remove\n\nRimuove e restituisce l'elemento all'indice specificato.\n\n**Firma:**\n```hemlock\narray.remove(indice: i32): any\n```\n\n**Parametri:**\n- `indice` - Posizione da cui rimuovere (base 0)\n\n**Restituisce:** Elemento rimosso\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet rimosso = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet rimosso2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**Comportamento:** Sposta gli elementi dopo l'indice verso sinistra.\n\n**Errore:** Errore a runtime se l'indice  fuori dai limiti.\n\n---\n\n### Ricerca e Trova\n\n#### find\n\nTrova la prima occorrenza di un valore.\n\n**Firma:**\n```hemlock\narray.find(valore: any): i32\n```\n\n**Parametri:**\n- `valore` - Valore da cercare\n\n**Restituisce:** Indice della prima occorrenza, o `-1` se non trovato\n\n**Esempi:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (non trovato)\n\n// Trova il primo duplicato\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (prima occorrenza)\n```\n\n**Confronto:** Usa l'uguaglianza di valore per i primitivi e le stringhe.\n\n---\n\n#### contains\n\nVerifica se l'array contiene un valore.\n\n**Firma:**\n```hemlock\narray.contains(valore: any): bool\n```\n\n**Parametri:**\n- `valore` - Valore da cercare\n\n**Restituisce:** `true` se trovato, `false` altrimenti\n\n**Esempi:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet ha = arr.contains(20);   // true\nlet ha2 = arr.contains(99);  // false\n\n// Funziona con le stringhe\nlet parole = [\"ciao\", \"mondo\"];\nlet ha3 = parole.contains(\"ciao\");  // true\n```\n\n---\n\n### Slicing ed Estrazione\n\n#### slice\n\nEstrae un sottoarray per intervallo (fine esclusiva).\n\n**Firma:**\n```hemlock\narray.slice(inizio: i32, fine: i32): array\n```\n\n**Parametri:**\n- `inizio` - Indice iniziale (base 0, inclusivo)\n- `fine` - Indice finale (esclusivo)\n\n**Restituisce:** Nuovo array con elementi da [inizio, fine)\n\n**Modifica:** No (restituisce un nuovo array)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);       // [2, 3, 4]\nlet primi_tre = arr.slice(0, 3); // [1, 2, 3]\nlet ultimi_due = arr.slice(3, 5);// [4, 5]\n\n// Slice vuoto\nlet vuoto = arr.slice(2, 2);     // []\n```\n\n---\n\n#### first\n\nOttiene il primo elemento senza rimuoverlo.\n\n**Firma:**\n```hemlock\narray.first(): any\n```\n\n**Restituisce:** Primo elemento\n\n**Modifica:** No\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (invariato)\n```\n\n**Errore:** Errore a runtime se l'array  vuoto.\n\n---\n\n#### last\n\nOttiene l'ultimo elemento senza rimuoverlo.\n\n**Firma:**\n```hemlock\narray.last(): any\n```\n\n**Restituisce:** Ultimo elemento\n\n**Modifica:** No\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (invariato)\n```\n\n**Errore:** Errore a runtime se l'array  vuoto.\n\n---\n\n### Manipolazione degli Array\n\n#### reverse\n\nInverte l'array in loco.\n\n**Firma:**\n```hemlock\narray.reverse(): null\n```\n\n**Restituisce:** `null`\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet parole = [\"ciao\", \"mondo\"];\nparole.reverse();            // [\"mondo\", \"ciao\"]\n```\n\n---\n\n#### clear\n\nRimuove tutti gli elementi dall'array.\n\n**Firma:**\n```hemlock\narray.clear(): null\n```\n\n**Restituisce:** `null`\n\n**Modifica:** S (modifica l'array in loco)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### Combinazione di Array\n\n#### concat\n\nConcatena con un altro array.\n\n**Firma:**\n```hemlock\narray.concat(altro: array): array\n```\n\n**Parametri:**\n- `altro` - Array da concatenare\n\n**Restituisce:** Nuovo array con elementi da entrambi gli array\n\n**Modifica:** No (restituisce un nuovo array)\n\n**Esempi:**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combinato = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                     // [1, 2, 3] (invariato)\nprint(b);                     // [4, 5, 6] (invariato)\n\n// Concatenazione a catena\nlet c = [7, 8];\nlet tutti = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### Operazioni Funzionali\n\n#### map\n\nTrasforma ogni elemento usando una funzione callback.\n\n**Firma:**\n```hemlock\narray.map(callback: fn): array\n```\n\n**Parametri:**\n- `callback` - Funzione che prende un elemento e restituisce il valore trasformato\n\n**Restituisce:** Nuovo array con elementi trasformati\n\n**Modifica:** No (restituisce un nuovo array)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet raddoppiato = arr.map(fn(x) { return x * 2; });\nprint(raddoppiato);  // [2, 4, 6, 8, 10]\n\nlet nomi = [\"alice\", \"bob\"];\nlet maiuscolo = nomi.map(fn(s) { return s.to_upper(); });\nprint(maiuscolo);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\nSeleziona gli elementi che corrispondono a un predicato.\n\n**Firma:**\n```hemlock\narray.filter(predicato: fn): array\n```\n\n**Parametri:**\n- `predicato` - Funzione che prende un elemento e restituisce bool\n\n**Restituisce:** Nuovo array con elementi per cui il predicato ha restituito true\n\n**Modifica:** No (restituisce un nuovo array)\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet pari = arr.filter(fn(x) { return x % 2 == 0; });\nprint(pari);  // [2, 4, 6]\n\nlet parole = [\"ciao\", \"io\", \"hey\", \"arrivederci\"];\nlet corte = parole.filter(fn(s) { return s.length < 4; });\nprint(corte);  // [\"io\", \"hey\"]\n```\n\n---\n\n#### reduce\n\nRiduce l'array a un singolo valore usando un accumulatore.\n\n**Firma:**\n```hemlock\narray.reduce(callback: fn, iniziale: any): any\n```\n\n**Parametri:**\n- `callback` - Funzione che prende (accumulatore, elemento) e restituisce il nuovo accumulatore\n- `iniziale` - Valore iniziale per l'accumulatore\n\n**Restituisce:** Valore finale accumulato\n\n**Modifica:** No\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet somma = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(somma);  // 15\n\nlet prodotto = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(prodotto);  // 120\n\n// Trova il valore massimo\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### Conversione a Stringa\n\n#### join\n\nUnisce gli elementi in una stringa con un delimitatore.\n\n**Firma:**\n```hemlock\narray.join(delimitatore: string): string\n```\n\n**Parametri:**\n- `delimitatore` - Stringa da inserire tra gli elementi\n\n**Restituisce:** Stringa con tutti gli elementi uniti\n\n**Esempi:**\n```hemlock\nlet parole = [\"ciao\", \"mondo\", \"foo\"];\nlet unito = parole.join(\" \");  // \"ciao mondo foo\"\n\nlet numeri = [1, 2, 3];\nlet csv = numeri.join(\",\");    // \"1,2,3\"\n\n// Funziona con tipi misti\nlet misto = [1, \"ciao\", true, null];\nprint(misto.join(\" | \"));  // \"1 | ciao | true | null\"\n\n// Delimitatore vuoto\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**Comportamento:** Converte automaticamente tutti gli elementi in stringhe.\n\n---\n\n## Concatenamento di Metodi\n\nI metodi degli array possono essere concatenati per operazioni concise:\n\n**Esempi:**\n```hemlock\n// Concatena slice e join\nlet risultato = [\"mela\", \"banana\", \"ciliegia\", \"dattero\"]\n    .slice(0, 2)\n    .join(\" e \");  // \"mela e banana\"\n\n// Concatena concat e slice\nlet combinato = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Concatenamento complesso\nlet parole = [\"ciao\", \"mondo\", \"foo\", \"bar\"];\nlet risultato2 = parole\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"ciao-mondo-foo-baz\"\n```\n\n---\n\n## Riepilogo Completo dei Metodi\n\n### Metodi Modificanti\n\nMetodi che modificano l'array in loco:\n\n| Metodo     | Firma                      | Restituisce | Descrizione                    |\n|------------|----------------------------|-------------|--------------------------------|\n| `push`     | `(valore: any)`            | `null`      | Aggiunge alla fine             |\n| `pop`      | `()`                       | `any`       | Rimuove dalla fine             |\n| `shift`    | `()`                       | `any`       | Rimuove dall'inizio            |\n| `unshift`  | `(valore: any)`            | `null`      | Aggiunge all'inizio            |\n| `insert`   | `(indice: i32, valore: any)` | `null`    | Inserisce all'indice           |\n| `remove`   | `(indice: i32)`            | `any`       | Rimuove all'indice             |\n| `reverse`  | `()`                       | `null`      | Inverte in loco                |\n| `clear`    | `()`                       | `null`      | Rimuove tutti gli elementi     |\n\n### Metodi Non Modificanti\n\nMetodi che restituiscono nuovi valori senza modificare l'originale:\n\n| Metodo     | Firma                      | Restituisce | Descrizione                    |\n|------------|----------------------------|-------------|--------------------------------|\n| `find`     | `(valore: any)`            | `i32`       | Trova la prima occorrenza      |\n| `contains` | `(valore: any)`            | `bool`      | Verifica se contiene il valore |\n| `slice`    | `(inizio: i32, fine: i32)` | `array`     | Estrae sottoarray              |\n| `first`    | `()`                       | `any`       | Ottiene il primo elemento      |\n| `last`     | `()`                       | `any`       | Ottiene l'ultimo elemento      |\n| `concat`   | `(altro: array)`           | `array`     | Concatena array                |\n| `join`     | `(delimitatore: string)`   | `string`    | Unisce elementi in stringa     |\n| `map`      | `(callback: fn)`           | `array`     | Trasforma ogni elemento        |\n| `filter`   | `(predicato: fn)`          | `array`     | Seleziona elementi corrispondenti |\n| `reduce`   | `(callback: fn, iniziale: any)` | `any`  | Riduce a un singolo valore     |\n\n---\n\n## Pattern di Utilizzo\n\n### Uso come Stack\n\n```hemlock\nlet stack = [];\n\n// Push degli elementi\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop degli elementi\nwhile (stack.length > 0) {\n    let elemento = stack.pop();\n    print(elemento);  // 3, 2, 1\n}\n```\n\n### Uso come Coda\n\n```hemlock\nlet coda = [];\n\n// Accodamento\ncoda.push(1);\ncoda.push(2);\ncoda.push(3);\n\n// Decodifica\nwhile (coda.length > 0) {\n    let elemento = coda.shift();\n    print(elemento);  // 1, 2, 3\n}\n```\n\n### Trasformazione di Array\n\n```hemlock\n// Filtro (manuale)\nlet numeri = [1, 2, 3, 4, 5, 6];\nlet pari = [];\nlet i = 0;\nwhile (i < numeri.length) {\n    if (numeri[i] % 2 == 0) {\n        pari.push(numeri[i]);\n    }\n    i = i + 1;\n}\n\n// Map (manuale)\nlet numeri2 = [1, 2, 3, 4, 5];\nlet raddoppiato = [];\nlet j = 0;\nwhile (j < numeri2.length) {\n    raddoppiato.push(numeri2[j] * 2);\n    j = j + 1;\n}\n```\n\n### Costruzione di Array\n\n```hemlock\nlet arr = [];\n\n// Costruisci array con ciclo\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## Dettagli di Implementazione\n\n**Gestione della Capacit:**\n- Gli array crescono automaticamente quando necessario\n- La capacit raddoppia quando viene superata\n- Nessun controllo manuale della capacit\n\n**Confronto dei Valori:**\n- `find()` e `contains()` usano l'uguaglianza di valore\n- Funziona correttamente per primitivi e stringhe\n- Oggetti/array confrontati per riferimento\n\n**Memoria:**\n- Allocati nell'heap\n- Nessuna liberazione automatica (gestione manuale della memoria)\n- Nessun controllo dei limiti sull'accesso diretto all'indice\n\n---\n\n## Vedi Anche\n\n- [Sistema di Tipi](#reference-type-system) - Dettagli sul tipo array\n- [API delle Stringhe](#reference-string-api) - Risultati di string join()\n- [Operatori](#reference-operators) - Operatore di indicizzazione degli array\n"}, "Riferimento API -> API dei File": {"id": "reference-file-api", "content": "# Riferimento API dei File\n\nRiferimento completo per il sistema di I/O su file di Hemlock.\n\n---\n\n## Panoramica\n\nHemlock fornisce un'**API a oggetti File** per le operazioni sui file con gestione appropriata degli errori e gestione delle risorse. I file devono essere aperti e chiusi manualmente.\n\n**Caratteristiche Principali:**\n- Oggetto file con metodi\n- Lettura/scrittura di dati testuali e binari\n- Ricerca e posizionamento\n- Messaggi di errore appropriati\n- Gestione manuale delle risorse (no RAII)\n\n---\n\n## Tipo File\n\n**Tipo:** `file`\n\n**Descrizione:** Handle di file per operazioni di I/O\n\n**Propriet (Sola Lettura):**\n- `.path` - Percorso del file (string)\n- `.mode` - Modalit di apertura (string)\n- `.closed` - Se il file  chiuso (bool)\n\n---\n\n## Apertura dei File\n\n### open\n\nApre un file per lettura, scrittura o entrambe.\n\n**Firma:**\n```hemlock\nopen(percorso: string, modalita?: string): file\n```\n\n**Parametri:**\n- `percorso` - Percorso del file (relativo o assoluto)\n- `modalita` (opzionale) - Modalit di apertura (predefinito: `\"r\"`)\n\n**Restituisce:** Oggetto file\n\n**Modalit:**\n- `\"r\"` - Lettura (predefinita)\n- `\"w\"` - Scrittura (tronca file esistente)\n- `\"a\"` - Append\n- `\"r+\"` - Lettura e scrittura\n- `\"w+\"` - Lettura e scrittura (tronca)\n- `\"a+\"` - Lettura e append\n\n**Esempi:**\n```hemlock\n// Modalit lettura (predefinita)\nlet f = open(\"dati.txt\");\nlet f_lettura = open(\"dati.txt\", \"r\");\n\n// Modalit scrittura (tronca)\nlet f_scrittura = open(\"output.txt\", \"w\");\n\n// Modalit append\nlet f_append = open(\"log.txt\", \"a\");\n\n// Modalit lettura/scrittura\nlet f_rw = open(\"dati.bin\", \"r+\");\n\n// Lettura/scrittura (tronca)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Lettura/append\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**Gestione degli Errori:**\n```hemlock\ntry {\n    let f = open(\"mancante.txt\", \"r\");\n} catch (e) {\n    print(\"Apertura fallita:\", e);\n    // Errore: Impossibile aprire 'mancante.txt': File o directory inesistente\n}\n```\n\n**Importante:** I file devono essere chiusi manualmente con `f.close()` per evitare perdite di descrittori di file.\n\n---\n\n## Metodi dei File\n\n### Lettura\n\n#### read\n\nLegge testo dal file.\n\n**Firma:**\n```hemlock\nfile.read(dimensione?: i32): string\n```\n\n**Parametri:**\n- `dimensione` (opzionale) - Numero di byte da leggere (se omesso, legge fino a EOF)\n\n**Restituisce:** Stringa con il contenuto del file\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\n// Leggi intero file\nlet tutto = f.read();\nprint(tutto);\n\n// Leggi numero specifico di byte\nlet blocco = f.read(1024);\n\nf.close();\n```\n\n**Comportamento:**\n- Legge dalla posizione corrente del file\n- Restituisce stringa vuota a EOF\n- Avanza la posizione del file\n\n**Errori:**\n- Lettura da file chiuso\n- Lettura da file di sola scrittura\n\n---\n\n#### read_bytes\n\nLegge dati binari dal file.\n\n**Firma:**\n```hemlock\nfile.read_bytes(dimensione: i32): buffer\n```\n\n**Parametri:**\n- `dimensione` - Numero di byte da leggere\n\n**Restituisce:** Buffer con dati binari\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.bin\", \"r\");\n\n// Leggi 256 byte\nlet binario = f.read_bytes(256);\nprint(binario.length);       // 256\n\n// Elabora dati binari\nlet i = 0;\nwhile (i < binario.length) {\n    print(binario[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**Comportamento:**\n- Legge numero esatto di byte\n- Restituisce buffer (non stringa)\n- Avanza la posizione del file\n\n---\n\n### Scrittura\n\n#### write\n\nScrive testo nel file.\n\n**Firma:**\n```hemlock\nfile.write(dati: string): i32\n```\n\n**Parametri:**\n- `dati` - Stringa da scrivere\n\n**Restituisce:** Numero di byte scritti (i32)\n\n**Esempi:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Scrivi testo\nlet scritti = f.write(\"Ciao, Mondo!\\n\");\nprint(\"Scritti\", scritti, \"byte\");\n\n// Scritture multiple\nf.write(\"Riga 1\\n\");\nf.write(\"Riga 2\\n\");\nf.write(\"Riga 3\\n\");\n\nf.close();\n```\n\n**Comportamento:**\n- Scrive alla posizione corrente del file\n- Restituisce numero di byte scritti\n- Avanza la posizione del file\n\n**Errori:**\n- Scrittura su file chiuso\n- Scrittura su file di sola lettura\n\n---\n\n#### write_bytes\n\nScrive dati binari nel file.\n\n**Firma:**\n```hemlock\nfile.write_bytes(dati: buffer): i32\n```\n\n**Parametri:**\n- `dati` - Buffer da scrivere\n\n**Restituisce:** Numero di byte scritti (i32)\n\n**Esempi:**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Crea buffer\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Scrivi buffer\nlet scritti = f.write_bytes(buf);\nprint(\"Scritti\", scritti, \"byte\");\n\nf.close();\n```\n\n**Comportamento:**\n- Scrive il contenuto del buffer nel file\n- Restituisce numero di byte scritti\n- Avanza la posizione del file\n\n---\n\n### Posizionamento\n\n#### seek\n\nSposta la posizione del file a un offset di byte specifico.\n\n**Firma:**\n```hemlock\nfile.seek(posizione: i32): i32\n```\n\n**Parametri:**\n- `posizione` - Offset in byte dall'inizio del file\n\n**Restituisce:** Nuova posizione nel file (i32)\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\n// Salta al byte 100\nf.seek(100);\n\n// Leggi da quella posizione\nlet blocco = f.read(50);\n\n// Torna all'inizio\nf.seek(0);\n\n// Leggi dall'inizio\nlet tutto = f.read();\n\nf.close();\n```\n\n**Comportamento:**\n- Imposta la posizione del file all'offset assoluto\n- Restituisce la nuova posizione\n- Posizionarsi oltre EOF  permesso (crea buco nel file durante la scrittura)\n\n---\n\n#### tell\n\nOttiene la posizione corrente nel file.\n\n**Firma:**\n```hemlock\nfile.tell(): i32\n```\n\n**Restituisce:** Offset corrente in byte dall'inizio del file (i32)\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\n\nprint(f.tell());        // 0 (all'inizio)\n\nf.read(100);\nprint(f.tell());        // 100 (dopo la lettura)\n\nf.seek(50);\nprint(f.tell());        // 50 (dopo il seek)\n\nf.close();\n```\n\n---\n\n### Chiusura\n\n#### close\n\nChiude il file (idempotente).\n\n**Firma:**\n```hemlock\nfile.close(): null\n```\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nlet contenuto = f.read();\nf.close();\n\n// Sicuro chiamarlo pi volte\nf.close();  // Nessun errore\nf.close();  // Nessun errore\n```\n\n**Comportamento:**\n- Chiude l'handle del file\n- Svuota qualsiasi scrittura in sospeso\n- Idempotente (sicuro chiamarlo pi volte)\n- Imposta la propriet `.closed` a `true`\n\n**Importante:** Chiudi sempre i file quando hai finito per evitare perdite di descrittori.\n\n---\n\n## Propriet dei File\n\n### .path\n\nOttiene il percorso del file.\n\n**Tipo:** `string`\n\n**Accesso:** Sola lettura\n\n**Esempi:**\n```hemlock\nlet f = open(\"/percorso/al/file.txt\", \"r\");\nprint(f.path);          // \"/percorso/al/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nOttiene la modalit di apertura.\n\n**Tipo:** `string`\n\n**Accesso:** Sola lettura\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nVerifica se il file  chiuso.\n\n**Tipo:** `bool`\n\n**Accesso:** Sola lettura\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## Gestione degli Errori\n\nTutte le operazioni sui file includono messaggi di errore appropriati con contesto:\n\n### File Non Trovato\n```hemlock\nlet f = open(\"mancante.txt\", \"r\");\n// Errore: Impossibile aprire 'mancante.txt': File o directory inesistente\n```\n\n### Lettura da File Chiuso\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nf.close();\nf.read();\n// Errore: Impossibile leggere da file chiuso 'dati.txt'\n```\n\n### Scrittura su File di Sola Lettura\n```hemlock\nlet f = open(\"sola_lettura.txt\", \"r\");\nf.write(\"dati\");\n// Errore: Impossibile scrivere su file 'sola_lettura.txt' aperto in modalit sola lettura\n```\n\n### Uso di try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"dati.txt\", \"r\");\n    let contenuto = f.read();\n    print(contenuto);\n} catch (e) {\n    print(\"Errore file:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Pattern di Gestione delle Risorse\n\n### Pattern Base\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nlet contenuto = f.read();\nf.close();\n```\n\n### Con Gestione degli Errori\n\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\ntry {\n    let contenuto = f.read();\n    elabora(contenuto);\n} finally {\n    f.close();  // Chiudi sempre, anche in caso di errore\n}\n```\n\n### Pattern Sicuro\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"dati.txt\", \"r\");\n    let contenuto = f.read();\n    // ... elabora contenuto ...\n} catch (e) {\n    print(\"Errore:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Esempi di Utilizzo\n\n### Leggi Intero File\n\n```hemlock\nfn leggi_file(nome_file: string): string {\n    let f = open(nome_file, \"r\");\n    let contenuto = f.read();\n    f.close();\n    return contenuto;\n}\n\nlet testo = leggi_file(\"dati.txt\");\nprint(testo);\n```\n\n### Scrivi File di Testo\n\n```hemlock\nfn scrivi_file(nome_file: string, contenuto: string) {\n    let f = open(nome_file, \"w\");\n    f.write(contenuto);\n    f.close();\n}\n\nscrivi_file(\"output.txt\", \"Ciao, Mondo!\\n\");\n```\n\n### Append a File\n\n```hemlock\nfn aggiungi_a_file(nome_file: string, riga: string) {\n    let f = open(nome_file, \"a\");\n    f.write(riga + \"\\n\");\n    f.close();\n}\n\naggiungi_a_file(\"log.txt\", \"Voce log 1\");\naggiungi_a_file(\"log.txt\", \"Voce log 2\");\n```\n\n### Leggi File Binario\n\n```hemlock\nfn leggi_binario(nome_file: string, dimensione: i32): buffer {\n    let f = open(nome_file, \"r\");\n    let dati = f.read_bytes(dimensione);\n    f.close();\n    return dati;\n}\n\nlet binario = leggi_binario(\"dati.bin\", 256);\nprint(\"Letti\", binario.length, \"byte\");\n```\n\n### Scrivi File Binario\n\n```hemlock\nfn scrivi_binario(nome_file: string, dati: buffer) {\n    let f = open(nome_file, \"w\");\n    f.write_bytes(dati);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nscrivi_binario(\"output.bin\", buf);\n```\n\n### Leggi File Riga per Riga\n\n```hemlock\nfn leggi_righe(nome_file: string): array {\n    let f = open(nome_file, \"r\");\n    let contenuto = f.read();\n    f.close();\n    return contenuto.split(\"\\n\");\n}\n\nlet righe = leggi_righe(\"dati.txt\");\nlet i = 0;\nwhile (i < righe.length) {\n    print(\"Riga\", i, \":\", righe[i]);\n    i = i + 1;\n}\n```\n\n### Copia File\n\n```hemlock\nfn copia_file(sorgente: string, dest: string) {\n    let f_in = open(sorgente, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let contenuto = f_in.read();\n    f_out.write(contenuto);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopia_file(\"input.txt\", \"output.txt\");\n```\n\n### Leggi File a Blocchi\n\n```hemlock\nfn elabora_blocchi(nome_file: string) {\n    let f = open(nome_file, \"r\");\n\n    while (true) {\n        let blocco = f.read(1024);  // Leggi 1KB alla volta\n        if (blocco.length == 0) {\n            break;  // EOF\n        }\n\n        // Elabora blocco\n        print(\"Elaborando\", blocco.length, \"byte\");\n    }\n\n    f.close();\n}\n\nelabora_blocchi(\"file_grande.txt\");\n```\n\n---\n\n## Riepilogo Completo dei Metodi\n\n| Metodo        | Firma                  | Restituisce | Descrizione                  |\n|---------------|------------------------|-------------|------------------------------|\n| `read`        | `(dimensione?: i32)`   | `string`    | Legge testo                  |\n| `read_bytes`  | `(dimensione: i32)`    | `buffer`    | Legge dati binari            |\n| `write`       | `(dati: string)`       | `i32`       | Scrive testo                 |\n| `write_bytes` | `(dati: buffer)`       | `i32`       | Scrive dati binari           |\n| `seek`        | `(posizione: i32)`     | `i32`       | Imposta posizione file       |\n| `tell`        | `()`                   | `i32`       | Ottiene posizione file       |\n| `close`       | `()`                   | `null`      | Chiude file (idempotente)    |\n\n---\n\n## Riepilogo Completo delle Propriet\n\n| Propriet | Tipo     | Accesso     | Descrizione              |\n|-----------|----------|-------------|--------------------------|\n| `.path`   | `string` | Sola lettura| Percorso del file        |\n| `.mode`   | `string` | Sola lettura| Modalit di apertura     |\n| `.closed` | `bool`   | Sola lettura| Se il file  chiuso      |\n\n---\n\n## Migrazione dalla Vecchia API\n\n**Vecchia API (Rimossa):**\n- `read_file(percorso)` - Usa `open(percorso, \"r\").read()`\n- `write_file(percorso, dati)` - Usa `open(percorso, \"w\").write(dati)`\n- `append_file(percorso, dati)` - Usa `open(percorso, \"a\").write(dati)`\n- `file_exists(percorso)` - Nessuna sostituzione ancora\n\n**Esempio di Migrazione:**\n```hemlock\n// Vecchio (v0.0)\nlet contenuto = read_file(\"dati.txt\");\nwrite_file(\"output.txt\", contenuto);\n\n// Nuovo (v0.1)\nlet f = open(\"dati.txt\", \"r\");\nlet contenuto = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(contenuto);\nf2.close();\n```\n\n---\n\n## Vedi Anche\n\n- [Funzioni Integrate](#reference-builtins) - Funzione `open()`\n- [API della Memoria](#reference-memory-api) - Tipo buffer\n- [API delle Stringhe](#reference-string-api) - Metodi delle stringhe per elaborazione del testo\n"}, "Riferimento API -> API della Memoria": {"id": "reference-memory-api", "content": "# Riferimento API della Memoria\n\nRiferimento completo per le funzioni di gestione della memoria e i tipi di puntatore di Hemlock.\n\n---\n\n## Panoramica\n\nHemlock fornisce **gestione manuale della memoria** con allocazione e deallocazione esplicite. La memoria  gestita attraverso due tipi di puntatore: puntatori grezzi (`ptr`) e buffer sicuri (`buffer`).\n\n**Principi Chiave:**\n- Allocazione e deallocazione esplicite\n- Nessun garbage collection\n- L'utente  responsabile di chiamare `free()`\n- Conteggio dei riferimenti interno per sicurezza di scope/riassegnazione (vedi sotto)\n\n### Conteggio dei Riferimenti Interno\n\nIl runtime usa il conteggio dei riferimenti internamente per gestire i tempi di vita degli oggetti attraverso gli scope. Per la maggior parte delle variabili locali, la pulizia  automatica.\n\n**Automatico (nessun `free()` necessario):**\n- Le variabili locali di tipi con conteggio riferimenti (buffer, array, oggetto, stringa) vengono liberate all'uscita dallo scope\n- I vecchi valori vengono rilasciati quando le variabili vengono riassegnate\n- Gli elementi dei contenitori vengono rilasciati quando i contenitori vengono liberati\n\n**`free()` manuale richiesto:**\n- Puntatori grezzi da `alloc()` - sempre\n- Pulizia anticipata prima dell'uscita dallo scope\n- Dati a lunga vita/globali\n\nVedi [Guida alla Gestione della Memoria](../language-guide/memory.md#internal-reference-counting) per dettagli.\n\n---\n\n## Tipi di Puntatore\n\n### ptr (Puntatore Grezzo)\n\n**Tipo:** `ptr`\n\n**Descrizione:** Indirizzo di memoria grezzo senza controllo dei limiti o tracciamento.\n\n**Dimensione:** 8 byte\n\n**Casi d'Uso:**\n- Operazioni di memoria a basso livello\n- FFI (Foreign Function Interface)\n- Massime prestazioni (nessun overhead)\n\n**Sicurezza:** Non sicuro - nessun controllo dei limiti, l'utente deve tracciare il tempo di vita\n\n**Esempi:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer (Buffer Sicuro)\n\n**Tipo:** `buffer`\n\n**Descrizione:** Wrapper sicuro del puntatore con controllo dei limiti.\n\n**Struttura:** Puntatore + lunghezza + capacit + ref_count\n\n**Propriet:**\n- `.length` - Dimensione del buffer (i32)\n- `.capacity` - Capacit allocata (i32)\n\n**Casi d'Uso:**\n- La maggior parte delle allocazioni di memoria\n- Quando la sicurezza  importante\n- Array dinamici\n\n**Sicurezza:** Controllo dei limiti nell'accesso all'indice\n\n**Conteggio Riferimenti:** I buffer hanno conteggio riferimenti interno. Automaticamente liberati all'uscita dallo scope o quando la variabile viene riassegnata. Usa `free()` per pulizia anticipata o dati a lunga vita.\n\n**Esempi:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Controllo limiti\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## Funzioni di Allocazione della Memoria\n\n### alloc\n\nAlloca memoria grezza.\n\n**Firma:**\n```hemlock\nalloc(dimensione: i32): ptr\n```\n\n**Parametri:**\n- `dimensione` - Numero di byte da allocare\n\n**Restituisce:** Puntatore alla memoria allocata (`ptr`)\n\n**Esempi:**\n```hemlock\nlet p = alloc(1024);        // Alloca 1KB\nmemset(p, 0, 1024);         // Inizializza a zero\nfree(p);                    // Libera quando finito\n\n// Alloca per struttura\nlet dim_struct = 16;\nlet p2 = alloc(dim_struct);\n```\n\n**Comportamento:**\n- Restituisce memoria non inizializzata\n- La memoria deve essere liberata manualmente\n- Restituisce `null` in caso di fallimento dell'allocazione (il chiamante deve verificare)\n\n**Vedi Anche:** `buffer()` per alternativa pi sicura\n\n---\n\n### buffer\n\nAlloca buffer sicuro con controllo dei limiti.\n\n**Firma:**\n```hemlock\nbuffer(dimensione: i32): buffer\n```\n\n**Parametri:**\n- `dimensione` - Dimensione del buffer in byte\n\n**Restituisce:** Oggetto buffer\n\n**Esempi:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Accesso con controllo limiti\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // ERRORE: fuori limiti\n\nfree(buf);\n```\n\n**Propriet:**\n- `.length` - Dimensione corrente (i32)\n- `.capacity` - Capacit allocata (i32)\n\n**Comportamento:**\n- Inizializza la memoria a zero\n- Fornisce controllo limiti nell'accesso all'indice\n- Restituisce `null` in caso di fallimento dell'allocazione (il chiamante deve verificare)\n- Deve essere liberato manualmente\n\n---\n\n### free\n\nLibera memoria allocata.\n\n**Firma:**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Parametri:**\n- `ptr` - Puntatore o buffer da liberare\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\n// Libera puntatore grezzo\nlet p = alloc(1024);\nfree(p);\n\n// Libera buffer\nlet buf = buffer(256);\nfree(buf);\n```\n\n**Comportamento:**\n- Libera memoria allocata da `alloc()` o `buffer()`\n- Double-free causa crash (responsabilit dell'utente evitarlo)\n- Liberare puntatori non validi causa comportamento indefinito\n\n**Importante:** Tu allochi, tu liberi. Nessuna pulizia automatica.\n\n---\n\n### realloc\n\nRidimensiona memoria allocata.\n\n**Firma:**\n```hemlock\nrealloc(ptr: ptr, nuova_dimensione: i32): ptr\n```\n\n**Parametri:**\n- `ptr` - Puntatore da ridimensionare\n- `nuova_dimensione` - Nuova dimensione in byte\n\n**Restituisce:** Puntatore alla memoria ridimensionata (potrebbe essere indirizzo diverso)\n\n**Esempi:**\n```hemlock\nlet p = alloc(100);\n// ... usa memoria ...\n\n// Serve pi spazio\np = realloc(p, 200);        // Ora 200 byte\n// ... usa memoria espansa ...\n\nfree(p);\n```\n\n**Comportamento:**\n- Potrebbe spostare la memoria in nuova posizione\n- Preserva dati esistenti (fino al minimo tra vecchia/nuova dimensione)\n- Il vecchio puntatore non  valido dopo realloc riuscito (usa il puntatore restituito)\n- Se nuova_dimensione  pi piccola, i dati vengono troncati\n- Restituisce `null` in caso di fallimento (il puntatore originale rimane valido)\n\n**Importante:** Verifica sempre `null` e aggiorna la tua variabile puntatore con il risultato.\n\n---\n\n## Operazioni sulla Memoria\n\n### memset\n\nRiempie la memoria con un valore byte.\n\n**Firma:**\n```hemlock\nmemset(ptr: ptr, byte: i32, dimensione: i32): null\n```\n\n**Parametri:**\n- `ptr` - Puntatore alla memoria\n- `byte` - Valore byte da riempire (0-255)\n- `dimensione` - Numero di byte da riempire\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nlet p = alloc(100);\n\n// Azzera la memoria\nmemset(p, 0, 100);\n\n// Riempi con valore specifico\nmemset(p, 0xFF, 100);\n\n// Inizializza buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Riempi con 'A'\n\nfree(p);\nfree(buf);\n```\n\n**Comportamento:**\n- Scrive il valore byte su ogni byte nell'intervallo\n- Il valore byte  troncato a 8 bit (0-255)\n- Nessun controllo limiti (non sicuro)\n\n---\n\n### memcpy\n\nCopia memoria da sorgente a destinazione.\n\n**Firma:**\n```hemlock\nmemcpy(dest: ptr, src: ptr, dimensione: i32): null\n```\n\n**Parametri:**\n- `dest` - Puntatore destinazione\n- `src` - Puntatore sorgente\n- `dimensione` - Numero di byte da copiare\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Inizializza sorgente\nmemset(src, 65, 100);\n\n// Copia a destinazione\nmemcpy(dest, src, 100);\n\n// dest ora contiene gli stessi dati di src\n\nfree(src);\nfree(dest);\n```\n\n**Comportamento:**\n- Copia byte per byte da src a dest\n- Nessun controllo limiti (non sicuro)\n- Regioni sovrapposte hanno comportamento indefinito (usa con cautela)\n\n---\n\n## Operazioni sulla Memoria Tipizzate\n\n### sizeof\n\nOttiene la dimensione di un tipo in byte.\n\n**Firma:**\n```hemlock\nsizeof(tipo): i32\n```\n\n**Parametri:**\n- `tipo` - Identificatore di tipo (es. `i32`, `f64`, `ptr`)\n\n**Restituisce:** Dimensione in byte (i32)\n\n**Dimensioni dei Tipi:**\n\n| Tipo | Dimensione (byte) |\n|------|-------------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`, `integer` | 4 |\n| `i64` | 8 |\n| `u8`, `byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`, `number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**Esempi:**\n```hemlock\nlet dim_int = sizeof(i32);      // 4\nlet dim_ptr = sizeof(ptr);      // 8\nlet dim_float = sizeof(f64);    // 8\nlet dim_byte = sizeof(u8);      // 1\nlet dim_rune = sizeof(rune);    // 4\n\n// Calcola dimensione allocazione array\nlet conteggio = 100;\nlet totale = sizeof(i32) * conteggio; // 400 byte\n```\n\n**Comportamento:**\n- Restituisce 0 per tipi sconosciuti\n- Accetta sia identificatori di tipo che stringhe di tipo\n\n---\n\n### talloc\n\nAlloca array di valori tipizzati.\n\n**Firma:**\n```hemlock\ntalloc(tipo, conteggio: i32): ptr\n```\n\n**Parametri:**\n- `tipo` - Tipo da allocare (es. `i32`, `f64`, `ptr`)\n- `conteggio` - Numero di elementi (deve essere positivo)\n\n**Restituisce:** Puntatore all'array allocato, o `null` in caso di fallimento\n\n**Esempi:**\n```hemlock\nlet arr = talloc(i32, 100);      // Array di 100 i32 (400 byte)\nlet floats = talloc(f64, 50);    // Array di 50 f64 (400 byte)\nlet bytes = talloc(u8, 1024);    // Array di 1024 byte\n\n// Verifica sempre il fallimento dell'allocazione\nif (arr == null) {\n    panic(\"allocazione fallita\");\n}\n\n// Usa la memoria allocata\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**Comportamento:**\n- Alloca `sizeof(tipo) * conteggio` byte\n- Restituisce memoria non inizializzata\n- La memoria deve essere liberata manualmente con `free()`\n- Restituisce `null` in caso di fallimento dell'allocazione (il chiamante deve verificare)\n- Va in panic se il conteggio non  positivo\n\n---\n\n## Propriet del Buffer\n\n### .length\n\nOttiene la dimensione del buffer.\n\n**Tipo:** `i32`\n\n**Accesso:** Sola lettura\n\n**Esempi:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nOttiene la capacit del buffer.\n\n**Tipo:** `i32`\n\n**Accesso:** Sola lettura\n\n**Esempi:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**Nota:** Attualmente, `.length` e `.capacity` sono uguali per i buffer creati con `buffer()`.\n\n---\n\n## Pattern di Utilizzo\n\n### Pattern di Allocazione Base\n\n```hemlock\n// Alloca\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"allocazione fallita\");\n}\n\n// Usa\nmemset(p, 0, 1024);\n\n// Libera\nfree(p);\n```\n\n### Pattern Buffer Sicuro\n\n```hemlock\n// Alloca buffer\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"allocazione buffer fallita\");\n}\n\n// Usa con controllo limiti\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Libera\nfree(buf);\n```\n\n### Pattern di Crescita Dinamica\n\n```hemlock\nlet dimensione = 100;\nlet p = alloc(dimensione);\nif (p == null) {\n    panic(\"allocazione fallita\");\n}\n\n// ... usa memoria ...\n\n// Serve pi spazio - verifica fallimento\nlet nuovo_p = realloc(p, 200);\nif (nuovo_p == null) {\n    // Il puntatore originale  ancora valido, pulisci\n    free(p);\n    panic(\"realloc fallito\");\n}\np = nuovo_p;\ndimensione = 200;\n\n// ... usa memoria espansa ...\n\nfree(p);\n```\n\n### Pattern di Copia Memoria\n\n```hemlock\nlet originale = alloc(100);\nmemset(originale, 65, 100);\n\n// Crea copia\nlet copia = alloc(100);\nmemcpy(copia, originale, 100);\n\nfree(originale);\nfree(copia);\n```\n\n---\n\n## Considerazioni sulla Sicurezza\n\n**La gestione della memoria di Hemlock  NON SICURA per design:**\n\n### Trappole Comuni\n\n**1. Memory Leak**\n```hemlock\n// MALE: Memory leak\nfn crea_buffer() {\n    let p = alloc(1024);\n    return null;  // Memoria persa!\n}\n\n// BENE: Pulizia appropriata\nfn crea_buffer() {\n    let p = alloc(1024);\n    // ... usa memoria ...\n    free(p);\n    return null;\n}\n```\n\n**2. Use After Free**\n```hemlock\n// MALE: Use after free\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // CRASH: uso di memoria liberata\n\n// BENE: Non usare dopo free\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// Non toccare p2 dopo questo\n```\n\n**3. Double Free**\n```hemlock\n// MALE: Double free\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: double free\n\n// BENE: Libera una volta sola\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. Buffer Overflow (ptr)**\n```hemlock\n// MALE: Buffer overflow con ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // CRASH: scrittura oltre allocazione\n\n// BENE: Usa buffer per controllo limiti\nlet buf = buffer(10);\n// buf[100] = 65;  // ERRORE: controllo limiti fallisce\n```\n\n**5. Dangling Pointers**\n```hemlock\n// MALE: Dangling pointer\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // CRASH: p2  dangling\n\n// BENE: Traccia ownership attentamente\nlet p = alloc(100);\n// ... usa p ...\nfree(p);\n// Non mantenere altri riferimenti a p\n```\n\n**6. Fallimento Allocazione Non Verificato**\n```hemlock\n// MALE: Non verificare null\nlet p = alloc(1000000000);  // Potrebbe fallire con poca memoria\nmemset(p, 0, 1000000000);   // CRASH: p  null\n\n// BENE: Verifica sempre il risultato dell'allocazione\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"memoria esaurita\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## Quando Usare Cosa\n\n### Usa `buffer()` quando:\n- Hai bisogno di controllo limiti\n- Lavori con dati dinamici\n- La sicurezza  importante\n- Stai imparando Hemlock\n\n### Usa `alloc()` quando:\n- Servono prestazioni massime\n- FFI/interfacciamento con C\n- Conosci esattamente il layout della memoria\n- Sei un esperto\n\n### Usa `realloc()` quando:\n- Devi crescere/ridurre allocazioni\n- Array dinamici\n- Devi preservare i dati\n\n---\n\n## Riepilogo Completo delle Funzioni\n\n| Funzione  | Firma                              | Restituisce | Descrizione                |\n|-----------|------------------------------------|-------------|----------------------------|\n| `alloc`   | `(dimensione: i32)`                | `ptr`       | Alloca memoria grezza      |\n| `buffer`  | `(dimensione: i32)`                | `buffer`    | Alloca buffer sicuro       |\n| `free`    | `(ptr: ptr \\| buffer)`             | `null`      | Libera memoria             |\n| `realloc` | `(ptr: ptr, nuova_dim: i32)`       | `ptr`       | Ridimensiona allocazione   |\n| `memset`  | `(ptr: ptr, byte: i32, dim: i32)`  | `null`      | Riempie memoria            |\n| `memcpy`  | `(dest: ptr, src: ptr, dim: i32)`  | `null`      | Copia memoria              |\n| `sizeof`  | `(tipo)`                           | `i32`       | Ottiene dimensione tipo in byte |\n| `talloc`  | `(tipo, conteggio: i32)`           | `ptr`       | Alloca array tipizzato     |\n\n---\n\n## Vedi Anche\n\n- [Sistema di Tipi](#reference-type-system) - Tipi puntatore e buffer\n- [Funzioni Integrate](#reference-builtins) - Tutte le funzioni integrate\n- [API delle Stringhe](#reference-string-api) - Metodo `.to_bytes()` delle stringhe\n"}, "Riferimento API -> API delle Stringhe": {"id": "reference-string-api", "content": "# Riferimento API delle Stringhe\n\nRiferimento completo per il tipo stringa di Hemlock e tutti i suoi 19 metodi.\n\n---\n\n## Panoramica\n\nLe stringhe in Hemlock sono sequenze **codificate in UTF-8, mutabili, allocate nell'heap** con supporto completo Unicode. Tutte le operazioni lavorano con **codepoint** (caratteri), non byte.\n\n**Caratteristiche Principali:**\n- Codifica UTF-8 (U+0000 a U+10FFFF)\n- Mutabili (possono modificare i caratteri in loco)\n- Indicizzazione basata sui codepoint\n- 19 metodi integrati\n- Concatenazione automatica con operatore `+`\n\n---\n\n## Tipo Stringa\n\n**Tipo:** `string`\n\n**Propriet:**\n- `.length` - Numero di codepoint (caratteri)\n- `.byte_length` - Numero di byte UTF-8\n\n**Sintassi Letterale:** Virgolette doppie `\"testo\"`\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nprint(s.length);        // 5 (codepoint)\nprint(s.byte_length);   // 5 (byte)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (un codepoint)\nprint(emoji.byte_length);   // 4 (quattro byte UTF-8)\n```\n\n---\n\n## Indicizzazione\n\nLe stringhe supportano l'indicizzazione basata sui codepoint usando `[]`:\n\n**Accesso in Lettura:**\n```hemlock\nlet s = \"ciao\";\nlet ch = s[0];          // Restituisce rune 'c'\n```\n\n**Accesso in Scrittura:**\n```hemlock\nlet s = \"ciao\";\ns[0] = 'C';             // Muta con rune (ora \"Ciao\")\n```\n\n**Esempio UTF-8:**\n```hemlock\nlet testo = \"Hi!\";\nprint(testo[0]);         // 'H'\nprint(testo[1]);         // 'i'\nprint(testo[2]);         // '' (un codepoint)\nprint(testo[3]);         // '!'\n```\n\n---\n\n## Concatenazione\n\nUsa l'operatore `+` per concatenare stringhe e rune:\n\n**Stringa + Stringa:**\n```hemlock\nlet s = \"ciao\" + \" \" + \"mondo\";  // \"ciao mondo\"\nlet msg = \"Conteggio: \" + typeof(42); // \"Conteggio: 42\"\n```\n\n**Stringa + Rune:**\n```hemlock\nlet saluto = \"Ciao\" + '!';       // \"Ciao!\"\nlet decorato = \"Testo\" + '';    // \"Testo\"\n```\n\n**Rune + Stringa:**\n```hemlock\nlet prefisso = '>' + \" Messaggio\";   // \"> Messaggio\"\nlet punto = '' + \" Elemento\";       // \" Elemento\"\n```\n\n**Concatenazioni Multiple:**\n```hemlock\nlet msg = \"Ciao \" + '' + \" Mondo \" + '';  // \"Ciao  Mondo \"\n```\n\n---\n\n## Propriet delle Stringhe\n\n### .length\n\nOttiene il numero di codepoint Unicode (caratteri).\n\n**Tipo:** `i32`\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nprint(s.length);        // 5\n\nlet emoji = \"\";\nprint(emoji.length);    // 1 (un codepoint)\n\nlet testo = \"Ciao !\";\nprint(testo.length);    // 7 (6 ASCII + 1 emoji)\n```\n\n---\n\n### .byte_length\n\nOttiene il numero di byte UTF-8.\n\n**Tipo:** `i32`\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nprint(s.byte_length);   // 5 (1 byte per carattere ASCII)\n\nlet emoji = \"\";\nprint(emoji.byte_length); // 4 (emoji  4 byte UTF-8)\n\nlet testo = \"Ciao !\";\nprint(testo.byte_length);  // 11 (7 ASCII + 4 per emoji)\n```\n\n---\n\n## Metodi delle Stringhe\n\n### Sottostringa e Slicing\n\n#### substr\n\nEstrae una sottostringa per posizione e lunghezza.\n\n**Firma:**\n```hemlock\nstring.substr(inizio: i32, lunghezza: i32): string\n```\n\n**Parametri:**\n- `inizio` - Indice del codepoint iniziale (base 0)\n- `lunghezza` - Numero di codepoint da estrarre\n\n**Restituisce:** Nuova stringa\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet sub = s.substr(5, 5);       // \"mondo\"\nlet primo = s.substr(0, 4);     // \"ciao\"\n\n// Esempio UTF-8\nlet testo = \"Hi!\";\nlet emoji = testo.substr(2, 1);  // \"\"\n```\n\n---\n\n#### slice\n\nEstrae una sottostringa per intervallo (fine esclusiva).\n\n**Firma:**\n```hemlock\nstring.slice(inizio: i32, fine: i32): string\n```\n\n**Parametri:**\n- `inizio` - Indice del codepoint iniziale (base 0)\n- `fine` - Indice del codepoint finale (esclusivo)\n\n**Restituisce:** Nuova stringa\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet sub = s.slice(0, 4);        // \"ciao\"\nlet mondo = s.slice(5, 10);     // \"mondo\"\n\n// Esempio UTF-8\nlet testo = \"Hi!\";\nlet primi_tre = testo.slice(0, 3);  // \"Hi\"\n```\n\n---\n\n### Ricerca e Trova\n\n#### find\n\nTrova la prima occorrenza di una sottostringa.\n\n**Firma:**\n```hemlock\nstring.find(ago: string): i32\n```\n\n**Parametri:**\n- `ago` - Sottostringa da cercare\n\n**Restituisce:** Indice del codepoint della prima occorrenza, o `-1` se non trovata\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet pos = s.find(\"mondo\");      // 5\nlet pos2 = s.find(\"foo\");       // -1 (non trovato)\nlet pos3 = s.find(\"o\");         // 3 (primo 'o')\n```\n\n---\n\n#### contains\n\nVerifica se la stringa contiene una sottostringa.\n\n**Firma:**\n```hemlock\nstring.contains(ago: string): bool\n```\n\n**Parametri:**\n- `ago` - Sottostringa da cercare\n\n**Restituisce:** `true` se trovata, `false` altrimenti\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet ha = s.contains(\"mondo\");   // true\nlet ha2 = s.contains(\"foo\");    // false\n```\n\n---\n\n### Split e Join\n\n#### split\n\nDivide la stringa in array per delimitatore.\n\n**Firma:**\n```hemlock\nstring.split(delimitatore: string): array\n```\n\n**Parametri:**\n- `delimitatore` - Stringa su cui dividere\n\n**Restituisce:** Array di stringhe\n\n**Esempi:**\n```hemlock\nlet csv = \"a,b,c\";\nlet parti = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet percorso = \"/usr/local/bin\";\nlet dir = percorso.split(\"/\");  // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet testo = \"ciao mondo foo\";\nlet parole = testo.split(\" \");  // [\"ciao\", \"mondo\", \"foo\"]\n```\n\n---\n\n#### trim\n\nRimuove gli spazi bianchi iniziali e finali.\n\n**Firma:**\n```hemlock\nstring.trim(): string\n```\n\n**Restituisce:** Nuova stringa con spazi bianchi rimossi\n\n**Esempi:**\n```hemlock\nlet s = \"  ciao  \";\nlet pulito = s.trim();           // \"ciao\"\n\nlet testo = \"\\n\\t  mondo  \\n\";\nlet pulito2 = testo.trim();      // \"mondo\"\n```\n\n---\n\n### Conversione Maiuscole/Minuscole\n\n#### to_upper\n\nConverte la stringa in maiuscolo.\n\n**Firma:**\n```hemlock\nstring.to_upper(): string\n```\n\n**Restituisce:** Nuova stringa in maiuscolo\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet maiuscolo = s.to_upper();    // \"CIAO MONDO\"\n\nlet misto = \"CiAo\";\nlet maiuscolo2 = misto.to_upper();  // \"CIAO\"\n```\n\n---\n\n#### to_lower\n\nConverte la stringa in minuscolo.\n\n**Firma:**\n```hemlock\nstring.to_lower(): string\n```\n\n**Restituisce:** Nuova stringa in minuscolo\n\n**Esempi:**\n```hemlock\nlet s = \"CIAO MONDO\";\nlet minuscolo = s.to_lower();    // \"ciao mondo\"\n\nlet misto = \"CiAo\";\nlet minuscolo2 = misto.to_lower();  // \"ciao\"\n```\n\n---\n\n### Prefisso e Suffisso\n\n#### starts_with\n\nVerifica se la stringa inizia con un prefisso.\n\n**Firma:**\n```hemlock\nstring.starts_with(prefisso: string): bool\n```\n\n**Parametri:**\n- `prefisso` - Prefisso da verificare\n\n**Restituisce:** `true` se la stringa inizia con il prefisso, `false` altrimenti\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet inizia = s.starts_with(\"ciao\");   // true\nlet inizia2 = s.starts_with(\"mondo\"); // false\n```\n\n---\n\n#### ends_with\n\nVerifica se la stringa termina con un suffisso.\n\n**Firma:**\n```hemlock\nstring.ends_with(suffisso: string): bool\n```\n\n**Parametri:**\n- `suffisso` - Suffisso da verificare\n\n**Restituisce:** `true` se la stringa termina con il suffisso, `false` altrimenti\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet termina = s.ends_with(\"mondo\");  // true\nlet termina2 = s.ends_with(\"ciao\");  // false\n```\n\n---\n\n### Sostituzione\n\n#### replace\n\nSostituisce la prima occorrenza di una sottostringa.\n\n**Firma:**\n```hemlock\nstring.replace(vecchio: string, nuovo: string): string\n```\n\n**Parametri:**\n- `vecchio` - Sottostringa da sostituire\n- `nuovo` - Stringa di sostituzione\n\n**Restituisce:** Nuova stringa con la prima occorrenza sostituita\n\n**Esempi:**\n```hemlock\nlet s = \"ciao mondo\";\nlet s2 = s.replace(\"mondo\", \"italia\");  // \"ciao italia\"\n\nlet testo = \"foo foo foo\";\nlet testo2 = testo.replace(\"foo\", \"bar\"); // \"bar foo foo\" (solo la prima)\n```\n\n---\n\n#### replace_all\n\nSostituisce tutte le occorrenze di una sottostringa.\n\n**Firma:**\n```hemlock\nstring.replace_all(vecchio: string, nuovo: string): string\n```\n\n**Parametri:**\n- `vecchio` - Sottostringa da sostituire\n- `nuovo` - Stringa di sostituzione\n\n**Restituisce:** Nuova stringa con tutte le occorrenze sostituite\n\n**Esempi:**\n```hemlock\nlet testo = \"foo foo foo\";\nlet testo2 = testo.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"ciao mondo ciao\";\nlet s2 = s.replace_all(\"ciao\", \"salve\");      // \"salve mondo salve\"\n```\n\n---\n\n### Ripetizione\n\n#### repeat\n\nRipete la stringa n volte.\n\n**Firma:**\n```hemlock\nstring.repeat(conteggio: i32): string\n```\n\n**Parametri:**\n- `conteggio` - Numero di ripetizioni\n\n**Restituisce:** Nuova stringa ripetuta conteggio volte\n\n**Esempi:**\n```hemlock\nlet s = \"ah\";\nlet ripetuto = s.repeat(3);     // \"ahahah\"\n\nlet linea = \"-\";\nlet separatore = linea.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### Accesso ai Caratteri\n\n#### char_at\n\nOttiene il codepoint Unicode all'indice.\n\n**Firma:**\n```hemlock\nstring.char_at(indice: i32): rune\n```\n\n**Parametri:**\n- `indice` - Indice del codepoint (base 0)\n\n**Restituisce:** Rune (codepoint Unicode)\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nlet ch = s.char_at(0);          // 'c'\nlet ch2 = s.char_at(1);         // 'i'\n\n// Esempio UTF-8\nlet emoji = \"\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (razzo)\n```\n\n---\n\n#### chars\n\nConverte la stringa in array di rune.\n\n**Firma:**\n```hemlock\nstring.chars(): array\n```\n\n**Restituisce:** Array di rune (codepoint)\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nlet caratteri = s.chars();          // ['c', 'i', 'a', 'o']\n\n// Esempio UTF-8\nlet testo = \"Hi!\";\nlet caratteri2 = testo.chars();     // ['H', 'i', '', '!']\n```\n\n---\n\n### Accesso ai Byte\n\n#### byte_at\n\nOttiene il valore del byte all'indice.\n\n**Firma:**\n```hemlock\nstring.byte_at(indice: i32): u8\n```\n\n**Parametri:**\n- `indice` - Indice del byte (base 0, NON indice del codepoint)\n\n**Restituisce:** Valore del byte (u8)\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nlet byte = s.byte_at(0);        // 99 (ASCII 'c')\nlet byte2 = s.byte_at(1);       // 105 (ASCII 'i')\n\n// Esempio UTF-8\nlet emoji = \"\";\nlet byte3 = emoji.byte_at(0);   // 240 (primo byte UTF-8)\n```\n\n---\n\n#### bytes\n\nConverte la stringa in array di byte.\n\n**Firma:**\n```hemlock\nstring.bytes(): array\n```\n\n**Restituisce:** Array di byte u8\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nlet bytes = s.bytes();          // [99, 105, 97, 111]\n\n// Esempio UTF-8\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 byte UTF-8)\n```\n\n---\n\n#### to_bytes\n\nConverte la stringa in buffer.\n\n**Firma:**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**Restituisce:** Buffer contenente i byte UTF-8\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// Esempio UTF-8\nlet emoji = \"\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**Nota:** Questo  un metodo legacy. Preferisci `.bytes()` per la maggior parte dei casi d'uso.\n\n---\n\n### Deserializzazione JSON\n\n#### deserialize\n\nAnalizza una stringa JSON in un valore.\n\n**Firma:**\n```hemlock\nstring.deserialize(): any\n```\n\n**Restituisce:** Valore analizzato (oggetto, array, numero, stringa, bool o null)\n\n**Esempi:**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**Tipi Supportati:**\n- Oggetti: `{\"chiave\": valore}`\n- Array: `[1, 2, 3]`\n- Numeri: `42`, `3.14`\n- Stringhe: `\"testo\"`\n- Booleani: `true`, `false`\n- Null: `null`\n\n**Vedi Anche:** Metodo `.serialize()` degli oggetti\n\n---\n\n## Concatenamento di Metodi\n\nI metodi delle stringhe possono essere concatenati per operazioni concise:\n\n**Esempi:**\n```hemlock\nlet risultato = \"  Ciao Mondo  \"\n    .trim()\n    .to_lower()\n    .replace(\"mondo\", \"hemlock\");  // \"ciao hemlock\"\n\nlet elaborato = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet pulito = \"  CIAO  \"\n    .trim()\n    .to_lower();                   // \"ciao\"\n```\n\n---\n\n## Riepilogo Completo dei Metodi\n\n| Metodo         | Firma                                    | Restituisce | Descrizione                           |\n|----------------|------------------------------------------|-------------|---------------------------------------|\n| `substr`       | `(inizio: i32, lunghezza: i32)`          | `string`    | Estrae sottostringa per posizione/lunghezza |\n| `slice`        | `(inizio: i32, fine: i32)`               | `string`    | Estrae sottostringa per intervallo    |\n| `find`         | `(ago: string)`                          | `i32`       | Trova prima occorrenza (-1 se non trovata) |\n| `contains`     | `(ago: string)`                          | `bool`      | Verifica se contiene sottostringa     |\n| `split`        | `(delimitatore: string)`                 | `array`     | Divide in array                       |\n| `trim`         | `()`                                     | `string`    | Rimuove spazi bianchi                 |\n| `to_upper`     | `()`                                     | `string`    | Converte in maiuscolo                 |\n| `to_lower`     | `()`                                     | `string`    | Converte in minuscolo                 |\n| `starts_with`  | `(prefisso: string)`                     | `bool`      | Verifica se inizia con prefisso       |\n| `ends_with`    | `(suffisso: string)`                     | `bool`      | Verifica se termina con suffisso      |\n| `replace`      | `(vecchio: string, nuovo: string)`       | `string`    | Sostituisce prima occorrenza          |\n| `replace_all`  | `(vecchio: string, nuovo: string)`       | `string`    | Sostituisce tutte le occorrenze       |\n| `repeat`       | `(conteggio: i32)`                       | `string`    | Ripete la stringa n volte             |\n| `char_at`      | `(indice: i32)`                          | `rune`      | Ottiene codepoint all'indice          |\n| `byte_at`      | `(indice: i32)`                          | `u8`        | Ottiene byte all'indice               |\n| `chars`        | `()`                                     | `array`     | Converte in array di rune             |\n| `bytes`        | `()`                                     | `array`     | Converte in array di byte             |\n| `to_bytes`     | `()`                                     | `buffer`    | Converte in buffer (legacy)           |\n| `deserialize`  | `()`                                     | `any`       | Analizza stringa JSON                 |\n\n---\n\n## Vedi Anche\n\n- [Sistema di Tipi](#reference-type-system) - Dettagli sul tipo stringa\n- [API degli Array](#reference-array-api) - Metodi degli array per risultati di split()\n- [Operatori](#reference-operators) - Operatore di concatenazione stringhe\n"}, "Riferimento API -> API di Concorrenza": {"id": "reference-concurrency-api", "content": "# Riferimento API di Concorrenza\n\nRiferimento completo per le funzionalit di concorrenza e parallelismo di Hemlock.\n\n---\n\n## Panoramica\n\nHemlock fornisce **concorrenza strutturata** basata su POSIX threads (pthreads) con task, canali e funzioni asincrone. Ogni task esegue su un thread del sistema operativo per un vero parallelismo su pi core CPU.\n\n**Caratteristiche Principali:**\n- Vero parallelismo multi-thread (non event loop o green threads)\n- Scheduling preemptive da parte del kernel\n- Canali per comunicazione sicura tra thread\n- async/await per funzioni asincrone\n- Propagazione delle eccezioni dai task\n\n---\n\n## Modello di Threading\n\n### Architettura\n\nHemlock usa threading **1:1** (un task = un pthread):\n\n```\nTask Utente          Thread OS          Core CPU\n---------            ---------          --------\nspawn(f1) ------->   pthread_create --> Core 0\nspawn(f2) ------->   pthread_create --> Core 1\nspawn(f3) ------->   pthread_create --> Core 2\n```\n\n**Caratteristiche:**\n- Ogni `spawn()` crea un nuovo pthread\n- Il kernel pianifica i thread sui core\n- Vera esecuzione parallela (nessun GIL)\n- Multitasking preemptive\n\n---\n\n## Tipo Task\n\n**Tipo:** `task`\n\n**Descrizione:** Handle per un task concorrente in esecuzione\n\n**Propriet:**\n- Handle opaco al thread sottostante\n- Contiene il risultato quando completato\n- Memorizza l'eccezione se lanciata\n\n---\n\n## Tipo Channel\n\n**Tipo:** `channel`\n\n**Descrizione:** Canale di comunicazione thread-safe con buffer\n\n**Propriet:**\n- `.length` - Numero di elementi attualmente nel buffer (i32)\n- `.capacity` - Dimensione massima del buffer (i32)\n- `.closed` - Se il canale  chiuso (bool)\n\n---\n\n## Funzioni di Gestione dei Task\n\n### spawn\n\nCrea un nuovo task per eseguire una funzione.\n\n**Firma:**\n```hemlock\nspawn(func: function, ...args): task\n```\n\n**Parametri:**\n- `func` - Funzione da eseguire\n- `args` - Argomenti da passare alla funzione\n\n**Restituisce:** Handle del task\n\n**Esempi:**\n```hemlock\n// Funzione semplice\nfn calcola(n: i32): i32 {\n    return n * n;\n}\n\nlet t = spawn(calcola, 42);\nlet risultato = join(t);       // 1764\n\n// Funzione con pi argomenti\nfn somma(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet t2 = spawn(somma, 10, 20);\nlet risultato2 = join(t2);     // 30\n\n// Spawn multipli per parallelismo\nlet t1 = spawn(calcola, 10);\nlet t2 = spawn(calcola, 20);\nlet t3 = spawn(calcola, 30);\n\nlet r1 = join(t1);  // 100\nlet r2 = join(t2);  // 400\nlet r3 = join(t3);  // 900\n```\n\n**Comportamento:**\n- Crea nuovo pthread\n- Inizia l'esecuzione immediatamente\n- Il task esegue concorrentemente con il chiamante\n- Gestisci il task con `join()` o `detach()`\n\n**Importante:** I task devono essere joinati o detachati per evitare leak di risorse.\n\n---\n\n### join\n\nAttende il completamento del task e ottiene il risultato.\n\n**Firma:**\n```hemlock\njoin(t: task): any\n```\n\n**Parametri:**\n- `t` - Handle del task da attendere\n\n**Restituisce:** Valore di ritorno della funzione del task\n\n**Esempi:**\n```hemlock\nfn lavoro(): i32 {\n    // Calcolo lungo...\n    return 42;\n}\n\nlet t = spawn(lavoro);\n// ... fai altro lavoro ...\nlet risultato = join(t);       // Attende, restituisce 42\n```\n\n**Comportamento:**\n- Si blocca finch il task non completa\n- Restituisce il valore di ritorno della funzione del task\n- Se il task ha lanciato un'eccezione, la rilancia nel chiamante\n- Pu essere chiamato una sola volta per task\n\n**Gestione Eccezioni:**\n```hemlock\nfn rischioso(): i32 {\n    throw \"fallimento\";\n}\n\nlet t = spawn(rischioso);\ntry {\n    let risultato = join(t);\n} catch (e) {\n    print(\"Task fallito:\", e);  // \"Task fallito: fallimento\"\n}\n```\n\n---\n\n### detach\n\nDetach un task per permettergli di eseguire indipendentemente.\n\n**Firma:**\n```hemlock\ndetach(t: task): null\n```\n\n**Parametri:**\n- `t` - Handle del task da detachare\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nfn lavoro_sfondo() {\n    // Lavoro di lunga durata...\n    print(\"Sfondo completato\");\n}\n\nlet t = spawn(lavoro_sfondo);\ndetach(t);  // Esegue indipendentemente\n\n// Il chiamante continua senza attendere\nprint(\"Continua...\");\n```\n\n**Comportamento:**\n- Il task esegue indipendentemente\n- Le risorse vengono pulite automaticamente quando completa\n- Non pu joinare dopo il detach\n- Il task potrebbe ancora essere in esecuzione quando il programma esce\n\n**Casi d'Uso:**\n- Operazioni fire-and-forget\n- Lavoro in background\n- Servizi di lunga durata\n\n---\n\n## Operazioni sui Canali\n\n### channel\n\nCrea un nuovo canale con buffer.\n\n**Firma:**\n```hemlock\nchannel(capacita?: i32): channel\n```\n\n**Parametri:**\n- `capacita` (opzionale) - Dimensione del buffer (predefinito: 0 per canale non bufferizzato)\n\n**Restituisce:** Nuovo canale\n\n**Esempi:**\n```hemlock\n// Canale non bufferizzato (capacit 0)\nlet ch_sync = channel();\nlet ch_sync2 = channel(0);\n\n// Canale bufferizzato\nlet ch_buf = channel(10);      // Pu contenere 10 elementi\n\nprint(ch_buf.capacity);        // 10\nprint(ch_buf.length);          // 0 (vuoto)\n```\n\n**Comportamento:**\n- Buffer circolare per elementi\n- Thread-safe (protetto da mutex)\n- Supporta pi mittenti e ricevitori\n\n---\n\n### send\n\nInvia un valore su un canale.\n\n**Firma:**\n```hemlock\nchannel.send(valore: any): null\n```\n\n**Parametri:**\n- `valore` - Valore da inviare\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nlet ch = channel(10);\n\n// Invia valori\nch.send(42);\nch.send(\"ciao\");\nch.send([1, 2, 3]);\n\nprint(ch.length);              // 3\n```\n\n**Comportamento:**\n- Aggiunge il valore al buffer del canale\n- Si blocca se il buffer  pieno (attende spazio)\n- Thread-safe\n\n**Pattern Produttore:**\n```hemlock\nfn produttore(ch: channel) {\n    let i = 0;\n    while (i < 10) {\n        ch.send(i);\n        i = i + 1;\n    }\n    ch.close();\n}\n\nlet ch = channel(5);\nlet t = spawn(produttore, ch);\n\n// Consuma...\n```\n\n---\n\n### recv\n\nRiceve un valore da un canale.\n\n**Firma:**\n```hemlock\nchannel.recv(): any\n```\n\n**Restituisce:** Valore ricevuto dal canale\n\n**Esempi:**\n```hemlock\nlet ch = channel(10);\n\nch.send(42);\nch.send(\"ciao\");\n\nlet val1 = ch.recv();          // 42\nlet val2 = ch.recv();          // \"ciao\"\n```\n\n**Comportamento:**\n- Rimuove e restituisce il valore pi vecchio dal buffer\n- Si blocca se il buffer  vuoto (attende dati)\n- Thread-safe\n- Restituisce `null` se il canale  chiuso e vuoto\n\n**Pattern Consumatore:**\n```hemlock\nfn consumatore(ch: channel) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null && ch.closed) {\n            break;\n        }\n        print(\"Ricevuto:\", val);\n    }\n}\n```\n\n---\n\n### close\n\nChiude un canale.\n\n**Firma:**\n```hemlock\nchannel.close(): null\n```\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nlet ch = channel(10);\nch.send(1);\nch.send(2);\nch.close();\n\nprint(ch.closed);              // true\n\n// Pu ancora ricevere valori esistenti\nlet val = ch.recv();           // 1\nlet val2 = ch.recv();          // 2\nlet val3 = ch.recv();          // null (canale chiuso e vuoto)\n\n// L'invio al canale chiuso genera errore\n// ch.send(3);                 // ERRORE\n```\n\n**Comportamento:**\n- Segna il canale come chiuso\n- Gli invii al canale chiuso generano errore\n- Le ricezioni possono ancora ottenere i valori esistenti\n- Le ricezioni restituiscono `null` quando chiuso e vuoto\n\n---\n\n## Propriet dei Canali\n\n### .length\n\nNumero di elementi attualmente nel buffer.\n\n**Tipo:** `i32`\n\n**Esempi:**\n```hemlock\nlet ch = channel(10);\nprint(ch.length);              // 0\n\nch.send(1);\nch.send(2);\nprint(ch.length);              // 2\n\nch.recv();\nprint(ch.length);              // 1\n```\n\n---\n\n### .capacity\n\nDimensione massima del buffer.\n\n**Tipo:** `i32`\n\n**Esempi:**\n```hemlock\nlet ch = channel(10);\nprint(ch.capacity);            // 10\n\nlet ch2 = channel();\nprint(ch2.capacity);           // 0\n```\n\n---\n\n### .closed\n\nSe il canale  chiuso.\n\n**Tipo:** `bool`\n\n**Esempi:**\n```hemlock\nlet ch = channel(10);\nprint(ch.closed);              // false\n\nch.close();\nprint(ch.closed);              // true\n```\n\n---\n\n## Funzioni Async\n\n### async fn\n\nDichiara una funzione asincrona.\n\n**Sintassi:**\n```hemlock\nasync fn nome(params): tipo_ritorno {\n    // corpo\n}\n```\n\n**Esempi:**\n```hemlock\nasync fn carica_dati(url: string): string {\n    // Operazione I/O simulata\n    let dati = http_get(url);\n    return dati;\n}\n\nasync fn calcola(n: i32): i32 {\n    // Calcolo CPU-bound\n    let risultato = 0;\n    let i = 0;\n    while (i < n) {\n        risultato = risultato + i;\n        i = i + 1;\n    }\n    return risultato;\n}\n```\n\n**Comportamento:**\n- Le funzioni async possono essere spawned come task\n- Restituiscono i loro valori normalmente\n- Le eccezioni si propagano al joiner\n\n---\n\n### await\n\nAttende il risultato di un task.\n\n**Firma:**\n```hemlock\nawait task: any\n```\n\n**Esempi:**\n```hemlock\nasync fn calcola(n: i32): i32 {\n    return n * n;\n}\n\nlet t = spawn(calcola, 42);\nlet risultato = await t;       // 1764\n\n// Equivalente a join()\nlet t2 = spawn(calcola, 10);\nlet risultato2 = join(t2);     // 100\n```\n\n**Comportamento:**\n- Identico a `join()`\n- Attende il completamento del task\n- Restituisce il risultato\n- Propaga le eccezioni\n\n---\n\n## Pattern di Utilizzo\n\n### Parallelismo Semplice\n\n```hemlock\nfn elabora(dati: array): array {\n    // Elaborazione pesante\n    return dati.map(fn(x) { return x * 2; });\n}\n\n// Elabora dataset in parallelo\nlet t1 = spawn(elabora, dati1);\nlet t2 = spawn(elabora, dati2);\nlet t3 = spawn(elabora, dati3);\n\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n### Pattern Produttore-Consumatore\n\n```hemlock\nfn produttore(ch: channel, conteggio: i32) {\n    let i = 0;\n    while (i < conteggio) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n}\n\nfn consumatore(ch: channel) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null && ch.closed) {\n            break;\n        }\n        print(\"Elaborato:\", val);\n    }\n}\n\nlet ch = channel(5);\nlet prod = spawn(produttore, ch, 10);\nlet cons = spawn(consumatore, ch);\n\njoin(prod);\njoin(cons);\n```\n\n### Pattern Worker Pool\n\n```hemlock\nfn worker(id: i32, lavori: channel, risultati: channel) {\n    while (true) {\n        let lavoro = lavori.recv();\n        if (lavoro == null && lavori.closed) {\n            break;\n        }\n\n        // Elabora lavoro\n        let risultato = lavoro * lavoro;\n        risultati.send({ worker_id: id, risultato: risultato });\n    }\n}\n\n// Crea canali\nlet lavori = channel(100);\nlet risultati = channel(100);\n\n// Crea worker\nlet worker1 = spawn(worker, 1, lavori, risultati);\nlet worker2 = spawn(worker, 2, lavori, risultati);\nlet worker3 = spawn(worker, 3, lavori, risultati);\n\n// Invia lavori\nlet i = 0;\nwhile (i < 10) {\n    lavori.send(i);\n    i = i + 1;\n}\nlavori.close();\n\n// Raccogli risultati\nlet conteggio = 0;\nwhile (conteggio < 10) {\n    let r = risultati.recv();\n    print(\"Worker\", r.worker_id, \":\", r.risultato);\n    conteggio = conteggio + 1;\n}\n\n// Pulisci\njoin(worker1);\njoin(worker2);\njoin(worker3);\n```\n\n### Pattern Fan-Out/Fan-In\n\n```hemlock\nfn worker(lavoro: i32): i32 {\n    return lavoro * lavoro;\n}\n\n// Fan-out: spawna pi task\nlet task = [];\nlet i = 0;\nwhile (i < 10) {\n    task.push(spawn(worker, i));\n    i = i + 1;\n}\n\n// Fan-in: raccogli risultati\nlet risultati = [];\ni = 0;\nwhile (i < task.length) {\n    risultati.push(join(task[i]));\n    i = i + 1;\n}\n\nprint(risultati);  // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n### Gestione delle Eccezioni nei Task\n\n```hemlock\nfn lavoro_rischioso(): i32 {\n    if (random() < 0.5) {\n        throw \"operazione fallita\";\n    }\n    return 42;\n}\n\nlet t = spawn(lavoro_rischioso);\n\ntry {\n    let risultato = join(t);\n    print(\"Successo:\", risultato);\n} catch (e) {\n    print(\"Task fallito:\", e);\n}\n```\n\n### Modello di Timeout\n\n```hemlock\n// Nota: Questo  un pattern concettuale\n// L'implementazione effettiva pu variare\n\nfn lavoro_lungo(): i32 {\n    sleep(5000);  // 5 secondi\n    return 42;\n}\n\nfn timeout_wrapper(func: function, timeout_ms: i32): any {\n    let ch = channel(1);\n\n    let worker = spawn(fn() {\n        let risultato = func();\n        ch.send(risultato);\n    });\n\n    // Attendi con timeout (concettuale)\n    sleep(timeout_ms);\n    if (ch.length == 0) {\n        throw \"operazione in timeout\";\n    }\n\n    return ch.recv();\n}\n```\n\n---\n\n## Considerazioni sulla Sicurezza dei Thread\n\n### Condivisione Dati\n\n**Primitivi:** Passati per valore (sicuro)\n```hemlock\nlet x = 42;\nlet t = spawn(fn() {\n    print(x);  // Copia di x\n});\n```\n\n**Oggetti/Array:** Passati per riferimento (usare cautela)\n```hemlock\nlet arr = [1, 2, 3];\nlet t = spawn(fn() {\n    // Condivide lo stesso array!\n    arr.push(4);  // Potenziale race condition\n});\n```\n\n**Canali:** Comunicazione thread-safe\n```hemlock\n// Passa dati tramite canali invece della memoria condivisa\nlet ch = channel(10);\n\nlet t = spawn(fn() {\n    while (true) {\n        let dati = ch.recv();\n        if (dati == null) { break; }\n        elabora(dati);\n    }\n});\n\nch.send({ x: 10, y: 20 });\n```\n\n### Best Practice\n\n**1. Preferisci i Canali**\n```hemlock\n// BENE: Comunica tramite canali\nlet ch = channel(10);\nlet t = spawn(worker, ch);\nch.send(dati);\n```\n\n**2. Evita la Memoria Condivisa**\n```hemlock\n// MALE: Accesso condiviso all'array\nlet risultati = [];\nlet t1 = spawn(fn() { risultati.push(1); });\nlet t2 = spawn(fn() { risultati.push(2); });\n\n// BENE: Ogni task ha il proprio spazio, merge dopo\nlet t1 = spawn(fn() { return [1]; });\nlet t2 = spawn(fn() { return [2]; });\nlet risultati = join(t1).concat(join(t2));\n```\n\n**3. Joina Sempre i Task**\n```hemlock\n// BENE: Pulizia appropriata\nlet t = spawn(lavoro);\nlet risultato = join(t);\n\n// O detach se  fire-and-forget\nlet t2 = spawn(sfondo);\ndetach(t2);\n```\n\n---\n\n## Riepilogo Completo delle Funzioni\n\n### Funzioni\n\n| Funzione  | Firma                          | Restituisce | Descrizione              |\n|-----------|--------------------------------|-------------|--------------------------|\n| `spawn`   | `(func, ...args)`              | `task`      | Crea nuovo task          |\n| `join`    | `(t: task)`                    | `any`       | Attende risultato task   |\n| `detach`  | `(t: task)`                    | `null`      | Detach task              |\n| `channel` | `(capacita?: i32)`             | `channel`   | Crea canale              |\n\n### Metodi dei Canali\n\n| Metodo    | Firma                | Restituisce | Descrizione              |\n|-----------|----------------------|-------------|--------------------------|\n| `send`    | `(valore: any)`      | `null`      | Invia valore             |\n| `recv`    | `()`                 | `any`       | Riceve valore            |\n| `close`   | `()`                 | `null`      | Chiude canale            |\n\n### Propriet dei Canali\n\n| Propriet   | Tipo   | Descrizione                |\n|-------------|--------|----------------------------|\n| `.length`   | `i32`  | Elementi nel buffer        |\n| `.capacity` | `i32`  | Dimensione massima buffer  |\n| `.closed`   | `bool` | Se chiuso                  |\n\n---\n\n## Vedi Anche\n\n- [Sistema di Tipi](#reference-type-system) - Tipi task e channel\n- [Funzioni Integrate](#reference-builtins) - Funzioni spawn, join, detach\n- [Gestione delle Eccezioni](#language-guide-exceptions) - Propagazione eccezioni\n"}, "Riferimento API -> Funzioni Integrate": {"id": "reference-builtins", "content": "# Riferimento delle Funzioni Integrate\n\nRiferimento completo per le funzioni e costanti integrate di Hemlock.\n\n---\n\n## Panoramica\n\nHemlock fornisce un insieme di funzioni integrate sempre disponibili nel scope globale. Queste funzioni coprono I/O, gestione della memoria, introspezione dei tipi, concorrenza e utilit di sistema.\n\n---\n\n## Funzioni di I/O\n\n### print\n\nStampa valori sullo standard output.\n\n**Firma:**\n```hemlock\nprint(...valori: any): null\n```\n\n**Parametri:**\n- `valori` - Uno o pi valori da stampare\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nprint(\"Ciao, Mondo!\");\nprint(42);\nprint(\"x =\", 10, \"y =\", 20);\nprint([1, 2, 3]);\nprint({ nome: \"Alice\" });\n```\n\n**Comportamento:**\n- Converte tutti i valori in stringhe\n- Separa pi valori con spazi\n- Aggiunge newline alla fine\n\n---\n\n### eprint\n\nStampa valori sullo standard error.\n\n**Firma:**\n```hemlock\neprint(...valori: any): null\n```\n\n**Parametri:**\n- `valori` - Uno o pi valori da stampare\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\neprint(\"Errore: qualcosa non va\");\neprint(\"Attenzione:\", errore_msg);\n```\n\n**Comportamento:**\n- Identico a `print()` ma scrive su stderr\n- Utile per messaggi di errore e diagnostica\n\n---\n\n### read_line\n\nLegge una riga dallo standard input.\n\n**Firma:**\n```hemlock\nread_line(): string?\n```\n\n**Restituisce:** Stringa con la riga di input, o `null` a EOF\n\n**Esempi:**\n```hemlock\nprint(\"Inserisci il tuo nome:\");\nlet nome = read_line();\nprint(\"Ciao,\", nome);\n\n// Gestisci EOF\nwhile (true) {\n    let riga = read_line();\n    if (riga == null) { break; }\n    print(\"Ricevuto:\", riga);\n}\n```\n\n**Comportamento:**\n- Si blocca finch non  disponibile input\n- Rimuove il newline finale\n- Restituisce `null` a fine file\n\n---\n\n### open\n\nApre un file per lettura/scrittura.\n\n**Firma:**\n```hemlock\nopen(percorso: string, modalita?: string): file\n```\n\n**Parametri:**\n- `percorso` - Percorso del file\n- `modalita` (opzionale) - Modalit di apertura (predefinito: `\"r\"`)\n\n**Modalit:**\n- `\"r\"` - Lettura\n- `\"w\"` - Scrittura (tronca)\n- `\"a\"` - Append\n- `\"r+\"` - Lettura e scrittura\n- `\"w+\"` - Lettura e scrittura (tronca)\n- `\"a+\"` - Lettura e append\n\n**Restituisce:** Oggetto file\n\n**Esempi:**\n```hemlock\nlet f = open(\"dati.txt\", \"r\");\nlet contenuto = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(\"Ciao!\");\nf2.close();\n```\n\n**Vedi Anche:** [API dei File](#reference-file-api)\n\n---\n\n## Funzioni di Memoria\n\n### alloc\n\nAlloca memoria grezza.\n\n**Firma:**\n```hemlock\nalloc(dimensione: i32): ptr\n```\n\n**Parametri:**\n- `dimensione` - Numero di byte da allocare\n\n**Restituisce:** Puntatore alla memoria allocata\n\n**Esempi:**\n```hemlock\nlet p = alloc(1024);\nmemset(p, 0, 1024);\nfree(p);\n```\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n### buffer\n\nAlloca buffer sicuro con controllo dei limiti.\n\n**Firma:**\n```hemlock\nbuffer(dimensione: i32): buffer\n```\n\n**Parametri:**\n- `dimensione` - Dimensione del buffer in byte\n\n**Restituisce:** Oggetto buffer\n\n**Esempi:**\n```hemlock\nlet buf = buffer(256);\nbuf[0] = 65;\nprint(buf.length);\nfree(buf);\n```\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n### free\n\nLibera memoria allocata.\n\n**Firma:**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Parametri:**\n- `ptr` - Puntatore o buffer da liberare\n\n**Restituisce:** `null`\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n### realloc\n\nRidimensiona memoria allocata.\n\n**Firma:**\n```hemlock\nrealloc(ptr: ptr, nuova_dimensione: i32): ptr\n```\n\n**Parametri:**\n- `ptr` - Puntatore da ridimensionare\n- `nuova_dimensione` - Nuova dimensione in byte\n\n**Restituisce:** Puntatore alla memoria ridimensionata\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n### memset\n\nRiempie la memoria con un valore byte.\n\n**Firma:**\n```hemlock\nmemset(ptr: ptr, byte: i32, dimensione: i32): null\n```\n\n**Parametri:**\n- `ptr` - Puntatore alla memoria\n- `byte` - Valore byte (0-255)\n- `dimensione` - Numero di byte\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n### memcpy\n\nCopia memoria.\n\n**Firma:**\n```hemlock\nmemcpy(dest: ptr, src: ptr, dimensione: i32): null\n```\n\n**Parametri:**\n- `dest` - Puntatore destinazione\n- `src` - Puntatore sorgente\n- `dimensione` - Numero di byte da copiare\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n### sizeof\n\nOttiene la dimensione di un tipo in byte.\n\n**Firma:**\n```hemlock\nsizeof(tipo): i32\n```\n\n**Parametri:**\n- `tipo` - Identificatore di tipo\n\n**Restituisce:** Dimensione in byte\n\n**Esempi:**\n```hemlock\nprint(sizeof(i32));         // 4\nprint(sizeof(f64));         // 8\nprint(sizeof(ptr));         // 8\n```\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n### talloc\n\nAlloca array tipizzato.\n\n**Firma:**\n```hemlock\ntalloc(tipo, conteggio: i32): ptr\n```\n\n**Parametri:**\n- `tipo` - Tipo di elemento\n- `conteggio` - Numero di elementi\n\n**Restituisce:** Puntatore all'array allocato\n\n**Esempi:**\n```hemlock\nlet arr = talloc(i32, 100);    // 400 byte\nfree(arr);\n```\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api)\n\n---\n\n## Funzioni di Introspezione dei Tipi\n\n### typeof\n\nOttiene il nome del tipo come stringa.\n\n**Firma:**\n```hemlock\ntypeof(valore: any): string\n```\n\n**Parametri:**\n- `valore` - Qualsiasi valore\n\n**Restituisce:** Stringa del nome del tipo\n\n**Esempi:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"ciao\"));          // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\nprint(typeof(null));            // \"null\"\n\ndefine Persona { nome: string }\nlet p: Persona = { nome: \"Alice\" };\nprint(typeof(p));               // \"Persona\"\n```\n\n**Valori Restituiti:**\n- Tipi primitivi: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Tipi composti: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Tipi speciali: `\"file\"`, `\"task\"`, `\"channel\"`\n- Oggetti tipizzati: Nome del tipo personalizzato\n\n---\n\n### len\n\nOttiene la lunghezza di una stringa o array.\n\n**Firma:**\n```hemlock\nlen(valore: string | array): i32\n```\n\n**Parametri:**\n- `valore` - Stringa o array\n\n**Restituisce:** Numero di elementi/caratteri\n\n**Esempi:**\n```hemlock\nprint(len(\"ciao\"));             // 5\nprint(len([1, 2, 3]));          // 3\nprint(len([]));                 // 0\n```\n\n---\n\n## Funzioni di Asserzione\n\n### assert\n\nAsserisce che una condizione  vera.\n\n**Firma:**\n```hemlock\nassert(condizione: bool, messaggio?: string): null\n```\n\n**Parametri:**\n- `condizione` - Condizione da verificare\n- `messaggio` (opzionale) - Messaggio di errore se fallisce\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nassert(x > 0);\nassert(x > 0, \"x deve essere positivo\");\nassert(utente != null, \"utente non trovato\");\n```\n\n**Comportamento:**\n- Non fa nulla se la condizione  vera\n- Esce con errore se la condizione  falsa\n\n---\n\n### panic\n\nTermina il programma con messaggio di errore.\n\n**Firma:**\n```hemlock\npanic(messaggio: string): never\n```\n\n**Parametri:**\n- `messaggio` - Messaggio di errore\n\n**Restituisce:** Non ritorna mai (termina il programma)\n\n**Esempi:**\n```hemlock\nif (ptr == null) {\n    panic(\"allocazione fallita\");\n}\n\npanic(\"errore irrecuperabile\");\n```\n\n**Comportamento:**\n- Stampa messaggio su stderr\n- Esce con codice di stato non-zero\n- Non pu essere catturato da try/catch\n\n---\n\n## Funzioni di Concorrenza\n\n### spawn\n\nCrea un nuovo task concorrente.\n\n**Firma:**\n```hemlock\nspawn(func: function, ...args): task\n```\n\n**Parametri:**\n- `func` - Funzione da eseguire\n- `args` - Argomenti per la funzione\n\n**Restituisce:** Handle del task\n\n**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)\n\n---\n\n### join\n\nAttende il completamento del task.\n\n**Firma:**\n```hemlock\njoin(t: task): any\n```\n\n**Parametri:**\n- `t` - Handle del task\n\n**Restituisce:** Risultato del task\n\n**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)\n\n---\n\n### detach\n\nEsegue il task in modo indipendente.\n\n**Firma:**\n```hemlock\ndetach(t: task): null\n```\n\n**Parametri:**\n- `t` - Handle del task\n\n**Restituisce:** `null`\n\n**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)\n\n---\n\n### channel\n\nCrea un canale di comunicazione.\n\n**Firma:**\n```hemlock\nchannel(capacita?: i32): channel\n```\n\n**Parametri:**\n- `capacita` (opzionale) - Dimensione del buffer (predefinito: 0)\n\n**Restituisce:** Nuovo canale\n\n**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)\n\n---\n\n## Funzioni di Sistema\n\n### exec\n\nEsegue un comando shell.\n\n**Firma:**\n```hemlock\nexec(comando: string): { stdout: string, stderr: string, code: i32 }\n```\n\n**Parametri:**\n- `comando` - Comando da eseguire\n\n**Restituisce:** Oggetto con stdout, stderr e codice di uscita\n\n**Esempi:**\n```hemlock\nlet risultato = exec(\"ls -la\");\nprint(risultato.stdout);\nprint(risultato.code);           // 0 se successo\n\nlet risultato2 = exec(\"comando_inesistente\");\nprint(risultato2.stderr);\nprint(risultato2.code);          // Non-zero se fallimento\n```\n\n---\n\n### sleep\n\nMette in pausa l'esecuzione.\n\n**Firma:**\n```hemlock\nsleep(ms: i32): null\n```\n\n**Parametri:**\n- `ms` - Millisecondi di pausa\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nprint(\"Aspetta...\");\nsleep(1000);                     // 1 secondo\nprint(\"Fatto!\");\n```\n\n---\n\n### exit\n\nTermina il programma con codice di stato.\n\n**Firma:**\n```hemlock\nexit(codice?: i32): never\n```\n\n**Parametri:**\n- `codice` (opzionale) - Codice di uscita (predefinito: 0)\n\n**Restituisce:** Non ritorna mai\n\n**Esempi:**\n```hemlock\nif (errore) {\n    exit(1);\n}\nexit(0);  // Successo\n```\n\n---\n\n### time_ms\n\nOttiene il tempo corrente in millisecondi.\n\n**Firma:**\n```hemlock\ntime_ms(): i64\n```\n\n**Restituisce:** Timestamp Unix in millisecondi\n\n**Esempi:**\n```hemlock\nlet inizio = time_ms();\n// ... fai lavoro ...\nlet fine = time_ms();\nprint(\"Tempo impiegato:\", fine - inizio, \"ms\");\n```\n\n---\n\n## Funzioni per i Segnali\n\n### signal\n\nRegistra un handler per un segnale.\n\n**Firma:**\n```hemlock\nsignal(sig: i32, handler: function): null\n```\n\n**Parametri:**\n- `sig` - Numero del segnale\n- `handler` - Funzione da chiamare al segnale\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nsignal(SIGINT, fn(sig) {\n    print(\"Interrotto!\");\n    exit(0);\n});\n```\n\n**Segnali Comuni:**\n- `SIGINT` (2) - Interrupt\n- `SIGTERM` (15) - Terminazione\n- `SIGUSR1` (10) - User-defined 1\n- `SIGUSR2` (12) - User-defined 2\n\n---\n\n### raise\n\nInvia un segnale al processo corrente.\n\n**Firma:**\n```hemlock\nraise(sig: i32): null\n```\n\n**Parametri:**\n- `sig` - Numero del segnale\n\n**Restituisce:** `null`\n\n**Esempi:**\n```hemlock\nraise(SIGUSR1);\n```\n\n---\n\n## Funzioni FFI\n\n### dlopen\n\nApre una libreria condivisa.\n\n**Firma:**\n```hemlock\ndlopen(percorso: string): ptr\n```\n\n**Parametri:**\n- `percorso` - Percorso alla libreria condivisa\n\n**Restituisce:** Handle alla libreria\n\n---\n\n### dlsym\n\nOttiene un simbolo da una libreria.\n\n**Firma:**\n```hemlock\ndlsym(lib: ptr, nome: string): ptr\n```\n\n**Parametri:**\n- `lib` - Handle alla libreria\n- `nome` - Nome del simbolo\n\n**Restituisce:** Puntatore al simbolo\n\n---\n\n### dlcall\n\nChiama una funzione esterna.\n\n**Firma:**\n```hemlock\ndlcall(func: ptr, ...args): any\n```\n\n**Parametri:**\n- `func` - Puntatore alla funzione\n- `args` - Argomenti per la funzione\n\n**Restituisce:** Valore di ritorno della funzione\n\n---\n\n### dlclose\n\nChiude una libreria condivisa.\n\n**Firma:**\n```hemlock\ndlclose(lib: ptr): null\n```\n\n**Parametri:**\n- `lib` - Handle alla libreria\n\n**Restituisce:** `null`\n\n---\n\n## Funzioni di Conversione dei Tipi\n\n### i32, i64, f64, bool, ecc.\n\nConverte valori o analizza stringhe.\n\n**Firma:**\n```hemlock\ni32(valore: any): i32\ni64(valore: any): i64\nf64(valore: any): f64\nbool(valore: any): bool\n// ... altri tipi\n```\n\n**Parametri:**\n- `valore` - Valore da convertire o stringa da analizzare\n\n**Restituisce:** Valore convertito\n\n**Esempi:**\n```hemlock\nlet n = i32(\"42\");              // 42\nlet f = f64(\"3.14\");            // 3.14\nlet b = bool(\"true\");           // true\n\nlet hex = i32(\"0xFF\");          // 255\nlet neg = i32(\"-42\");           // -42\n\n// Conversioni tra tipi\nlet grande = i64(42);           // i32 a i64\nlet troncato = i32(3.99);       // f64 a i32 (tronca a 3)\n```\n\n---\n\n## Costanti\n\n### Costanti Booleane\n\n| Costante | Tipo   | Valore |\n|----------|--------|--------|\n| `true`   | `bool` | Vero   |\n| `false`  | `bool` | Falso  |\n| `null`   | `null` | Nessun valore |\n\n### Costanti dei Segnali\n\n| Costante   | Valore | Descrizione     |\n|------------|--------|-----------------|\n| `SIGINT`   | 2      | Interrupt       |\n| `SIGTERM`  | 15     | Terminazione    |\n| `SIGUSR1`  | 10     | User-defined 1  |\n| `SIGUSR2`  | 12     | User-defined 2  |\n\n---\n\n## Riepilogo Completo delle Funzioni\n\n### I/O\n\n| Funzione    | Descrizione                    |\n|-------------|--------------------------------|\n| `print`     | Stampa su stdout               |\n| `eprint`    | Stampa su stderr               |\n| `read_line` | Legge riga da stdin            |\n| `open`      | Apre file                      |\n\n### Memoria\n\n| Funzione  | Descrizione                    |\n|-----------|--------------------------------|\n| `alloc`   | Alloca memoria grezza          |\n| `buffer`  | Alloca buffer sicuro           |\n| `free`    | Libera memoria                 |\n| `realloc` | Ridimensiona memoria           |\n| `memset`  | Riempie memoria                |\n| `memcpy`  | Copia memoria                  |\n| `sizeof`  | Dimensione tipo                |\n| `talloc`  | Alloca array tipizzato         |\n\n### Tipi\n\n| Funzione | Descrizione                    |\n|----------|--------------------------------|\n| `typeof` | Ottiene nome tipo              |\n| `len`    | Ottiene lunghezza              |\n\n### Asserzione\n\n| Funzione | Descrizione                    |\n|----------|--------------------------------|\n| `assert` | Verifica condizione            |\n| `panic`  | Termina con errore             |\n\n### Concorrenza\n\n| Funzione  | Descrizione                    |\n|-----------|--------------------------------|\n| `spawn`   | Crea task                      |\n| `join`    | Attende task                   |\n| `detach`  | Detach task                    |\n| `channel` | Crea canale                    |\n\n### Sistema\n\n| Funzione  | Descrizione                    |\n|-----------|--------------------------------|\n| `exec`    | Esegue comando                 |\n| `sleep`   | Pausa esecuzione               |\n| `exit`    | Termina programma              |\n| `time_ms` | Ottiene tempo                  |\n\n### Segnali\n\n| Funzione | Descrizione                    |\n|----------|--------------------------------|\n| `signal` | Registra handler               |\n| `raise`  | Invia segnale                  |\n\n### FFI\n\n| Funzione  | Descrizione                    |\n|-----------|--------------------------------|\n| `dlopen`  | Apre libreria                  |\n| `dlsym`   | Ottiene simbolo                |\n| `dlcall`  | Chiama funzione                |\n| `dlclose` | Chiude libreria                |\n\n---\n\n## Vedi Anche\n\n- [API della Memoria](#reference-memory-api) - Dettagli gestione memoria\n- [API dei File](#reference-file-api) - Dettagli I/O su file\n- [API di Concorrenza](#reference-concurrency-api) - Dettagli threading\n- [Sistema di Tipi](#reference-type-system) - Informazioni sui tipi\n"}, "Riferimento API -> Operatori": {"id": "reference-operators", "content": "# Riferimento degli Operatori\n\nRiferimento completo per gli operatori di Hemlock, la precedenza e il comportamento dei tipi.\n\n---\n\n## Panoramica\n\nHemlock fornisce un insieme completo di operatori per aritmetica, confronto, logica e manipolazione bit a bit. Gli operatori seguono la sintassi in stile C con regole di precedenza chiare.\n\n**Caratteristiche Principali:**\n- Sintassi familiare in stile C\n- Promozione automatica dei tipi nelle operazioni miste\n- Operatori bit a bit per manipolazione interi\n- Controllo preciso della precedenza\n\n---\n\n## Operatori Aritmetici\n\n### Aritmetica Base\n\n| Operatore | Nome | Esempio | Risultato |\n|-----------|------|---------|-----------|\n| `+` | Addizione | `5 + 3` | `8` |\n| `-` | Sottrazione | `5 - 3` | `2` |\n| `*` | Moltiplicazione | `5 * 3` | `15` |\n| `/` | Divisione | `5 / 2` | `2.5` |\n| `%` | Modulo | `5 % 3` | `2` |\n\n**Esempi:**\n```hemlock\n// Aritmetica intera\nlet a = 10 + 5;     // 15\nlet b = 10 - 5;     // 5\nlet c = 10 * 5;     // 50\nlet d = 10 / 3;     // 3.333... (sempre float)\nlet e = 10 % 3;     // 1\n\n// Aritmetica float\nlet f = 3.14 + 2.0; // 5.14\nlet g = 10.0 / 4.0; // 2.5\n\n// Aritmetica mista\nlet h = 10 + 2.5;   // 12.5 (promosso a float)\n```\n\n### Divisione Intera\n\nL'operatore `/` restituisce sempre un float. Per la divisione intera, usa `divi()`:\n\n```hemlock\nlet a = 10 / 3;         // 3.333...\nlet b = divi(10, 3);    // 3 (troncato)\n\n// Oppure usa conversione esplicita\nlet c: i32 = 10 / 3;    // 3 (troncato via annotazione di tipo)\n```\n\n### Negazione Unaria\n\n| Operatore | Nome | Esempio | Risultato |\n|-----------|------|---------|-----------|\n| `-` | Negazione | `-5` | `-5` |\n\n```hemlock\nlet x = 5;\nlet y = -x;         // -5\nlet z = --x;        // 5 (doppia negazione)\n```\n\n---\n\n## Operatori di Incremento/Decremento\n\n| Operatore | Nome | Esempio | Descrizione |\n|-----------|------|---------|-------------|\n| `++` | Pre-incremento | `++x` | Incrementa x, restituisce nuovo valore |\n| `++` | Post-incremento | `x++` | Restituisce valore corrente, poi incrementa |\n| `--` | Pre-decremento | `--x` | Decrementa x, restituisce nuovo valore |\n| `--` | Post-decremento | `x--` | Restituisce valore corrente, poi decrementa |\n\n**Esempi:**\n```hemlock\nlet x = 5;\n\n// Pre-incremento\nlet a = ++x;        // x = 6, a = 6\n\n// Post-incremento\nlet b = x++;        // b = 6, x = 7\n\n// Pre-decremento\nlet c = --x;        // x = 6, c = 6\n\n// Post-decremento\nlet d = x--;        // d = 6, x = 5\n```\n\n---\n\n## Operatori di Confronto\n\n| Operatore | Nome | Esempio | Risultato |\n|-----------|------|---------|-----------|\n| `==` | Uguale a | `5 == 5` | `true` |\n| `!=` | Diverso da | `5 != 3` | `true` |\n| `<` | Minore di | `3 < 5` | `true` |\n| `>` | Maggiore di | `5 > 3` | `true` |\n| `<=` | Minore o uguale | `3 <= 3` | `true` |\n| `>=` | Maggiore o uguale | `5 >= 5` | `true` |\n\n**Esempi:**\n```hemlock\n// Confronto numeri\nprint(5 == 5);      // true\nprint(5 != 3);      // true\nprint(3 < 5);       // true\nprint(5 > 3);       // true\nprint(3 <= 3);      // true\nprint(5 >= 5);      // true\n\n// Confronto stringhe\nprint(\"abc\" == \"abc\");  // true\nprint(\"abc\" < \"abd\");   // true (lessicografico)\n\n// Confronto tipi misti\nprint(5 == 5.0);    // true (promosso a float)\nprint(5 != \"5\");    // true (tipi diversi)\n```\n\n---\n\n## Operatori Logici\n\n| Operatore | Nome | Esempio | Risultato |\n|-----------|------|---------|-----------|\n| `&&` | AND logico | `true && false` | `false` |\n| `\\|\\|` | OR logico | `true \\|\\| false` | `true` |\n| `!` | NOT logico | `!true` | `false` |\n\n**Esempi:**\n```hemlock\n// Operazioni booleane\nprint(true && true);    // true\nprint(true && false);   // false\nprint(true || false);   // true\nprint(false || false);  // false\nprint(!true);           // false\nprint(!false);          // true\n\n// Valutazione cortocircuito\nlet x = false && costoso();  // costoso() non viene chiamata\nlet y = true || costoso();   // costoso() non viene chiamata\n```\n\n### Valutazione Cortocircuito\n\n`&&` e `||` usano la valutazione cortocircuito:\n\n```hemlock\n// AND: si ferma al primo false\nlet risultato = a() && b() && c();\n// Se a() restituisce false, b() e c() non sono valutate\n\n// OR: si ferma al primo true\nlet risultato = a() || b() || c();\n// Se a() restituisce true, b() e c() non sono valutate\n```\n\n---\n\n## Operatori Bit a Bit\n\n| Operatore | Nome | Esempio | Risultato |\n|-----------|------|---------|-----------|\n| `&` | AND bit a bit | `5 & 3` | `1` |\n| `\\|` | OR bit a bit | `5 \\| 3` | `7` |\n| `^` | XOR bit a bit | `5 ^ 3` | `6` |\n| `~` | NOT bit a bit | `~5` | `-6` |\n| `<<` | Shift sinistra | `5 << 2` | `20` |\n| `>>` | Shift destra | `20 >> 2` | `5` |\n\n**Esempi:**\n```hemlock\n// AND: 0101 & 0011 = 0001\nprint(5 & 3);           // 1\n\n// OR: 0101 | 0011 = 0111\nprint(5 | 3);           // 7\n\n// XOR: 0101 ^ 0011 = 0110\nprint(5 ^ 3);           // 6\n\n// NOT: ~0101 = ...1010 (complemento a due)\nprint(~5);              // -6\n\n// Shift sinistra: 0101 << 2 = 10100\nprint(5 << 2);          // 20\n\n// Shift destra: 10100 >> 2 = 00101\nprint(20 >> 2);         // 5\n```\n\n### Tecniche Bit a Bit\n\n```hemlock\n// Impostare un bit\nlet flag = 1 << 3;          // Bit 3: 0b1000 = 8\n\n// Verificare un bit\nlet ha_bit = (valore & flag) != 0;\n\n// Pulire un bit\nlet pulito = valore & ~flag;\n\n// Attivare/disattivare un bit\nlet attivato = valore ^ flag;\n\n// Verifica potenza di 2\nlet e_pot2 = n != 0 && (n & (n - 1)) == 0;\n```\n\n---\n\n## Operatori di Assegnazione\n\n### Assegnazione Semplice\n\n| Operatore | Nome | Esempio | Equivalente |\n|-----------|------|---------|-------------|\n| `=` | Assegnazione | `x = 5` | - |\n\n### Assegnazione Composta\n\n| Operatore | Nome | Esempio | Equivalente |\n|-----------|------|---------|-------------|\n| `+=` | Addizione assegnazione | `x += 5` | `x = x + 5` |\n| `-=` | Sottrazione assegnazione | `x -= 5` | `x = x - 5` |\n| `*=` | Moltiplicazione assegnazione | `x *= 5` | `x = x * 5` |\n| `/=` | Divisione assegnazione | `x /= 5` | `x = x / 5` |\n| `%=` | Modulo assegnazione | `x %= 5` | `x = x % 5` |\n| `&=` | AND assegnazione | `x &= 5` | `x = x & 5` |\n| `\\|=` | OR assegnazione | `x \\|= 5` | `x = x \\| 5` |\n| `^=` | XOR assegnazione | `x ^= 5` | `x = x ^ 5` |\n| `<<=` | Shift sinistra assegnazione | `x <<= 2` | `x = x << 2` |\n| `>>=` | Shift destra assegnazione | `x >>= 2` | `x = x >> 2` |\n\n**Esempi:**\n```hemlock\nlet x = 10;\nx += 5;         // x = 15\nx -= 3;         // x = 12\nx *= 2;         // x = 24\nx /= 4;         // x = 6.0\nx %= 4;         // x = 2\n\nlet flags = 0;\nflags |= 0b0100;    // Imposta bit 2\nflags &= ~0b0010;   // Pulisci bit 1\nflags ^= 0b1000;    // Attiva bit 3\n```\n\n---\n\n## Operatore Ternario\n\n| Operatore | Nome | Esempio | Risultato |\n|-----------|------|---------|-----------|\n| `? :` | Condizionale | `x > 0 ? \"pos\" : \"non-pos\"` | Dipende da x |\n\n**Esempi:**\n```hemlock\nlet x = 5;\nlet segno = x > 0 ? \"positivo\" : \"non-positivo\";\nprint(segno);       // \"positivo\"\n\n// Ternario annidato\nlet categoria = x > 10 ? \"grande\" :\n                x > 5 ? \"medio\" : \"piccolo\";\n\n// Come espressione\nprint(x % 2 == 0 ? \"pari\" : \"dispari\");\n```\n\n---\n\n## Concatenazione di Stringhe\n\n| Operatore | Nome | Esempio | Risultato |\n|-----------|------|---------|-----------|\n| `+` | Concatenazione | `\"ciao\" + \" mondo\"` | `\"ciao mondo\"` |\n\n**Esempi:**\n```hemlock\nlet saluto = \"Ciao\" + \" \" + \"Mondo\";\nprint(saluto);      // \"Ciao Mondo\"\n\n// Stringa + Rune\nlet msg = \"Fatto\" + '!';\nprint(msg);         // \"Fatto!\"\n\n// Stringa + altri tipi (conversione automatica)\nlet conteggio = \"Totale: \" + 42;\nprint(conteggio);   // \"Totale: 42\"\n```\n\n---\n\n## Operatori di Accesso\n\n### Accesso ad Array\n\n| Operatore | Nome | Esempio | Descrizione |\n|-----------|------|---------|-------------|\n| `[]` | Indicizzazione | `arr[0]` | Ottiene elemento all'indice |\n\n**Esempi:**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);      // 10\narr[1] = 25;        // Modifica elemento\nprint(arr[1]);      // 25\n```\n\n### Accesso a Campi\n\n| Operatore | Nome | Esempio | Descrizione |\n|-----------|------|---------|-------------|\n| `.` | Accesso campo | `obj.campo` | Ottiene propriet dell'oggetto |\n\n**Esempi:**\n```hemlock\nlet persona = { nome: \"Alice\", eta: 30 };\nprint(persona.nome);    // \"Alice\"\npersona.eta = 31;       // Modifica campo\n```\n\n### Chiamata di Funzione\n\n| Operatore | Nome | Esempio | Descrizione |\n|-----------|------|---------|-------------|\n| `()` | Chiamata | `func(a, b)` | Chiama funzione con argomenti |\n\n**Esempi:**\n```hemlock\nfn somma(a, b) {\n    return a + b;\n}\nprint(somma(3, 4));     // 7\n\n// Chiamata di metodo\nlet s = \"ciao\";\nprint(s.to_upper());    // \"CIAO\"\n```\n\n---\n\n## Operatori Null-Coalescing\n\n| Operatore | Nome | Esempio | Descrizione |\n|-----------|------|---------|-------------|\n| `??` | Null coalescing | `a ?? b` | Restituisce a se non-null, altrimenti b |\n| `??=` | Null assegnazione | `a ??= b` | Assegna b ad a solo se a  null |\n| `?.` | Navigazione sicura | `obj?.campo` | Restituisce null se obj  null |\n\n**Esempi:**\n```hemlock\n// Null coalescing\nlet nome = utente.nome ?? \"Anonimo\";\nlet primo = a ?? b ?? c ?? \"predefinito\";\n\n// Assegnazione null coalescing\nlet config = null;\nconfig ??= { timeout: 30 };     // config ora  { timeout: 30 }\nconfig ??= { timeout: 60 };     // config invariato (non null)\n\n// Navigazione sicura\nlet citta = utente?.indirizzo?.citta;  // null se qualsiasi parte  null\nlet maiusc = nome?.to_upper();          // chiamata metodo sicura\nlet elem = arr?.[0];                    // indicizzazione sicura\n```\n\n---\n\n## Precedenza degli Operatori\n\nDalla precedenza pi bassa a quella pi alta:\n\n| Livello | Operatori | Associativit | Descrizione |\n|---------|-----------|---------------|-------------|\n| 1 | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `\\|=`, `^=`, `<<=`, `>>=`, `??=` | Destra | Assegnazione |\n| 2 | `??` | Sinistra | Null coalescing |\n| 3 | `? :` | Destra | Condizionale |\n| 4 | `\\|\\|` | Sinistra | OR logico |\n| 5 | `&&` | Sinistra | AND logico |\n| 6 | `\\|` | Sinistra | OR bit a bit |\n| 7 | `^` | Sinistra | XOR bit a bit |\n| 8 | `&` | Sinistra | AND bit a bit |\n| 9 | `==`, `!=` | Sinistra | Uguaglianza |\n| 10 | `<`, `>`, `<=`, `>=` | Sinistra | Confronto |\n| 11 | `<<`, `>>` | Sinistra | Shift |\n| 12 | `+`, `-` | Sinistra | Addizione/Sottrazione |\n| 13 | `*`, `/`, `%` | Sinistra | Moltiplicazione/Divisione |\n| 14 | `!`, `-`, `~`, `++`, `--` | Destra | Unario |\n| 15 | `()`, `[]`, `.`, `?.` | Sinistra | Chiamata/Accesso |\n\n**Esempi:**\n```hemlock\n// La moltiplicazione lega pi stretto dell'addizione\nlet x = 2 + 3 * 4;      // 14, non 20\n\n// AND logico lega pi stretto di OR\nlet y = true || false && false;  // true\n\n// Usa parentesi per chiarezza\nlet z = (2 + 3) * 4;    // 20\nlet w = (a || b) && c;  // (a || b) valutato prima\n\n// Accesso a campo lega pi stretto di operatori aritmetici\nlet lunghezza = arr.length * 2;  // (arr.length) * 2\n```\n\n---\n\n## Promozione dei Tipi\n\nQuando si mescolano tipi nelle operazioni, Hemlock promuove al tipo \"superiore\":\n\n**Gerarchia di Promozione:**\n```\nf64 (precisione massima)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (minima)\n```\n\n**Regole:**\n1. Il float vince sempre sull'intero\n2. Dimensione maggiore vince nella stessa categoria\n3. Entrambi gli operandi sono promossi al tipo risultato\n4. **Preservazione precisione:** i64/u64 + f32 promuove a f64 (non f32)\n\n**Esempi:**\n```hemlock\n// Promozione dimensione\nu8 + i32     i32    // Dimensione maggiore vince\ni32 + i64    i64    // Dimensione maggiore vince\nu32 + u64    u64    // Dimensione maggiore vince\n\n// Promozione float\ni32 + f32    f32    // Float vince, f32 sufficiente per i32\ni64 + f32    f64    // Promuove a f64 per preservare precisione i64\ni64 + f64    f64    // Float vince sempre\ni8 + f64     f64    // Float + pi grande vince\n```\n\n---\n\n## Riepilogo Completo degli Operatori\n\n### Operatori Aritmetici\n| Operatore | Descrizione |\n|-----------|-------------|\n| `+` | Addizione |\n| `-` | Sottrazione |\n| `*` | Moltiplicazione |\n| `/` | Divisione (restituisce float) |\n| `%` | Modulo |\n| `-` (unario) | Negazione |\n| `++` | Incremento |\n| `--` | Decremento |\n\n### Operatori di Confronto\n| Operatore | Descrizione |\n|-----------|-------------|\n| `==` | Uguale a |\n| `!=` | Diverso da |\n| `<` | Minore di |\n| `>` | Maggiore di |\n| `<=` | Minore o uguale |\n| `>=` | Maggiore o uguale |\n\n### Operatori Logici\n| Operatore | Descrizione |\n|-----------|-------------|\n| `&&` | AND logico |\n| `\\|\\|` | OR logico |\n| `!` | NOT logico |\n\n### Operatori Bit a Bit\n| Operatore | Descrizione |\n|-----------|-------------|\n| `&` | AND bit a bit |\n| `\\|` | OR bit a bit |\n| `^` | XOR bit a bit |\n| `~` | NOT bit a bit |\n| `<<` | Shift sinistra |\n| `>>` | Shift destra |\n\n### Operatori di Assegnazione\n| Operatore | Descrizione |\n|-----------|-------------|\n| `=` | Assegnazione |\n| `+=`, `-=`, `*=`, `/=`, `%=` | Aritmetica composta |\n| `&=`, `\\|=`, `^=`, `<<=`, `>>=` | Bit a bit composta |\n| `??=` | Null assegnazione |\n\n### Altri Operatori\n| Operatore | Descrizione |\n|-----------|-------------|\n| `? :` | Condizionale |\n| `??` | Null coalescing |\n| `?.` | Navigazione sicura |\n| `[]` | Indicizzazione |\n| `.` | Accesso campo |\n| `()` | Chiamata funzione |\n\n---\n\n## Vedi Anche\n\n- [Sistema di Tipi](#reference-type-system) - Regole di promozione dei tipi\n- [Funzioni Integrate](#reference-builtins) - Funzioni come `divi()`\n- [API delle Stringhe](#reference-string-api) - Concatenazione stringhe\n- [API degli Array](#reference-array-api) - Indicizzazione array\n"}, "Riferimento API -> Sistema di Tipi": {"id": "reference-type-system", "content": "# Riferimento del Sistema di Tipi\n\nRiferimento completo per il sistema di tipi di Hemlock, inclusi tutti i tipi primitivi e composti.\n\n---\n\n## Panoramica\n\nHemlock usa un **sistema di tipi dinamico** con tag di tipo a runtime e annotazioni di tipo opzionali. Ogni valore ha un tipo a runtime, e le conversioni di tipo seguono regole di promozione esplicite.\n\n**Caratteristiche Principali:**\n- Controllo dei tipi a runtime (interprete)\n- Controllo dei tipi a compile-time (hemlockc - abilitato di default)\n- Annotazioni di tipo opzionali\n- Inferenza di tipo automatica per i letterali\n- Regole di promozione dei tipi esplicite\n- Nessuna conversione implicita che perde precisione\n\n---\n\n## Controllo dei Tipi a Compile-Time (hemlockc)\n\nIl compilatore Hemlock (`hemlockc`) include un controllo dei tipi a compile-time che valida il codice prima di generare eseguibili. Questo cattura gli errori di tipo in anticipo senza bisogno di eseguire il programma.\n\n### Comportamento Predefinito\n\nIl controllo dei tipi  **abilitato di default** in hemlockc:\n\n```bash\n# Il controllo dei tipi avviene automaticamente\nhemlockc programma.hml -o programma\n\n# Gli errori sono riportati prima della compilazione\nhemlockc tipi_errati.hml\n# Output: 1 errore di tipo trovato\n```\n\n### Flag del Compilatore\n\n| Flag | Descrizione |\n|------|-------------|\n| `--check` | Solo controllo tipi, non compila (esce dopo validazione) |\n| `--no-type-check` | Disabilita controllo tipi (non raccomandato) |\n| `--strict-types` | Abilita avvisi pi rigidi sui tipi |\n\n**Esempi:**\n\n```bash\n# Solo validare i tipi senza compilare\nhemlockc --check programma.hml\n# Output: programma.hml: nessun errore di tipo\n\n# Disabilitare controllo tipi (usare con cautela)\nhemlockc --no-type-check codice_dinamico.hml -o programma\n\n# Abilitare avvisi rigidi per tipi any impliciti\nhemlockc --strict-types programma.hml -o programma\n```\n\n### Cosa Valida il Controllo dei Tipi\n\n1. **Annotazioni di tipo** - Assicura che i valori assegnati corrispondano ai tipi dichiarati\n2. **Chiamate di funzione** - Valida i tipi degli argomenti rispetto ai tipi dei parametri\n3. **Tipi di ritorno** - Verifica che le istruzioni return corrispondano al tipo di ritorno dichiarato\n4. **Uso degli operatori** - Verifica che gli operandi siano compatibili\n5. **Accesso alle propriet** - Valida i tipi dei campi degli oggetti per oggetti tipizzati\n\n### Conversioni Numeriche Permissive\n\nIl controllo dei tipi permette conversioni di tipo numerico a compile-time, con validazione dell'intervallo a runtime:\n\n```hemlock\nlet x: i8 = 100;      // OK - 100 sta in i8 (validato a runtime)\nlet y: u8 = 255;      // OK - nell'intervallo u8\nlet z: f64 = 42;      // OK - i32 a f64  sicuro\n```\n\n### Supporto per Codice Dinamico\n\nIl codice senza annotazioni di tipo  trattato come dinamico (tipo `any`) e passa sempre il controllo dei tipi:\n\n```hemlock\nlet x = get_value();  // Dinamico - nessuna annotazione\nprocess(x);           // OK - valori dinamici accettati ovunque\n```\n\n---\n\n## Tipi Primitivi\n\n### Tipi Numerici\n\n#### Interi con Segno\n\n| Tipo   | Dimensione | Intervallo                                   | Alias     |\n|--------|------------|----------------------------------------------|-----------|\n| `i8`   | 1 byte     | -128 a 127                                   | -         |\n| `i16`  | 2 byte     | -32.768 a 32.767                             | -         |\n| `i32`  | 4 byte     | -2.147.483.648 a 2.147.483.647               | `integer` |\n| `i64`  | 8 byte     | -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807 | - |\n\n**Esempi:**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Alias di tipo\nlet x: integer = 42;  // Uguale a i32\n```\n\n#### Interi senza Segno\n\n| Tipo   | Dimensione | Intervallo                  | Alias  |\n|--------|------------|-----------------------------|--------|\n| `u8`   | 1 byte     | 0 a 255                     | `byte` |\n| `u16`  | 2 byte     | 0 a 65.535                  | -      |\n| `u32`  | 4 byte     | 0 a 4.294.967.295           | -      |\n| `u64`  | 8 byte     | 0 a 18.446.744.073.709.551.615 | -   |\n\n**Esempi:**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Alias di tipo\nlet val_byte: byte = 65;  // Uguale a u8\n```\n\n#### Virgola Mobile\n\n| Tipo   | Dimensione | Precisione   | Alias    |\n|--------|------------|--------------|----------|\n| `f32`  | 4 byte     | ~7 cifre     | -        |\n| `f64`  | 8 byte     | ~15 cifre    | `number` |\n\n**Esempi:**\n```hemlock\nlet pi: f32 = 3.14159;\nlet preciso: f64 = 3.14159265359;\n\n// Alias di tipo\nlet x: number = 2.718;  // Uguale a f64\n```\n\n---\n\n### Inferenza dei Letterali Interi\n\nI letterali interi sono tipizzati automaticamente in base al loro valore:\n\n**Regole:**\n- Valori nell'intervallo i32 (-2.147.483.648 a 2.147.483.647): inferiti come `i32`\n- Valori fuori dall'intervallo i32 ma nell'intervallo i64: inferiti come `i64`\n- Usa annotazioni di tipo esplicite per altri tipi (i8, i16, u8, u16, u32, u64)\n\n**Esempi:**\n```hemlock\nlet piccolo = 42;                    // i32 (sta in i32)\nlet grande = 5000000000;             // i64 (> max i32)\nlet max_i64 = 9223372036854775807;   // i64 (INT64_MAX)\nlet esplicito: u32 = 100;            // u32 (annotazione sovrascrive)\n```\n\n---\n\n### Tipo Booleano\n\n**Tipo:** `bool`\n\n**Valori:** `true`, `false`\n\n**Dimensione:** 1 byte (internamente)\n\n**Esempi:**\n```hemlock\nlet attivo: bool = true;\nlet fatto = false;\n\nif (attivo && !fatto) {\n    print(\"lavorando\");\n}\n```\n\n---\n\n### Tipi Carattere\n\n#### Rune\n\n**Tipo:** `rune`\n\n**Descrizione:** Codepoint Unicode (U+0000 a U+10FFFF)\n\n**Dimensione:** 4 byte (valore 32-bit)\n\n**Intervallo:** 0 a 0x10FFFF (1.114.111)\n\n**Sintassi Letterale:** Apici singoli `'x'`\n\n**Esempi:**\n```hemlock\n// ASCII\nlet a = 'A';\nlet cifra = '0';\n\n// UTF-8 multi-byte\nlet razzo = '';      // U+1F680\nlet cuore = '';       // U+2764\nlet cinese = '';     // U+4E2D\n\n// Sequenze di escape\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet apice = '\\'';\nlet null_char = '\\0';\n\n// Escape Unicode\nlet emoji = '\\u{1F680}';   // Fino a 6 cifre hex\nlet max = '\\u{10FFFF}';    // Codepoint massimo\n```\n\n**Conversioni di Tipo:**\n```hemlock\n// Intero a rune\nlet codice: rune = 65;        // 'A'\nlet r: rune = 128640;         // \n\n// Rune a intero\nlet valore: i32 = 'Z';        // 90\n\n// Rune a stringa\nlet s: string = 'H';          // \"H\"\n\n// u8 a rune\nlet byte_val: u8 = 65;\nlet rune_val: rune = byte_val;  // 'A'\n```\n\n**Vedi Anche:** [API delle Stringhe](#reference-string-api) per concatenazione stringa + rune\n\n---\n\n### Tipo Stringa\n\n**Tipo:** `string`\n\n**Descrizione:** Testo codificato UTF-8, mutabile, allocato nell'heap\n\n**Codifica:** UTF-8 (U+0000 a U+10FFFF)\n\n**Mutabilit:** Mutabile (diversamente dalla maggior parte dei linguaggi)\n\n**Propriet:**\n- `.length` - Conteggio codepoint (numero di caratteri)\n- `.byte_length` - Conteggio byte (dimensione codifica UTF-8)\n\n**Sintassi Letterale:** Virgolette doppie `\"testo\"`\n\n**Esempi:**\n```hemlock\nlet s = \"ciao\";\ns[0] = 'C';             // Muta (ora \"Ciao\")\nprint(s.length);        // 5 (conteggio codepoint)\nprint(s.byte_length);   // 5 (byte UTF-8)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (un codepoint)\nprint(emoji.byte_length);   // 4 (quattro byte UTF-8)\n```\n\n**Indicizzazione:**\n```hemlock\nlet s = \"ciao\";\nlet ch = s[0];          // Restituisce rune 'c'\ns[0] = 'C';             // Imposta con rune\n```\n\n**Vedi Anche:** [API delle Stringhe](#reference-string-api) per riferimento completo dei metodi\n\n---\n\n### Tipo Null\n\n**Tipo:** `null`\n\n**Descrizione:** Il valore null (assenza di valore)\n\n**Dimensione:** 8 byte (internamente)\n\n**Valore:** `null`\n\n**Esempi:**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // ERRORE: mismatch di tipo\n\nif (x == null) {\n    print(\"x  null\");\n}\n```\n\n---\n\n## Tipi Composti\n\n### Tipo Array\n\n**Tipo:** `array`\n\n**Descrizione:** Array dinamico, allocato nell'heap, a tipi misti\n\n**Propriet:**\n- `.length` - Numero di elementi\n\n**Indicizzazione a base zero:** S\n\n**Sintassi Letterale:** `[elem1, elem2, ...]`\n\n**Esempi:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Tipi misti\nlet misto = [1, \"ciao\", true, null];\n```\n\n**Vedi Anche:** [API degli Array](#reference-array-api) per riferimento completo dei metodi\n\n---\n\n### Tipo Oggetto\n\n**Tipo:** `object`\n\n**Descrizione:** Oggetto stile JavaScript con campi dinamici\n\n**Sintassi Letterale:** `{ campo: valore, ... }`\n\n**Esempi:**\n```hemlock\nlet persona = { nome: \"Alice\", eta: 30 };\nprint(persona.nome);  // \"Alice\"\n\n// Aggiunge campo dinamicamente\npersona.email = \"alice@esempio.com\";\n```\n\n**Definizioni di Tipo:**\n```hemlock\ndefine Persona {\n    nome: string,\n    eta: i32,\n    attivo?: bool,  // Campo opzionale\n}\n\nlet p: Persona = { nome: \"Bob\", eta: 25 };\nprint(typeof(p));  // \"Persona\"\n```\n\n---\n\n### Tipi Puntatore\n\n#### Puntatore Grezzo (ptr)\n\n**Tipo:** `ptr`\n\n**Descrizione:** Indirizzo di memoria grezzo (non sicuro)\n\n**Dimensione:** 8 byte\n\n**Controllo Limiti:** Nessuno\n\n**Esempi:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### Buffer (buffer)\n\n**Tipo:** `buffer`\n\n**Descrizione:** Wrapper sicuro del puntatore con controllo limiti\n\n**Struttura:** Puntatore + lunghezza + capacit\n\n**Propriet:**\n- `.length` - Dimensione buffer\n- `.capacity` - Capacit allocata\n\n**Esempi:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Con controllo limiti\nprint(b.length);        // 64\nfree(b);\n```\n\n**Vedi Anche:** [API della Memoria](#reference-memory-api) per funzioni di allocazione\n\n---\n\n## Tipi Speciali\n\n### Tipo File\n\n**Tipo:** `file`\n\n**Descrizione:** Handle di file per operazioni di I/O\n\n**Propriet:**\n- `.path` - Percorso del file (string)\n- `.mode` - Modalit di apertura (string)\n- `.closed` - Se il file  chiuso (bool)\n\n**Vedi Anche:** [API dei File](#reference-file-api)\n\n---\n\n### Tipo Task\n\n**Tipo:** `task`\n\n**Descrizione:** Handle per task concorrente\n\n**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)\n\n---\n\n### Tipo Channel\n\n**Tipo:** `channel`\n\n**Descrizione:** Canale di comunicazione thread-safe\n\n**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)\n\n---\n\n### Tipo Funzione\n\n**Tipo:** `function`\n\n**Descrizione:** Valore funzione di prima classe\n\n**Esempi:**\n```hemlock\nfn somma(a, b) {\n    return a + b;\n}\n\nlet moltiplica = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(somma));      // \"function\"\nprint(typeof(moltiplica)); // \"function\"\n```\n\n---\n\n### Tipo Void\n\n**Tipo:** `void`\n\n**Descrizione:** Assenza di valore di ritorno (uso interno)\n\n---\n\n## Regole di Promozione dei Tipi\n\nQuando si mescolano tipi nelle operazioni, Hemlock promuove al tipo \"superiore\":\n\n**Gerarchia di Promozione:**\n```\nf64 (precisione massima)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (minima)\n```\n\n**Regole:**\n1. Il float vince sempre sull'intero\n2. Dimensione maggiore vince nella stessa categoria (int/uint/float)\n3. Entrambi gli operandi sono promossi al tipo risultato\n4. **Preservazione precisione:** i64/u64 + f32 promuove a f64 (non f32)\n\n**Esempi:**\n```hemlock\n// Promozione dimensione\nu8 + i32     i32    // Dimensione maggiore vince\ni32 + i64    i64    // Dimensione maggiore vince\nu32 + u64    u64    // Dimensione maggiore vince\n\n// Promozione float\ni32 + f32    f32    // Float vince, f32 sufficiente per i32\ni64 + f32    f64    // Promuove a f64 per preservare precisione i64\ni64 + f64    f64    // Float vince sempre\ni8 + f64     f64    // Float + pi grande vince\n```\n\n**Perch i64 + f32  f64?**\n\nf32 ha solo una mantissa di 24 bit, che non pu rappresentare precisamente interi\npi grandi di 2^24 (16.777.216). Poich i64 pu contenere valori fino a 2^63,\nmescolare i64 con f32 causerebbe grave perdita di precisione. Hemlock promuove\na f64 (mantissa 53 bit) invece.\n\n---\n\n## Controllo dell'Intervallo\n\nLe annotazioni di tipo impongono controlli dell'intervallo all'assegnazione:\n\n**Assegnazioni Valide:**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**Assegnazioni Non Valide (Errore a Runtime):**\n```hemlock\nlet x: u8 = 256;             // ERRORE: fuori intervallo\nlet y: i8 = 128;             // ERRORE: max  127\nlet z: u64 = -1;             // ERRORE: u64 non pu essere negativo\n```\n\n---\n\n## Introspezione dei Tipi\n\n### typeof(valore)\n\nRestituisce il nome del tipo come stringa.\n\n**Firma:**\n```hemlock\ntypeof(valore: any): string\n```\n\n**Restituisce:**\n- Tipi primitivi: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Tipi composti: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Tipi speciali: `\"file\"`, `\"task\"`, `\"channel\"`\n- Oggetti tipizzati: Nome del tipo personalizzato (es. `\"Persona\"`)\n\n**Esempi:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"ciao\"));          // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Persona { nome: string }\nlet p: Persona = { nome: \"Alice\" };\nprint(typeof(p));               // \"Persona\"\n```\n\n**Vedi Anche:** [Funzioni Integrate](builtins.md#typeof)\n\n---\n\n## Conversioni di Tipo\n\n### Conversioni Implicite\n\nHemlock esegue conversioni di tipo implicite nelle operazioni aritmetiche seguendo le regole di promozione dei tipi.\n\n**Esempi:**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet risultato = a + b;     // risultato  i32 (promosso)\n```\n\n### Conversioni Esplicite\n\nUsa le annotazioni di tipo per conversioni esplicite:\n\n**Esempi:**\n```hemlock\n// Intero a float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float a intero (tronca)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Intero a rune\nlet codice: rune = 65;  // 'A'\n\n// Rune a intero\nlet valore: i32 = 'Z';  // 90\n\n// Rune a stringa\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## Alias di Tipo\n\n### Alias Integrati\n\nHemlock fornisce alias di tipo integrati per tipi comuni:\n\n| Alias     | Tipo Effettivo | Uso                      |\n|-----------|----------------|--------------------------|\n| `integer` | `i32`          | Interi generici          |\n| `number`  | `f64`          | Float generici           |\n| `byte`    | `u8`           | Valori byte              |\n\n**Esempi:**\n```hemlock\nlet conteggio: integer = 100;       // Uguale a i32\nlet prezzo: number = 19.99;         // Uguale a f64\nlet b: byte = 255;                  // Uguale a u8\n```\n\n### Alias di Tipo Personalizzati\n\nDefinisci alias di tipo personalizzati usando la parola chiave `type`:\n\n```hemlock\n// Alias semplici\ntype Intero = i32;\ntype Testo = string;\n\n// Alias di tipo funzione\ntype Callback = fn(i32): void;\ntype Predicato = fn(any): bool;\ntype OpBinaria = fn(i32, i32): i32;\n\n// Alias di tipo composto\ndefine HaNome { nome: string }\ndefine HaEta { eta: i32 }\ntype Persona = HaNome & HaEta;\n\n// Alias di tipo generico\ntype Coppia<T> = { primo: T, secondo: T };\ntype Risultato<T, E> = { valore: T?, errore: E? };\n```\n\n**Usando alias personalizzati:**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Persona = { nome: \"Alice\", eta: 30 };\nlet coord: Coppia<f64> = { primo: 3.14, secondo: 2.71 };\n```\n\n**Nota:** Gli alias di tipo sono trasparenti - `typeof()` restituisce il nome del tipo sottostante.\n\n---\n\n## Tipi Funzione\n\nI tipi funzione specificano la firma dei valori funzione:\n\n### Sintassi\n\n```hemlock\nfn(tipi_parametri): tipo_ritorno\n```\n\n### Esempi\n\n```hemlock\n// Tipo funzione base\nlet somma: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Parametro funzione\nfn applica(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Funzione di ordine superiore che restituisce funzione\nfn crea_sommatore(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Tipo funzione async\nfn esegui_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## Tipi Composti (Intersezione)\n\nI tipi composti usano `&` per richiedere vincoli di tipo multipli:\n\n```hemlock\ndefine HaNome { nome: string }\ndefine HaEta { eta: i32 }\ndefine HaEmail { email: string }\n\n// L'oggetto deve soddisfare tutti i tipi\nlet persona: HaNome & HaEta = { nome: \"Alice\", eta: 30 };\n\n// Tre o pi tipi\nfn descrivi(p: HaNome & HaEta & HaEmail) {\n    print(p.nome + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## Tabella Riassuntiva\n\n| Tipo       | Dim.     | Mutabile | Heap   | Descrizione                    |\n|------------|----------|----------|--------|--------------------------------|\n| `i8`-`i64` | 1-8 byte | No       | No     | Interi con segno               |\n| `u8`-`u64` | 1-8 byte | No       | No     | Interi senza segno             |\n| `f32`      | 4 byte   | No       | No     | Float singola precisione       |\n| `f64`      | 8 byte   | No       | No     | Float doppia precisione        |\n| `bool`     | 1 byte   | No       | No     | Booleano                       |\n| `rune`     | 4 byte   | No       | No     | Codepoint Unicode              |\n| `string`   | Variabile| S       | S     | Testo UTF-8                    |\n| `array`    | Variabile| S       | S     | Array dinamico                 |\n| `object`   | Variabile| S       | S     | Oggetto dinamico               |\n| `ptr`      | 8 byte   | No       | No     | Puntatore grezzo               |\n| `buffer`   | Variabile| S       | S     | Wrapper puntatore sicuro       |\n| `file`     | Opaco    | S       | S     | Handle file                    |\n| `task`     | Opaco    | No       | S     | Handle task concorrente        |\n| `channel`  | Opaco    | S       | S     | Canale thread-safe             |\n| `function` | Opaco    | No       | S     | Valore funzione                |\n| `null`     | 8 byte   | No       | No     | Valore null                    |\n\n---\n\n## Vedi Anche\n\n- [Riferimento Operatori](#reference-operators) - Comportamento dei tipi nelle operazioni\n- [Funzioni Integrate](#reference-builtins) - Introspezione e conversione tipi\n- [API delle Stringhe](#reference-string-api) - Metodi del tipo stringa\n- [API degli Array](#reference-array-api) - Metodi del tipo array\n- [API della Memoria](#reference-memory-api) - Operazioni su puntatori e buffer\n"}, "Design e Filosofia -> Filosofia": {"id": "design-philosophy", "content": "# Filosofia di Progettazione del Linguaggio Hemlock\n\n> \"Un linguaggio piccolo e non sicuro per scrivere cose non sicure in modo sicuro.\"\n\nQuesto documento cattura i principi fondamentali di progettazione e la filosofia di Hemlock. Leggi questo prima di apportare modifiche o aggiunte al linguaggio.\n\n---\n\n## Sommario\n\n- [Identit Fondamentale](#identit-fondamentale)\n- [Principi di Progettazione](#principi-di-progettazione)\n- [Filosofia sulla Sicurezza](#filosofia-sulla-sicurezza)\n- [Cosa NON Aggiungere](#cosa-non-aggiungere)\n- [Considerazioni Future](#considerazioni-future)\n- [Riflessioni Finali](#riflessioni-finali)\n\n---\n\n## Identit Fondamentale\n\nHemlock  un **linguaggio di scripting per sistemi** che abbraccia la gestione manuale della memoria e il controllo esplicito.  progettato per programmatori che vogliono:\n\n- La potenza del C\n- L'ergonomia dei moderni linguaggi di scripting\n- Concorrenza asincrona strutturata integrata\n- Nessun comportamento nascosto o magia\n\n### Cosa Hemlock NON \n\n- **Memory-safe** (i puntatori dangling sono responsabilit tua)\n- **Un sostituto di Rust, Go o Lua**\n- **Un linguaggio che nasconde la complessit**\n\n### Cosa Hemlock \n\n- **Esplicito su implicito, sempre**\n- **Educativo e sperimentale**\n- **Un \"livello di scripting C\" per lavoro sui sistemi**\n- **Onesto sui compromessi**\n\n---\n\n## Principi di Progettazione\n\n### 1. Esplicito su Implicito\n\nHemlock favorisce l'esplicitezza in tutti i costrutti del linguaggio. Non dovrebbero esserci sorprese, magie o comportamenti nascosti.\n\n**Male (implicito):**\n```hemlock\nlet x = 5  // Punto e virgola mancante - dovrebbe dare errore\n```\n\n**Bene (esplicito):**\n```hemlock\nlet x = 5;\nfree(ptr);  // Lo hai allocato tu, lo liberi tu\n```\n\n**Aspetti chiave:**\n- I punti e virgola sono obbligatori (nessuna inserzione automatica)\n- Nessun garbage collection\n- Gestione manuale della memoria (alloc/free)\n- Le annotazioni di tipo sono opzionali ma verificate a runtime\n- Nessuna pulizia automatica delle risorse (no RAII), ma `defer` fornisce pulizia esplicita\n\n### 2. Dinamico di Default, Tipizzato per Scelta\n\nOgni valore ha un tag di tipo a runtime, ma il sistema  progettato per essere flessibile pur catturando gli errori.\n\n**Inferenza dei tipi:**\n- Interi piccoli (stanno in i32): `42`  `i32`\n- Interi grandi (> intervallo i32): `9223372036854775807`  `i64`\n- Float: `3.14`  `f64`\n\n**Tipizzazione esplicita quando necessaria:**\n```hemlock\nlet x = 42;              // i32 inferito (valore piccolo)\nlet y: u8 = 255;         // u8 esplicito\nlet z = x + y;           // promuove a i32\nlet grande = 5000000000; // i64 inferito (> max i32)\n```\n\n**Le regole di promozione dei tipi** seguono una gerarchia chiara dal pi piccolo al pi grande, con i float che vincono sempre sugli interi.\n\n### 3. Non Sicuro  una Caratteristica, Non un Bug\n\nHemlock non cerca di prevenire tutti gli errori. Invece, ti d gli strumenti per essere sicuro permettendoti di optare per comportamenti non sicuri quando necessario.\n\n**Esempi di non sicurezza intenzionale:**\n- L'aritmetica dei puntatori pu causare overflow (responsabilit dell'utente)\n- Nessun controllo dei limiti sui `ptr` grezzi (usa `buffer` se vuoi sicurezza)\n- I double-free causano crash (gestione manuale della memoria)\n- Il sistema dei tipi previene gli incidenti ma permette operazioni rischiose quando necessario\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Molto oltre l'allocazione - permesso ma pericoloso\n```\n\n**La filosofia:** Il sistema dei tipi dovrebbe prevenire gli *incidenti* ma permettere operazioni non sicure *intenzionali*.\n\n### 4. Concorrenza Strutturata di Prima Classe\n\nLa concorrenza non  un ripensamento in Hemlock.  integrata nel linguaggio dalle fondamenta.\n\n**Caratteristiche chiave:**\n- `async`/`await` integrati nel linguaggio\n- Canali per la comunicazione\n- `spawn`/`join`/`detach` per la gestione dei task\n- Nessun thread grezzo, nessun lock - solo strutturato\n- Vero parallelismo multi-thread usando thread POSIX\n\n**Non un event loop o green thread** - Hemlock usa veri thread del sistema operativo per un vero parallelismo su pi core CPU.\n\n### 5. Sintassi Simile al C, Poca Cerimonia\n\nHemlock dovrebbe risultare familiare ai programmatori di sistemi riducendo il boilerplate.\n\n**Scelte di progettazione:**\n- Blocchi `{}` sempre, nessuna parentesi opzionale\n- Gli operatori corrispondono al C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- La sintassi dei tipi corrisponde a Rust/TypeScript: `let x: tipo = valore;`\n- Le funzioni sono valori di prima classe\n- Parole chiave e forme speciali minimali\n\n---\n\n## Filosofia sulla Sicurezza\n\n**La posizione di Hemlock sulla sicurezza:**\n\n> \"Ti diamo gli strumenti per essere sicuro (`buffer`, annotazioni di tipo, controllo dei limiti) ma non ti obblighiamo a usarli (`ptr`, memoria manuale, operazioni non sicure).\n>\n> Il default dovrebbe guidare verso la sicurezza, ma la via d'uscita dovrebbe essere sempre disponibile.\"\n\n### Strumenti di Sicurezza Forniti\n\n**1. Tipo buffer sicuro:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // controllo dei limiti\nprint(b.length);        // 64\nfree(b);                // ancora manuale\n```\n\n**2. Puntatori grezzi non sicuri:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Devi ricordarti di liberare\n```\n\n**3. Annotazioni di tipo:**\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERRORE: fuori intervallo\n```\n\n**4. Controllo dei tipi a runtime:**\n```hemlock\nlet val = qualche_funzione();\nif (typeof(val) == \"i32\") {\n    // Sicuro da usare come intero\n}\n```\n\n### Principi Guida\n\n1. **Default a pattern sicuri nella documentazione** - Mostra `buffer` prima di `ptr`, incoraggia le annotazioni di tipo\n2. **Rendi ovvie le operazioni non sicure** - L'aritmetica dei puntatori grezzi dovrebbe sembrare intenzionale\n3. **Fornisci vie d'uscita** - Non impedire agli utenti esperti di fare lavoro a basso livello\n4. **Sii onesto sui compromessi** - Documenta cosa pu andare storto\n\n### Esempi di Sicurezza vs. Non Sicurezza\n\n| Pattern Sicuro | Pattern Non Sicuro | Quando Usare Non Sicuro |\n|----------------|-------------------|------------------------|\n| tipo `buffer` | tipo `ptr` | FFI, codice critico per le prestazioni |\n| Annotazioni di tipo | Nessuna annotazione | Interfacce esterne, validazione |\n| Accesso con controllo limiti | Aritmetica puntatori | Operazioni memoria a basso livello |\n| Gestione eccezioni | Restituzione null/codici errore | Quando le eccezioni sono troppo pesanti |\n\n---\n\n## Cosa NON Aggiungere\n\nCapire cosa **non** aggiungere  importante quanto sapere cosa aggiungere.\n\n### Non Aggiungere Comportamento Implicito\n\n**Esempi negativi:**\n\n```hemlock\n// MALE: Inserzione automatica punto e virgola\nlet x = 5\nlet y = 10\n\n// MALE: Conversioni di tipo implicite che perdono precisione\nlet x: i32 = 3.14  // Dovrebbe troncare o dare errore?\n```\n\n**Perch:** Il comportamento implicito crea sorprese e rende il codice pi difficile da ragionare.\n\n### Non Nascondere la Complessit\n\n**Esempi negativi:**\n\n```hemlock\n// MALE: Ottimizzazione magica dietro le quinte\nlet arr = [1, 2, 3]  //  sullo stack o nell'heap? L'utente dovrebbe saperlo! (Heap, refcounted)\n\n// MALE: Puntatore grezzo liberato automaticamente\nlet p = alloc(100)  // Si libera automaticamente? NO! I ptr grezzi richiedono sempre free()\n```\n\n**Nota sul refcounting:** Hemlock usa il refcounting interno per stringhe, array, oggetti e buffer - questi SONO liberati automaticamente quando lo scope esce. Questo  esplicito e prevedibile (pulizia deterministica quando ref raggiunge 0, nessuna pausa GC). I puntatori grezzi (`ptr` da `alloc()`) NON sono refcounted e richiedono sempre `free()` manuale.\n\n**Perch:** La complessit nascosta rende impossibile prevedere le prestazioni e debuggare i problemi.\n\n### Non Rompere la Semantica Esistente\n\n**Non cambiare mai queste decisioni fondamentali:**\n- I punti e virgola sono obbligatori - non renderli opzionali\n- Gestione manuale della memoria - non aggiungere GC\n- Stringhe mutabili - non renderle immutabili\n- Controllo dei tipi a runtime - non rimuoverlo\n\n**Perch:** Consistenza e stabilit sono pi importanti delle funzionalit alla moda.\n\n### Non Aggiungere Funzionalit \"Comode\" Che Riducono l'Esplicitezza\n\n**Esempi di funzionalit da evitare:**\n- Overloading degli operatori (forse per tipi utente, ma con attenzione)\n- Coercizione di tipo implicita che perde informazioni\n- Pulizia automatica delle risorse (RAII)\n- Concatenamento di metodi che nasconde complessit\n- DSL e sintassi magica\n\n**Eccezione:** Le funzionalit comode vanno bene se sono **zucchero sintattico esplicito** su operazioni semplici:\n- `else if` va bene (sono solo istruzioni if annidate)\n- L'interpolazione di stringhe potrebbe andare bene se  chiaramente zucchero sintattico\n- La sintassi dei metodi per gli oggetti va bene ( esplicito cosa fa)\n\n---\n\n## Considerazioni Future\n\n### Forse Aggiungere (In Discussione)\n\nQueste funzionalit si allineano con la filosofia di Hemlock ma necessitano di progettazione attenta:\n\n**1. Pattern matching**\n```hemlock\nmatch (valore) {\n    case i32: print(\"intero\");\n    case string: print(\"testo\");\n    case _: print(\"altro\");\n}\n```\n- Controllo dei tipi esplicito\n- Nessun costo nascosto\n- Possibile controllo esaustivit a compile-time\n\n**2. Tipi errore (`Result<T, E>`)**\n```hemlock\nfn dividi(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"divisione per zero\");\n    }\n    return Ok(a / b);\n}\n```\n- Gestione errori esplicita\n- Forza gli utenti a pensare agli errori\n- Alternativa alle eccezioni\n\n**3. Tipi array/slice**\n- Abbiamo gi array dinamici\n- Potremmo aggiungere array di dimensione fissa per allocazione sullo stack\n- Dovrebbe essere esplicito su stack vs. heap\n\n**4. Strumenti di sicurezza memoria migliorati**\n- Flag opzionale per controllo limiti\n- Rilevamento memory leak nelle build di debug\n- Integrazione sanitizer\n\n### Probabilmente Mai Aggiungere\n\nQueste funzionalit violano i principi fondamentali:\n\n**1. Garbage collection**\n- Nasconde la complessit della gestione memoria\n- Prestazioni imprevedibili\n- Contro il principio del controllo esplicito\n\n**2. Gestione automatica della memoria**\n- Stesse ragioni del GC\n- Il reference counting potrebbe andare bene se esplicito\n\n**3. Conversioni di tipo implicite che perdono dati**\n- Va contro \"esplicito su implicito\"\n- Fonte di bug sottili\n\n**4. Macro (complesse)**\n- Troppa potenza, troppa complessit\n- Un sistema macro semplice potrebbe andare bene\n- Preferisci generazione di codice o funzioni\n\n**5. OOP basata su classi con ereditariet**\n- Troppo comportamento implicito\n- Duck typing e oggetti sono sufficienti\n- Composizione su ereditariet\n\n**6. Sistema di moduli con risoluzione complessa**\n- Mantieni gli import semplici ed espliciti\n- Nessun percorso di ricerca magico\n- Nessuna risoluzione versioni (usa il package manager del sistema operativo)\n\n---\n\n## Riflessioni Finali\n\n### Fiducia e Responsabilit\n\nHemlock riguarda **fiducia e responsabilit**. Ci fidiamo del programmatore per:\n\n- Gestire la memoria correttamente\n- Usare i tipi appropriatamente\n- Gestire gli errori propriamente\n- Capire i compromessi\n\nIn cambio, Hemlock fornisce:\n\n- Nessun costo nascosto\n- Nessun comportamento sorprendente\n- Controllo completo quando necessario\n- Strumenti di sicurezza quando voluti\n\n### La Domanda Guida\n\n**Quando si considera una nuova funzionalit, chiedi:**\n\n> \"Questo d al programmatore pi controllo esplicito, o nasconde qualcosa?\"\n\n- Se **aggiunge controllo esplicito**  probabilmente adatto a Hemlock\n- Se **nasconde complessit**  probabilmente non appartiene\n- Se  **zucchero opzionale** chiaramente documentato  potrebbe andare bene\n\n### Esempi di Buone Aggiunte\n\n- **Istruzioni switch** - Flusso di controllo esplicito, nessuna magia, semantica chiara\n\n- **Async/await con pthread** - Concorrenza esplicita, vero parallelismo, l'utente controlla lo spawning\n\n- **Tipo buffer insieme a ptr** - D scelta tra sicuro e non sicuro\n\n- **Annotazioni di tipo opzionali** - Aiuta a catturare bug senza forzare rigidit\n\n- **Try/catch/finally** - Gestione errori esplicita con flusso di controllo chiaro\n\n### Esempi di Cattive Aggiunte\n\n- **Inserzione automatica punto e virgola** - Nasconde errori di sintassi, rende il codice ambiguo\n\n- **RAII/distruttori** - Pulizia automatica nasconde quando le risorse vengono rilasciate\n\n- **Null coalescing implicito** - Nasconde i controlli null, rende il codice pi difficile da ragionare\n\n- **Stringhe che crescono automaticamente** - Nasconde allocazione memoria, prestazioni imprevedibili\n\n---\n\n## Conclusione\n\nHemlock non cerca di essere il linguaggio pi sicuro, il pi veloce, o il pi ricco di funzionalit.\n\n**Hemlock cerca di essere il linguaggio pi *onesto*.**\n\nTi dice esattamente cosa sta facendo, ti d controllo quando ne hai bisogno, e non nasconde gli spigoli affilati.  un linguaggio per persone che vogliono capire il loro codice a basso livello godendo comunque di ergonomia moderna.\n\nSe non sei sicuro se una funzionalit appartiene a Hemlock, ricorda:\n\n> **Esplicito su implicito, sempre.**\n> **Non sicuro  una caratteristica, non un bug.**\n> **L'utente  responsabile, e va bene cos.**\n"}, "Design e Filosofia -> Implementazione": {"id": "design-implementation", "content": "# Dettagli di Implementazione di Hemlock\n\nQuesto documento descrive l'implementazione tecnica del linguaggio Hemlock, inclusa la struttura del progetto, la pipeline di compilazione, l'architettura del runtime e le decisioni di progettazione.\n\n---\n\n## Sommario\n\n- [Struttura del Progetto](#struttura-del-progetto)\n- [Pipeline di Compilazione](#pipeline-di-compilazione)\n- [Design Modulare dell'Interprete](#design-modulare-dellinterprete)\n- [Architettura del Runtime](#architettura-del-runtime)\n- [Rappresentazione dei Valori](#rappresentazione-dei-valori)\n- [Implementazione del Sistema di Tipi](#implementazione-del-sistema-di-tipi)\n- [Gestione della Memoria](#gestione-della-memoria)\n- [Modello di Concorrenza](#modello-di-concorrenza)\n- [Piani Futuri](#piani-futuri)\n\n---\n\n## Struttura del Progetto\n\n```\nhemlock/\n src/\n    frontend/              # Condiviso: lexer, parser, AST\n       lexer.c            # Tokenizzazione\n       parser/            # Parser a discesa ricorsiva\n       ast.c              # Gestione nodi AST\n       module.c           # Risoluzione moduli\n    backends/\n       interpreter/       # hemlock: interprete tree-walking\n          main.c         # Entry point CLI\n          runtime.c      # Valutazione espressioni/istruzioni\n          builtins.c     # Funzioni integrate\n          ...\n       compiler/          # hemlockc: generatore codice C\n           main.c         # CLI, orchestrazione\n           type_check.c   # Controllo tipi compile-time\n           codegen.c      # Contesto generazione codice\n           codegen_expr.c # Generazione espressioni\n           codegen_stmt.c # Generazione istruzioni\n           ...\n    tools/\n       lsp/               # Language Server Protocol\n       bundler/           # Strumenti bundle/package\n runtime/                   # libhemlock_runtime.a (per programmi compilati)\n stdlib/                    # Libreria standard (39 moduli)\n    docs/                  # Documentazione moduli\n tests/\n    parity/                # Test che devono passare entrambi i backend\n    interpreter/           # Test specifici interprete\n    compiler/              # Test specifici compilatore\n examples/                  # Programmi di esempio\n docs/                      # Documentazione\n```\n\n### Organizzazione delle Directory\n\n**`include/`** - Header API pubblici che definiscono l'interfaccia tra i componenti:\n- Separazione pulita tra lexer, parser, AST e interprete\n- Dichiarazioni forward per minimizzare le dipendenze\n- API pubblica per incorporare Hemlock in altri programmi\n\n**`src/`** - File di implementazione:\n- I file di livello superiore gestiscono lexing, parsing, gestione AST\n- `main.c` fornisce CLI e REPL\n- L'interprete  modularizzato in sottosistemi separati\n\n**`src/interpreter/`** - Implementazione modulare dell'interprete:\n- Ogni modulo ha una singola, chiara responsabilit\n- API interna definita in `internal.h` per comunicazione inter-modulo\n- I moduli possono essere compilati indipendentemente per build pi veloci\n\n**`tests/`** - Suite di test completa:\n- Organizzata per area funzionale\n- Ogni directory contiene casi di test focalizzati\n- `run_tests.sh` orchestra l'esecuzione dei test\n\n---\n\n## Pipeline di Compilazione\n\nHemlock usa una pipeline di compilazione tradizionale con fasi distinte:\n\n### Fase 1: Analisi Lessicale (Lexer)\n\n**Input:** Testo del codice sorgente\n**Output:** Stream di token\n**Implementazione:** `src/lexer.c`\n\n```\nSorgente: \"let x = 42;\"\n   \nToken: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**Caratteristiche principali:**\n- Riconosce parole chiave, identificatori, letterali, operatori, punteggiatura\n- Gestisce letterali stringa UTF-8 e letterali rune\n- Riporta numeri di riga per messaggi di errore\n- Passata singola, nessun backtracking\n\n### Fase 2: Analisi Sintattica (Parser)\n\n**Input:** Stream di token\n**Output:** Abstract Syntax Tree (AST)\n**Implementazione:** `src/parser.c`\n\n```\nToken: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   \nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**Caratteristiche principali:**\n- Parser a discesa ricorsiva\n- Costruisce rappresentazione ad albero della struttura del programma\n- Gestisce la precedenza degli operatori\n- Valida la sintassi (parentesi, punti e virgola, ecc.)\n- Nessuna analisi semantica ancora (fatta a runtime)\n\n**Precedenza Operatori (dalla pi bassa alla pi alta):**\n1. Assegnazione: `=`\n2. OR logico: `||`\n3. AND logico: `&&`\n4. OR bit a bit: `|`\n5. XOR bit a bit: `^`\n6. AND bit a bit: `&`\n7. Uguaglianza: `==`, `!=`\n8. Confronto: `<`, `>`, `<=`, `>=`\n9. Shift bit a bit: `<<`, `>>`\n10. Addizione/Sottrazione: `+`, `-`\n11. Moltiplicazione/Divisione/Modulo: `*`, `/`, `%`\n12. Unario: `!`, `-`, `~`\n13. Chiamata/Indice/Membro: `()`, `[]`, `.`\n\n### Fase 3a: Interpretazione (Tree-Walking)\n\n**Input:** AST\n**Output:** Esecuzione del programma\n**Implementazione:** `src/backends/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   \nEsecuzione: Valuta nodi AST ricorsivamente\n   \nRisultato: Variabile x creata con valore 42\n```\n\n**Caratteristiche principali:**\n- Attraversamento diretto dell'AST (interprete tree-walking)\n- Controllo dinamico dei tipi a runtime\n- Storage delle variabili basato su environment\n\n### Fase 3b: Compilazione (hemlockc)\n\n**Input:** AST\n**Output:** Eseguibile nativo via generazione codice C\n**Implementazione:** `src/backends/compiler/`\n\n```\nAST: LetStmt { ... }\n   \nControllo Tipi: Valida tipi a compile-time\n   \nCodegen C: Genera codice C equivalente\n   \nGCC: Compila C in binario nativo\n   \nRisultato: Eseguibile standalone\n```\n\n**Caratteristiche principali:**\n- Controllo tipi a compile-time (abilitato di default)\n- Generazione codice C per portabilit\n- Linka contro `libhemlock_runtime.a`\n- Esecuzione significativamente pi veloce dell'interprete\n\n---\n\n## Backend Compilatore (hemlockc)\n\nIl compilatore Hemlock genera codice C dall'AST, che viene poi compilato in un eseguibile nativo usando GCC.\n\n### Architettura del Compilatore\n\n```\nsrc/backends/compiler/\n main.c              # CLI, parsing argomenti, orchestrazione\n codegen.c           # Contesto core generazione codice\n codegen_expr.c      # Generazione codice espressioni\n codegen_stmt.c      # Generazione codice istruzioni\n codegen_call.c      # Generazione chiamate funzione\n codegen_closure.c   # Implementazione closure\n codegen_program.c   # Generazione programma top-level\n codegen_module.c    # Gestione moduli/import\n type_check.c        # Controllo tipi compile-time\n type_check.h        # API controllo tipi\n```\n\n### Controllo dei Tipi\n\nIl compilatore include un sistema unificato di controllo dei tipi che:\n\n1. **Valida i tipi a compile-time** - Cattura errori di tipo prima dell'esecuzione\n2. **Supporta codice dinamico** - Codice non tipizzato trattato come `any` (sempre valido)\n3. **Fornisce hint di ottimizzazione** - Identifica variabili che possono essere unboxed\n\n**Flag Controllo Tipi:**\n\n| Flag | Descrizione |\n|------|-------------|\n| (default) | Controllo tipi abilitato |\n| `--check` | Solo controllo tipi, non compila |\n| `--no-type-check` | Disabilita controllo tipi |\n| `--strict-types` | Avvisa su tipi `any` impliciti |\n\n**Implementazione Controllo Tipi:**\n\n```c\n// type_check.h - Strutture chiave\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // Hint ottimizzazione\n    // ... type environment, definizioni, ecc.\n} TypeCheckContext;\n\n// Entry point principale\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### Generazione del Codice\n\nLa fase di codegen traduce i nodi AST in codice C:\n\n**Mapping Espressioni:**\n```\nHemlock                   C Generato\n----------------------------------------\nlet x = 42;              HmlValue x = hml_val_i32(42);\nx + y                    hml_add(x, y)\narr[i]                   hml_array_get(arr, i)\nobj.field                hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }         Closure con cattura environment\n```\n\n**Integrazione Runtime:**\n\nIl codice C generato linka contro `libhemlock_runtime.a` che fornisce:\n- Tipo union taggata `HmlValue`\n- Gestione memoria (reference counting)\n- Funzioni integrate (print, typeof, ecc.)\n- Primitive di concorrenza (task, canali)\n- Supporto FFI\n\n### Ottimizzazione Unboxing\n\nIl controllo tipi identifica variabili che possono usare tipi C nativi invece di `HmlValue` boxed:\n\n**Pattern Unboxable:**\n- Contatori di loop con tipo intero noto\n- Variabili accumulatore nei loop\n- Variabili con annotazioni di tipo esplicite (i32, i64, f64, bool)\n\n```hemlock\n// Il contatore loop 'i' pu essere unboxed a int32_t nativo\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    somma = somma + i;\n}\n```\n\n---\n\n## Design Modulare dell'Interprete\n\nL'interprete  diviso in moduli focalizzati per manutenibilit e scalabilit.\n\n### Responsabilit dei Moduli\n\n#### 1. Environment (`environment.c`) - 121 righe\n\n**Scopo:** Scoping delle variabili e risoluzione dei nomi\n\n**Funzioni chiave:**\n- `env_create()` - Crea nuovo environment con parent opzionale\n- `env_define()` - Definisce nuova variabile nello scope corrente\n- `env_get()` - Cerca variabile nello scope corrente o parent\n- `env_set()` - Aggiorna valore variabile esistente\n- `env_free()` - Libera environment e tutte le variabili\n\n**Design:**\n- Scope collegati (ogni environment ha puntatore al parent)\n- HashMap per lookup veloce delle variabili\n- Supporta scoping lessicale per le closure\n\n#### 2. Values (`values.c`) - 394 righe\n\n**Scopo:** Costruttori di valori e gestione strutture dati\n\n**Funzioni chiave:**\n- `value_create_*()` - Costruttori per ogni tipo di valore\n- `value_copy()` - Logica di copia deep/shallow\n- `value_free()` - Pulizia e deallocazione memoria\n- `value_to_string()` - Rappresentazione stringa per stampa\n\n**Strutture dati:**\n- Oggetti (array campi dinamici)\n- Array (ridimensionamento dinamico)\n- Buffer (ptr + length + capacity)\n- Closure (funzione + environment catturato)\n- Task e Channel (primitive di concorrenza)\n\n#### 3. Types (`types.c`) - 440 righe\n\n**Scopo:** Sistema tipi, conversioni e duck typing\n\n**Funzioni chiave:**\n- `type_check()` - Validazione tipi runtime\n- `type_convert()` - Conversioni/promozioni implicite\n- `duck_type_check()` - Controllo tipi strutturale per oggetti\n- `type_name()` - Ottiene nome tipo stampabile\n\n**Caratteristiche:**\n- Gerarchia promozione tipi (i8  i16  i32  i64  f32  f64, con i64/u64 + f32  f64)\n- Controllo intervallo per tipi numerici\n- Duck typing per definizioni tipo oggetto\n- Default campi opzionali\n\n#### 4. Builtins (`builtins.c`) - 955 righe\n\n**Scopo:** Funzioni integrate e registrazione globale\n\n**Funzioni chiave:**\n- `register_builtins()` - Registra tutte le funzioni e costanti integrate\n- Implementazioni funzioni integrate (print, typeof, alloc, free, ecc.)\n- Funzioni gestione segnali\n- Esecuzione comandi (exec)\n\n**Categorie di builtin:**\n- I/O: print, open, read_file, write_file\n- Memoria: alloc, free, memset, memcpy, realloc\n- Tipi: typeof, assert\n- Concorrenza: spawn, join, detach, channel\n- Sistema: exec, signal, raise, panic\n- FFI: dlopen, dlsym, dlcall, dlclose\n\n#### 5. I/O (`io.c`) - 449 righe\n\n**Scopo:** I/O su file e serializzazione JSON\n\n**Funzioni chiave:**\n- Metodi oggetto file (read, write, seek, tell, close)\n- Serializzazione/deserializzazione JSON\n- Rilevamento riferimenti circolari\n\n**Caratteristiche:**\n- Oggetto file con propriet (path, mode, closed)\n- I/O testo consapevole UTF-8\n- Supporto I/O binario\n- Round-tripping JSON per oggetti e array\n\n#### 6. FFI (`ffi.c`) - Foreign Function Interface\n\n**Scopo:** Chiamare funzioni C da librerie condivise\n\n**Funzioni chiave:**\n- `dlopen()` - Carica libreria condivisa\n- `dlsym()` - Ottiene puntatore funzione per nome\n- `dlcall()` - Chiama funzione C con conversione tipi\n- `dlclose()` - Scarica libreria\n\n**Caratteristiche:**\n- Integrazione con libffi per chiamate funzione dinamiche\n- Conversione tipi automatica (Hemlock  tipi C)\n- Supporto per tutti i tipi primitivi\n- Supporto puntatori e buffer\n\n#### 7. Runtime (`runtime.c`) - 865 righe\n\n**Scopo:** Valutazione espressioni ed esecuzione istruzioni\n\n**Funzioni chiave:**\n- `eval_expr()` - Valuta espressioni (ricorsivo)\n- `eval_stmt()` - Esegue istruzioni\n- Gestione flusso di controllo (if, while, for, switch, ecc.)\n- Gestione eccezioni (try/catch/finally/throw)\n\n**Caratteristiche:**\n- Valutazione espressioni ricorsiva\n- Valutazione booleana cortocircuito\n- Rilevamento chiamate metodo e binding `self`\n- Propagazione eccezioni\n- Gestione break/continue/return\n\n### Benefici del Design Modulare\n\n**1. Separazione delle Responsabilit**\n- Ogni modulo ha una chiara responsabilit\n- Facile trovare dove sono implementate le funzionalit\n- Riduce il carico cognitivo quando si fanno modifiche\n\n**2. Build Incrementali Pi Veloci**\n- Solo i moduli modificati necessitano ricompilazione\n- Compilazione parallela possibile\n- Tempi di iterazione pi brevi durante lo sviluppo\n\n**3. Testing e Debug Pi Facili**\n- I moduli possono essere testati in isolamento\n- I bug sono localizzati in sottosistemi specifici\n- Implementazioni mock possibili per testing\n\n**4. Scalabilit**\n- Nuove funzionalit possono essere aggiunte ai moduli appropriati\n- I moduli possono essere refactorizzati indipendentemente\n- La dimensione del codice per file rimane gestibile\n\n**5. Organizzazione del Codice**\n- Raggruppamento logico di funzionalit correlate\n- Grafo delle dipendenze chiaro\n- Onboarding pi facile per nuovi contributori\n\n---\n\n## Architettura del Runtime\n\n### Rappresentazione dei Valori\n\nTutti i valori in Hemlock sono rappresentati dalla struct `Value` usando una union taggata:\n\n```c\ntypedef struct Value {\n    ValueType type;  // Tag tipo runtime\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**Decisioni di design:**\n- **Union taggata** per type safety mantenendo flessibilit\n- **Tag tipo runtime** abilitano tipizzazione dinamica con controllo tipi\n- **Storage valore diretto** per primitivi (no boxing)\n- **Storage puntatore** per tipi allocati nell'heap (stringhe, oggetti, array)\n\n### Esempi Layout Memoria\n\n**Intero (i32):**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- Dimensione totale: ~16 byte (8-byte tag + 8-byte union)\n- Allocato sullo stack\n- Nessuna allocazione heap necessaria\n\n**Stringa:**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Puntatore a heap\n}\n\nHeap: \"ciao\\0\" (6 byte, null-terminated UTF-8)\n```\n- Value  16 byte sullo stack\n- Dati stringa allocati nell'heap\n- Deve essere liberata manualmente\n\n**Oggetto:**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Puntatore a heap\n}\n\nHeap: Object {\n    type_name: \"Persona\",\n    fields: [\n        { name: \"nome\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"eta\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- Struttura oggetto nell'heap\n- Campi memorizzati in array dinamico\n- Valori campi sono struct Value embedded\n\n### Implementazione Environment\n\nLe variabili sono memorizzate in catene di environment:\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // nome  Value\n    struct Environment *parent;  // Scope parent lessicale\n} Environment;\n```\n\n**Esempio catena scope:**\n```\nScope Globale: { print: <builtin>, args: <array> }\n    \nScope Funzione: { x: 10, y: 20 }\n    \nScope Blocco: { i: 0 }\n```\n\n**Algoritmo di lookup:**\n1. Controlla hashmap dell'environment corrente\n2. Se non trovato, controlla environment parent\n3. Ripeti finch trovato o raggiunto scope globale\n4. Errore se non trovato in nessuno scope\n\n---\n\n## Implementazione del Sistema di Tipi\n\n### Strategia Controllo Tipi\n\nHemlock usa **controllo tipi runtime** con **annotazioni tipo opzionali**:\n\n```hemlock\nlet x = 42;           // Nessun controllo tipo, inferisce i32\nlet y: u8 = 255;      // Controllo runtime: valore deve stare in u8\nlet z: i32 = x + y;   // Controllo runtime + promozione tipo\n```\n\n**Flusso implementazione:**\n1. **Inferenza letterali** - Lexer/parser determinano tipo iniziale dal letterale\n2. **Controllo annotazione tipo** - Se annotazione presente, valida all'assegnazione\n3. **Promozione** - Operazioni binarie promuovono a tipo comune\n4. **Conversione** - Conversioni esplicite avvengono su richiesta\n\n### Implementazione Promozione Tipi\n\nLa promozione tipi segue una gerarchia fissa con preservazione precisione:\n\n```c\n// Logica promozione semplificata\nValueType promote_types(ValueType a, ValueType b) {\n    // f64 vince sempre\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32 con i64/u64 promuove a f64 (preservazione precisione)\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // Tipi interi pi grandi vincono\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**Rank dei tipi:**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### Implementazione Duck Typing\n\nIl controllo tipo degli oggetti usa confronto strutturale:\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // Controlla tutti i campi richiesti\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // Campo mancante\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // Tipo sbagliato\n        }\n    }\n\n    return true;  // Tutti i campi richiesti presenti e tipo corretto\n}\n```\n\n**Il duck typing permette:**\n- Campi extra negli oggetti (ignorati)\n- Tipizzazione sub-strutturale (oggetto pu avere pi del richiesto)\n- Assegnazione nome tipo dopo validazione\n\n---\n\n## Gestione della Memoria\n\n### Strategia di Allocazione\n\nHemlock usa **gestione manuale della memoria** con due primitive di allocazione:\n\n**1. Puntatori grezzi (`ptr`):**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Memoria esaurita\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- malloc/free diretti\n- Nessun tracking\n- Responsabilit utente liberare\n\n**2. Buffer (`buffer`):**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- Traccia dimensione e capacit\n- Controllo limiti sull'accesso\n- Richiede comunque free manuale\n\n### Tipi Allocati nell'Heap\n\n**Stringhe:**\n- Array byte UTF-8 nell'heap\n- Null-terminated per interop C\n- Mutabili (possono modificare in loco)\n- Refcounted (auto-liberate quando scope esce)\n\n**Oggetti:**\n- Array campi dinamico\n- Nomi e valori campi nell'heap\n- Refcounted (auto-liberati quando scope esce)\n- Riferimenti circolari possibili (gestiti con tracking visited-set)\n\n**Array:**\n- Crescita capacit dinamica (raddoppio)\n- Elementi sono struct Value embedded\n- Riallocazione automatica alla crescita\n- Refcounted (auto-liberati quando scope esce)\n\n**Closure:**\n- Cattura environment per riferimento\n- Environment allocato nell'heap\n- Environment closure liberati propriamente quando non pi referenziati\n\n---\n\n## Modello di Concorrenza\n\n### Architettura Threading\n\nHemlock usa **threading 1:1** con POSIX threads (pthreads):\n\n```\nTask Utente          Thread OS          Core CPU\n---------            ---------          --------\nspawn(f1) ------->   pthread_create --> Core 0\nspawn(f2) ------->   pthread_create --> Core 1\nspawn(f3) ------->   pthread_create --> Core 2\n```\n\n**Caratteristiche chiave:**\n- Ogni `spawn()` crea un nuovo pthread\n- Kernel schedula thread sui core\n- Vera esecuzione parallela (nessun GIL)\n- Multitasking preemptive\n\n### Implementazione Task\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // Handle thread OS\n    Value result;            // Valore ritorno\n    char *error;             // Messaggio eccezione (se lanciata)\n    pthread_mutex_t lock;    // Protegge lo stato\n    TaskState state;         // RUNNING, FINISHED, ERROR\n} Task;\n```\n\n**Ciclo vita task:**\n1. `spawn(func, args)`  Crea Task, avvia pthread\n2. Thread esegue funzione con argomenti\n3. Al ritorno: Memorizza risultato, imposta stato a FINISHED\n4. All'eccezione: Memorizza messaggio errore, imposta stato a ERROR\n5. `join(task)`  Attende thread, restituisce risultato o lancia eccezione\n\n### Implementazione Channel\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Buffer circolare di Value*\n    size_t capacity;         // Elementi massimi bufferizzati\n    size_t count;            // Elementi correnti nel buffer\n    size_t read_index;       // Prossima posizione lettura\n    size_t write_index;      // Prossima posizione scrittura\n    bool closed;             // Flag canale chiuso\n    pthread_mutex_t lock;    // Protegge buffer\n    pthread_cond_t not_full; // Segnala quando spazio disponibile\n    pthread_cond_t not_empty;// Segnala quando dati disponibili\n} Channel;\n```\n\n**Operazione send:**\n1. Lock mutex\n2. Attendi se buffer pieno (cond_wait su not_full)\n3. Scrivi valore a buffer[write_index]\n4. Incrementa write_index (circolare)\n5. Segnala not_empty\n6. Unlock mutex\n\n**Operazione receive:**\n1. Lock mutex\n2. Attendi se buffer vuoto (cond_wait su not_empty)\n3. Leggi valore da buffer[read_index]\n4. Incrementa read_index (circolare)\n5. Segnala not_full\n6. Unlock mutex\n\n**Garanzie di sincronizzazione:**\n- send/recv thread-safe (protetti da mutex)\n- Semantica bloccante (produttore attende se pieno, consumatore attende se vuoto)\n- Consegna ordinata (FIFO all'interno di un canale)\n\n---\n\n## Piani Futuri\n\n### Completato: Backend Compilatore\n\nIl backend compilatore (`hemlockc`)  stato implementato con:\n- Generazione codice C da AST\n- Controllo tipi compile-time (abilitato di default)\n- Libreria runtime (`libhemlock_runtime.a`)\n- Parit completa con interprete (98% test pass rate)\n- Framework ottimizzazione unboxing\n\n### Focus Corrente: Miglioramenti Sistema Tipi\n\n**Miglioramenti recenti:**\n- Sistemi unificati controllo tipi e inferenza tipi\n- Controllo tipi compile-time abilitato di default\n- Flag `--check` per validazione solo tipi\n- Contesto tipi passato a codegen per hint ottimizzazione\n\n### Miglioramenti Futuri\n\n**Potenziali aggiunte:**\n- Generics/template\n- Pattern matching\n- Integrazione LSP per supporto IDE type-aware\n- Ottimizzazioni unboxing pi aggressive\n- Escape analysis per allocazione stack\n\n### Ottimizzazioni a Lungo Termine\n\n**Possibili miglioramenti:**\n- Inline caching per chiamate metodo\n- Compilazione JIT per hot path\n- Scheduler work-stealing per migliore concorrenza\n- Ottimizzazione profile-guided\n\n---\n\n## Linee Guida Implementazione\n\n### Aggiungere Nuove Funzionalit\n\nQuando si implementano nuove funzionalit, seguire queste linee guida:\n\n**1. Scegliere il modulo giusto:**\n- Nuovi tipi valore  `values.c`\n- Conversioni tipo  `types.c`\n- Funzioni integrate  `builtins.c`\n- Operazioni I/O  `io.c`\n- Flusso controllo  `runtime.c`\n\n**2. Aggiornare tutti i layer:**\n- Aggiungere tipi nodo AST se necessario (`ast.h`, `ast.c`)\n- Aggiungere token lexer se necessario (`lexer.c`)\n- Aggiungere regole parser (`parser.c`)\n- Implementare comportamento runtime (`runtime.c` o modulo appropriato)\n- Aggiungere test (`tests/`)\n\n**3. Mantenere consistenza:**\n- Seguire stile codice esistente\n- Usare convenzioni naming consistenti\n- Documentare API pubblica negli header\n- Mantenere messaggi errore chiari e consistenti\n\n**4. Testare approfonditamente:**\n- Aggiungere casi test prima di implementare\n- Testare percorsi successo ed errore\n- Testare casi limite\n- Verificare nessun memory leak (valgrind)\n\n### Considerazioni Prestazioni\n\n**Colli di bottiglia attuali:**\n- Lookup HashMap per accesso variabili\n- Chiamate funzione ricorsive (no TCO)\n- Concatenazione stringhe (alloca nuova stringa ogni volta)\n- Overhead controllo tipi su ogni operazione\n\n**Opportunit ottimizzazione:**\n- Cache posizioni variabili (inline caching)\n- Ottimizzazione tail call\n- String builder per concatenazione\n- Inferenza tipi per saltare controlli runtime\n\n### Suggerimenti Debug\n\n**Strumenti utili:**\n- `valgrind` - Rilevamento memory leak\n- `gdb` - Debug crash\n- Flag `-g` - Simboli debug\n- Debug con `printf` - Semplice ma efficace\n\n**Problemi comuni:**\n- Segfault  Dereferenziazione puntatore null (controlla valori ritorno)\n- Memory leak  Chiamata free() mancante (controlla percorsi value_free)\n- Errore tipo  Controlla logica type_convert() e type_check()\n- Crash nei thread  Race condition (controlla uso mutex)\n\n---\n\n## Conclusione\n\nL'implementazione di Hemlock priorizza:\n- **Modularit** - Chiara separazione responsabilit\n- **Semplicit** - Implementazione diretta\n- **Esplicitezza** - Nessuna magia nascosta\n- **Manutenibilit** - Facile da capire e modificare\n\nL'attuale interprete tree-walking  intenzionalmente semplice per facilitare lo sviluppo rapido di funzionalit e la sperimentazione. Il futuro backend compilatore migliorer le prestazioni mantenendo la stessa semantica.\n"}, "Design e Filosofia -> Sintassi delle Firme": {"id": "design-signature-syntax", "content": "# Design della Sintassi delle Firme\n\n> Estensione del sistema di tipi di Hemlock con tipi funzione, modificatori nullable, alias di tipo, parametri const e firme di metodo.\n\n**Stato:** Implementato (v1.7.0)\n**Versione:** 1.0\n**Autore:** Claude\n\n---\n\n## Panoramica\n\nQuesto documento propone cinque estensioni interconnesse del sistema di tipi che si basano sull'infrastruttura esistente di Hemlock:\n\n1. **Annotazioni Tipo Funzione** - Tipi funzione di prima classe\n2. **Modificatori Tipo Nullable** - Gestione esplicita del null (estende flag `nullable` esistente)\n3. **Alias di Tipo** - Abbreviazioni di tipo con nome\n4. **Parametri Const** - Contratti di immutabilit\n5. **Firme di Metodo in Define** - Comportamento simile a interfacce\n\nQueste funzionalit condividono la filosofia: **esplicito su implicito, opzionale ma applicato quando usato**.\n\n---\n\n## 1. Annotazioni Tipo Funzione\n\n### Motivazione\n\nAttualmente, non c' modo di esprimere la firma di una funzione come tipo:\n\n```hemlock\n// Attuale: callback non ha informazioni di tipo\nfn map(arr: array, callback) { ... }\n\n// Proposto: tipo funzione esplicito\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### Sintassi\n\n```hemlock\n// Tipo funzione base\nfn(i32, i32): i32\n\n// Con nomi parametri (solo documentazione, non applicati)\nfn(a: i32, b: i32): i32\n\n// Nessun valore ritorno (void)\nfn(string): void\nfn(string)              // Abbreviazione: ometti `: void`\n\n// Ritorno nullable\nfn(i32): string?\n\n// Parametri opzionali\nfn(nome: string, eta?: i32): void\n\n// Parametri rest\nfn(...args: array): i32\n\n// Nessun parametro\nfn(): bool\n\n// Ordine superiore: funzione che restituisce funzione\nfn(i32): fn(i32): i32\n\n// Tipo funzione async\nasync fn(i32): i32\n```\n\n### Esempi d'Uso\n\n```hemlock\n// Variabile con tipo funzione\nlet somma: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Parametro funzione\nfn applica(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Tipo ritorno  funzione\nfn crea_sommatore(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Array di funzioni\nlet ops: array<fn(i32, i32): i32> = [somma, sottrai, moltiplica];\n\n// Campo oggetto\ndefine EventHandler {\n    nome: string;\n    callback: fn(Event): void;\n}\n```\n\n### Modifiche AST\n\n```c\n// In enum TypeKind (include/ast.h)\ntypedef enum {\n    // ... tipi esistenti ...\n    TYPE_FUNCTION,      // NUOVO: Tipo funzione\n} TypeKind;\n\n// In struct Type (include/ast.h)\nstruct Type {\n    TypeKind kind;\n    // ... campi esistenti ...\n\n    // Per TYPE_FUNCTION:\n    struct Type **param_types;      // Tipi parametri\n    char **param_names;             // Nomi parametri opzionali (docs)\n    int *param_optional;            // Quali param sono opzionali\n    int num_params;\n    char *rest_param_name;          // Nome parametro rest o NULL\n    struct Type *rest_param_type;   // Tipo parametro rest\n    struct Type *return_type;       // Tipo ritorno (NULL = void)\n    int is_async;                   // tipo fn async\n};\n```\n\n### Parsing\n\nI tipi funzione iniziano con `fn` (o `async fn`) seguito dalla lista parametri:\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**Disambiguazione:** Quando si parsa un tipo e si incontra `fn`:\n- Se seguito da `(`,  un tipo funzione\n- Altrimenti, errore di sintassi (`fn` da solo non  un tipo valido)\n\n### Compatibilit Tipi\n\n```hemlock\n// Match esatto richiesto per tipi funzione\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK\n\n// Controvarianza parametri (accettare tipi pi ampi  OK)\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Covarianza ritorno (restituire tipi pi ristretti  OK)\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Arit deve corrispondere\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // ERRORE: mismatch arit\n\n// Parametri opzionali compatibili con richiesti\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK\n```\n\n---\n\n## 2. Modificatori Tipo Nullable\n\n### Motivazione\n\nIl suffisso `?` rende esplicita l'accettazione del null nelle firme:\n\n```hemlock\n// Attuale: non chiaro se null  valido\nfn trova(arr: array, val: any): i32 { ... }\n\n// Proposto: ritorno nullable esplicito\nfn trova(arr: array, val: any): i32? { ... }\n```\n\n### Sintassi\n\n```hemlock\n// Tipi nullable con suffisso ?\nstring?           // stringa o null\ni32?              // i32 o null\nUtente?           // Utente o null\narray<i32>?       // array o null\nfn(i32): i32?     // funzione che restituisce i32 o null\n\n// Composizione con tipi funzione\nfn(string?): i32          // Accetta stringa o null\nfn(string): i32?          // Restituisce i32 o null\nfn(string?): i32?         // Entrambi nullable\n\n// In define\ndefine Risultato {\n    valore: any?;\n    errore: string?;\n}\n```\n\n### Note Implementazione\n\n**Gi esiste:** Il flag `Type.nullable`  gi nell'AST. Questa funzionalit necessita principalmente:\n1. Supporto parser per suffisso `?` su qualsiasi tipo (verificare/estendere)\n2. Composizione corretta con tipi funzione\n3. Applicazione runtime\n\n### Compatibilit Tipi\n\n```hemlock\n// Non-nullable assegnabile a nullable\nlet x: i32? = 42;           // OK\nlet y: i32? = null;         // OK\n\n// Nullable NON assegnabile a non-nullable\nlet z: i32 = x;             // ERRORE: x potrebbe essere null\n\n// Null coalescing per unwrap\nlet z: i32 = x ?? 0;        // OK: ?? fornisce default\n\n// Optional chaining restituisce nullable\nlet nome: string? = utente?.nome;\n```\n\n---\n\n## 3. Alias di Tipo\n\n### Motivazione\n\nTipi complessi beneficiano di abbreviazioni con nome:\n\n```hemlock\n// Attuale: tipi composti ripetitivi\nfn elabora(entita: HaNome & HaId & HaTimestamp) { ... }\nfn valida(entita: HaNome & HaId & HaTimestamp) { ... }\n\n// Proposto: alias con nome\ntype Entita = HaNome & HaId & HaTimestamp;\nfn elabora(entita: Entita) { ... }\nfn valida(entita: Entita) { ... }\n```\n\n### Sintassi\n\n```hemlock\n// Alias base\ntype Intero = i32;\ntype Testo = string;\n\n// Alias tipo composto\ntype Entita = HaNome & HaId;\ntype Auditabile = HaCreatoIl & HaModificatoIl & HaCreadaDa;\n\n// Alias tipo funzione\ntype Callback = fn(Evento): void;\ntype Predicato = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype TaskAsync = async fn(): any;\n\n// Alias nullable\ntype StringaOpzionale = string?;\n\n// Alias generico (se supportiamo alias tipo generici)\ntype Coppia<T> = { primo: T, secondo: T };\ntype Risultato<T, E> = { valore: T?, errore: E? };\n\n// Alias tipo array\ntype ArrayInt = array<i32>;\ntype Matrice = array<array<f64>>;\n```\n\n### Scope e Visibilit\n\n```hemlock\n// Scope modulo di default\ntype Callback = fn(Evento): void;\n\n// Esportabile\nexport type Handler = fn(Request): Response;\n\n// In altro file\nimport { Handler } from \"./handlers.hml\";\nfn registra(h: Handler) { ... }\n```\n\n### Modifiche AST\n\n```c\n// Nuovo tipo istruzione\ntypedef enum {\n    // ... istruzioni esistenti ...\n    STMT_TYPE_ALIAS,    // NUOVO\n} StmtKind;\n\n// In union Stmt\nstruct {\n    char *name;                 // Nome alias\n    char **type_params;         // Param generici: <T, U>\n    int num_type_params;\n    Type *aliased_type;         // Il tipo effettivo\n} type_alias;\n```\n\n### Parsing\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**Nota:** `type`  una nuova parola chiave. Verifica conflitti con identificatori esistenti.\n\n### Risoluzione\n\nGli alias di tipo sono risolti a:\n- **Tempo di parse:** Alias registrato in type environment\n- **Tempo di controllo:** Alias espanso a tipo sottostante\n- **Runtime:** Alias  trasparente (stesso del tipo sottostante)\n\n```hemlock\ntype MioInt = i32;\nlet x: MioInt = 42;\ntypeof(x);           // \"i32\" (non \"MioInt\")\n```\n\n---\n\n## 4. Parametri Const\n\n### Motivazione\n\nSegnala l'intento di immutabilit nelle firme di funzione:\n\n```hemlock\n// Attuale: non chiaro se array sar modificato\nfn stampa_tutti(elementi: array) { ... }\n\n// Proposto: contratto di immutabilit esplicito\nfn stampa_tutti(const elementi: array) { ... }\n```\n\n### Sintassi\n\n```hemlock\n// Parametro const\nfn elabora(const dati: buffer) {\n    // dati[0] = 0;        // ERRORE: non pu mutare const\n    let x = dati[0];       // OK: lettura permessa\n    return x;\n}\n\n// Pi parametri const\nfn confronta(const a: array, const b: array): bool { ... }\n\n// Const e mutabile misti\nfn aggiorna(const sorgente: array, destinazione: array) {\n    for (elem in sorgente) {\n        destinazione.push(elem);   // OK: destinazione  mutabile\n    }\n}\n\n// Const con inferenza tipo\nfn log(const msg) {\n    print(msg);\n}\n\n// Const in tipi funzione\ntype Lettore = fn(const buffer): i32;\n```\n\n### Cosa Previene Const\n\n```hemlock\nfn cattivo(const arr: array) {\n    arr.push(1);         // ERRORE: metodo mutante\n    arr.pop();           // ERRORE: metodo mutante\n    arr[0] = 5;          // ERRORE: assegnazione indice\n    arr.clear();         // ERRORE: metodo mutante\n}\n\nfn buono(const arr: array) {\n    let x = arr[0];      // OK: lettura\n    let lun = len(arr);  // OK: controllo lunghezza\n    let copia = arr.slice(0, 10);  // OK: crea nuovo array\n    for (elem in arr) {  // OK: iterazione\n        print(elem);\n    }\n}\n```\n\n### Metodi Mutanti vs Non-Mutanti\n\n| Tipo | Mutanti (bloccati da const) | Non-Mutanti (permessi) |\n|------|----------------------------|------------------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |\n| string | assegnazione indice (`s[0] = 'x'`) | tutti i metodi (restituiscono nuove stringhe) |\n| buffer | assegnazione indice, memset, memcpy (verso) | lettura indice, slice |\n| object | assegnazione campo | lettura campo |\n\n### Modifiche AST\n\n```c\n// In espressione funzione (include/ast.h)\nstruct {\n    // ... campi esistenti ...\n    int *param_is_const;    // NUOVO: 1 se const, 0 altrimenti\n} function;\n\n// In struct Type per tipi funzione\nstruct Type {\n    // ... campi esistenti ...\n    int *param_is_const;    // Per TYPE_FUNCTION\n};\n```\n\n### Applicazione\n\n**Interprete:**\n- Traccia const-ness nei binding variabili\n- Verifica prima delle operazioni di mutazione\n- Errore runtime su violazione const\n\n**Compilatore:**\n- Emetti variabili C const-qualified dove benefico\n- Analisi statica per violazioni const\n- Warning/errore a compile-time\n\n---\n\n## 5. Firme di Metodo in Define\n\n### Motivazione\n\nPermette ai blocchi `define` di specificare metodi attesi, non solo campi dati:\n\n```hemlock\n// Attuale: solo campi dati\ndefine Utente {\n    nome: string;\n    eta: i32;\n}\n\n// Proposto: firme metodo\ndefine Comparabile {\n    fn confronta(altro: Self): i32;\n}\n\ndefine Serializzabile {\n    fn serializza(): string;\n    fn deserializza(dati: string): Self;  // Metodo statico\n}\n```\n\n### Sintassi\n\n```hemlock\n// Firma metodo (nessun corpo)\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// Metodi multipli\ndefine Collezione {\n    fn dimensione(): i32;\n    fn e_vuota(): bool;\n    fn contiene(elemento: any): bool;\n}\n\n// Campi e metodi misti\ndefine Entita {\n    id: i32;\n    nome: string;\n    fn valida(): bool;\n    fn serializza(): string;\n}\n\n// Usando tipo Self\ndefine Clonabile {\n    fn clona(): Self;\n}\n\ndefine Comparabile {\n    fn confronta(altro: Self): i32;\n    fn uguale(altro: Self): bool;\n}\n\n// Metodi opzionali\ndefine Stampabile {\n    fn to_string(): string;\n    fn debug_string?(): string;  // Metodo opzionale (pu essere assente)\n}\n\n// Metodi con implementazione default\ndefine Ordinato {\n    fn confronta(altro: Self): i32;  // Richiesto\n\n    // Implementazioni default (ereditate se non sovrascritte)\n    fn minore_di(altro: Self): bool {\n        return self.confronta(altro) < 0;\n    }\n    fn maggiore_di(altro: Self): bool {\n        return self.confronta(altro) > 0;\n    }\n    fn uguale(altro: Self): bool {\n        return self.confronta(altro) == 0;\n    }\n}\n```\n\n### Il Tipo `Self`\n\n`Self` si riferisce al tipo concreto che implementa l'interfaccia:\n\n```hemlock\ndefine Sommabile {\n    fn somma(altro: Self): Self;\n}\n\n// Quando usato:\nlet a: Sommabile = {\n    valore: 10,\n    somma: fn(altro) {\n        return { valore: self.valore + altro.valore, somma: self.somma };\n    }\n};\n```\n\n### Tipizzazione Strutturale (Duck Typing)\n\nLe firme metodo usano lo stesso duck typing dei campi:\n\n```hemlock\ndefine Stringificabile {\n    fn to_string(): string;\n}\n\n// Qualsiasi oggetto con metodo to_string() soddisfa Stringificabile\nlet x: Stringificabile = {\n    nome: \"test\",\n    to_string: fn() { return self.nome; }\n};\n\n// Tipi composti con metodi\ndefine Nominato { nome: string; }\ndefine Stampabile { fn to_string(): string; }\n\ntype NominatoStampabile = Nominato & Stampabile;\n\nlet y: NominatoStampabile = {\n    nome: \"Alice\",\n    to_string: fn() { return \"Nome: \" + self.nome; }\n};\n```\n\n### Modifiche AST\n\n```c\n// Estendi define_object in union Stmt\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // Campi (esistenti)\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // Metodi (NUOVO)\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // Metodi opzionali (fn nome?(): tipo)\n    Expr **method_defaults;     // Implementazioni default (NULL se solo firma)\n    int num_methods;\n} define_object;\n```\n\n### Controllo Tipi\n\nQuando si controlla `valore: TipoInterfaccia`:\n1. Verifica tutti i campi richiesti esistano con tipi compatibili\n2. Verifica tutti i metodi richiesti esistano con firme compatibili\n3. Campi/metodi opzionali possono essere assenti\n\n```hemlock\ndefine Ordinabile {\n    fn confronta(altro: Self): i32;\n}\n\n// Valido: ha metodo confronta\nlet valido: Ordinabile = {\n    valore: 10,\n    confronta: fn(altro) { return self.valore - altro.valore; }\n};\n\n// Non valido: manca confronta\nlet invalido: Ordinabile = { valore: 10 };  // ERRORE: metodo 'confronta' mancante\n\n// Non valido: firma sbagliata\nlet sbagliato: Ordinabile = {\n    confronta: fn() { return 0; }  // ERRORE: atteso (Self): i32\n};\n```\n\n---\n\n## Esempi di Interazione\n\n### Combinare Tutte le Funzionalit\n\n```hemlock\n// Alias tipo per tipo funzione complesso\ntype CallbackEvento = fn(evento: Evento, contesto: Contesto?): bool;\n\n// Alias tipo per interfaccia composta\ntype Entita = HaId & HaNome & Serializzabile;\n\n// Define con firme metodo\ndefine Repository<T> {\n    fn trova(id: i32): T?;\n    fn salva(const entita: T): bool;\n    fn elimina(id: i32): bool;\n    fn trova_tutti(predicato: fn(T): bool): array<T>;\n}\n\n// Usare tutto insieme\nfn crea_repo_utente(): Repository<Utente> {\n    let utenti: array<Utente> = [];\n\n    return {\n        trova: fn(id) {\n            for (u in utenti) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        salva: fn(const entita) {\n            utenti.push(entita);\n            return true;\n        },\n        elimina: fn(id) {\n            // ...\n            return true;\n        },\n        trova_tutti: fn(predicato) {\n            return utenti.filter(predicato);\n        }\n    };\n}\n```\n\n### Callback con Tipi Espliciti\n\n```hemlock\ntype ClickHandler = fn(evento: MouseEvent): void;\ntype KeyHandler = fn(evento: KeyEvent, modificatori: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn crea_pulsante(etichetta: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### Tipi Funzione Nullable\n\n```hemlock\n// Callback opzionale\nfn fetch(url: string, on_completo: fn(Response): void?): void {\n    let risposta = http_get(url);\n    if (on_completo != null) {\n        on_completo(risposta);\n    }\n}\n\n// Ritorno nullable da tipo funzione\ntype Parser = fn(input: string): AST?;\n\nfn prova_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let risultato = p(input);\n        if (risultato != null) {\n            return risultato;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## Roadmap Implementazione\n\n### Fase 1: Infrastruttura Core\n1. Aggiungere `TYPE_FUNCTION` a enum TypeKind\n2. Estendere struct Type con campi tipo funzione\n3. Aggiungere `CHECKED_FUNCTION` al type checker del compilatore\n4. Aggiungere supporto tipo `Self` (TYPE_SELF)\n\n### Fase 2: Parsing\n1. Implementare `parse_function_type()` nel parser\n2. Gestire `fn(...)` in posizione tipo\n3. Aggiungere parola chiave `type` e parsing `STMT_TYPE_ALIAS`\n4. Aggiungere parsing modificatore parametro `const`\n5. Estendere parsing define per firme metodo\n\n### Fase 3: Controllo Tipi\n1. Regole compatibilit tipi funzione\n2. Risoluzione ed espansione alias tipo\n3. Controllo mutazione parametri const\n4. Validazione firme metodo in tipi define\n5. Risoluzione tipo Self\n\n### Fase 4: Runtime\n1. Validazione tipo funzione ai call site\n2. Rilevamento violazione const\n3. Trasparenza alias tipo\n\n### Fase 5: Test Parit\n1. Test annotazione tipo funzione\n2. Test composizione nullable\n3. Test alias tipo\n4. Test parametri const\n5. Test firme metodo\n\n---\n\n## Decisioni di Design\n\n### 1. Alias Tipo Generici: **S**\n\nGli alias tipo supportano parametri generici:\n\n```hemlock\n// Alias tipo generici\ntype Coppia<T> = { primo: T, secondo: T };\ntype Risultato<T, E> = { valore: T?, errore: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// Uso\nlet coord: Coppia<f64> = { primo: 3.14, secondo: 2.71 };\nlet risultato: Risultato<Utente, string> = { valore: utente, errore: null };\nlet trasforma: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Propagazione Const: **PROFONDA**\n\nI parametri const sono completamente immutabili - nessuna mutazione attraverso nessun percorso:\n\n```hemlock\nfn elabora(const arr: array<object>) {\n    arr.push({});        // ERRORE: non pu mutare array const\n    arr[0] = {};         // ERRORE: non pu mutare array const\n    arr[0].x = 5;        // ERRORE: non pu mutare attraverso const (PROFONDO)\n\n    let x = arr[0].x;    // OK: lettura  permessa\n    let copia = arr[0];  // OK: crea una copia\n    copia.x = 5;         // OK: copia non  const\n}\n\nfn annidato(const obj: object) {\n    obj.utente.nome = \"x\"; // ERRORE: const profondo previene mutazione annidata\n    obj.elementi[0] = 1;   // ERRORE: const profondo previene mutazione annidata\n}\n```\n\n**Motivazione:** Const profondo fornisce garanzie pi forti ed  pi utile per\nassicurare l'integrit dei dati. Se devi mutare dati annidati, fai prima una copia.\n\n### 3. Self in Alias Tipo Standalone: **NO**\n\n`Self`  valido solo dentro blocchi `define` dove ha significato chiaro:\n\n```hemlock\n// Valido: Self si riferisce al tipo definito\ndefine Comparabile {\n    fn confronta(altro: Self): i32;\n}\n\n// Non valido: Self non ha significato qui\ntype Clonatore = fn(Self): Self;  // ERRORE: Self fuori contesto define\n\n// Invece, usa generici:\ntype Clonatore<T> = fn(T): T;\n```\n\n### 4. Implementazioni Metodo Default: **S (Solo Semplici)**\n\nPermetti implementazioni default per metodi semplici/utility:\n\n```hemlock\ndefine Comparabile {\n    // Richiesto: deve essere implementato\n    fn confronta(altro: Self): i32;\n\n    // Implementazioni default (metodi convenience semplici)\n    fn uguale(altro: Self): bool {\n        return self.confronta(altro) == 0;\n    }\n    fn minore_di(altro: Self): bool {\n        return self.confronta(altro) < 0;\n    }\n    fn maggiore_di(altro: Self): bool {\n        return self.confronta(altro) > 0;\n    }\n}\n\ndefine Stampabile {\n    fn to_string(): string;\n\n    // Default: delega a metodo richiesto\n    fn stampa() {\n        print(self.to_string());\n    }\n    fn stampa_ln() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// L'oggetto deve solo implementare i metodi richiesti\nlet elemento: Comparabile = {\n    valore: 42,\n    confronta: fn(altro) { return self.valore - altro.valore; }\n    // uguale, minore_di, maggiore_di sono ereditati dai default\n};\n\nelemento.minore_di({ valore: 50, confronta: elemento.confronta });  // true\n```\n\n**Linee guida per i default:**\n- Mantienili semplici (1-3 righe)\n- Dovrebbero delegare a metodi richiesti\n- Nessuna logica complessa o effetti collaterali\n- Solo primitive e composizioni dirette\n\n### 5. Varianza: **INFERITA (Nessuna Annotazione Esplicita)**\n\nLa varianza  inferita da come sono usati i parametri tipo:\n\n```hemlock\n// La varianza  automatica in base alla posizione\ntype Produttore<T> = fn(): T;           // T in ritorno = covariante\ntype Consumatore<T> = fn(T): void;      // T in parametro = controvariante\ntype Trasformatore<T> = fn(T): T;       // T in entrambi = invariante\n\n// Esempio: Cane <: Animale (Cane  sottotipo di Animale)\nlet produttore_cane: Produttore<Cane> = fn() { return nuovo_cane(); };\nlet produttore_animale: Produttore<Animale> = produttore_cane;  // OK: covariante\n\nlet consumatore_animale: Consumatore<Animale> = fn(a) { print(a); };\nlet consumatore_cane: Consumatore<Cane> = consumatore_animale;  // OK: controvariante\n```\n\n**Perch inferire?**\n- Meno boilerplate (`<out T>` / `<in T>` aggiunge rumore)\n- Segue \"esplicito su implicito\" - la posizione  esplicita\n- Corrisponde a come la maggior parte dei linguaggi gestisce la varianza dei tipi funzione\n- Gli errori sono chiari quando le regole di varianza sono violate\n\n---\n\n## Appendice: Modifiche Grammatica\n\n```ebnf\n(* Tipi *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* Istruzioni *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" marca metodo opzionale, block fornisce implementazione default *)\n\n(* Parametri *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "Contribuire -> Linee Guida": {"id": "contributing-guidelines", "content": "# Contribuire a Hemlock\n\nGrazie per il tuo interesse a contribuire a Hemlock! Questa guida ti aiutera a capire come contribuire efficacemente mantenendo la filosofia di design del linguaggio e la qualita del codice.\n\n---\n\n## Indice\n\n- [Prima di Iniziare](#prima-di-iniziare)\n- [Flusso di Lavoro per i Contributi](#flusso-di-lavoro-per-i-contributi)\n- [Linee Guida sullo Stile del Codice](#linee-guida-sullo-stile-del-codice)\n- [Cosa Contribuire](#cosa-contribuire)\n- [Cosa NON Contribuire](#cosa-non-contribuire)\n- [Pattern Comuni](#pattern-comuni)\n- [Aggiungere Nuove Funzionalita](#aggiungere-nuove-funzionalita)\n- [Processo di Code Review](#processo-di-code-review)\n\n---\n\n## Prima di Iniziare\n\n### Letture Obbligatorie\n\nPrima di contribuire, leggi questi documenti nell'ordine indicato:\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Comprendi i principi fondamentali di Hemlock\n2. **`/home/user/hemlock/docs/design/implementation.md`** - Impara la struttura del codebase\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - Comprendi i requisiti di testing\n4. **Questo documento** - Impara le linee guida per i contributi\n\n### Prerequisiti\n\n**Conoscenze richieste:**\n- Programmazione C (puntatori, gestione della memoria, struct)\n- Basi di compilatori/interpreti (lexing, parsing, AST)\n- Flusso di lavoro Git e GitHub\n- Linea di comando Unix/Linux\n\n**Strumenti richiesti:**\n- Compilatore GCC o Clang\n- Sistema di build Make\n- Controllo versione Git\n- Valgrind (per rilevare memory leak)\n- Editor di testo o IDE di base\n\n### Canali di Comunicazione\n\n**Dove fare domande:**\n- GitHub Issues - Segnalazioni di bug e richieste di funzionalita\n- GitHub Discussions - Domande generali e discussioni sul design\n- Commenti sulle Pull Request - Feedback specifico sul codice\n\n---\n\n## Flusso di Lavoro per i Contributi\n\n### 1. Trova o Crea una Issue\n\n**Prima di scrivere codice:**\n- Verifica se esiste gia una issue per il tuo contributo\n- Se non esiste, creane una descrivendo cosa vuoi fare\n- Aspetta il feedback dei maintainer prima di iniziare modifiche importanti\n- Piccole correzioni di bug possono saltare questo passaggio\n\n**Una buona descrizione della issue include:**\n- Descrizione del problema (cosa non funziona o manca)\n- Soluzione proposta (come intendi risolverlo)\n- Esempi (snippet di codice che mostrano il problema)\n- Motivazione (perche questa modifica e in linea con la filosofia di Hemlock)\n\n### 2. Fork e Clone\n\n```bash\n# Prima fai il fork del repository su GitHub, poi:\ngit clone https://github.com/TUO_USERNAME/hemlock.git\ncd hemlock\ngit checkout -b feature/nome-della-tua-feature\n```\n\n### 3. Apporta le Tue Modifiche\n\nSegui queste linee guida:\n- Scrivi i test prima (approccio TDD)\n- Implementa la funzionalita\n- Assicurati che tutti i test passino\n- Controlla la presenza di memory leak\n- Aggiorna la documentazione\n\n### 4. Testa le Tue Modifiche\n\n```bash\n# Esegui l'intera suite di test\nmake test\n\n# Esegui una categoria di test specifica\n./tests/run_tests.sh tests/category/\n\n# Controlla i memory leak\nvalgrind ./hemlock tests/your_test.hml\n\n# Compila e testa\nmake clean && make && make test\n```\n\n### 5. Esegui il Commit delle Modifiche\n\n**Buoni messaggi di commit:**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**Formato del messaggio di commit:**\n- Prima riga: Breve riepilogo (max 50 caratteri)\n- Riga vuota\n- Spiegazione dettagliata (a capo a 72 caratteri)\n- Riferimento ai numeri delle issue\n\n### 6. Invia una Pull Request\n\n**Prima di inviare:**\n- Rebase sull'ultimo branch main\n- Assicurati che tutti i test passino\n- Esegui valgrind per controllare i leak\n- Aggiorna CLAUDE.md se aggiungi funzionalita visibili all'utente\n\n**La descrizione della pull request dovrebbe includere:**\n- Quale problema risolve\n- Come lo risolve\n- Modifiche che rompono la compatibilita (se presenti)\n- Esempi della nuova sintassi o comportamento\n- Riepilogo della copertura dei test\n\n---\n\n## Linee Guida sullo Stile del Codice\n\n### Stile del Codice C\n\n**Formattazione:**\n```c\n// Indenta con 4 spazi (niente tab)\n// Stile K&R per le parentesi nelle funzioni\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // Parentesi sulla stessa riga per le strutture di controllo\n        do_something();\n    }\n}\n\n// Lunghezza riga: max 100 caratteri\n// Usa spazi intorno agli operatori\nint result = (a + b) * c;\n\n// Asterisco del puntatore con il tipo\nchar *string;   // Corretto\nchar* string;   // Evitare\nchar * string;  // Evitare\n```\n\n**Convenzioni di denominazione:**\n```c\n// Funzioni: minuscolo_con_underscore\nvoid eval_expression(ASTNode *node);\n\n// Tipi: PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// Costanti: MAIUSCOLO_CON_UNDERSCORE\n#define MAX_BUFFER_SIZE 4096\n\n// Variabili: minuscolo_con_underscore\nint item_count;\nValue *current_value;\n\n// Enum: PREFISSO_TIPO_NOME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**Commenti:**\n```c\n// Commenti su una riga per brevi spiegazioni\n// Usa frasi complete con corretta maiuscola\n\n/*\n * Commenti multi-riga per spiegazioni piu lunghe\n * Allinea gli asterischi per leggibilita\n */\n\n/**\n * Commento di documentazione della funzione\n * @param node - Nodo AST da valutare\n * @return Valore valutato\n */\nValue eval_expr(ASTNode *node);\n```\n\n**Gestione degli errori:**\n```c\n// Controlla tutte le chiamate malloc\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Error: Out of memory\\n\");\n    exit(1);\n}\n\n// Fornisci contesto nei messaggi di errore\nif (file == NULL) {\n    fprintf(stderr, \"Error: Failed to open '%s': %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// Usa messaggi di errore significativi\n// Male: \"Error: Invalid value\"\n// Bene: \"Error: Expected integer, got string\"\n```\n\n**Gestione della memoria:**\n```c\n// Libera sempre cio che allochi\nValue *val = value_create_i32(42);\n// ... usa val\nvalue_free(val);\n\n// Imposta i puntatori a NULL dopo averli liberati (previene double-free)\nfree(ptr);\nptr = NULL;\n\n// Documenta la proprieta nei commenti\n// Questa funzione prende la proprieta di 'value' e lo liberera\nvoid store_value(Value *value);\n\n// Questa funzione NON prende la proprieta (il chiamante deve liberare)\nValue *get_value(void);\n```\n\n### Organizzazione del Codice\n\n**Struttura dei file:**\n```c\n// 1. Include (prima header di sistema, poi locali)\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. Costanti e macro\n#define INITIAL_CAPACITY 16\n\n// 3. Definizioni di tipo\ntypedef struct Foo Foo;\n\n// 4. Dichiarazioni di funzioni statiche (helper interni)\nstatic void helper_function(void);\n\n// 5. Implementazioni delle funzioni pubbliche\nvoid public_api_function(void)\n{\n    // Implementazione\n}\n\n// 6. Implementazioni delle funzioni statiche\nstatic void helper_function(void)\n{\n    // Implementazione\n}\n```\n\n**File header:**\n```c\n// Usa header guard\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// Dichiarazioni forward\ntypedef struct Value Value;\n\n// Solo API pubblica negli header\nvoid public_function(Value *val);\n\n// Documenta parametri e valori di ritorno\n/**\n * Valuta un nodo AST di espressione\n * @param node - Il nodo AST da valutare\n * @param env - L'ambiente corrente\n * @return Il valore risultante\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## Cosa Contribuire\n\n### Contributi Incoraggiati\n\n**Correzioni di bug:**\n- Memory leak\n- Segmentation fault\n- Comportamenti errati\n- Miglioramenti ai messaggi di errore\n\n**Documentazione:**\n- Commenti nel codice\n- Documentazione delle API\n- Guide utente e tutorial\n- Programmi di esempio\n- Documentazione dei casi di test\n\n**Test:**\n- Casi di test aggiuntivi per funzionalita esistenti\n- Copertura dei casi limite\n- Test di regressione per bug corretti\n- Benchmark delle prestazioni\n\n**Piccole aggiunte di funzionalita:**\n- Nuove funzioni built-in (se si adattano alla filosofia)\n- Metodi per stringhe/array\n- Funzioni di utilita\n- Miglioramenti alla gestione degli errori\n\n**Miglioramenti delle prestazioni:**\n- Algoritmi piu veloci (senza cambiare la semantica)\n- Riduzione dell'uso della memoria\n- Suite di benchmark\n- Strumenti di profiling\n\n**Strumenti:**\n- Evidenziazione della sintassi per editor\n- Language Server Protocol (LSP)\n- Integrazione con debugger\n- Miglioramenti al sistema di build\n\n### Discuti Prima\n\n**Funzionalita importanti:**\n- Nuovi costrutti del linguaggio\n- Modifiche al sistema di tipi\n- Aggiunte alla sintassi\n- Primitive di concorrenza\n\n**Come discutere:**\n1. Apri una issue o discussione su GitHub\n2. Descrivi la funzionalita e la motivazione\n3. Mostra codice di esempio\n4. Spiega come si adatta alla filosofia di Hemlock\n5. Aspetta il feedback dei maintainer\n6. Itera sul design prima di implementare\n\n---\n\n## Cosa NON Contribuire\n\n### Contributi Scoraggiati\n\n**Non aggiungere funzionalita che:**\n- Nascondono complessita all'utente\n- Rendono il comportamento implicito o magico\n- Rompono semantica o sintassi esistenti\n- Aggiungono garbage collection o gestione automatica della memoria\n- Violano il principio \"esplicito piuttosto che implicito\"\n\n**Esempi di contributi rifiutati:**\n\n**1. Inserimento automatico del punto e virgola**\n```hemlock\n// MALE: Questo verrebbe rifiutato\nlet x = 5  // Nessun punto e virgola\nlet y = 10 // Nessun punto e virgola\n```\nPerche: Rende la sintassi ambigua, nasconde gli errori\n\n**2. RAII/distruttori**\n```hemlock\n// MALE: Questo verrebbe rifiutato\nlet f = open(\"file.txt\");\n// File chiuso automaticamente alla fine dello scope\n```\nPerche: Nasconde quando le risorse vengono rilasciate, non e esplicito\n\n**3. Coercizione implicita di tipo che perde dati**\n```hemlock\n// MALE: Questo verrebbe rifiutato\nlet x: i32 = 3.14;  // Tronca silenziosamente a 3\n```\nPerche: La perdita di dati dovrebbe essere esplicita, non silenziosa\n\n**4. Garbage collection**\n```c\n// MALE: Questo verrebbe rifiutato\nvoid *gc_malloc(size_t size) {\n    // Traccia l'allocazione per pulizia automatica\n}\n```\nPerche: Nasconde la gestione della memoria, prestazioni imprevedibili\n\n**5. Sistema di macro complesso**\n```hemlock\n// MALE: Questo verrebbe rifiutato\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\nPerche: Troppa magia, rende il codice difficile da ragionare\n\n### Motivi Comuni di Rifiuto\n\n**\"Questo e troppo implicito\"**\n- Soluzione: Rendi il comportamento esplicito e documentalo\n\n**\"Questo nasconde complessita\"**\n- Soluzione: Esponi la complessita ma rendila ergonomica\n\n**\"Questo rompe il codice esistente\"**\n- Soluzione: Trova un'alternativa non distruttiva o discuti il versioning\n\n**\"Questo non si adatta alla filosofia di Hemlock\"**\n- Soluzione: Rileggi philosophy.md e riconsidera l'approccio\n\n---\n\n## Pattern Comuni\n\n### Pattern per la Gestione degli Errori\n\n```c\n// Usa questo pattern per errori recuperabili nel codice Hemlock\nValue *divide(Value *a, Value *b)\n{\n    // Controlla le precondizioni\n    if (b->type != TYPE_I32) {\n        // Restituisci valore di errore o solleva eccezione\n        return create_error(\"Expected integer divisor\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division by zero\");\n    }\n\n    // Esegui l'operazione\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### Pattern per la Gestione della Memoria\n\n```c\n// Pattern: Alloca, usa, libera\nvoid process_data(void)\n{\n    // Alloca\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // Usa\n    if (buf && str) {\n        // ... fai il lavoro\n    }\n\n    // Libera (in ordine inverso rispetto all'allocazione)\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### Pattern per la Creazione di Valori\n\n```c\n// Crea valori usando i costruttori\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### Pattern per il Controllo dei Tipi\n\n```c\n// Controlla i tipi prima delle operazioni\nValue *add_values(Value *a, Value *b)\n{\n    // Controllo dei tipi\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Type mismatch\");\n    }\n\n    // Sicuro procedere\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### Pattern per la Costruzione di Stringhe\n\n```c\n// Costruisci stringhe in modo efficiente\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Error: %s (line %d)\", detail, line_number);\n}\n```\n\n---\n\n## Aggiungere Nuove Funzionalita\n\n### Checklist per l'Aggiunta di Funzionalita\n\nQuando aggiungi una nuova funzionalita, segui questi passaggi:\n\n#### 1. Fase di Design\n\n- [ ] Leggi philosophy.md per assicurarti dell'allineamento\n- [ ] Crea una issue su GitHub che descrive la funzionalita\n- [ ] Ottieni l'approvazione dei maintainer per il design\n- [ ] Scrivi la specifica (sintassi, semantica, esempi)\n- [ ] Considera i casi limite e le condizioni di errore\n\n#### 2. Fase di Implementazione\n\n**Se aggiungi un costrutto del linguaggio:**\n\n- [ ] Aggiungi il tipo di token in `lexer.h` (se necessario)\n- [ ] Aggiungi la regola del lexer in `lexer.c` (se necessario)\n- [ ] Aggiungi il tipo di nodo AST in `ast.h`\n- [ ] Aggiungi il costruttore AST in `ast.c`\n- [ ] Aggiungi la regola del parser in `parser.c`\n- [ ] Aggiungi il comportamento runtime in `runtime.c` o nel modulo appropriato\n- [ ] Gestisci la pulizia nelle funzioni di free dell'AST\n\n**Se aggiungi una funzione built-in:**\n\n- [ ] Aggiungi l'implementazione della funzione in `builtins.c`\n- [ ] Registra la funzione in `register_builtins()`\n- [ ] Gestisci tutte le combinazioni di tipi di parametri\n- [ ] Restituisci valori di errore appropriati\n- [ ] Documenta parametri e tipo di ritorno\n\n**Se aggiungi un tipo di valore:**\n\n- [ ] Aggiungi l'enum del tipo in `values.h`\n- [ ] Aggiungi il campo alla union Value\n- [ ] Aggiungi il costruttore in `values.c`\n- [ ] Aggiungi a `value_free()` per la pulizia\n- [ ] Aggiungi a `value_copy()` per la copia\n- [ ] Aggiungi a `value_to_string()` per la stampa\n- [ ] Aggiungi regole di promozione del tipo se numerico\n\n#### 3. Fase di Testing\n\n- [ ] Scrivi casi di test (vedi testing.md)\n- [ ] Testa i casi di successo\n- [ ] Testa i casi di errore\n- [ ] Testa i casi limite\n- [ ] Esegui l'intera suite di test (`make test`)\n- [ ] Controlla i memory leak con valgrind\n- [ ] Testa su piu piattaforme (se possibile)\n\n#### 4. Fase di Documentazione\n\n- [ ] Aggiorna CLAUDE.md con la documentazione per l'utente\n- [ ] Aggiungi commenti nel codice che spiegano l'implementazione\n- [ ] Crea esempi in `examples/`\n- [ ] Aggiorna i file docs/ pertinenti\n- [ ] Documenta eventuali modifiche che rompono la compatibilita\n\n#### 5. Fase di Invio\n\n- [ ] Pulisci il codice di debug e i commenti\n- [ ] Verifica la conformita allo stile del codice\n- [ ] Rebase sull'ultimo main\n- [ ] Crea la pull request con descrizione dettagliata\n- [ ] Rispondi al feedback della code review\n\n### Esempio: Aggiungere un Nuovo Operatore\n\nVediamo come aggiungere l'operatore modulo `%` come esempio:\n\n**1. Lexer (lexer.c):**\n```c\n// Aggiungi allo switch statement in get_next_token()\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. Header del lexer (lexer.h):**\n```c\ntypedef enum {\n    // ... token esistenti\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h):**\n```c\ntypedef enum {\n    // ... operatori esistenti\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. Parser (parser.c):**\n```c\n// Aggiungi a parse_multiplicative() o al livello di precedenza appropriato\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. Runtime (runtime.c):**\n```c\n// Aggiungi a eval_binary_op()\ncase OP_MOD:\n    // Controllo dei tipi\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Error: Modulo by zero\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... gestisci altre combinazioni di tipi\n    break;\n```\n\n**6. Test (tests/operators/modulo.hml):**\n```hemlock\n// Modulo base\nprint(10 % 3);  // Expect: 2\n\n// Modulo negativo\nprint(-10 % 3); // Expect: -1\n\n// Caso di errore (dovrebbe fallire)\n// print(10 % 0);  // Divisione per zero\n```\n\n**7. Documentazione (CLAUDE.md):**\n```markdown\n### Operatori Aritmetici\n- `+` - Addizione\n- `-` - Sottrazione\n- `*` - Moltiplicazione\n- `/` - Divisione\n- `%` - Modulo (resto)\n```\n\n---\n\n## Processo di Code Review\n\n### Cosa Cercano i Reviewer\n\n**1. Correttezza**\n- Il codice fa quello che dichiara?\n- I casi limite sono gestiti?\n- Ci sono memory leak?\n- Gli errori sono gestiti correttamente?\n\n**2. Allineamento con la Filosofia**\n- Questo si adatta ai principi di design di Hemlock?\n- E esplicito o implicito?\n- Nasconde complessita?\n\n**3. Qualita del Codice**\n- Il codice e leggibile e manutenibile?\n- I nomi delle variabili sono descrittivi?\n- Le funzioni hanno dimensioni ragionevoli?\n- C'e documentazione adeguata?\n\n**4. Testing**\n- Ci sono casi di test sufficienti?\n- I test coprono i percorsi di successo e fallimento?\n- I casi limite sono testati?\n\n**5. Documentazione**\n- La documentazione per l'utente e aggiornata?\n- I commenti nel codice sono chiari?\n- Sono forniti esempi?\n\n### Rispondere al Feedback\n\n**Fai:**\n- Ringrazia i reviewer per il loro tempo\n- Fai domande di chiarimento se non capisci\n- Spiega il tuo ragionamento se non sei d'accordo\n- Apporta le modifiche richieste prontamente\n- Aggiorna la descrizione della PR se cambia lo scope\n\n**Non fare:**\n- Prendere le critiche sul personale\n- Discutere in modo difensivo\n- Ignorare il feedback\n- Fare force-push sopra i commenti della review (a meno che non stai facendo rebase)\n- Aggiungere modifiche non correlate alla PR\n\n### Far Mergiare la Tua PR\n\n**Requisiti per il merge:**\n- [ ] Tutti i test passano\n- [ ] Nessun memory leak (valgrind pulito)\n- [ ] Approvazione della code review dal maintainer\n- [ ] Documentazione aggiornata\n- [ ] Segue le linee guida sullo stile del codice\n- [ ] Si allinea con la filosofia di Hemlock\n\n**Tempistiche:**\n- PR piccole (correzioni di bug): Di solito revisionate entro pochi giorni\n- PR medie (nuove funzionalita): Possono richiedere 1-2 settimane\n- PR grandi (modifiche importanti): Richiedono discussione approfondita\n\n---\n\n## Risorse Aggiuntive\n\n### Risorse di Apprendimento\n\n**Capire gli interpreti:**\n- \"Crafting Interpreters\" di Robert Nystrom\n- \"Writing An Interpreter In Go\" di Thorsten Ball\n- \"Modern Compiler Implementation in C\" di Andrew Appel\n\n**Programmazione C:**\n- \"The C Programming Language\" di K&R\n- \"Expert C Programming\" di Peter van der Linden\n- \"C Interfaces and Implementations\" di David Hanson\n\n**Gestione della memoria:**\n- Documentazione di Valgrind\n- \"Understanding and Using C Pointers\" di Richard Reese\n\n### Comandi Utili\n\n```bash\n# Compila con simboli di debug\nmake clean && make CFLAGS=\"-g -O0\"\n\n# Esegui con valgrind\nvalgrind --leak-check=full ./hemlock script.hml\n\n# Esegui una categoria di test specifica\n./tests/run_tests.sh tests/strings/\n\n# Genera file di tag per la navigazione del codice\nctags -R .\n\n# Trova tutti i TODO e FIXME\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## Domande?\n\nSe hai domande su come contribuire:\n\n1. Controlla la documentazione in `docs/`\n2. Cerca nelle issue esistenti su GitHub\n3. Chiedi nelle GitHub Discussions\n4. Apri una nuova issue con la tua domanda\n\n**Grazie per contribuire a Hemlock!**\n"}, "Contribuire -> Test": {"id": "contributing-testing", "content": "# Guida ai Test per Hemlock\n\nQuesta guida spiega la filosofia di testing di Hemlock, come scrivere test e come eseguire la suite di test.\n\n---\n\n## Indice\n\n- [Filosofia di Testing](#filosofia-di-testing)\n- [Struttura della Suite di Test](#struttura-della-suite-di-test)\n- [Eseguire i Test](#eseguire-i-test)\n- [Scrivere Test](#scrivere-test)\n- [Categorie di Test](#categorie-di-test)\n- [Test di Memory Leak](#test-di-memory-leak)\n- [Integrazione Continua](#integrazione-continua)\n- [Best Practice](#best-practice)\n\n---\n\n## Filosofia di Testing\n\n### Principi Fondamentali\n\n**1. Test-Driven Development (TDD)**\n\nScrivi i test **prima** di implementare le funzionalita:\n\n```\n1. Scrivi un test che fallisce\n2. Implementa la funzionalita\n3. Esegui il test (dovrebbe passare)\n4. Refactoring se necessario\n5. Ripeti\n```\n\n**Benefici:**\n- Assicura che le funzionalita funzionino davvero\n- Previene regressioni\n- Documenta il comportamento atteso\n- Rende il refactoring piu sicuro\n\n**2. Copertura Completa**\n\nTesta sia i casi di successo che di fallimento:\n\n```hemlock\n// Caso di successo\nlet x: u8 = 255;  // Dovrebbe funzionare\n\n// Caso di fallimento\nlet y: u8 = 256;  // Dovrebbe generare un errore\n```\n\n**3. Testa Presto e Spesso**\n\nEsegui i test:\n- Prima di fare commit del codice\n- Dopo aver apportato modifiche\n- Prima di inviare pull request\n- Durante la code review\n\n**Regola:** Tutti i test devono passare prima del merge.\n\n### Cosa Testare\n\n**Testa sempre:**\n- Funzionalita di base (percorso felice)\n- Condizioni di errore (percorso triste)\n- Casi limite (condizioni al contorno)\n- Controllo e conversione dei tipi\n- Gestione della memoria (nessun leak)\n- Concorrenza e race condition\n\n**Esempio di copertura dei test:**\n```hemlock\n// Funzionalita: String.substr(start, length)\n\n// Percorso felice\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Casi limite\nprint(\"hello\".substr(0, 0));  // \"\" (vuoto)\nprint(\"hello\".substr(5, 0));  // \"\" (alla fine)\nprint(\"hello\".substr(2, 100)); // \"llo\" (oltre la fine)\n\n// Casi di errore\n// \"hello\".substr(-1, 5);  // Errore: indice negativo\n// \"hello\".substr(0, -1);  // Errore: lunghezza negativa\n```\n\n---\n\n## Struttura della Suite di Test\n\n### Organizzazione delle Directory\n\n```\ntests/\n run_tests.sh          # Script principale per l'esecuzione dei test\n primitives/           # Test del sistema di tipi\n    integers.hml\n    floats.hml\n    booleans.hml\n    i64.hml\n    u64.hml\n conversions/          # Test di conversione dei tipi\n    int_to_float.hml\n    promotion.hml\n    rune_conversions.hml\n memory/               # Test di puntatori/buffer\n    alloc.hml\n    buffer.hml\n    memcpy.hml\n strings/              # Test delle operazioni sulle stringhe\n    concat.hml\n    methods.hml\n    utf8.hml\n    runes.hml\n control/              # Test del flusso di controllo\n    if.hml\n    switch.hml\n    while.hml\n functions/            # Test di funzioni e closure\n    basics.hml\n    closures.hml\n    recursion.hml\n objects/              # Test degli oggetti\n    literals.hml\n    methods.hml\n    duck_typing.hml\n    serialization.hml\n arrays/               # Test delle operazioni sugli array\n    basics.hml\n    methods.hml\n    slicing.hml\n loops/                # Test dei cicli\n    for.hml\n    while.hml\n    break.hml\n    continue.hml\n exceptions/           # Test della gestione degli errori\n    try_catch.hml\n    finally.hml\n    throw.hml\n io/                   # Test di I/O su file\n    file_object.hml\n    read_write.hml\n    seek.hml\n async/                # Test di concorrenza\n    spawn_join.hml\n    channels.hml\n    exceptions.hml\n ffi/                  # Test FFI\n    basic_call.hml\n    types.hml\n    dlopen.hml\n signals/              # Test della gestione dei segnali\n    basic.hml\n    handlers.hml\n    raise.hml\n args/                 # Test degli argomenti da riga di comando\n     basic.hml\n```\n\n### Nomenclatura dei File di Test\n\n**Convenzioni:**\n- Usa nomi descrittivi: `method_chaining.hml` non `test1.hml`\n- Raggruppa test correlati: `string_substr.hml`, `string_slice.hml`\n- Un'area di funzionalita per file\n- Mantieni i file focalizzati e piccoli\n\n---\n\n## Eseguire i Test\n\n### Esegui Tutti i Test\n\n```bash\n# Dalla directory root di hemlock\nmake test\n\n# Oppure direttamente\n./tests/run_tests.sh\n```\n\n**Output:**\n```\nRunning tests in tests/primitives/...\n   integers.hml\n   floats.hml\n   booleans.hml\n\nRunning tests in tests/strings/...\n   concat.hml\n   methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### Esegui una Categoria Specifica\n\n```bash\n# Esegui solo i test delle stringhe\n./tests/run_tests.sh tests/strings/\n\n# Esegui solo un file di test\n./tests/run_tests.sh tests/strings/concat.hml\n\n# Esegui piu categorie\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Esegui con Valgrind (Controllo Memory Leak)\n\n```bash\n# Controlla un singolo test per leak\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# Controlla tutti i test (lento!)\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### Debug dei Test Falliti\n\n```bash\n# Esegui con output verboso\n./hemlock tests/failing_test.hml\n\n# Esegui con gdb\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # se crasha\n```\n\n---\n\n## Scrivere Test\n\n### Formato dei File di Test\n\nI file di test sono semplicemente programmi Hemlock con output atteso:\n\n**Esempio: tests/primitives/integers.hml**\n```hemlock\n// Test dei literal interi di base\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// Test dell'aritmetica\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// Test dell'inferenza di tipo\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```\n\n**Come funzionano i test:**\n1. Il test runner esegue il file .hml\n2. Cattura l'output su stdout\n3. Confronta con l'output atteso (da commenti o file .out separato)\n4. Riporta pass/fail\n\n### Metodi per l'Output Atteso\n\n**Metodo 1: Commenti inline (consigliato per test semplici)**\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```\n\nIl test runner analizza i commenti `// Expect: ...`.\n\n**Metodo 2: File .out separato**\n\nCrea `nome_test.hml.out` con l'output atteso:\n\n**nome_test.hml:**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**nome_test.hml.out:**\n```\nline 1\nline 2\nline 3\n```\n\n### Testare i Casi di Errore\n\nI test di errore dovrebbero far uscire il programma con stato non-zero:\n\n**Esempio: tests/primitives/range_error.hml**\n```hemlock\n// Questo dovrebbe fallire con un errore di tipo\nlet x: u8 = 256;  // Fuori range per u8\n```\n\n**Comportamento atteso:**\n- Il programma esce con stato non-zero\n- Stampa messaggio di errore su stderr\n\n**Gestione del test runner:**\n- I test che si aspettano errori dovrebbero essere in file separati\n- Usa la convenzione di nomenclatura: `*_error.hml` o `*_fail.hml`\n- Documenta l'errore atteso nei commenti\n\n### Testare i Casi di Successo\n\n**Esempio: tests/strings/methods.hml**\n```hemlock\n// Test di substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// Test di find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// Test di contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// Test di trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```\n\n### Testare i Casi Limite\n\n**Esempio: tests/arrays/edge_cases.hml**\n```hemlock\n// Array vuoto\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// Singolo elemento\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// Indice negativo (dovrebbe dare errore in un file di test separato)\n// print(single[-1]);  // Errore\n\n// Indice oltre la fine (dovrebbe dare errore)\n// print(single[100]);  // Errore\n\n// Condizioni al contorno\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: [] (vuoto)\nprint(arr.slice(3, 3));  // Expect: [] (vuoto)\nprint(arr.slice(1, 2));  // Expect: [2]\n```\n\n### Testare il Sistema di Tipi\n\n**Esempio: tests/conversions/promotion.hml**\n```hemlock\n// Test della promozione di tipo nelle operazioni binarie\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```\n\n### Testare la Concorrenza\n\n**Esempio: tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Avvia task\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Join e stampa risultati\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```\n\n### Testare le Eccezioni\n\n**Esempio: tests/exceptions/try_catch.hml**\n```hemlock\n// Test di base try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// Test di finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// Test della propagazione delle eccezioni\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```\n\n---\n\n## Categorie di Test\n\n### Test dei Primitivi\n\n**Cosa testare:**\n- Tipi interi (i8, i16, i32, i64, u8, u16, u32, u64)\n- Tipi float (f32, f64)\n- Tipo boolean\n- Tipo string\n- Tipo rune\n- Tipo null\n\n**Aree di esempio:**\n- Sintassi dei literal\n- Inferenza di tipo\n- Controllo del range\n- Comportamento di overflow\n- Annotazioni di tipo\n\n### Test delle Conversioni\n\n**Cosa testare:**\n- Promozione implicita di tipo\n- Conversione esplicita di tipo\n- Conversioni con perdita di dati (dovrebbero dare errore)\n- Promozione di tipo nelle operazioni\n- Confronti tra tipi diversi\n\n### Test della Memoria\n\n**Cosa testare:**\n- Correttezza di alloc/free\n- Creazione e accesso ai buffer\n- Controllo dei limiti sui buffer\n- memset, memcpy, realloc\n- Rilevamento di memory leak (valgrind)\n\n### Test delle Stringhe\n\n**Cosa testare:**\n- Concatenazione\n- Tutti i 18 metodi delle stringhe\n- Gestione UTF-8\n- Indicizzazione con rune\n- Concatenazione string + rune\n- Casi limite (stringhe vuote, singolo carattere, ecc.)\n\n### Test del Flusso di Controllo\n\n**Cosa testare:**\n- if/else/else if\n- Cicli while\n- Cicli for\n- Istruzioni switch\n- break/continue\n- Istruzioni return\n\n### Test delle Funzioni\n\n**Cosa testare:**\n- Definizione e chiamata di funzioni\n- Passaggio dei parametri\n- Valori di ritorno\n- Ricorsione\n- Closure e cattura\n- Funzioni di prima classe\n- Funzioni anonime\n\n### Test degli Oggetti\n\n**Cosa testare:**\n- Literal degli oggetti\n- Accesso e assegnazione dei campi\n- Metodi e binding di self\n- Duck typing\n- Campi opzionali\n- Serializzazione/deserializzazione JSON\n- Rilevamento di riferimenti circolari\n\n### Test degli Array\n\n**Cosa testare:**\n- Creazione di array\n- Indicizzazione e assegnazione\n- Tutti i 15 metodi degli array\n- Tipi misti\n- Ridimensionamento dinamico\n- Casi limite (vuoto, singolo elemento)\n\n### Test delle Eccezioni\n\n**Cosa testare:**\n- try/catch/finally\n- Istruzione throw\n- Propagazione delle eccezioni\n- try/catch annidati\n- Return in try/catch/finally\n- Eccezioni non catturate\n\n### Test di I/O\n\n**Cosa testare:**\n- Modalita di apertura file\n- Operazioni di lettura/scrittura\n- Seek/tell\n- Proprieta dei file\n- Gestione degli errori (file mancanti, ecc.)\n- Pulizia delle risorse\n\n### Test Async\n\n**Cosa testare:**\n- spawn/join/detach\n- send/recv sui canali\n- Propagazione delle eccezioni nei task\n- Task concorrenti multipli\n- Comportamento di blocco dei canali\n\n### Test FFI\n\n**Cosa testare:**\n- dlopen/dlclose\n- dlsym\n- dlcall con vari tipi\n- Conversione di tipo\n- Gestione degli errori\n\n---\n\n## Test di Memory Leak\n\n### Usare Valgrind\n\n**Uso di base:**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**Esempio di output (nessun leak):**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**Esempio di output (con leak):**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### Fonti Comuni di Leak\n\n**1. Chiamate free() mancanti:**\n```c\n// MALE\nchar *str = malloc(100);\n// ... usa str\n// Dimenticato di liberare!\n\n// BENE\nchar *str = malloc(100);\n// ... usa str\nfree(str);\n```\n\n**2. Puntatori persi:**\n```c\n// MALE\nchar *ptr = malloc(100);\nptr = malloc(200);  // Perso il riferimento alla prima allocazione!\n\n// BENE\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. Percorsi di eccezione:**\n```c\n// MALE\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // Leak!\n    }\n    free(data);\n}\n\n// BENE\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### Leak Accettabili Conosciuti\n\nAlcuni piccoli \"leak\" sono allocazioni intenzionali all'avvio:\n\n**Built-in globali:**\n```hemlock\n// Funzioni built-in, tipi FFI e costanti sono allocati all'avvio\n// e non liberati all'uscita (tipicamente ~200 byte)\n```\n\nQuesti non sono veri leak - sono allocazioni una tantum che persistono per tutta la vita del programma e vengono pulite dal sistema operativo all'uscita.\n\n---\n\n## Integrazione Continua\n\n### GitHub Actions (Futuro)\n\nUna volta impostata la CI, tutti i test verranno eseguiti automaticamente su:\n- Push sul branch main\n- Creazione/aggiornamento di pull request\n- Esecuzioni giornaliere programmate\n\n**Flusso di lavoro CI:**\n1. Compila Hemlock\n2. Esegui la suite di test\n3. Controlla i memory leak (valgrind)\n4. Riporta i risultati sulla PR\n\n### Controlli Pre-Commit\n\nPrima di fare commit, esegui:\n\n```bash\n# Compila da zero\nmake clean && make\n\n# Esegui tutti i test\nmake test\n\n# Controlla alcuni test per leak\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## Best Practice\n\n### Da Fare\n\n- **Scrivi i test prima (TDD)**\n```bash\n1. Crea tests/feature/new_feature.hml\n2. Implementa la funzionalita in src/\n3. Esegui i test finche non passano\n```\n\n- **Testa sia successo che fallimento**\n```hemlock\n// Successo: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Expect: valore atteso\n\n// Fallimento: tests/feature/failure.hml\ndo_invalid_thing();  // Dovrebbe dare errore\n```\n\n- **Usa nomi di test descrittivi**\n```\nBene: tests/strings/substr_utf8_boundary.hml\nMale: tests/test1.hml\n```\n\n- **Mantieni i test focalizzati**\n- Un'area di funzionalita per file\n- Setup e asserzioni chiare\n- Codice minimo\n\n- **Aggiungi commenti che spiegano test complicati**\n```hemlock\n// Test che la closure cattura la variabile esterna per riferimento\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Modifica dopo la creazione della closure\n    return f();  // Dovrebbe restituire 20, non 10\n}\n```\n\n- **Testa i casi limite**\n- Input vuoti\n- Valori null\n- Valori al contorno (min/max)\n- Input grandi\n- Valori negativi\n\n### Da Non Fare\n\n- **Non saltare i test**\n- Tutti i test devono passare prima del merge\n- Non commentare i test che falliscono\n- Correggi il bug o rimuovi la funzionalita\n\n- **Non scrivere test che dipendono l'uno dall'altro**\n```hemlock\n// MALE: test2.hml dipende dall'output di test1.hml\n// I test dovrebbero essere indipendenti\n```\n\n- **Non usare valori casuali nei test**\n```hemlock\n// MALE: Non deterministico\nlet x = random();\nprint(x);  // Non puoi prevedere l'output\n\n// BENE: Deterministico\nlet x = 42;\nprint(x);  // Expect: 42\n```\n\n- **Non testare dettagli implementativi**\n```hemlock\n// MALE: Testare la struttura interna\nlet obj = { x: 10 };\n// Non controllare l'ordine interno dei campi, capacita, ecc.\n\n// BENE: Testare il comportamento\nprint(obj.x);  // Expect: 10\n```\n\n- **Non ignorare i memory leak**\n- Tutti i test dovrebbero essere puliti a valgrind\n- Documenta i leak conosciuti/accettabili\n- Correggi i leak prima del merge\n\n### Manutenzione dei Test\n\n**Quando aggiornare i test:**\n- Il comportamento della funzionalita cambia\n- Le correzioni di bug richiedono nuovi casi di test\n- Vengono scoperti casi limite\n- Miglioramenti delle prestazioni\n\n**Quando rimuovere i test:**\n- Funzionalita rimossa dal linguaggio\n- Il test duplica copertura esistente\n- Il test era errato\n\n**Refactoring dei test:**\n- Raggruppa test correlati insieme\n- Estrai codice di setup comune\n- Usa nomenclatura consistente\n- Mantieni i test semplici e leggibili\n\n---\n\n## Esempio di Sessione di Test\n\nEcco un esempio completo di aggiunta di una funzionalita con test:\n\n### Funzionalita: Aggiungere il metodo `array.first()`\n\n**1. Scrivi prima il test:**\n\n```bash\n# Crea il file di test\ncat > tests/arrays/first_method.hml << 'EOF'\n// Test del metodo array.first()\n\n// Caso base\nlet arr = [1, 2, 3];\nprint(arr.first());  // Expect: 1\n\n// Singolo elemento\nlet single = [42];\nprint(single.first());  // Expect: 42\n\n// Array vuoto (dovrebbe dare errore - file di test separato)\n// let empty = [];\n// print(empty.first());  // Errore\nEOF\n```\n\n**2. Esegui il test (dovrebbe fallire):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Error: Method 'first' not found on array\n```\n\n**3. Implementa la funzionalita:**\n\nModifica `src/interpreter/builtins.c`:\n\n```c\n// Aggiungi il metodo array_first\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Error: Cannot get first element of empty array\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// Registra nella tabella dei metodi array\n// ... aggiungi alla registrazione dei metodi array\n```\n\n**4. Esegui il test (dovrebbe passare):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# Successo!\n```\n\n**5. Controlla i memory leak:**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. Esegui l'intera suite di test:**\n\n```bash\nmake test\n# Total: 252 tests (251 + nuovo)\n# Passed: 252\n# Failed: 0\n```\n\n**7. Commit:**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## Riepilogo\n\n**Ricorda:**\n- Scrivi i test prima (TDD)\n- Testa i casi di successo e fallimento\n- Esegui tutti i test prima di fare commit\n- Controlla i memory leak\n- Documenta i problemi noti\n- Mantieni i test semplici e focalizzati\n\n**La qualita dei test e importante quanto la qualita del codice!**\n"}, "hpm: Primi Passi -> Avvio Rapido": {"id": "hpm-quick-start", "content": "# Avvio Rapido\n\nInizia a usare hpm in 5 minuti.\n\n## Installa hpm\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nPer ulteriori opzioni di installazione, consulta la [Guida all'Installazione](#hpm-quick-start-installation).\n\n## Crea un Nuovo Progetto\n\nInizia creando una nuova directory e inizializzando un pacchetto:\n\n```bash\nmkdir mio-progetto\ncd mio-progetto\nhpm init\n```\n\nTi verranno richiesti i dettagli del progetto:\n\n```\nNome pacchetto (proprietario/repo): mionome/mio-progetto\nVersione (1.0.0):\nDescrizione: Il mio fantastico progetto Hemlock\nAutore: Il Tuo Nome <tu@esempio.com>\nLicenza (MIT):\nFile principale (src/index.hml):\n\nCreato package.json\n```\n\nUsa `--yes` per accettare tutti i valori predefiniti:\n\n```bash\nhpm init --yes\n```\n\n## Struttura del Progetto\n\nCrea la struttura di base del progetto:\n\n```\nmio-progetto/\n package.json        # Manifesto del progetto\n src/\n    index.hml      # Punto di ingresso principale\n test/\n     test.hml       # Test\n```\n\nCrea il tuo file principale:\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml:**\n```hemlock\n// Punto di ingresso principale\nexport fn saluta(nome: string): string {\n    return \"Ciao, \" + nome + \"!\";\n}\n\nexport fn main() {\n    print(saluta(\"Mondo\"));\n}\n```\n\n## Installa le Dipendenze\n\nCerca pacchetti su GitHub (i pacchetti usano il formato `proprietario/repo`):\n\n```bash\n# Installa un pacchetto\nhpm install hemlang/sprout\n\n# Installa con vincolo di versione\nhpm install hemlang/json@^1.0.0\n\n# Installa come dipendenza di sviluppo\nhpm install hemlang/test-utils --dev\n```\n\nDopo l'installazione, la struttura del tuo progetto include `hem_modules/`:\n\n```\nmio-progetto/\n package.json\n package-lock.json   # File di lock (generato automaticamente)\n hem_modules/        # Pacchetti installati\n    hemlang/\n        sprout/\n src/\n    index.hml\n test/\n     test.hml\n```\n\n## Usa i Pacchetti Installati\n\nImporta i pacchetti usando il loro percorso GitHub:\n\n```hemlock\n// Importa dal pacchetto installato\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// Importa da un sottopercorso\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Libreria standard (integrata)\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## Aggiungi Script\n\nAggiungi script al tuo `package.json`:\n\n```json\n{\n  \"name\": \"mionome/mio-progetto\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nEsegui gli script con `hpm run`:\n\n```bash\nhpm run start\nhpm run build\n\n# Abbreviazione per test\nhpm test\n```\n\n## Flussi di Lavoro Comuni\n\n### Installazione di Tutte le Dipendenze\n\nQuando cloni un progetto con un `package.json`:\n\n```bash\ngit clone https://github.com/qualcuno/progetto.git\ncd progetto\nhpm install\n```\n\n### Aggiornamento delle Dipendenze\n\nAggiorna tutti i pacchetti alle ultime versioni entro i vincoli:\n\n```bash\nhpm update\n```\n\nAggiorna un pacchetto specifico:\n\n```bash\nhpm update hemlang/sprout\n```\n\n### Visualizzazione dei Pacchetti Installati\n\nElenca tutti i pacchetti installati:\n\n```bash\nhpm list\n```\n\nL'output mostra l'albero delle dipendenze:\n\n```\nmio-progetto@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n hemlang/json@1.2.3\n```\n\n### Verifica degli Aggiornamenti\n\nVedi quali pacchetti hanno versioni piu recenti:\n\n```bash\nhpm outdated\n```\n\n### Rimozione di un Pacchetto\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## Esempio: Applicazione Web\n\nEcco un esempio completo usando un framework web:\n\n**package.json:**\n```json\n{\n  \"name\": \"mionome/mia-app-web\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Un'applicazione web\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml:**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Ciao, Mondo!\");\n    });\n\n    router.get(\"/api/stato\", fn(req, res) {\n        res.json({ stato: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server in esecuzione su http://localhost:3000\");\n}\n```\n\nEsegui l'applicazione:\n\n```bash\nhpm install\nhpm run start\n```\n\n## Prossimi Passi\n\n- [Riferimento Comandi](#hpm-quick-start-commands) - Impara tutti i comandi hpm\n- [Creazione di Pacchetti](#hpm-quick-start-creating-packages) - Pubblica i tuoi pacchetti\n- [Configurazione](#hpm-quick-start-configuration) - Configura hpm e i token GitHub\n- [Configurazione del Progetto](#hpm-quick-start-project-setup) - Configurazione dettagliata del progetto\n"}, "hpm: Primi Passi -> Configurazione del Progetto": {"id": "hpm-project-setup", "content": "# Configurazione del Progetto\n\nGuida completa per configurare progetti Hemlock con hpm.\n\n## Iniziare un Nuovo Progetto\n\n### Configurazione di Base\n\nCrea un nuovo progetto da zero:\n\n```bash\n# Crea la directory del progetto\nmkdir mio-progetto\ncd mio-progetto\n\n# Inizializza package.json\nhpm init\n\n# Crea la struttura delle directory\nmkdir -p src test\n```\n\n### Modelli di Progetto\n\nEcco strutture di progetto comuni per diversi casi d'uso:\n\n#### Pacchetto Libreria\n\nPer librerie riutilizzabili:\n\n```\nmia-libreria/\n package.json\n README.md\n LICENSE\n src/\n    index.hml          # Ingresso principale, esporta API pubblica\n    core.hml           # Funzionalita core\n    utils.hml          # Funzioni di utilita\n    types.hml          # Definizioni dei tipi\n test/\n     framework.hml      # Framework di test\n     run.hml            # Esecutore dei test\n     test_core.hml      # Test\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"tuonome/mia-libreria\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Una libreria Hemlock riutilizzabile\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### Applicazione\n\nPer applicazioni standalone:\n\n```\nmia-app/\n package.json\n README.md\n src/\n    main.hml           # Punto di ingresso dell'applicazione\n    config.hml         # Configurazione\n    commands/          # Comandi CLI\n       index.hml\n       run.hml\n    lib/               # Librerie interne\n        utils.hml\n test/\n    run.hml\n data/                  # File di dati\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"tuonome/mia-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Un'applicazione Hemlock\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Applicazione Web\n\nPer server web:\n\n```\nmia-app-web/\n package.json\n README.md\n src/\n    main.hml           # Punto di ingresso del server\n    routes/            # Gestori delle route\n       index.hml\n       api.hml\n       auth.hml\n    middleware/        # Middleware\n       index.hml\n       auth.hml\n    models/            # Modelli dati\n       user.hml\n    services/          # Logica di business\n        user.hml\n test/\n    run.hml\n static/                # File statici\n    css/\n    js/\n views/                 # Template\n     index.hml\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"tuonome/mia-app-web\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Un'applicazione web Hemlock\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## Il File package.json\n\n### Campi Obbligatori\n\n```json\n{\n  \"name\": \"proprietario/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### Tutti i Campi\n\n```json\n{\n  \"name\": \"tuonome/mio-pacchetto\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Descrizione del pacchetto\",\n  \"author\": \"Il Tuo Nome <tu@esempio.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/tuonome/mio-pacchetto\",\n  \"homepage\": \"https://tuonome.github.io/mio-pacchetto\",\n  \"bugs\": \"https://github.com/tuonome/mio-pacchetto/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utilita\", \"parser\"],\n  \"dependencies\": {\n    \"proprietario/pacchetto\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"proprietario/lib-test\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### Riferimento Campi\n\n| Campo | Tipo | Descrizione |\n|-------|------|-------------|\n| `name` | stringa | Nome del pacchetto in formato proprietario/repo (obbligatorio) |\n| `version` | stringa | Versione semantica (obbligatorio) |\n| `description` | stringa | Breve descrizione |\n| `author` | stringa | Nome e email dell'autore |\n| `license` | stringa | Identificatore della licenza (MIT, Apache-2.0, ecc.) |\n| `repository` | stringa | URL del repository |\n| `homepage` | stringa | Homepage del progetto |\n| `bugs` | stringa | URL del tracker dei problemi |\n| `main` | stringa | File punto di ingresso (default: src/index.hml) |\n| `keywords` | array | Parole chiave per la ricerca |\n| `dependencies` | oggetto | Dipendenze runtime |\n| `devDependencies` | oggetto | Dipendenze di sviluppo |\n| `scripts` | oggetto | Script denominati |\n| `files` | array | File da includere nella pubblicazione |\n| `native` | oggetto | Requisiti librerie native |\n\n## Il File package-lock.json\n\nIl file di lock viene generato automaticamente e dovrebbe essere committato nel controllo versione. Garantisce installazioni riproducibili.\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### Best Practice per il File di Lock\n\n- **Committa** package-lock.json nel controllo versione\n- **Non modificare** manualmente - viene generato automaticamente\n- **Esegui `hpm install`** dopo aver scaricato le modifiche\n- **Elimina e rigenera** se corrotto:\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## La Directory hem_modules\n\nI pacchetti installati sono memorizzati in `hem_modules/`:\n\n```\nhem_modules/\n hemlang/\n    sprout/\n       package.json\n       src/\n    router/\n        package.json\n        src/\n alice/\n     http-client/\n         package.json\n         src/\n```\n\n### Best Practice per hem_modules\n\n- **Aggiungi a .gitignore** - non committare le dipendenze\n- **Non modificare** - le modifiche verranno sovrascritte\n- **Elimina per reinstallare da zero**:\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\nFile .gitignore consigliato per progetti Hemlock:\n\n```gitignore\n# Dipendenze\nhem_modules/\n\n# Output di build\ndist/\n*.hmlc\n\n# File IDE\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# File del sistema operativo\n.DS_Store\nThumbs.db\n\n# Log\n*.log\nlogs/\n\n# Ambiente\n.env\n.env.local\n\n# Copertura dei test\ncoverage/\n```\n\n## Lavorare con le Dipendenze\n\n### Aggiungere Dipendenze\n\n```bash\n# Aggiungi dipendenza runtime\nhpm install hemlang/json\n\n# Aggiungi con vincolo di versione\nhpm install hemlang/sprout@^2.0.0\n\n# Aggiungi dipendenza di sviluppo\nhpm install hemlang/test-utils --dev\n```\n\n### Importare Dipendenze\n\n```hemlock\n// Importa dal pacchetto (usa la voce \"main\")\nimport { parse, stringify } from \"hemlang/json\";\n\n// Importa da sottopercorso\nimport { Router } from \"hemlang/sprout/router\";\n\n// Importa libreria standard\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### Risoluzione delle Import\n\nhpm risolve le import in questo ordine:\n\n1. **Libreria standard**: import `@stdlib/*` per moduli integrati\n2. **Root del pacchetto**: `proprietario/repo` usa il campo `main`\n3. **Sottopercorso**: `proprietario/repo/percorso` controlla:\n   - `hem_modules/proprietario/repo/percorso.hml`\n   - `hem_modules/proprietario/repo/percorso/index.hml`\n   - `hem_modules/proprietario/repo/src/percorso.hml`\n   - `hem_modules/proprietario/repo/src/percorso/index.hml`\n\n## Script\n\n### Definire Script\n\nAggiungi script a package.json:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### Eseguire Script\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# Abbreviazione per test\nhpm test\n\n# Passare argomenti\nhpm run test -- --verbose --filter=unit\n```\n\n### Convenzioni di Denominazione degli Script\n\n| Script | Scopo |\n|--------|-------|\n| `start` | Esegui l'applicazione |\n| `dev` | Esegui in modalita sviluppo |\n| `test` | Esegui tutti i test |\n| `build` | Compila per la produzione |\n| `clean` | Rimuovi i file generati |\n| `lint` | Controlla lo stile del codice |\n| `format` | Formatta il codice |\n\n## Flusso di Lavoro di Sviluppo\n\n### Configurazione Iniziale\n\n```bash\n# Clona il progetto\ngit clone https://github.com/tuonome/mio-progetto.git\ncd mio-progetto\n\n# Installa le dipendenze\nhpm install\n\n# Esegui i test\nhpm test\n\n# Inizia lo sviluppo\nhpm run dev\n```\n\n### Flusso di Lavoro Giornaliero\n\n```bash\n# Scarica le ultime modifiche\ngit pull\n\n# Installa eventuali nuove dipendenze\nhpm install\n\n# Apporta modifiche...\n\n# Esegui i test\nhpm test\n\n# Committa\ngit add .\ngit commit -m \"Aggiungi funzionalita\"\ngit push\n```\n\n### Aggiungere una Nuova Funzionalita\n\n```bash\n# Crea branch per la funzionalita\ngit checkout -b feature/nuova-funzionalita\n\n# Aggiungi nuova dipendenza se necessario\nhpm install hemlang/nuova-lib\n\n# Implementa la funzionalita...\n\n# Testa\nhpm test\n\n# Committa e pusha\ngit add .\ngit commit -m \"Aggiungi nuova funzionalita\"\ngit push -u origin feature/nuova-funzionalita\n```\n\n## Configurazione Specifica per Ambiente\n\n### Usare Variabili d'Ambiente\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Attenzione: API_KEY non impostata\");\n}\n```\n\n### File di Configurazione\n\n**config.hml:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"miaapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## Vedi Anche\n\n- [Avvio Rapido](#hpm-project-setup-quick-start) - Inizia velocemente\n- [Comandi](#hpm-project-setup-commands) - Riferimento comandi\n- [Creazione di Pacchetti](#hpm-project-setup-creating-packages) - Pubblicare pacchetti\n- [Configurazione](#hpm-project-setup-configuration) - Configurazione di hpm\n"}, "hpm: Primi Passi -> Installazione": {"id": "hpm-installation", "content": "# Installazione\n\nQuesta guida spiega come installare hpm sul tuo sistema.\n\n## Installazione Rapida (Consigliata)\n\nInstalla l'ultima versione con un singolo comando:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nQuesto esegue automaticamente:\n- Rileva il tuo sistema operativo (Linux, macOS)\n- Rileva la tua architettura (x86_64, arm64)\n- Scarica il binario precompilato appropriato\n- Installa in `/usr/local/bin` (o usa sudo se necessario)\n\n### Opzioni di Installazione\n\n```bash\n# Installa in una posizione personalizzata (sudo non richiesto)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# Installa una versione specifica\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# Combina le opzioni\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### Piattaforme Supportate\n\n| Piattaforma | Architettura | Stato |\n|-------------|--------------|-------|\n| Linux    | x86_64       | Supportato |\n| macOS    | x86_64       | Supportato |\n| macOS    | arm64 (M1/M2/M3) | Supportato |\n| Linux    | arm64        | Compilare dal sorgente |\n\n## Compilazione dal Sorgente\n\nSe preferisci compilare dal sorgente o hai bisogno di una piattaforma non coperta dai binari precompilati, segui queste istruzioni.\n\n### Prerequisiti\n\nhpm richiede che [Hemlock](https://github.com/hemlang/hemlock) sia installato prima. Segui le istruzioni di installazione di Hemlock prima di procedere.\n\nVerifica che Hemlock sia installato:\n\n```bash\nhemlock --version\n```\n\n## Metodi di Installazione\n\n### Metodo 1: Make Install\n\nCompila dal sorgente e installa.\n\n```bash\n# Clona il repository\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Installa in /usr/local/bin (richiede sudo)\nsudo make install\n```\n\nDopo l'installazione, verifica che funzioni:\n\n```bash\nhpm --version\n```\n\n### Metodo 2: Posizione Personalizzata\n\nInstalla in una directory personalizzata (sudo non richiesto):\n\n```bash\n# Clona il repository\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Installa in ~/.local/bin\nmake install PREFIX=$HOME/.local\n\n# Oppure qualsiasi posizione personalizzata\nmake install PREFIX=/opt/hemlock\n```\n\nAssicurati che la tua directory bin personalizzata sia nel tuo PATH:\n\n```bash\n# Aggiungi a ~/.bashrc o ~/.zshrc\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### Metodo 3: Esegui Senza Installare\n\nPuoi eseguire hpm direttamente senza installare:\n\n```bash\n# Clona il repository\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Crea lo script wrapper locale\nmake\n\n# Esegui dalla directory hpm\n./hpm --help\n\n# Oppure esegui tramite hemlock direttamente\nhemlock src/main.hml --help\n```\n\n### Metodo 4: Installazione Manuale\n\nCrea il tuo script wrapper:\n\n```bash\n# Clona in una posizione permanente\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# Crea lo script wrapper\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## Variabili di Installazione\n\nIl Makefile supporta queste variabili:\n\n| Variabile | Predefinito | Descrizione |\n|-----------|-------------|-------------|\n| `PREFIX` | `/usr/local` | Prefisso di installazione |\n| `BINDIR` | `$(PREFIX)/bin` | Directory dei binari |\n| `HEMLOCK` | `hemlock` | Percorso dell'interprete hemlock |\n\nEsempio con variabili personalizzate:\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## Come Funziona\n\nL'installer crea uno script shell wrapper che invoca l'interprete Hemlock con il codice sorgente di hpm:\n\n```bash\n#!/bin/sh\nexec hemlock \"/percorso/a/hpm/src/main.hml\" \"$@\"\n```\n\nQuesto approccio:\n- Non richiede compilazione\n- Esegue sempre il codice sorgente piu recente\n- Funziona in modo affidabile su tutte le piattaforme\n\n## Aggiornamento di hpm\n\nPer aggiornare hpm all'ultima versione:\n\n```bash\ncd /percorso/a/hpm\ngit pull origin main\n\n# Reinstalla se il percorso e cambiato\nsudo make install\n```\n\n## Disinstallazione\n\nRimuovi hpm dal tuo sistema:\n\n```bash\ncd /percorso/a/hpm\nsudo make uninstall\n```\n\nOppure rimuovi manualmente:\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## Verifica dell'Installazione\n\nDopo l'installazione, verifica che tutto funzioni:\n\n```bash\n# Controlla la versione\nhpm --version\n\n# Visualizza l'aiuto\nhpm --help\n\n# Testa l'inizializzazione (in una directory vuota)\nmkdir progetto-test && cd progetto-test\nhpm init --yes\ncat package.json\n```\n\n## Risoluzione dei Problemi\n\n### \"hemlock: comando non trovato\"\n\nHemlock non e installato o non e nel tuo PATH. Installa prima Hemlock:\n\n```bash\n# Controlla se hemlock esiste\nwhich hemlock\n\n# Se non trovato, installa Hemlock da https://github.com/hemlang/hemlock\n```\n\n### \"Permesso negato\"\n\nUsa sudo per l'installazione a livello di sistema, oppure installa in una directory utente:\n\n```bash\n# Opzione 1: Usa sudo\nsudo make install\n\n# Opzione 2: Installa nella directory utente\nmake install PREFIX=$HOME/.local\n```\n\n### \"hpm: comando non trovato\" dopo l'installazione\n\nIl tuo PATH potrebbe non includere la directory di installazione:\n\n```bash\n# Controlla dove e stato installato hpm\nls -la /usr/local/bin/hpm\n\n# Aggiungi al PATH se usi una posizione personalizzata\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Note Specifiche per Piattaforma\n\n### Linux\n\nL'installazione standard funziona su tutte le distribuzioni Linux. Alcune distribuzioni potrebbero richiedere:\n\n```bash\n# Debian/Ubuntu: Assicurati di avere gli strumenti di compilazione\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\nL'installazione standard funziona. Se usi Homebrew:\n\n```bash\n# Assicurati di avere gli strumenti da riga di comando Xcode\nxcode-select --install\n```\n\n### Windows (WSL)\n\nhpm funziona nel Windows Subsystem for Linux:\n\n```bash\n# Nel terminale WSL\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## Prossimi Passi\n\nDopo l'installazione:\n\n1. [Avvio Rapido](#hpm-installation-quick-start) - Crea il tuo primo progetto\n2. [Riferimento Comandi](#hpm-installation-commands) - Impara tutti i comandi\n3. [Configurazione](#hpm-installation-configuration) - Configura hpm\n"}, "hpm: Guida Utente -> Comandi": {"id": "hpm-commands", "content": "# Riferimento Comandi\n\nRiferimento completo per tutti i comandi hpm.\n\n## Opzioni Globali\n\nQueste opzioni funzionano con qualsiasi comando:\n\n| Opzione | Descrizione |\n|---------|-------------|\n| `--help`, `-h` | Mostra messaggio di aiuto |\n| `--version`, `-v` | Mostra versione di hpm |\n| `--verbose` | Mostra output dettagliato |\n\n## Comandi\n\n### hpm init\n\nCrea un nuovo file `package.json`.\n\n```bash\nhpm init        # Modalita interattiva\nhpm init --yes  # Accetta tutti i valori predefiniti\nhpm init -y     # Forma breve\n```\n\n**Opzioni:**\n\n| Opzione | Descrizione |\n|---------|-------------|\n| `--yes`, `-y` | Accetta valori predefiniti per tutti i prompt |\n\n**Prompt interattivi:**\n- Nome pacchetto (formato proprietario/repo)\n- Versione (default: 1.0.0)\n- Descrizione\n- Autore\n- Licenza (default: MIT)\n- File principale (default: src/index.hml)\n\n**Esempio:**\n\n```bash\n$ hpm init\nNome pacchetto (proprietario/repo): alice/mia-lib\nVersione (1.0.0):\nDescrizione: Una libreria di utilita\nAutore: Alice <alice@esempio.com>\nLicenza (MIT):\nFile principale (src/index.hml):\n\nCreato package.json\n```\n\n---\n\n### hpm install\n\nInstalla dipendenze o aggiungi nuovi pacchetti.\n\n```bash\nhpm install                           # Installa tutto da package.json\nhpm install proprietario/repo         # Aggiungi e installa pacchetto\nhpm install proprietario/repo@^1.0.0  # Con vincolo di versione\nhpm install proprietario/repo --dev   # Come dipendenza di sviluppo\nhpm i proprietario/repo               # Forma breve\n```\n\n**Opzioni:**\n\n| Opzione | Descrizione |\n|---------|-------------|\n| `--dev`, `-D` | Aggiungi a devDependencies |\n| `--verbose` | Mostra progresso dettagliato |\n| `--dry-run` | Anteprima senza installare |\n| `--offline` | Installa solo dalla cache (nessuna rete) |\n| `--parallel` | Abilita download paralleli (sperimentale) |\n\n**Sintassi vincoli di versione:**\n\n| Sintassi | Esempio | Significato |\n|----------|---------|-------------|\n| (nessuno) | `proprietario/repo` | Ultima versione |\n| Esatta | `proprietario/repo@1.2.3` | Esattamente 1.2.3 |\n| Caret | `proprietario/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| Tilde | `proprietario/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| Range | `proprietario/repo@>=1.0.0` | Almeno 1.0.0 |\n\n**Esempi:**\n\n```bash\n# Installa tutte le dipendenze\nhpm install\n\n# Installa pacchetto specifico\nhpm install hemlang/json\n\n# Installa con vincolo di versione\nhpm install hemlang/sprout@^2.0.0\n\n# Installa come dipendenza di sviluppo\nhpm install hemlang/test-utils --dev\n\n# Anteprima di cio che verrebbe installato\nhpm install hemlang/sprout --dry-run\n\n# Output verboso\nhpm install --verbose\n\n# Installa solo dalla cache (offline)\nhpm install --offline\n```\n\n**Output:**\n\n```\nInstallazione dipendenze...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (dipendenza di hemlang/sprout)\n\nInstallati 2 pacchetti in 1.2s\n```\n\n---\n\n### hpm uninstall\n\nRimuovi un pacchetto.\n\n```bash\nhpm uninstall proprietario/repo\nhpm rm proprietario/repo          # Forma breve\nhpm remove proprietario/repo      # Alternativa\n```\n\n**Esempi:**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**Output:**\n\n```\nRimosso hemlang/sprout@2.1.0\nAggiornato package.json\nAggiornato package-lock.json\n```\n\n---\n\n### hpm update\n\nAggiorna i pacchetti alle ultime versioni entro i vincoli.\n\n```bash\nhpm update              # Aggiorna tutti i pacchetti\nhpm update proprietario/repo   # Aggiorna pacchetto specifico\nhpm up proprietario/repo       # Forma breve\n```\n\n**Opzioni:**\n\n| Opzione | Descrizione |\n|---------|-------------|\n| `--verbose` | Mostra progresso dettagliato |\n| `--dry-run` | Anteprima senza aggiornare |\n\n**Esempi:**\n\n```bash\n# Aggiorna tutti i pacchetti\nhpm update\n\n# Aggiorna pacchetto specifico\nhpm update hemlang/sprout\n\n# Anteprima aggiornamenti\nhpm update --dry-run\n```\n\n**Output:**\n\n```\nAggiornamento dipendenze...\n  hemlang/sprout: 2.0.0  2.1.0\n  hemlang/router: 1.4.0  1.5.0\n\nAggiornati 2 pacchetti\n```\n\n---\n\n### hpm list\n\nMostra i pacchetti installati.\n\n```bash\nhpm list              # Mostra albero completo delle dipendenze\nhpm list --depth=0    # Solo dipendenze dirette\nhpm list --depth=1    # Un livello di dipendenze transitive\nhpm ls                # Forma breve\n```\n\n**Opzioni:**\n\n| Opzione | Descrizione |\n|---------|-------------|\n| `--depth=N` | Limita profondita albero (default: tutto) |\n\n**Esempi:**\n\n```bash\n$ hpm list\nmio-progetto@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n    hemlang/middleware@1.2.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmio-progetto@1.0.0\n hemlang/sprout@2.1.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\nMostra i pacchetti con versioni piu recenti disponibili.\n\n```bash\nhpm outdated\n```\n\n**Output:**\n\n```\nPacchetto          Corrente Desiderata Ultima\nhemlang/sprout     2.0.0    2.0.5      2.1.0\nhemlang/router     1.4.0    1.4.2      1.5.0\n```\n\n- **Corrente**: Versione installata\n- **Desiderata**: Versione piu alta che soddisfa il vincolo\n- **Ultima**: Ultima versione disponibile\n\n---\n\n### hpm run\n\nEsegui uno script da package.json.\n\n```bash\nhpm run <script>\nhpm run <script> -- <argomenti>\n```\n\n**Esempi:**\n\nDato questo package.json:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nEsegui gli script:\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# Passa argomenti allo script\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\nAbbreviazione per `hpm run test`.\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\nEquivalente a:\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\nSpiega perche un pacchetto e installato (mostra la catena delle dipendenze).\n\n```bash\nhpm why proprietario/repo\n```\n\n**Esempio:**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 e installato perche:\n\nmio-progetto@1.0.0\n hemlang/sprout@2.1.0\n     hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\nGestisci la cache globale dei pacchetti.\n\n```bash\nhpm cache list    # Elenca pacchetti in cache\nhpm cache clean   # Pulisci tutti i pacchetti in cache\n```\n\n**Sottocomandi:**\n\n| Sottocomando | Descrizione |\n|--------------|-------------|\n| `list` | Mostra tutti i pacchetti in cache e le dimensioni |\n| `clean` | Rimuovi tutti i pacchetti in cache |\n\n**Esempi:**\n\n```bash\n$ hpm cache list\nPacchetti in cache in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotale: 2.95 MB\n\n$ hpm cache clean\nCache pulita (2.95 MB liberati)\n```\n\n---\n\n## Scorciatoie dei Comandi\n\nPer comodita, diversi comandi hanno alias brevi:\n\n| Comando | Scorciatoie |\n|---------|-------------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**Esempi:**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## Codici di Uscita\n\nhpm usa codici di uscita specifici per indicare diverse condizioni di errore:\n\n| Codice | Significato |\n|--------|-------------|\n| 0 | Successo |\n| 1 | Conflitto di dipendenze |\n| 2 | Pacchetto non trovato |\n| 3 | Versione non trovata |\n| 4 | Errore di rete |\n| 5 | package.json non valido |\n| 6 | Verifica integrita fallita |\n| 7 | Limite di frequenza GitHub superato |\n| 8 | Dipendenza circolare |\n\nUsa i codici di uscita negli script:\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installazione fallita\"\n    exit 1\nfi\n```\n\n---\n\n## Variabili d'Ambiente\n\nhpm rispetta queste variabili d'ambiente:\n\n| Variabile | Descrizione |\n|-----------|-------------|\n| `GITHUB_TOKEN` | Token API GitHub per autenticazione |\n| `HPM_CACHE_DIR` | Sovrascrive la posizione della directory cache |\n| `HOME` | Directory home utente (per config/cache) |\n\n**Esempi:**\n\n```bash\n# Usa token GitHub per limiti di frequenza piu alti\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Usa directory cache personalizzata\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## Vedi Anche\n\n- [Configurazione](#hpm-commands-configuration) - File di configurazione\n- [Specifiche dei Pacchetti](#hpm-commands-package-spec) - Formato package.json\n- [Risoluzione dei Problemi](#hpm-commands-troubleshooting) - Problemi comuni\n"}, "hpm: Guida Utente -> Configurazione": {"id": "hpm-configuration", "content": "# Configurazione\n\nQuesta guida copre tutte le opzioni di configurazione per hpm.\n\n## Panoramica\n\nhpm puo essere configurato attraverso:\n\n1. **Variabili d'ambiente** - Per impostazioni runtime\n2. **File di configurazione globale** - `~/.hpm/config.json`\n3. **File di progetto** - `package.json` e `package-lock.json`\n\n## Variabili d'Ambiente\n\n### GITHUB_TOKEN\n\nToken API GitHub per l'autenticazione.\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**Vantaggi dell'autenticazione:**\n- Limiti di frequenza API piu alti (5000 vs 60 richieste/ora)\n- Accesso a repository privati\n- Risoluzione delle dipendenze piu veloce\n\n**Creazione di un token:**\n\n1. Vai su GitHub -> Impostazioni -> Impostazioni sviluppatore -> Token di accesso personali\n2. Clicca \"Genera nuovo token (classico)\"\n3. Seleziona gli ambiti:\n   - `repo` - Per accesso a repository privati\n   - `read:packages` - Per GitHub Packages (se usato)\n4. Genera e copia il token\n\n### HPM_CACHE_DIR\n\nSovrascrive la directory cache predefinita.\n\n```bash\nexport HPM_CACHE_DIR=/percorso/cache/personalizzato\n```\n\nPredefinito: `~/.hpm/cache`\n\n**Casi d'uso:**\n- Sistemi CI/CD con posizioni cache personalizzate\n- Cache condivisa tra progetti\n- Cache temporanea per build isolate\n\n### HOME\n\nDirectory home dell'utente. Usata per localizzare:\n- Directory config: `$HOME/.hpm/`\n- Directory cache: `$HOME/.hpm/cache/`\n\nSolitamente impostata dal sistema; sovrascrivere solo se necessario.\n\n### Esempio .bashrc / .zshrc\n\n```bash\n# Autenticazione GitHub (consigliata)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# Posizione cache personalizzata (opzionale)\n# export HPM_CACHE_DIR=/percorso/a/cache\n\n# Aggiungi hpm al PATH (se usi posizione di installazione personalizzata)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## File di Configurazione Globale\n\n### Posizione\n\n`~/.hpm/config.json`\n\n### Formato\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### Creazione del File di Configurazione\n\n```bash\n# Crea directory di configurazione\nmkdir -p ~/.hpm\n\n# Crea file di configurazione\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_il_tuo_token_qui\"\n}\nEOF\n\n# Proteggi il file (consigliato)\nchmod 600 ~/.hpm/config.json\n```\n\n### Priorita del Token\n\nSe entrambi sono impostati, la variabile d'ambiente ha la precedenza:\n\n1. Variabile d'ambiente `GITHUB_TOKEN` (piu alta)\n2. Campo `github_token` in `~/.hpm/config.json`\n3. Nessuna autenticazione (default)\n\n## Struttura delle Directory\n\n### Directory Globali\n\n```\n~/.hpm/\n config.json          # Configurazione globale\n cache/               # Cache dei pacchetti\n     proprietario/\n         repo/\n             1.0.0.tar.gz\n```\n\n### Directory di Progetto\n\n```\nmio-progetto/\n package.json         # Manifesto del progetto\n package-lock.json    # File di lock delle dipendenze\n hem_modules/         # Pacchetti installati\n    proprietario/\n        repo/\n            package.json\n            src/\n src/                 # Codice sorgente\n test/                # Test\n```\n\n## Cache dei Pacchetti\n\n### Posizione\n\nPredefinita: `~/.hpm/cache/`\n\nSovrascrivere con: variabile d'ambiente `HPM_CACHE_DIR`\n\n### Struttura\n\n```\n~/.hpm/cache/\n hemlang/\n    sprout/\n       2.0.0.tar.gz\n       2.1.0.tar.gz\n    router/\n        1.5.0.tar.gz\n alice/\n     http-client/\n         1.0.0.tar.gz\n```\n\n### Gestione della Cache\n\n```bash\n# Visualizza pacchetti in cache\nhpm cache list\n\n# Pulisci l'intera cache\nhpm cache clean\n```\n\n### Comportamento della Cache\n\n- I pacchetti vengono messi in cache dopo il primo download\n- Le installazioni successive usano le versioni in cache\n- Usa `--offline` per installare solo dalla cache\n- La cache e condivisa tra tutti i progetti\n\n## Limiti di Frequenza API GitHub\n\n### Senza Autenticazione\n\n- **60 richieste per ora** per indirizzo IP\n- Condiviso tra tutti gli utenti non autenticati sullo stesso IP\n- Esaurito rapidamente in CI/CD o con molte dipendenze\n\n### Con Autenticazione\n\n- **5000 richieste per ora** per utente autenticato\n- Limite di frequenza personale, non condiviso\n\n### Gestione dei Limiti di Frequenza\n\nhpm automaticamente:\n- Riprova con backoff esponenziale (1s, 2s, 4s, 8s)\n- Riporta errori di limite di frequenza con codice di uscita 7\n- Suggerisce l'autenticazione se viene raggiunto il limite\n\n**Soluzioni quando si raggiunge il limite:**\n\n```bash\n# Opzione 1: Autenticarsi con token GitHub\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Opzione 2: Aspettare il reset del limite di frequenza\n# (I limiti si resettano ogni ora)\n\n# Opzione 3: Usare la modalita offline (se i pacchetti sono in cache)\nhpm install --offline\n```\n\n## Modalita Offline\n\nInstalla pacchetti senza accesso alla rete:\n\n```bash\nhpm install --offline\n```\n\n**Requisiti:**\n- Tutti i pacchetti devono essere in cache\n- Il file di lock deve esistere con versioni esatte\n\n**Casi d'uso:**\n- Ambienti air-gapped\n- Build CI/CD piu veloci (con cache calda)\n- Evitare limiti di frequenza\n\n## Configurazione CI/CD\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Configura Hemlock\n      run: |\n        # Installa Hemlock (adatta in base alla tua configurazione)\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: Cache pacchetti hpm\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Installa dipendenze\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Esegui test\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile:**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# Copia prima i file del pacchetto (per il caching dei layer)\nCOPY package.json package-lock.json ./\n\n# Installa le dipendenze\nRUN hpm install\n\n# Copia il codice sorgente\nCOPY . .\n\n# Esegui l'applicazione\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml:**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## Configurazione Proxy\n\nPer ambienti dietro un proxy, configura a livello di sistema:\n\n```bash\nexport HTTP_PROXY=http://proxy.esempio.com:8080\nexport HTTPS_PROXY=http://proxy.esempio.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## Best Practice di Sicurezza\n\n### Sicurezza del Token\n\n1. **Non committare mai token** nel controllo versione\n2. **Usa variabili d'ambiente** in CI/CD\n3. **Limita gli ambiti del token** al minimo necessario\n4. **Ruota i token** regolarmente\n5. **Proteggi il file di configurazione**:\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### Repository Privati\n\nPer accedere a pacchetti privati:\n\n1. Crea token con ambito `repo`\n2. Configura l'autenticazione (variabile d'ambiente o file di configurazione)\n3. Assicurati che il token abbia accesso al repository\n\n```bash\n# Testa l'accesso\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install tuaorg/pacchetto-privato\n```\n\n## Risoluzione Problemi di Configurazione\n\n### Verifica Configurazione\n\n```bash\n# Controlla se il token e impostato\necho $GITHUB_TOKEN | head -c 10\n\n# Controlla il file di configurazione\ncat ~/.hpm/config.json\n\n# Controlla la directory cache\nls -la ~/.hpm/cache/\n\n# Testa con output verboso\nhpm install --verbose\n```\n\n### Problemi Comuni\n\n**\"Limite di frequenza GitHub superato\"**\n- Configura l'autenticazione con `GITHUB_TOKEN`\n- Aspetta il reset del limite di frequenza\n- Usa `--offline` se i pacchetti sono in cache\n\n**\"Permesso negato\" sulla cache**\n```bash\n# Correggi i permessi della cache\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"File di configurazione non trovato\"**\n```bash\n# Crea la directory di configurazione\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## Vedi Anche\n\n- [Installazione](#hpm-configuration-installation) - Installare hpm\n- [Risoluzione dei Problemi](#hpm-configuration-troubleshooting) - Problemi comuni\n- [Comandi](#hpm-configuration-commands) - Riferimento comandi\n"}, "hpm: Guida Utente -> Risoluzione dei Problemi": {"id": "hpm-troubleshooting", "content": "# Risoluzione dei Problemi\n\nSoluzioni ai problemi comuni di hpm.\n\n## Problemi di Installazione\n\n### \"hemlock: comando non trovato\"\n\n**Causa:** Hemlock non e installato o non e nel PATH.\n\n**Soluzione:**\n\n```bash\n# Controlla se hemlock esiste\nwhich hemlock\n\n# Se non trovato, installa prima Hemlock\n# Visita: https://github.com/hemlang/hemlock\n\n# Dopo l'installazione, verifica\nhemlock --version\n```\n\n### \"hpm: comando non trovato\"\n\n**Causa:** hpm non e installato o non e nel PATH.\n\n**Soluzione:**\n\n```bash\n# Controlla dove e installato hpm\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# Se usi una posizione personalizzata, aggiungi al PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# Aggiungi a ~/.bashrc o ~/.zshrc per renderlo permanente\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# Reinstalla se necessario\ncd /percorso/a/hpm\nsudo make install\n```\n\n### \"Permesso negato\" durante l'installazione\n\n**Causa:** Nessun permesso di scrittura nella directory di installazione.\n\n**Soluzione:**\n\n```bash\n# Opzione 1: Usa sudo per installazione a livello di sistema\nsudo make install\n\n# Opzione 2: Installa nella directory utente (senza sudo)\nmake install PREFIX=$HOME/.local\n```\n\n## Problemi di Dipendenze\n\n### \"Pacchetto non trovato\" (codice di uscita 2)\n\n**Causa:** Il pacchetto non esiste su GitHub.\n\n**Soluzione:**\n\n```bash\n# Verifica che il pacchetto esista\n# Controlla: https://github.com/proprietario/repo\n\n# Verifica l'ortografia\nhpm install hemlang/sprout  # Corretto\nhpm install hemlan/sprout   # Proprietario sbagliato\nhpm install hemlang/spout   # Repo sbagliato\n\n# Controlla errori di battitura in package.json\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Versione non trovata\" (codice di uscita 3)\n\n**Causa:** Nessuna release corrisponde al vincolo di versione.\n\n**Soluzione:**\n\n```bash\n# Elenca le versioni disponibili (controlla release/tag su GitHub)\n# I tag devono iniziare con 'v' (es. v1.0.0)\n\n# Usa un vincolo di versione valido\nhpm install proprietario/repo@^1.0.0\n\n# Prova l'ultima versione\nhpm install proprietario/repo\n\n# Controlla i tag disponibili su GitHub\n# https://github.com/proprietario/repo/tags\n```\n\n### \"Conflitto di dipendenze\" (codice di uscita 1)\n\n**Causa:** Due pacchetti richiedono versioni incompatibili di una dipendenza.\n\n**Soluzione:**\n\n```bash\n# Vedi il conflitto\nhpm install --verbose\n\n# Controlla cosa richiede la dipendenza\nhpm why pacchetto/in-conflitto\n\n# Soluzioni:\n# 1. Aggiorna il pacchetto in conflitto\nhpm update pacchetto/problema\n\n# 2. Cambia i vincoli di versione in package.json\n# Modifica per permettere versioni compatibili\n\n# 3. Rimuovi uno dei pacchetti in conflitto\nhpm uninstall un/pacchetto\n```\n\n### \"Dipendenza circolare\" (codice di uscita 8)\n\n**Causa:** Il pacchetto A dipende da B, che dipende da A.\n\n**Soluzione:**\n\n```bash\n# Identifica il ciclo\nhpm install --verbose\n\n# Questo e solitamente un bug nei pacchetti\n# Contatta i manutentori dei pacchetti\n\n# Workaround: evita uno dei pacchetti\n```\n\n## Problemi di Rete\n\n### \"Errore di rete\" (codice di uscita 4)\n\n**Causa:** Impossibile connettersi all'API GitHub.\n\n**Soluzione:**\n\n```bash\n# Controlla la connessione internet\nping github.com\n\n# Controlla se l'API GitHub e accessibile\ncurl -I https://api.github.com\n\n# Riprova (hpm riprova automaticamente)\nhpm install\n\n# Usa la modalita offline se i pacchetti sono in cache\nhpm install --offline\n\n# Controlla le impostazioni proxy se sei dietro un firewall\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"Limite di frequenza GitHub superato\" (codice di uscita 7)\n\n**Causa:** Troppe richieste API senza autenticazione.\n\n**Soluzione:**\n\n```bash\n# Opzione 1: Autenticati con token GitHub (consigliato)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Crea token: GitHub -> Impostazioni -> Impostazioni sviluppatore -> Token di accesso personali\n\n# Opzione 2: Salva il token nel file di configurazione\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# Opzione 3: Aspetta il reset del limite di frequenza (si resetta ogni ora)\n\n# Opzione 4: Usa la modalita offline\nhpm install --offline\n```\n\n### Timeout della connessione\n\n**Causa:** Rete lenta o problemi API GitHub.\n\n**Soluzione:**\n\n```bash\n# hpm riprova automaticamente con backoff esponenziale\n\n# Controlla se GitHub ha problemi\n# Visita: https://www.githubstatus.com\n\n# Riprova piu tardi\nhpm install\n\n# Usa i pacchetti in cache\nhpm install --offline\n```\n\n## Problemi di Package.json\n\n### \"package.json non valido\" (codice di uscita 5)\n\n**Causa:** Malformato o campi obbligatori mancanti.\n\n**Soluzione:**\n\n```bash\n# Valida la sintassi JSON\ncat package.json | python -m json.tool\n\n# Controlla i campi obbligatori\ncat package.json\n\n# Campi obbligatori:\n# - \"name\": formato proprietario/repo\n# - \"version\": formato X.Y.Z\n\n# Rigenera se necessario\nrm package.json\nhpm init\n```\n\n### Errore formato \"name\"\n\n**Causa:** Nome pacchetto non nel formato `proprietario/repo`.\n\n**Soluzione:**\n\n```json\n// Sbagliato\n{\n  \"name\": \"mio-pacchetto\"\n}\n\n// Corretto\n{\n  \"name\": \"tuonome/mio-pacchetto\"\n}\n```\n\n### Errore formato \"version\"\n\n**Causa:** Versione non nel formato semver.\n\n**Soluzione:**\n\n```json\n// Sbagliato\n{\n  \"version\": \"1.0\"\n}\n\n// Corretto\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## Problemi del File di Lock\n\n### File di lock non sincronizzato\n\n**Causa:** package.json modificato senza eseguire install.\n\n**Soluzione:**\n\n```bash\n# Rigenera il file di lock\nrm package-lock.json\nhpm install\n```\n\n### File di lock corrotto\n\n**Causa:** JSON non valido o modifiche manuali.\n\n**Soluzione:**\n\n```bash\n# Controlla validita JSON\ncat package-lock.json | python -m json.tool\n\n# Rigenera\nrm package-lock.json\nhpm install\n```\n\n## Problemi di hem_modules\n\n### I pacchetti non si installano\n\n**Causa:** Vari possibili problemi.\n\n**Soluzione:**\n\n```bash\n# Pulisci e reinstalla\nrm -rf hem_modules\nhpm install\n\n# Controlla output verboso\nhpm install --verbose\n```\n\n### L'import non funziona\n\n**Causa:** Pacchetto non installato correttamente o percorso import sbagliato.\n\n**Soluzione:**\n\n```bash\n# Verifica che il pacchetto sia installato\nls hem_modules/proprietario/repo/\n\n# Controlla il campo main di package.json\ncat hem_modules/proprietario/repo/package.json\n\n# Formato import corretto\nimport { x } from \"proprietario/repo\";          # Usa la voce main\nimport { y } from \"proprietario/repo/sottopercorso\";  # Import sottopercorso\n```\n\n### Errore \"Modulo non trovato\"\n\n**Causa:** Il percorso import non si risolve a un file.\n\n**Soluzione:**\n\n```bash\n# Controlla il percorso import\nls hem_modules/proprietario/repo/src/\n\n# Controlla index.hml\nls hem_modules/proprietario/repo/src/index.hml\n\n# Verifica il campo main in package.json\ncat hem_modules/proprietario/repo/package.json | grep main\n```\n\n## Problemi di Cache\n\n### La cache occupa troppo spazio\n\n**Soluzione:**\n\n```bash\n# Visualizza dimensione cache\nhpm cache list\n\n# Pulisci cache\nhpm cache clean\n```\n\n### Permessi cache\n\n**Soluzione:**\n\n```bash\n# Correggi permessi\nchmod -R u+rw ~/.hpm/cache\n\n# Oppure rimuovi e reinstalla\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### Usa cache sbagliata\n\n**Soluzione:**\n\n```bash\n# Controlla posizione cache\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# Pulisci variabile d'ambiente se non corretta\nunset HPM_CACHE_DIR\n```\n\n## Problemi di Script\n\n### \"Script non trovato\"\n\n**Causa:** Il nome dello script non esiste in package.json.\n\n**Soluzione:**\n\n```bash\n# Elenca script disponibili\ncat package.json | grep -A 20 scripts\n\n# Controlla l'ortografia\nhpm run test    # Corretto\nhpm run tests   # Sbagliato se lo script si chiama \"test\"\n```\n\n### Lo script fallisce\n\n**Causa:** Errore nel comando dello script.\n\n**Soluzione:**\n\n```bash\n# Esegui il comando direttamente per vedere l'errore\nhemlock test/run.hml\n\n# Controlla la definizione dello script\ncat package.json | grep test\n```\n\n## Debug\n\n### Abilita output verboso\n\n```bash\nhpm install --verbose\n```\n\n### Controlla versione hpm\n\n```bash\nhpm --version\n```\n\n### Controlla versione hemlock\n\n```bash\nhemlock --version\n```\n\n### Dry run\n\nAnteprima senza apportare modifiche:\n\n```bash\nhpm install --dry-run\n```\n\n### Ripartire da zero\n\nRicomincia da capo:\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## Ottenere Aiuto\n\n### Aiuto comandi\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### Segnalare problemi\n\nSe incontri un bug:\n\n1. Controlla i problemi esistenti: https://github.com/hemlang/hpm/issues\n2. Crea un nuovo problema con:\n   - Versione hpm (`hpm --version`)\n   - Versione Hemlock (`hemlock --version`)\n   - Sistema operativo\n   - Passi per riprodurre\n   - Messaggio di errore (usa `--verbose`)\n\n## Riferimento Codici di Uscita\n\n| Codice | Significato | Soluzione Comune |\n|--------|-------------|------------------|\n| 0 | Successo | - |\n| 1 | Conflitto di dipendenze | Aggiorna o cambia i vincoli |\n| 2 | Pacchetto non trovato | Controlla ortografia, verifica che il repo esista |\n| 3 | Versione non trovata | Controlla versioni disponibili su GitHub |\n| 4 | Errore di rete | Controlla connessione, riprova |\n| 5 | package.json non valido | Correggi sintassi JSON e campi obbligatori |\n| 6 | Verifica integrita fallita | Pulisci cache, reinstalla |\n| 7 | Limite frequenza GitHub | Aggiungi GITHUB_TOKEN |\n| 8 | Dipendenza circolare | Contatta i manutentori dei pacchetti |\n\n## Vedi Anche\n\n- [Installazione](#hpm-troubleshooting-installation) - Guida all'installazione\n- [Configurazione](#hpm-troubleshooting-configuration) - Opzioni di configurazione\n- [Comandi](#hpm-troubleshooting-commands) - Riferimento comandi\n"}, "hpm: Sviluppo Pacchetti -> Creazione di Pacchetti": {"id": "hpm-creating-packages", "content": "# Creazione di Pacchetti\n\nQuesta guida spiega come creare, strutturare e pubblicare pacchetti Hemlock.\n\n## Panoramica\n\nhpm usa GitHub come suo registro di pacchetti. I pacchetti sono identificati dal loro percorso GitHub `proprietario/repo`, e le versioni sono tag Git. Pubblicare significa semplicemente pushare una release taggata.\n\n## Creazione di un Nuovo Pacchetto\n\n### 1. Inizializza il Pacchetto\n\nCrea una nuova directory e inizializza:\n\n```bash\nmkdir mio-pacchetto\ncd mio-pacchetto\nhpm init\n```\n\nRispondi ai prompt:\n\n```\nNome pacchetto (proprietario/repo): tuonome/mio-pacchetto\nVersione (1.0.0):\nDescrizione: Un utile pacchetto Hemlock\nAutore: Il Tuo Nome <tu@esempio.com>\nLicenza (MIT):\nFile principale (src/index.hml):\n\nCreato package.json\n```\n\n### 2. Crea la Struttura del Progetto\n\nStruttura consigliata per i pacchetti:\n\n```\nmio-pacchetto/\n package.json          # Manifesto del pacchetto\n README.md             # Documentazione\n LICENSE               # File di licenza\n src/\n    index.hml         # Punto di ingresso principale (esporta API pubblica)\n    utils.hml         # Utilita interne\n    types.hml         # Definizioni dei tipi\n test/\n     framework.hml     # Framework di test\n     test_utils.hml    # Test\n```\n\n### 3. Definisci la Tua API Pubblica\n\n**src/index.hml** - Punto di ingresso principale:\n\n```hemlock\n// Riesporta API pubblica\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// Export diretti\nexport fn create(options: Options): Config {\n    // Implementazione\n}\n\nexport fn validate(config: Config): bool {\n    // Implementazione\n}\n```\n\n### 4. Scrivi il Tuo package.json\n\nEsempio completo di package.json:\n\n```json\n{\n  \"name\": \"tuonome/mio-pacchetto\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Un utile pacchetto Hemlock\",\n  \"author\": \"Il Tuo Nome <tu@esempio.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/tuonome/mio-pacchetto\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utilita\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## Denominazione dei Pacchetti\n\n### Requisiti\n\n- Deve essere nel formato `proprietario/repo`\n- `proprietario` dovrebbe essere il tuo username o organizzazione GitHub\n- `repo` dovrebbe essere il nome del repository\n- Usa minuscole con trattini per nomi composti\n\n### Nomi Validi\n\n```\nhemlang/sprout\nalice/http-client\nmiaorg/json-utils\nbob/date-formatter\n```\n\n### Da Evitare\n\n```\nmio-pacchetto          # Manca il proprietario\nalice/MioPacchetto     # PascalCase\nalice/mio_pacchetto    # Underscore\n```\n\n## Best Practice per la Struttura del Pacchetto\n\n### Punto di Ingresso\n\nIl campo `main` in package.json specifica il punto di ingresso:\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\nQuesto file dovrebbe esportare la tua API pubblica:\n\n```hemlock\n// Esporta tutto cio di cui gli utenti hanno bisogno\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// Tipi\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### Interno vs Pubblico\n\nMantieni i dettagli di implementazione interni privati:\n\n```\nsrc/\n index.hml          # Pubblico: API esportata\n parser.hml         # Pubblico: usato da index.hml\n formatter.hml      # Pubblico: usato da index.hml\n internal/\n     helpers.hml    # Privato: solo uso interno\n     constants.hml  # Privato: solo uso interno\n```\n\nGli utenti importano dalla root del tuo pacchetto:\n\n```hemlock\n// Buono - importa dall'API pubblica\nimport { parse, Parser } from \"tuonome/mio-pacchetto\";\n\n// Funziona anche - import da sottopercorso\nimport { validate } from \"tuonome/mio-pacchetto/validator\";\n\n// Sconsigliato - accesso agli interni\nimport { helper } from \"tuonome/mio-pacchetto/internal/helpers\";\n```\n\n### Export da Sottopercorso\n\nSupporta l'import da sottopercorsi:\n\n```\nsrc/\n index.hml              # Ingresso principale\n parser/\n    index.hml          # tuonome/pkg/parser\n formatter/\n    index.hml          # tuonome/pkg/formatter\n utils/\n     index.hml          # tuonome/pkg/utils\n```\n\nGli utenti possono importare:\n\n```hemlock\nimport { parse } from \"tuonome/mio-pacchetto\";           # Principale\nimport { Parser } from \"tuonome/mio-pacchetto/parser\";   # Sottopercorso\nimport { format } from \"tuonome/mio-pacchetto/formatter\";\n```\n\n## Dipendenze\n\n### Aggiungere Dipendenze\n\n```bash\n# Dipendenza runtime\nhpm install hemlang/json\n\n# Dipendenza di sviluppo\nhpm install hemlang/test-utils --dev\n```\n\n### Best Practice per le Dipendenze\n\n1. **Usa range caret** per la maggior parte delle dipendenze:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **Fissa le versioni** solo quando necessario (instabilita API):\n   ```json\n   {\n     \"dependencies\": {\n       \"instabile/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **Evita range troppo restrittivi**:\n   ```json\n   // Male: troppo restrittivo\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // Bene: permette aggiornamenti compatibili\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **Separa le dipendenze di sviluppo**:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## Test del Pacchetto\n\n### Scrivi i Test\n\n**test/run.hml:**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn esegui_test() {\n    suite(\"Parser\", fn() {\n        test(\"analizza input valido\", fn() {\n            let risultato = parse(\"ciao\");\n            assert_eq(risultato.value, \"ciao\");\n        });\n\n        test(\"gestisce input vuoto\", fn() {\n            let risultato = parse(\"\");\n            assert_eq(risultato.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"converte oggetto in stringa\", fn() {\n            let obj = { nome: \"test\" };\n            let risultato = stringify(obj);\n            assert_eq(risultato, '{\"nome\":\"test\"}');\n        });\n    });\n}\n\nesegui_test();\n```\n\n### Esegui i Test\n\nAggiungi uno script di test:\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\nEsegui con:\n\n```bash\nhpm test\n```\n\n## Pubblicazione\n\n### Prerequisiti\n\n1. Crea un repository GitHub corrispondente al nome del tuo pacchetto\n2. Assicurati che `package.json` sia completo e valido\n3. Tutti i test passano\n\n### Processo di Pubblicazione\n\nPubblicare significa semplicemente pushare un tag Git:\n\n```bash\n# 1. Assicurati che tutto sia committato\ngit add .\ngit commit -m \"Prepara release v1.0.0\"\n\n# 2. Crea un tag versione (deve iniziare con 'v')\ngit tag v1.0.0\n\n# 3. Pusha codice e tag\ngit push origin main\ngit push origin v1.0.0\n# Oppure pusha tutti i tag insieme\ngit push origin main --tags\n```\n\n### Tag di Versione\n\nI tag devono seguire il formato `vX.Y.Z`:\n\n```bash\ngit tag v1.0.0      # Release\ngit tag v1.0.1      # Patch\ngit tag v1.1.0      # Minor\ngit tag v2.0.0      # Major\ngit tag v1.0.0-beta.1  # Pre-release\n```\n\n### Checklist per la Release\n\nPrima di pubblicare una nuova versione:\n\n1. **Aggiorna la versione** in package.json\n2. **Esegui i test**: `hpm test`\n3. **Aggiorna il CHANGELOG** (se ne hai uno)\n4. **Aggiorna il README** se l'API e cambiata\n5. **Committa le modifiche**\n6. **Crea il tag**\n7. **Pusha su GitHub**\n\n### Esempio Automatizzato\n\nCrea uno script di release:\n\n```bash\n#!/bin/bash\n# release.sh - Rilascia una nuova versione\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Uso: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# Esegui i test\nhpm test || exit 1\n\n# Aggiorna la versione in package.json\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# Committa e tagga\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# Pusha\ngit push origin main --tags\n\necho \"Rilasciata v$VERSION\"\n```\n\n## Utenti che Installano il Tuo Pacchetto\n\nDopo la pubblicazione, gli utenti possono installare:\n\n```bash\n# Ultima versione\nhpm install tuonome/mio-pacchetto\n\n# Versione specifica\nhpm install tuonome/mio-pacchetto@1.0.0\n\n# Vincolo di versione\nhpm install tuonome/mio-pacchetto@^1.0.0\n```\n\nE importare:\n\n```hemlock\nimport { parse, stringify } from \"tuonome/mio-pacchetto\";\n```\n\n## Documentazione\n\n### README.md\n\nOgni pacchetto dovrebbe avere un README:\n\n```markdown\n# mio-pacchetto\n\nUna breve descrizione di cosa fa questo pacchetto.\n\n## Installazione\n\n\\`\\`\\`bash\nhpm install tuonome/mio-pacchetto\n\\`\\`\\`\n\n## Utilizzo\n\n\\`\\`\\`hemlock\nimport { parse } from \"tuonome/mio-pacchetto\";\n\nlet risultato = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\nAnalizza la stringa di input.\n\n### stringify(obj: any): string\n\nConverte l'oggetto in stringa.\n\n## Licenza\n\nMIT\n```\n\n### Documentazione API\n\nDocumenta tutti gli export pubblici:\n\n```hemlock\n/// Analizza la stringa di input in un Result strutturato.\n///\n/// # Argomenti\n/// * `input` - La stringa da analizzare\n///\n/// # Ritorna\n/// Un Result contenente i dati analizzati o un errore\n///\n/// # Esempio\n/// ```\n/// let risultato = parse(\"ciao mondo\");\n/// print(risultato.value);\n/// ```\nexport fn parse(input: string): Result {\n    // Implementazione\n}\n```\n\n## Linee Guida per il Versionamento\n\nSegui il [Versionamento Semantico](https://semver.org/):\n\n- **MAJOR** (1.0.0 -> 2.0.0): Modifiche incompatibili\n- **MINOR** (1.0.0 -> 1.1.0): Nuove funzionalita, retrocompatibili\n- **PATCH** (1.0.0 -> 1.0.1): Correzioni bug, retrocompatibili\n\n### Quando Incrementare\n\n| Tipo di Modifica | Incremento Versione |\n|------------------|---------------------|\n| Modifica API incompatibile | MAJOR |\n| Rimozione funzione/tipo | MAJOR |\n| Cambio firma funzione | MAJOR |\n| Aggiunta nuova funzione | MINOR |\n| Aggiunta nuova funzionalita | MINOR |\n| Correzione bug | PATCH |\n| Aggiornamento documentazione | PATCH |\n| Refactoring interno | PATCH |\n\n## Vedi Anche\n\n- [Specifiche dei Pacchetti](#hpm-creating-packages-package-spec) - Riferimento completo package.json\n- [Versionamento](#hpm-creating-packages-versioning) - Dettagli versionamento semantico\n- [Configurazione](#hpm-creating-packages-configuration) - Autenticazione GitHub\n"}, "hpm: Sviluppo Pacchetti -> Specifiche dei Pacchetti": {"id": "hpm-package-spec", "content": "# Specifiche dei Pacchetti\n\nRiferimento completo per il formato del file `package.json`.\n\n## Panoramica\n\nOgni pacchetto hpm richiede un file `package.json` nella root del progetto. Questo file definisce i metadati del pacchetto, le dipendenze e gli script.\n\n## Esempio Minimo\n\n```json\n{\n  \"name\": \"proprietario/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## Esempio Completo\n\n```json\n{\n  \"name\": \"hemlang/pacchetto-esempio\",\n  \"version\": \"1.2.3\",\n  \"description\": \"Un pacchetto Hemlock di esempio\",\n  \"author\": \"Team Hemlock <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/pacchetto-esempio\",\n  \"homepage\": \"https://hemlang.github.io/pacchetto-esempio\",\n  \"bugs\": \"https://github.com/hemlang/pacchetto-esempio/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"esempio\", \"utilita\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## Riferimento Campi\n\n### name (obbligatorio)\n\nIl nome del pacchetto nel formato `proprietario/repo`.\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**Requisiti:**\n- Deve essere nel formato `proprietario/repo`\n- `proprietario` dovrebbe essere il tuo username o organizzazione GitHub\n- `repo` dovrebbe essere il nome del repository\n- Usa lettere minuscole, numeri e trattini\n- Massimo 214 caratteri totali\n\n**Nomi validi:**\n```\nhemlang/sprout\nalice/http-client\nmiaorg/json-utils\nbob123/mia-lib\n```\n\n**Nomi non validi:**\n```\nmio-pacchetto          # Manca il proprietario\nhemlang/Mio_Pacchetto  # Maiuscole e underscore\nhemlang                # Manca il repo\n```\n\n### version (obbligatorio)\n\nLa versione del pacchetto seguendo il [Versionamento Semantico](https://semver.org/).\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**Formato:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`\n\n**Versioni valide:**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\nBreve descrizione del pacchetto.\n\n```json\n{\n  \"description\": \"Un parser JSON veloce per Hemlock\"\n}\n```\n\n- Mantienila sotto i 200 caratteri\n- Descrivi cosa fa il pacchetto, non come\n\n### author\n\nInformazioni sull'autore del pacchetto.\n\n```json\n{\n  \"author\": \"Il Tuo Nome <email@esempio.com>\"\n}\n```\n\n**Formati accettati:**\n```json\n\"author\": \"Il Tuo Nome\"\n\"author\": \"Il Tuo Nome <email@esempio.com>\"\n\"author\": \"Il Tuo Nome <email@esempio.com> (https://sitoweb.com)\"\n```\n\n### license\n\nL'identificatore della licenza.\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**Licenze comuni:**\n- `MIT` - Licenza MIT\n- `Apache-2.0` - Licenza Apache 2.0\n- `GPL-3.0` - GNU General Public License v3.0\n- `BSD-3-Clause` - Licenza BSD 3-Clause\n- `ISC` - Licenza ISC\n- `UNLICENSED` - Proprietario/privato\n\nUsa gli [identificatori SPDX](https://spdx.org/licenses/) quando possibile.\n\n### repository\n\nLink al repository sorgente.\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\nURL della homepage del progetto.\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\nURL del tracker dei problemi.\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\nFile punto di ingresso per il pacchetto.\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**Predefinito:** `src/index.hml`\n\nQuando gli utenti importano il tuo pacchetto:\n```hemlock\nimport { x } from \"proprietario/repo\";\n```\n\nhpm carica il file specificato in `main`.\n\n**Ordine di risoluzione per le import:**\n1. Percorso esatto: `src/index.hml`\n2. Con estensione .hml: `src/index` -> `src/index.hml`\n3. File index: `src/index/` -> `src/index/index.hml`\n\n### keywords\n\nArray di parole chiave per la scoperta.\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utilita\", \"hemlock\"]\n}\n```\n\n- Usa minuscole\n- Sii specifico e rilevante\n- Includi il linguaggio (\"hemlock\") se appropriato\n\n### dependencies\n\nDipendenze runtime richieste per il funzionamento del pacchetto.\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**Chiave:** Nome del pacchetto (`proprietario/repo`)\n**Valore:** Vincolo di versione\n\n**Sintassi vincoli di versione:**\n\n| Vincolo | Significato |\n|---------|-------------|\n| `1.2.3` | Versione esatta |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | Almeno 1.0.0 |\n| `>=1.0.0 <2.0.0` | Range |\n| `*` | Qualsiasi versione |\n\n### devDependencies\n\nDipendenze solo per lo sviluppo (test, build, ecc.).\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\nLe dipendenze di sviluppo sono:\n- Installate durante lo sviluppo\n- Non installate quando il pacchetto e usato come dipendenza\n- Usate per test, build, linting, ecc.\n\n### scripts\n\nComandi denominati che possono essere eseguiti con `hpm run`.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**Esecuzione degli script:**\n```bash\nhpm run start\nhpm run build\nhpm test        # Abbreviazione per 'hpm run test'\n```\n\n**Passare argomenti:**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**Script comuni:**\n\n| Script | Scopo |\n|--------|-------|\n| `start` | Avvia l'applicazione |\n| `dev` | Modalita sviluppo con hot reload |\n| `test` | Esegui i test |\n| `build` | Build per produzione |\n| `clean` | Rimuovi artefatti di build |\n| `lint` | Controlla stile codice |\n| `format` | Formatta il codice |\n\n### files\n\nFile e directory da includere quando il pacchetto viene installato.\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**Comportamento predefinito:** Se non specificato, include:\n- Tutti i file nel repository\n- Esclude `.git/`, `node_modules/`, `hem_modules/`\n\n**Usa per:**\n- Ridurre la dimensione del pacchetto\n- Escludere file di test dalla distribuzione\n- Includere solo i file necessari\n\n### native\n\nRequisiti di librerie native.\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\nDocumenta le dipendenze native che devono essere installate sul sistema.\n\n## Validazione\n\nhpm valida package.json in varie operazioni. Errori di validazione comuni:\n\n### Campi obbligatori mancanti\n\n```\nErrore: package.json manca del campo obbligatorio: name\n```\n\n**Soluzione:** Aggiungi il campo obbligatorio.\n\n### Formato nome non valido\n\n```\nErrore: Nome pacchetto non valido. Deve essere nel formato proprietario/repo.\n```\n\n**Soluzione:** Usa il formato `proprietario/repo`.\n\n### Versione non valida\n\n```\nErrore: Versione non valida \"1.0\". Deve essere in formato semver (X.Y.Z).\n```\n\n**Soluzione:** Usa il formato semver completo (`1.0.0`).\n\n### JSON non valido\n\n```\nErrore: package.json non e un JSON valido\n```\n\n**Soluzione:** Controlla la sintassi JSON (virgole, virgolette, parentesi).\n\n## Creazione di package.json\n\n### Interattivo\n\n```bash\nhpm init\n```\n\nRichiede ogni campo interattivamente.\n\n### Con Valori Predefiniti\n\n```bash\nhpm init --yes\n```\n\nCrea con valori predefiniti:\n```json\n{\n  \"name\": \"nome-directory/nome-directory\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### Manuale\n\nCrea il file manualmente:\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"tuonome/tuo-pacchetto\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Descrizione del tuo pacchetto\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## Best Practice\n\n1. **Specifica sempre main** - Non affidarti al default\n2. **Usa range caret** - `^1.0.0` per la maggior parte delle dipendenze\n3. **Separa le dipendenze di sviluppo** - Mantieni le dipendenze test/build in devDependencies\n4. **Includi keywords** - Aiuta gli utenti a trovare il tuo pacchetto\n5. **Documenta gli script** - Dai nomi chiari agli script\n6. **Specifica la licenza** - Obbligatorio per open source\n7. **Aggiungi descrizione** - Aiuta gli utenti a capire lo scopo\n\n## Vedi Anche\n\n- [Creazione di Pacchetti](#hpm-package-spec-creating-packages) - Guida alla pubblicazione\n- [Versionamento](#hpm-package-spec-versioning) - Vincoli di versione\n- [Configurazione del Progetto](#hpm-package-spec-project-setup) - Struttura del progetto\n"}, "hpm: Sviluppo Pacchetti -> Versionamento": {"id": "hpm-versioning", "content": "# Versionamento\n\nGuida completa al versionamento semantico in hpm.\n\n## Versionamento Semantico\n\nhpm usa il [Versionamento Semantico 2.0.0](https://semver.org/) (semver) per le versioni dei pacchetti.\n\n### Formato della Versione\n\n```\nMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**Esempi:**\n```\n1.0.0           # Versione di release\n2.1.3           # Versione di release\n1.0.0-alpha     # Pre-release\n1.0.0-beta.1    # Pre-release con numero\n1.0.0-rc.1      # Release candidate\n1.0.0+20231201  # Con metadati di build\n1.0.0-beta+exp  # Pre-release con metadati di build\n```\n\n### Componenti della Versione\n\n| Componente | Descrizione | Esempio |\n|------------|-------------|---------|\n| MAJOR | Modifiche incompatibili | `1.0.0` -> `2.0.0` |\n| MINOR | Nuove funzionalita (retrocompatibili) | `1.0.0` -> `1.1.0` |\n| PATCH | Correzioni bug (retrocompatibili) | `1.0.0` -> `1.0.1` |\n| PRERELEASE | Identificatore pre-release | `1.0.0-alpha` |\n| BUILD | Metadati di build (ignorati nel confronto) | `1.0.0+build123` |\n\n### Quando Incrementare\n\n| Tipo di Modifica | Incremento | Esempio |\n|------------------|------------|---------|\n| Modifica API incompatibile | MAJOR | Rimuovere una funzione |\n| Rinominare funzione pubblica | MAJOR | `parse()` -> `decode()` |\n| Cambiare firma funzione | MAJOR | Aggiungere parametro obbligatorio |\n| Aggiungere nuova funzione | MINOR | Aggiungere `validate()` |\n| Aggiungere parametro opzionale | MINOR | Nuovo argomento `options` opzionale |\n| Correzione bug | PATCH | Correggere puntatore nullo |\n| Miglioramento prestazioni | PATCH | Algoritmo piu veloce |\n| Refactoring interno | PATCH | Nessun cambio API |\n\n## Vincoli di Versione\n\n### Sintassi dei Vincoli\n\n| Sintassi | Significato | Si risolve in |\n|----------|-------------|---------------|\n| `1.2.3` | Versione esatta | Solo 1.2.3 |\n| `^1.2.3` | Caret (compatibile) | >=1.2.3 e <2.0.0 |\n| `~1.2.3` | Tilde (aggiornamenti patch) | >=1.2.3 e <1.3.0 |\n| `>=1.0.0` | Almeno | 1.0.0 o superiore |\n| `>1.0.0` | Maggiore di | Superiore a 1.0.0 |\n| `<2.0.0` | Minore di | Inferiore a 2.0.0 |\n| `<=2.0.0` | Al massimo | 2.0.0 o inferiore |\n| `>=1.0.0 <2.0.0` | Range | Tra 1.0.0 e 2.0.0 |\n| `*` | Qualsiasi | Qualsiasi versione |\n\n### Range Caret (^)\n\nIl caret (`^`) permette modifiche che non alterano la cifra non-zero piu a sinistra:\n\n```\n^1.2.3  ->  >=1.2.3 <2.0.0   # Permette 1.x.x\n^0.2.3  ->  >=0.2.3 <0.3.0   # Permette 0.2.x\n^0.0.3  ->  >=0.0.3 <0.0.4   # Permette solo 0.0.3\n```\n\n**Usa quando:** Vuoi aggiornamenti compatibili entro una versione major.\n\n**Vincolo piu comune** - consigliato per la maggior parte delle dipendenze.\n\n### Range Tilde (~)\n\nIl tilde (`~`) permette solo modifiche a livello patch:\n\n```\n~1.2.3  ->  >=1.2.3 <1.3.0   # Permette 1.2.x\n~1.2    ->  >=1.2.0 <1.3.0   # Permette 1.2.x\n~1      ->  >=1.0.0 <2.0.0   # Permette 1.x.x\n```\n\n**Usa quando:** Vuoi solo correzioni bug, nessuna nuova funzionalita.\n\n### Range di Confronto\n\nCombina operatori di confronto per un controllo preciso:\n\n```json\n{\n  \"dependencies\": {\n    \"proprietario/pkg\": \">=1.0.0 <2.0.0\",\n    \"proprietario/altro\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### Qualsiasi Versione (*)\n\nCorrisponde a qualsiasi versione:\n\n```json\n{\n  \"dependencies\": {\n    \"proprietario/pkg\": \"*\"\n  }\n}\n```\n\n**Attenzione:** Non consigliato per produzione. Prendera sempre l'ultima versione.\n\n## Versioni Pre-release\n\n### Identificatori Pre-release\n\nLe pre-release hanno precedenza inferiore rispetto alle release:\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### Tag Pre-release Comuni\n\n| Tag | Significato | Fase |\n|-----|-------------|------|\n| `alpha` | Sviluppo iniziale | Molto instabile |\n| `beta` | Funzionalita complete | Test |\n| `rc` | Release candidate | Test finali |\n| `dev` | Snapshot di sviluppo | Instabile |\n\n### Pre-release nei Vincoli\n\nI vincoli non corrispondono alle pre-release per default:\n\n```\n^1.0.0    # NON corrisponde a 1.1.0-beta\n>=1.0.0   # NON corrisponde a 2.0.0-alpha\n```\n\nPer includere le pre-release, referenziale esplicitamente:\n\n```\n>=1.0.0-alpha <2.0.0   # Include tutte le pre-release 1.x\n```\n\n## Confronto delle Versioni\n\n### Regole di Confronto\n\n1. Confronta MAJOR, MINOR, PATCH numericamente\n2. Release > pre-release con stessa versione\n3. Pre-release confrontate alfanumericamente\n4. Metadati di build ignorati\n\n### Esempi\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # Metadati di build ignorati\n```\n\n### Ordinamento\n\nLe versioni si ordinano in modo ascendente:\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## Risoluzione delle Versioni\n\n### Algoritmo di Risoluzione\n\nQuando piu pacchetti richiedono la stessa dipendenza:\n\n1. Raccogli tutti i vincoli\n2. Trova l'intersezione di tutti i range\n3. Seleziona la versione piu alta nell'intersezione\n4. Errore se nessuna versione soddisfa tutti\n\n### Esempio di Risoluzione\n\n```\npacchetto-a richiede hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npacchetto-b richiede hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\nIntersezione: >=1.2.0 <1.3.0\nDisponibili: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\nRisolto: 1.2.5 (piu alta nell'intersezione)\n```\n\n### Rilevamento Conflitti\n\nIl conflitto si verifica quando nessuna versione soddisfa tutti i vincoli:\n\n```\npacchetto-a richiede hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npacchetto-b richiede hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\nIntersezione: (vuota)\nRisultato: CONFLITTO - nessuna versione soddisfa entrambi\n```\n\n## Best Practice\n\n### Per i Consumatori di Pacchetti\n\n1. **Usa range caret** per la maggior parte delle dipendenze:\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **Usa range tilde** per dipendenze critiche:\n   ```json\n   \"critico/lib\": \"~1.2.0\"\n   ```\n\n3. **Fissa le versioni** solo quando necessario:\n   ```json\n   \"instabile/pkg\": \"1.2.3\"\n   ```\n\n4. **Committa il tuo file di lock** per build riproducibili\n\n5. **Aggiorna regolarmente** per ottenere correzioni di sicurezza:\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### Per gli Autori di Pacchetti\n\n1. **Inizia da 0.1.0** per lo sviluppo iniziale:\n   - L'API puo cambiare frequentemente\n   - Gli utenti si aspettano instabilita\n\n2. **Vai a 1.0.0** quando l'API e stabile:\n   - Impegno pubblico alla stabilita\n   - Le modifiche incompatibili richiedono bump major\n\n3. **Segui rigorosamente semver**:\n   - Modifica incompatibile = MAJOR\n   - Nuova funzionalita = MINOR\n   - Correzione bug = PATCH\n\n4. **Usa pre-release** per i test:\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **Documenta le modifiche incompatibili** nel CHANGELOG\n\n## Pubblicazione delle Versioni\n\n### Creazione delle Release\n\n```bash\n# Aggiorna la versione in package.json\n# Modifica package.json: \"version\": \"1.1.0\"\n\n# Committa la modifica della versione\ngit add package.json\ngit commit -m \"Bump versione a 1.1.0\"\n\n# Crea e pusha il tag\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### Formato del Tag\n\nI tag **devono** iniziare con `v`:\n\n```\nv1.0.0      Corretto\nv1.0.0-beta Corretto\n1.0.0       Non verra riconosciuto\n```\n\n### Flusso di Lavoro per la Release\n\n```bash\n# 1. Assicurati che i test passino\nhpm test\n\n# 2. Aggiorna la versione in package.json\n# 3. Aggiorna CHANGELOG.md\n# 4. Committa le modifiche\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. Crea il tag\ngit tag v1.2.0\n\n# 6. Pusha tutto\ngit push origin main --tags\n```\n\n## Verifica delle Versioni\n\n### Elenca le Versioni Installate\n\n```bash\nhpm list\n```\n\n### Controlla gli Aggiornamenti\n\n```bash\nhpm outdated\n```\n\nOutput:\n```\nPacchetto       Corrente Desiderata Ultima\nhemlang/json    1.0.0    1.0.5      1.2.0\nhemlang/sprout  2.0.0    2.0.3      2.1.0\n```\n\n- **Corrente**: Versione installata\n- **Desiderata**: Piu alta che corrisponde al vincolo\n- **Ultima**: Ultima disponibile\n\n### Aggiorna i Pacchetti\n\n```bash\n# Aggiorna tutti\nhpm update\n\n# Aggiorna pacchetto specifico\nhpm update hemlang/json\n```\n\n## Vedi Anche\n\n- [Creazione di Pacchetti](#hpm-versioning-creating-packages) - Guida alla pubblicazione\n- [Specifiche dei Pacchetti](#hpm-versioning-package-spec) - Formato package.json\n- [Comandi](#hpm-versioning-commands) - Riferimento CLI\n"}, "hpm: Riferimento -> Architettura": {"id": "hpm-architecture", "content": "# Architettura\n\nArchitettura interna e design di hpm. Questo documento e per i contributori e per chi e interessato a capire come funziona hpm.\n\n## Panoramica\n\nhpm e scritto in Hemlock e consiste di diversi moduli che gestiscono diversi aspetti della gestione dei pacchetti:\n\n```\nsrc/\n main.hml        # Punto di ingresso CLI e routing dei comandi\n manifest.hml    # Gestione package.json\n lockfile.hml    # Gestione package-lock.json\n semver.hml      # Versionamento semantico\n resolver.hml    # Risoluzione delle dipendenze\n github.hml      # Client API GitHub\n installer.hml   # Download ed estrazione dei pacchetti\n cache.hml       # Gestione cache globale\n```\n\n## Responsabilita dei Moduli\n\n### main.hml\n\nIl punto di ingresso per l'applicazione CLI.\n\n**Responsabilita:**\n- Analizzare gli argomenti da riga di comando\n- Instradare i comandi ai gestori appropriati\n- Visualizzare aiuto e informazioni sulla versione\n- Gestire flag globali (--verbose, --dry-run, ecc.)\n- Uscire con codici appropriati\n\n**Funzioni principali:**\n- `main()` - Punto di ingresso, analizza args e smista comandi\n- `cmd_init()` - Gestisce `hpm init`\n- `cmd_install()` - Gestisce `hpm install`\n- `cmd_uninstall()` - Gestisce `hpm uninstall`\n- `cmd_update()` - Gestisce `hpm update`\n- `cmd_list()` - Gestisce `hpm list`\n- `cmd_outdated()` - Gestisce `hpm outdated`\n- `cmd_run()` - Gestisce `hpm run`\n- `cmd_why()` - Gestisce `hpm why`\n- `cmd_cache()` - Gestisce `hpm cache`\n\n**Scorciatoie dei comandi:**\n```hemlock\nlet scorciatoie = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\nGestisce la lettura e scrittura dei file `package.json`.\n\n**Responsabilita:**\n- Leggere/scrivere package.json\n- Validare la struttura del pacchetto\n- Gestire le dipendenze\n- Analizzare gli specificatori dei pacchetti (proprietario/repo@versione)\n\n**Funzioni principali:**\n```hemlock\ncreate_default(): Manifest           // Crea manifesto vuoto\nread_manifest(): Manifest            // Leggi da file\nwrite_manifest(m: Manifest)          // Scrivi su file\nvalidate(m: Manifest): bool          // Valida struttura\nget_all_dependencies(m): Map         // Ottieni deps + devDeps\nadd_dependency(m, pkg, ver, dev)     // Aggiungi dipendenza\nremove_dependency(m, pkg)            // Rimuovi dipendenza\nparse_specifier(spec): (name, ver)   // Analizza \"proprietario/repo@^1.0.0\"\nsplit_name(name): (owner, repo)      // Analizza \"proprietario/repo\"\n```\n\n**Struttura Manifest:**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\nGestisce il file `package-lock.json` per installazioni riproducibili.\n\n**Responsabilita:**\n- Creare/leggere/scrivere file di lock\n- Tracciare le versioni esatte risolte\n- Memorizzare URL di download e hash di integrita\n- Eliminare dipendenze orfane\n\n**Funzioni principali:**\n```hemlock\ncreate_empty(): Lockfile              // Crea lockfile vuoto\nread_lockfile(): Lockfile             // Leggi da file\nwrite_lockfile(l: Lockfile)           // Scrivi su file\ncreate_entry(ver, url, hash, deps)    // Crea voce lock\nget_locked(l, pkg): LockEntry?        // Ottieni versione bloccata\nset_locked(l, pkg, entry)             // Imposta versione bloccata\nremove_locked(l, pkg)                 // Rimuovi voce\nprune(l, keep: Set)                   // Rimuovi orfani\nneeds_update(l, m): bool              // Controlla se non sincronizzato\n```\n\n**Struttura Lockfile:**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // URL di download\n    integrity: string,    // Hash SHA256\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\nImplementazione completa del Versionamento Semantico 2.0.0.\n\n**Responsabilita:**\n- Analizzare stringhe di versione\n- Confrontare versioni\n- Analizzare e valutare vincoli di versione\n- Trovare versioni che soddisfano i vincoli\n\n**Funzioni principali:**\n```hemlock\n// Analisi\nparse(s: string): Version             // \"1.2.3-beta+build\" -> Version\nstringify(v: Version): string         // Version -> \"1.2.3-beta+build\"\n\n// Confronto\ncompare(a, b: Version): int           // -1, 0, o 1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// Vincoli\nparse_constraint(s: string): Constraint    // \"^1.2.3\" -> Constraint\nsatisfies(v: Version, c: Constraint): bool // Controlla se v corrisponde a c\nmax_satisfying(versions, c): Version?      // Trova la corrispondenza piu alta\nsort(versions): [Version]                  // Ordina ascendente\n\n// Utilita\nconstraints_overlap(a, b: Constraint): bool  // Controlla compatibilita\n```\n\n**Struttura Version:**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // es. [\"beta\", \"1\"]\n    build: string?          // es. \"20230101\"\n};\n```\n\n**Tipi di Vincolo:**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\" -> >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\" -> >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\", \"<2.0.0\"\n    | And(Constraint, Constraint)  // Range combinati\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\nImplementa la risoluzione delle dipendenze in stile npm.\n\n**Responsabilita:**\n- Risolvere alberi di dipendenze\n- Rilevare conflitti di versione\n- Rilevare dipendenze circolari\n- Costruire alberi di visualizzazione\n\n**Funzioni principali:**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // Risolutore principale: ritorna mappa piatta di tutte le dipendenze con versioni risolte\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // Trova versione che soddisfa tutti i vincoli\n\ndetect_cycles(deps: Map): [Cycle]?\n    // Trova dipendenze circolari usando DFS\n\nbuild_tree(lockfile): Tree\n    // Crea struttura ad albero per la visualizzazione\n\nfind_why(pkg, lockfile): [Chain]\n    // Trova catene di dipendenze che spiegano perche pkg e installato\n```\n\n**Algoritmo di risoluzione:**\n\n1. **Raccogli vincoli**: Percorri manifesto e dipendenze transitive\n2. **Risolvi ogni pacchetto**: Per ogni pacchetto:\n   - Ottieni tutti i vincoli di versione dai dipendenti\n   - Recupera versioni disponibili da GitHub\n   - Trova la versione piu alta che soddisfa TUTTI i vincoli\n   - Errore se nessuna versione soddisfa tutti (conflitto)\n3. **Rileva cicli**: Esegui DFS per trovare dipendenze circolari\n4. **Ritorna mappa piatta**: Nome pacchetto -> info versione risolta\n\n**Struttura ResolveResult:**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\nClient API GitHub per la scoperta e il download dei pacchetti.\n\n**Responsabilita:**\n- Recuperare versioni disponibili (tag)\n- Scaricare package.json dai repository\n- Scaricare tarball delle release\n- Gestire autenticazione e limiti di frequenza\n\n**Funzioni principali:**\n```hemlock\nget_token(): string?\n    // Ottieni token da env o config\n\ngithub_request(url, headers?): Response\n    // Effettua richiesta API con retry\n\nget_tags(owner, repo): [string]\n    // Ottieni tag di versione (v1.0.0, v1.1.0, ecc.)\n\nget_package_json(owner, repo, ref): Manifest\n    // Recupera package.json a un tag/commit specifico\n\ndownload_tarball(owner, repo, tag): bytes\n    // Scarica archivio release\n\nrepo_exists(owner, repo): bool\n    // Controlla se il repository esiste\n\nget_repo_info(owner, repo): RepoInfo\n    // Ottieni metadati del repository\n```\n\n**Logica di retry:**\n- Backoff esponenziale: 1s, 2s, 4s, 8s\n- Retry su: 403 (limite frequenza), 5xx (errore server), errori di rete\n- Massimo 4 retry\n- Riporta errori di limite di frequenza chiaramente\n\n**Endpoint API usati:**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\nGestisce il download e l'estrazione dei pacchetti.\n\n**Responsabilita:**\n- Scaricare pacchetti da GitHub\n- Estrarre tarball in hem_modules\n- Controllare/usare pacchetti in cache\n- Installare/disinstallare pacchetti\n\n**Funzioni principali:**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // Scarica e installa singolo pacchetto\n\ninstall_all(packages: Map, options): InstallResult\n    // Installa tutti i pacchetti risolti\n\nuninstall_package(name: string): bool\n    // Rimuovi pacchetto da hem_modules\n\nget_installed(): Map<string, string>\n    // Elenca pacchetti attualmente installati\n\nverify_integrity(pkg): bool\n    // Verifica integrita del pacchetto\n\nprefetch_packages(packages: Map): void\n    // Download parallelo in cache (sperimentale)\n```\n\n**Processo di installazione:**\n\n1. Controlla se gia installato alla versione corretta\n2. Controlla cache per tarball\n3. Se non in cache, scarica da GitHub\n4. Memorizza in cache per uso futuro\n5. Estrai in `hem_modules/proprietario/repo/`\n6. Verifica installazione\n\n**Struttura directory creata:**\n```\nhem_modules/\n proprietario/\n     repo/\n         package.json\n         src/\n         ...\n```\n\n### cache.hml\n\nGestisce la cache globale dei pacchetti.\n\n**Responsabilita:**\n- Memorizzare tarball scaricati\n- Recuperare pacchetti in cache\n- Elencare pacchetti in cache\n- Pulire cache\n- Gestire configurazione\n\n**Funzioni principali:**\n```hemlock\nget_cache_dir(): string\n    // Ottieni directory cache (rispetta HPM_CACHE_DIR)\n\nget_config_dir(): string\n    // Ottieni directory config (~/.hpm)\n\nis_cached(owner, repo, version): bool\n    // Controlla se tarball e in cache\n\nget_cached_path(owner, repo, version): string\n    // Ottieni percorso a tarball in cache\n\nstore_tarball_file(owner, repo, version, data): void\n    // Salva tarball in cache\n\nlist_cached(): [CachedPackage]\n    // Elenca tutti i pacchetti in cache\n\nclear_cache(): int\n    // Rimuovi tutti i pacchetti in cache, ritorna byte liberati\n\nget_cache_size(): int\n    // Calcola dimensione totale cache\n\nread_config(): Config\n    // Leggi ~/.hpm/config.json\n\nwrite_config(c: Config): void\n    // Scrivi file config\n```\n\n**Struttura cache:**\n```\n~/.hpm/\n config.json\n cache/\n     proprietario/\n         repo/\n             1.0.0.tar.gz\n             1.1.0.tar.gz\n```\n\n## Flusso dei Dati\n\n### Flusso del Comando Install\n\n```\nhpm install proprietario/repo@^1.0.0\n         \n         \n    \n     main.hml  Analizza args, chiama cmd_install\n    \n         \n         \n    \n    manifest.hml Leggi package.json, aggiungi dipendenza\n    \n         \n         \n    \n    resolver.hml Risolvi tutte le dipendenze\n    \n         \n         \n                        \n        \n     github.hml     semver.hml Ottieni versioni, trova soddisfacente\n        \n         \n         \n    \n    installer.hml Scarica ed estrai pacchetti\n    \n         \n         \n                        \n        \n     github.hml     cache.hml Scarica o usa cache\n        \n         \n         \n    \n    lockfile.hml Aggiorna package-lock.json\n    \n```\n\n### Dettaglio Algoritmo di Risoluzione\n\n```\nInput: manifest.dependencies, manifest.devDependencies, lockfile esistente\n\n1. Inizializza:\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [dipendenze dirette]\n\n2. Mentre queue non e vuota:\n   a. pkg = queue.pop()\n   b. Se pkg gia risolto, salta\n   c. Ottieni tutti i vincoli per pkg dai dipendenti\n   d. Recupera versioni disponibili da GitHub (in cache)\n   e. Trova versione max che soddisfa tutti i vincoli\n   f. Se nessuna trovata: CONFLITTO\n   g. resolved[pkg] = {version, url, deps}\n   h. Aggiungi dipendenze di pkg alla queue\n\n3. Rileva cicli nel grafo risolto\n   - Se ciclo trovato: ERRORE\n\n4. Ritorna mappa risolta\n```\n\n## Gestione degli Errori\n\n### Codici di Uscita\n\nDefiniti in main.hml:\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### Propagazione degli Errori\n\nGli errori risalgono attraverso i valori di ritorno:\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ? propaga\n    // ...\n}\n```\n\n## Test\n\n### Framework di Test\n\nFramework di test personalizzato in `test/framework.hml`:\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"   \" + name);\n    } catch e {\n        print(\"   \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Atteso \" + expected + \", ottenuto \" + actual;\n    }\n}\n```\n\n### File di Test\n\n- `test/test_semver.hml` - Parsing versioni, confronto, vincoli\n- `test/test_manifest.hml` - Lettura/scrittura manifesto, validazione\n- `test/test_lockfile.hml` - Operazioni lockfile\n- `test/test_cache.hml` - Gestione cache\n\n### Esecuzione dei Test\n\n```bash\n# Tutti i test\nmake test\n\n# Test specifici\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## Miglioramenti Futuri\n\n### Funzionalita Pianificate\n\n1. **Verifica integrita** - Controllo hash SHA256 completo\n2. **Workspace** - Supporto monorepo\n3. **Sistema plugin** - Comandi estensibili\n4. **Audit** - Controllo vulnerabilita di sicurezza\n5. **Registro privato** - Hosting pacchetti self-hosted\n\n### Limitazioni Note\n\n1. **Bug bundler** - Non puo creare eseguibile standalone\n2. **Download paralleli** - Sperimentale, potrebbe avere race condition\n3. **Integrita** - SHA256 non completamente implementato\n\n## Contribuire\n\n### Stile del Codice\n\n- Usa indentazione di 4 spazi\n- Le funzioni dovrebbero fare una cosa sola\n- Commenta la logica complessa\n- Scrivi test per le nuove funzionalita\n\n### Aggiungere un Comando\n\n1. Aggiungi handler in `main.hml`:\n   ```hemlock\n   fn cmd_nuovocmd(args: [string]) {\n       // Implementazione\n   }\n   ```\n\n2. Aggiungi al dispatch dei comandi:\n   ```hemlock\n   match command {\n       \"nuovocmd\" => cmd_nuovocmd(args),\n       // ...\n   }\n   ```\n\n3. Aggiorna il testo di aiuto\n\n### Aggiungere un Modulo\n\n1. Crea `src/nuovomodulo.hml`\n2. Esporta l'interfaccia pubblica\n3. Importa nei moduli che ne hanno bisogno\n4. Aggiungi test in `test/test_nuovomodulo.hml`\n\n## Vedi Anche\n\n- [Comandi](#hpm-architecture-commands) - Riferimento CLI\n- [Creazione di Pacchetti](#hpm-architecture-creating-packages) - Sviluppo pacchetti\n- [Versionamento](#hpm-architecture-versioning) - Versionamento semantico\n"}, "hpm: Riferimento -> Codici di Uscita": {"id": "hpm-exit-codes", "content": "# Codici di Uscita\n\nRiferimento per i codici di uscita di hpm e i loro significati.\n\n## Tabella dei Codici di Uscita\n\n| Codice | Nome | Descrizione |\n|--------|------|-------------|\n| 0 | SUCCESS | Comando completato con successo |\n| 1 | CONFLICT | Conflitto di versione delle dipendenze |\n| 2 | NOT_FOUND | Pacchetto non trovato |\n| 3 | VERSION_NOT_FOUND | Versione richiesta non trovata |\n| 4 | NETWORK | Errore di rete |\n| 5 | INVALID_MANIFEST | package.json non valido |\n| 6 | INTEGRITY | Verifica integrita fallita |\n| 7 | RATE_LIMIT | Limite di frequenza API GitHub superato |\n| 8 | CIRCULAR | Dipendenza circolare rilevata |\n\n## Descrizioni Dettagliate\n\n### Codice di Uscita 0: SUCCESS\n\nIl comando e stato completato con successo.\n\n```bash\n$ hpm install\nInstallati 5 pacchetti\n$ echo $?\n0\n```\n\n### Codice di Uscita 1: CONFLICT\n\nDue o piu pacchetti richiedono versioni incompatibili di una dipendenza.\n\n**Esempio:**\n```\nErrore: Conflitto di dipendenze per hemlang/json\n\n  pacchetto-a richiede hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  pacchetto-b richiede hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNessuna versione soddisfa tutti i vincoli.\n```\n\n**Soluzioni:**\n1. Controlla quali pacchetti hanno il conflitto:\n   ```bash\n   hpm why hemlang/json\n   ```\n2. Aggiorna il pacchetto in conflitto:\n   ```bash\n   hpm update pacchetto-a\n   ```\n3. Rilassa i vincoli di versione in package.json\n4. Rimuovi uno dei pacchetti in conflitto\n\n### Codice di Uscita 2: NOT_FOUND\n\nIl pacchetto specificato non esiste su GitHub.\n\n**Esempio:**\n```\nErrore: Pacchetto non trovato: hemlang/inesistente\n\nIl repository hemlang/inesistente non esiste su GitHub.\n```\n\n**Soluzioni:**\n1. Verifica l'ortografia del nome del pacchetto\n2. Controlla se il repository esiste: `https://github.com/proprietario/repo`\n3. Verifica di avere accesso (per repo privati, imposta GITHUB_TOKEN)\n\n### Codice di Uscita 3: VERSION_NOT_FOUND\n\nNessuna versione corrisponde al vincolo specificato.\n\n**Esempio:**\n```\nErrore: Nessuna versione di hemlang/json corrisponde al vincolo ^5.0.0\n\nVersioni disponibili: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**Soluzioni:**\n1. Controlla le versioni disponibili su GitHub releases/tags\n2. Usa un vincolo di versione valido\n3. I tag di versione devono iniziare con 'v' (es. `v1.0.0`)\n\n### Codice di Uscita 4: NETWORK\n\nSi e verificato un errore relativo alla rete.\n\n**Esempio:**\n```\nErrore: Errore di rete: impossibile connettersi a api.github.com\n\nPer favore controlla la tua connessione internet e riprova.\n```\n\n**Soluzioni:**\n1. Controlla la connessione internet\n2. Controlla se GitHub e accessibile\n3. Verifica le impostazioni proxy se sei dietro un firewall\n4. Usa `--offline` se i pacchetti sono in cache:\n   ```bash\n   hpm install --offline\n   ```\n5. Aspetta e riprova (hpm riprova automaticamente)\n\n### Codice di Uscita 5: INVALID_MANIFEST\n\nIl file package.json e invalido o malformato.\n\n**Esempio:**\n```\nErrore: package.json non valido\n\n  - Campo obbligatorio mancante: name\n  - Formato versione non valido: \"1.0\"\n```\n\n**Soluzioni:**\n1. Controlla la sintassi JSON (usa un validatore JSON)\n2. Assicurati che i campi obbligatori esistano (`name`, `version`)\n3. Verifica i formati dei campi:\n   - name: formato `proprietario/repo`\n   - version: formato semver `X.Y.Z`\n4. Rigenera:\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### Codice di Uscita 6: INTEGRITY\n\nLa verifica dell'integrita del pacchetto e fallita.\n\n**Esempio:**\n```\nErrore: Verifica integrita fallita per hemlang/json@1.0.0\n\nAtteso: sha256-abc123...\nAttuale: sha256-def456...\n\nIl pacchetto scaricato potrebbe essere corrotto.\n```\n\n**Soluzioni:**\n1. Pulisci la cache e reinstalla:\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. Controlla problemi di rete (download parziali)\n3. Verifica che il pacchetto non sia stato manomesso\n\n### Codice di Uscita 7: RATE_LIMIT\n\nIl limite di frequenza dell'API GitHub e stato superato.\n\n**Esempio:**\n```\nErrore: Limite di frequenza API GitHub superato\n\nLimite di frequenza non autenticato: 60 richieste/ora\nUtilizzo attuale: 60/60\n\nIl limite di frequenza si resetta alle: 2024-01-15 10:30:00 UTC\n```\n\n**Soluzioni:**\n1. **Autenticati con GitHub** (consigliato):\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. Aspetta che il limite di frequenza si resetti (si resetta ogni ora)\n3. Usa la modalita offline se i pacchetti sono in cache:\n   ```bash\n   hpm install --offline\n   ```\n\n### Codice di Uscita 8: CIRCULAR\n\nRilevata dipendenza circolare nel grafo delle dipendenze.\n\n**Esempio:**\n```\nErrore: Dipendenza circolare rilevata\n\n  pacchetto-a@1.0.0\n   pacchetto-b@1.0.0\n       pacchetto-a@1.0.0  (circolare!)\n\nImpossibile risolvere l'albero delle dipendenze.\n```\n\n**Soluzioni:**\n1. Questo e solitamente un bug nei pacchetti stessi\n2. Contatta i manutentori dei pacchetti\n3. Evita di usare uno dei pacchetti circolari\n\n## Uso dei Codici di Uscita negli Script\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\ncodice_uscita=$?\n\ncase $codice_uscita in\n  0)\n    echo \"Installazione riuscita\"\n    ;;\n  1)\n    echo \"Conflitto di dipendenze - controlla i vincoli di versione\"\n    exit 1\n    ;;\n  2)\n    echo \"Pacchetto non trovato - controlla il nome del pacchetto\"\n    exit 1\n    ;;\n  4)\n    echo \"Errore di rete - controlla la connessione\"\n    exit 1\n    ;;\n  7)\n    echo \"Limite di frequenza - imposta GITHUB_TOKEN\"\n    exit 1\n    ;;\n  *)\n    echo \"Errore sconosciuto: $codice_uscita\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Installa dipendenze\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::Limite di frequenza GitHub superato. Aggiungi GITHUB_TOKEN.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installazione fallita con codice $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## Risoluzione dei Problemi per Codice di Uscita\n\n### Riferimento Rapido\n\n| Codice | Prima Cosa da Controllare |\n|--------|---------------------------|\n| 1 | Esegui `hpm why <pacchetto>` per vedere il conflitto |\n| 2 | Verifica il nome del pacchetto su GitHub |\n| 3 | Controlla i tag versione disponibili su GitHub |\n| 4 | Controlla la connessione internet |\n| 5 | Valida la sintassi di package.json |\n| 6 | Esegui `hpm cache clean && hpm install` |\n| 7 | Imposta la variabile d'ambiente `GITHUB_TOKEN` |\n| 8 | Contatta i manutentori dei pacchetti |\n\n## Vedi Anche\n\n- [Risoluzione dei Problemi](#hpm-exit-codes-troubleshooting) - Soluzioni dettagliate\n- [Comandi](#hpm-exit-codes-commands) - Riferimento comandi\n- [Configurazione](#hpm-exit-codes-configuration) - Configurazione del token GitHub\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            const isOpen = sidebar.classList.contains('open');
            menuToggle.textContent = isOpen ? '\u00d7' : '\u2630';
            menuToggle.setAttribute('aria-expanded', isOpen);
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                    menuToggle.setAttribute('aria-expanded', 'false');
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')" aria-label="Copy code">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>