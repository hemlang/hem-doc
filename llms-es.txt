================================================================================
HEMLOCK PROGRAMMING LANGUAGE - COMPLETE DOCUMENTATION (EspaÃ±ol)
================================================================================

This file contains the complete documentation for the Hemlock programming
language and the hpm package manager in EspaÃ±ol.
It is optimized for LLM consumption.

Source: https://github.com/hemlang/hem-doc

--------------------------------------------------------------------------------
TABLE OF CONTENTS
--------------------------------------------------------------------------------

  1. Bienvenido
  2. Referencia del Lenguaje

[Primeros Pasos]
  3. Inicio RÃ¡pido
  4. InstalaciÃ³n
  5. Rutas de Aprendizaje
  6. Tutorial

[GuÃ­a del Lenguaje]
  7. Arreglos
  8. Cadenas
  9. Coincidencia de Patrones
  10. Flujo de Control
  11. Funciones
  12. GestiÃ³n de Memoria
  13. Manejo de Errores
  14. MÃ³dulos
  15. Objetos
  16. Runas
  17. Sintaxis
  18. Tipos

[Temas Avanzados]
  19. Argumentos de LÃ­nea de Comandos
  20. AsincronÃ­a y Concurrencia
  21. EjecuciÃ³n de Comandos
  22. Empaquetado y DistribuciÃ³n
  23. FFI
  24. File IO
  25. Operaciones AtÃ³micas
  26. Perfilado
  27. SeÃ±ales

[Referencia de API]
  28. API de Archivos
  29. API de Arreglos
  30. API de Cadenas
  31. API de Concurrencia
  32. API de Memoria
  33. Funciones Integradas
  34. Operadores
  35. Sistema de Tipos

[DiseÃ±o y FilosofÃ­a]
  36. FilosofÃ­a
  37. ImplementaciÃ³n
  38. Sintaxis de Firmas

[Contribuir]
  39. GuÃ­as de ContribuciÃ³n
  40. Pruebas

[hpm: Primeros Pasos]
  41. ConfiguraciÃ³n del Proyecto
  42. Inicio RÃ¡pido
  43. InstalaciÃ³n

[hpm: GuÃ­a del Usuario]
  44. Comandos
  45. ConfiguraciÃ³n
  46. SoluciÃ³n de Problemas

[hpm: Desarrollo de Paquetes]
  47. CreaciÃ³n de Paquetes
  48. EspecificaciÃ³n de Paquetes
  49. Versionado

[hpm: Referencia]
  50. Arquitectura
  51. CÃ³digos de Salida


================================================================================
DOCUMENTATION
================================================================================

--------------------------------------------------------------------------------
## Bienvenido
--------------------------------------------------------------------------------

# Bienvenido a Hemlock

> "Un lenguaje pequeÃ±o e inseguro para escribir cosas inseguras de manera segura."

**Hemlock** es un lenguaje de scripting de sistemas que combina el poder de C con la ergonomÃ­a de los scripts modernos. Cuenta con gestiÃ³n manual de memoria, control explÃ­cito y concurrencia asÃ­ncrona estructurada incorporada.

## Â¿QuÃ© es Hemlock?

Hemlock estÃ¡ diseÃ±ado para programadores que desean:

- **Control explÃ­cito** sobre la memoria y la ejecuciÃ³n
- **Sintaxis similar a C** con comodidades modernas
- **Sin comportamiento oculto** ni magia
- **AsincronÃ­a paralela real** con concurrencia basada en pthread

Hemlock NO es un lenguaje con seguridad de memoria y recolecciÃ³n de basura. En cambio, te proporciona las herramientas para estar seguro (`buffer`, anotaciones de tipos, verificaciÃ³n de lÃ­mites) sin obligarte a usarlas (`ptr`, memoria manual, operaciones inseguras).

## Ejemplo RÃ¡pido

```hemlock
// Â¡Hola, Hemlock!
fn greet(name: string): string {
    return `Â¡Hola, ${name}!`;
}

let message = greet("Mundo");
print(message);

// GestiÃ³n manual de memoria
let buf = buffer(64);
buf[0] = 72;  // 'H'
buf[1] = 105; // 'i'
print(buf);
free(buf);
```

## CaracterÃ­sticas de un Vistazo

| CaracterÃ­stica | DescripciÃ³n |
|----------------|-------------|
| **Sistema de Tipos** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |
| **Memoria** | GestiÃ³n manual con `alloc()`, `buffer()`, `free()` |
| **Async** | `async`/`await` incorporado con verdadero paralelismo pthread |
| **FFI** | Llamar funciones C directamente desde bibliotecas compartidas |
| **Biblioteca EstÃ¡ndar** | 40 mÃ³dulos incluyendo crypto, http, sqlite, json y mÃ¡s |

## Primeros Pasos

Â¿Listo para comenzar? AsÃ­ es como empezar:

1. **[InstalaciÃ³n](getting-started-installation)** - Descargar y configurar Hemlock
2. **[Inicio RÃ¡pido](getting-started-quick-start)** - Escribe tu primer programa en minutos
3. **[Tutorial](getting-started-tutorial)** - Aprende Hemlock paso a paso

## Secciones de DocumentaciÃ³n

- **Primeros Pasos** - InstalaciÃ³n, guÃ­a de inicio rÃ¡pido y tutoriales
- **GuÃ­a del Lenguaje** - ProfundizaciÃ³n en sintaxis, tipos, funciones y mÃ¡s
- **Temas Avanzados** - ProgramaciÃ³n asÃ­ncrona, FFI, seÃ±ales y atÃ³micos
- **Referencia de API** - Referencia completa para funciones integradas y biblioteca estÃ¡ndar
- **DiseÃ±o y FilosofÃ­a** - Comprender por quÃ© Hemlock es como es

## Gestor de Paquetes

Hemlock viene con **hpm**, un gestor de paquetes para administrar dependencias:

```bash
hpm init my-project
hpm add some-package
hpm run
```

Consulta las secciones de documentaciÃ³n de hpm para mÃ¡s detalles.

---

Usa la navegaciÃ³n a la izquierda para explorar la documentaciÃ³n, o utiliza la barra de bÃºsqueda para encontrar temas especÃ­ficos.


--------------------------------------------------------------------------------
## Referencia del Lenguaje
--------------------------------------------------------------------------------

# Filosofia de Diseno del Lenguaje Hemlock

> "Un lenguaje pequeno e inseguro para escribir cosas inseguras de manera segura."

Este documento captura los principios de diseno fundamentales para asistentes de IA que trabajan con Hemlock.
Para documentacion detallada, consulte `docs/README.md` y el directorio `stdlib/docs/`.

---

## Identidad Central

Hemlock es un **lenguaje de scripting de sistemas** con gestion manual de memoria y control explicito:
- El poder de C con ergonomia de scripting moderna
- Concurrencia asincrona estructurada incorporada
- Sin comportamiento oculto ni magia

**Hemlock NO ES:** Seguro en memoria, un lenguaje con GC, ni oculta complejidad.
**Hemlock ES:** Explicito sobre implicito, educativo, una "capa de scripting C" para trabajo de sistemas.

---

## Principios de Diseno

### 1. Explicito Sobre Implicito
- Punto y coma obligatorio (sin ASI)
- Gestion manual de memoria (alloc/free)
- Anotaciones de tipo opcionales pero verificadas en tiempo de ejecucion

### 2. Dinamico por Defecto, Tipado por Eleccion
- Cada valor tiene una etiqueta de tipo en tiempo de ejecucion
- Los literales infieren tipos: `42` â†’ i32, `5000000000` â†’ i64, `3.14` â†’ f64
- Las anotaciones de tipo opcionales imponen verificaciones en tiempo de ejecucion

### 3. Inseguro es una Caracteristica
- Aritmetica de punteros permitida (responsabilidad del usuario)
- Sin verificacion de limites en `ptr` crudo (use `buffer` para seguridad)
- Se permiten fallos por doble liberacion

### 4. Concurrencia Estructurada de Primera Clase
- `async`/`await` incorporados con paralelismo basado en pthread
- Canales para comunicacion
- `spawn`/`join`/`detach` para gestion de tareas

### 5. Sintaxis Similar a C
- Bloques `{}` siempre requeridos
- Comentarios: `// linea` y `/* bloque */`
- Operadores coinciden con C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`
- Incremento/decremento: `++x`, `x++`, `--x`, `x--` (prefijo y posfijo)
- Asignacion compuesta: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
- `/` siempre devuelve flotante (use `divi()` para division entera)
- Sintaxis de tipo: `let x: type = value;`

---

## Referencia Rapida

### Tipos
```
Signed:   i8, i16, i32, i64
Unsigned: u8, u16, u32, u64
Floats:   f32, f64
Other:    bool, string, rune, array, ptr, buffer, null, object, file, task, channel
Aliases:  integer (i32), number (f64), byte (u8)
```

**Promocion de tipos:** i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64 (los flotantes siempre ganan, pero i64/u64 + f32 â†’ f64 para preservar precision)

### Literales
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64 (> i32 max)
let hex = 0xDEADBEEF;    // hex literal
let bin = 0b1010;        // binary literal
let oct = 0o777;         // octal literal
let sep = 1_000_000;     // numeric separators allowed
let pi = 3.14;           // f64
let half = .5;           // f64 (no leading zero)
let s = "hello";         // string
let esc = "\x41\u{1F600}"; // hex and unicode escapes
let ch = 'A';            // rune
let emoji = 'ðŸš€';        // rune (Unicode)
let arr = [1, 2, 3];     // array
let obj = { x: 10 };     // object
```

### Conversion de Tipos
```hemlock
// Type constructor functions - parse strings to types
let n = i32("42");       // Parse string to i32
let f = f64("3.14");     // Parse string to f64
let b = bool("true");    // Parse string to bool ("true" or "false")

// All numeric types supported
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// Hex and negative numbers
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// Type aliases work too
let x = integer("100");  // Same as i32("100")
let y = number("1.5");   // Same as f64("1.5")
let z = byte("200");     // Same as u8("200")

// Convert between numeric types
let big = i64(42);       // i32 to i64
let truncated = i32(3.99); // f64 to i32 (truncates to 3)

// Type annotations validate types (but don't parse strings)
let f: f64 = 100;        // i32 to f64 via annotation (numeric coercion OK)
// let n: i32 = "42";    // ERROR - use i32("42") for string parsing
```

### Introspeccion
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5 (string length in bytes)
len([1, 2, 3]);          // 3 (array length)
```

### Memoria
```hemlock
let p = alloc(64);       // raw pointer
let b = buffer(64);      // safe buffer (bounds checked)
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // manual cleanup required
```

### Flujo de Control
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // infinite loop (cleaner than while(true))
switch (x) { case 1: break; default: break; }  // C-style fall-through
defer cleanup();         // runs when function returns

// Loop labels for targeted break/continue in nested loops
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // break outer loop
        if (i == 3) { continue outer; }  // continue outer loop
    }
}
```

### Coincidencia de Patrones
```hemlock
// Match expression - returns value
let result = match (value) {
    0 => "zero",                    // Literal pattern
    1 | 2 | 3 => "small",           // OR pattern
    n if n < 10 => "medium",        // Guard expression
    n => "large: " + n              // Variable binding
};

// Type patterns
match (val) {
    n: i32 => "integer",
    s: string => "string",
    _ => "other"                    // Wildcard
}

// Object destructuring
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// Array destructuring with rest
match (arr) {
    [] => "empty",
    [first, ...rest] => "head: " + first,
    _ => "other"
}

// Nested patterns
match (user) {
    { name, address: { city } } => name + " in " + city
}
```

Consulte `docs/language-guide/pattern-matching.md` para documentacion completa.

### Operadores de Coalescencia Nula
```hemlock
// Null coalescing (??) - returns left if non-null, else right
let name = user.name ?? "Anonymous";
let first = a ?? b ?? c ?? "fallback";

// Null coalescing assignment (??=) - assigns only if null
let config = null;
config ??= { timeout: 30 };    // config is now { timeout: 30 }
config ??= { timeout: 60 };    // config unchanged (not null)

// Works with properties and indices
obj.field ??= "default";
arr[0] ??= "first";

// Safe navigation (?.) - returns null if object is null
let city = user?.address?.city;  // null if any part is null
let upper = name?.to_upper();    // safe method call
let item = arr?.[0];             // safe indexing
```

### Funciones
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Hello") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // anonymous/closure

// Expression-bodied functions (arrow syntax)
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // anonymous expression-bodied

// Parameter modifiers
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // pass-by-reference
fn print_all(const items: array) { for (i in items) { print(i); } }  // immutable
```

### Argumentos con Nombre
```hemlock
// Functions can be called with named arguments
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// Positional arguments (traditional)
create_user("Alice", 25, false);

// Named arguments - can be in any order
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// Skip optional parameters by naming what you need
create_user("David", active: false);  // Uses default age=18

// Named arguments must come after positional arguments
create_user("Eve", age: 21);          // OK: positional then named
// create_user(name: "Bad", 25);      // ERROR: positional after named
```

**Reglas:**
- Los argumentos con nombre usan sintaxis `name: value`
- Pueden aparecer en cualquier orden despues de los argumentos posicionales
- Los argumentos posicionales no pueden seguir a los argumentos con nombre
- Funciona con parametros por defecto/opcionales
- Los nombres de parametros desconocidos causan errores en tiempo de ejecucion

### Objetos y Enums
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// Object shorthand syntax (ES6-style)
let name = "Alice";
let age = 30;
let person = { name, age };         // equivalent to { name: name, age: age }

// Object spread operator
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // copies defaults, overrides size

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### Tipos Compuestos (Interseccion/Tipos Duck)
```hemlock
// Define structural types
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Compound type: object must satisfy ALL types
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Function parameters with compound types
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

// Three or more types
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// Extra fields allowed (duck typing)
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Engineering"  // OK - extra fields ignored
};
```

Los tipos compuestos proporcionan comportamiento similar a interfaces sin una palabra clave `interface` separada,
construyendo sobre los paradigmas existentes de `define` y duck typing.

### Alias de Tipos
```hemlock
// Simple type alias
type Integer = i32;
type Text = string;

// Function type alias
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Compound type alias (great for reusable interfaces)
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Generic type alias
type Pair<T> = { first: T, second: T };

// Using type aliases
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

Los alias de tipos crean atajos con nombre para tipos complejos, mejorando la legibilidad y mantenibilidad.

### Tipos de Funcion
```hemlock
// Function type annotations for parameters
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Higher-order function returning a function
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Async function types
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// Function types with multiple parameters
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Parametros Const
```hemlock
// Const parameter - deep immutability
fn print_all(const items: array) {
    // items.push(4);  // ERROR: cannot mutate const parameter
    for (item in items) {
        print(item);
    }
}

// Const with objects - no mutation through any path
fn describe(const person: object) {
    print(person.name);       // OK: reading is allowed
    // person.name = "Bob";   // ERROR: cannot mutate
}

// Nested access is allowed for reading
fn get_city(const user: object) {
    return user.address.city;  // OK: reading nested properties
}
```

El modificador `const` previene cualquier mutacion del parametro, incluyendo propiedades anidadas.
Esto proporciona seguridad en tiempo de compilacion para funciones que no deben modificar sus entradas.

### Parametros Ref (Paso por Referencia)
```hemlock
// Ref parameter - caller's variable is modified directly
fn increment(ref x: i32) {
    x = x + 1;  // Modifies the original variable
}

let count = 10;
increment(count);
print(count);  // 11 - original was modified

// Classic swap function
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// Mix ref and regular parameters
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

El modificador `ref` pasa una referencia a la variable del llamador, permitiendo que la funcion
la modifique directamente. Sin `ref`, los primitivos se pasan por valor (copiados). Use `ref` cuando
necesite mutar el estado del llamador sin devolver un valor.

**Reglas:**
- Los parametros `ref` deben recibir variables, no literales o expresiones
- Funciona con todos los tipos (primitivos, arrays, objetos)
- Combine con anotaciones de tipo: `ref x: i32`
- No se puede combinar con `const` (son opuestos)

### Firmas de Metodos en Define
```hemlock
// Define with method signatures (interface pattern)
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // Required method signature
}

// Objects must provide the required method
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Optional methods with ?
define Serializable {
    fn serialize(): string,        // Required
    fn pretty?(): string           // Optional method
}

// Self type refers to the defining type
define Cloneable {
    fn clone(): Self   // Returns same type as the object
}
```

Las firmas de metodos en bloques `define` usan delimitadores de coma (como interfaces de TypeScript),
estableciendo contratos que los objetos deben cumplir y habilitando patrones de programacion
similares a interfaces con el sistema de duck typing de Hemlock.

### Manejo de Errores
```hemlock
try { throw "error"; } catch (e) { print(e); } finally { cleanup(); }
panic("unrecoverable");  // exits immediately, not catchable
```

### Async/Concurrencia
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // or join(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**Propiedad de memoria:** Las tareas reciben copias de valores primitivos pero comparten punteros. Si pasa un `ptr` a una tarea generada, debe asegurarse de que la memoria permanezca valida hasta que la tarea complete. Use `join()` antes de `free()`, o use canales para senalar finalizacion.

### Entrada de Usuario
```hemlock
let name = read_line();          // Read line from stdin (blocks)
print("Hello, " + name);
eprint("Error message");         // Print to stderr

// read_line() returns null on EOF
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Got:", line);
}
```

### E/S de Archivos
```hemlock
let f = open("file.txt", "r");  // modes: r, w, a, r+, w+, a+
let content = f.read();
f.write("data");
f.seek(0);
f.close();
```

### Senales
```hemlock
signal(SIGINT, fn(sig) { print("Interrupted"); });
raise(SIGUSR1);
```

---

## Metodos de String (19)

`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,
`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,
`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`

Strings de plantilla: `` `Hello ${name}!` ``

**Mutabilidad de strings:** Los strings son mutables via asignacion por indice (`s[0] = 'H'`), pero todos los metodos de string devuelven nuevos strings sin modificar el original. Esto permite mutacion in situ cuando se necesita mientras mantiene el encadenamiento de metodos funcional.

**Propiedades de longitud de string:**
```hemlock
let s = "hello ðŸš€";
print(s.length);       // 7 (character/rune count)
print(s.byte_length);  // 10 (byte count - emoji is 4 bytes UTF-8)
```

## Metodos de Array (18)

`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,
`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`

Arrays tipados: `let nums: array<i32> = [1, 2, 3];`

---

## Biblioteca Estandar (40 modulos)

Importe con prefijo `@stdlib/`:
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| Modulo | Descripcion |
|--------|-------------|
| `arena` | Asignador de memoria arena (asignacion bump) |
| `args` | Analisis de argumentos de linea de comandos |
| `assert` | Utilidades de asercion |
| `async` | ThreadPool, parallel_map |
| `async_fs` | Operaciones de E/S de archivos asincronas |
| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |
| `compression` | gzip, gunzip, deflate |
| `crypto` | aes_encrypt, rsa_sign, random_bytes |
| `csv` | Analisis y generacion de CSV |
| `datetime` | Clase DateTime, formateo, analisis |
| `encoding` | base64_encode, hex_encode, url_encode |
| `env` | getenv, setenv, exit, get_pid |
| `fmt` | Utilidades de formateo de strings |
| `fs` | read_file, write_file, list_dir, exists |
| `glob` | Coincidencia de patrones de archivos |
| `hash` | sha256, sha512, md5, djb2 |
| `http` | http_get, http_post, http_request |
| `ipc` | Comunicacion entre procesos |
| `iter` | Utilidades de iterador |
| `json` | parse, stringify, pretty, get, set |
| `logging` | Logger con niveles |
| `math` | sin, cos, sqrt, pow, rand, PI, E |
| `net` | TcpListener, TcpStream, UdpSocket |
| `os` | platform, arch, cpu_count, hostname |
| `path` | Manipulacion de rutas de archivos |
| `process` | fork, exec, wait, kill |
| `random` | Generacion de numeros aleatorios |
| `regex` | compile, test (POSIX ERE) |
| `retry` | Logica de reintento con backoff |
| `semver` | Versionado semantico |
| `shell` | Utilidades de comandos shell |
| `sqlite` | Base de datos SQLite, query, exec, transacciones |
| `strings` | pad_left, is_alpha, reverse, lines |
| `terminal` | Colores y estilos ANSI |
| `testing` | describe, test, expect |
| `time` | now, time_ms, sleep, clock |
| `toml` | Analisis y generacion de TOML |
| `url` | Analisis y manipulacion de URL |
| `uuid` | Generacion de UUID |
| `websocket` | Cliente WebSocket |

Consulte `stdlib/docs/` para documentacion detallada de modulos.

---

## FFI (Interfaz de Funcion Foranea)

Declare y llame funciones C desde bibliotecas compartidas:
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Hello!");  // 6
let pid = getpid();
```

Exporte funciones FFI desde modulos:
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

FFI dinamico (enlace en tiempo de ejecucion):
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Hello from C!");
ffi_close(lib);
```

Tipos: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.

---

## Operaciones Atomicas

Programacion concurrente sin bloqueos con operaciones atomicas:

```hemlock
// Allocate memory for atomic i32
let p = alloc(4);
ptr_write_i32(p, 0);

// Atomic load/store
let val = atomic_load_i32(p);        // Read atomically
atomic_store_i32(p, 42);             // Write atomically

// Fetch-and-modify operations (return OLD value)
let old = atomic_add_i32(p, 10);     // Add, return old
old = atomic_sub_i32(p, 5);          // Subtract, return old
old = atomic_and_i32(p, 0xFF);       // Bitwise AND
old = atomic_or_i32(p, 0x10);        // Bitwise OR
old = atomic_xor_i32(p, 0x0F);       // Bitwise XOR

// Compare-and-swap (CAS)
let success = atomic_cas_i32(p, 42, 100);  // If *p == 42, set to 100
// Returns true if swap succeeded, false otherwise

// Atomic exchange
old = atomic_exchange_i32(p, 999);   // Swap, return old

free(p);

// i64 variants available (atomic_load_i64, atomic_add_i64, etc.)

// Memory fence (full barrier)
atomic_fence();
```

Todas las operaciones usan consistencia secuencial (`memory_order_seq_cst`).

---

## Estructura del Proyecto

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/         # Shared: lexer, parser, AST, modules
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/  # hemlock: tree-walking interpreter
â”‚   â”‚   â””â”€â”€ compiler/     # hemlockc: C code generator
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/          # Language Server Protocol
â”‚   â”‚   â””â”€â”€ bundler/      # Bundle/package tools
â”œâ”€â”€ runtime/              # Compiled program runtime (libhemlock_runtime.a)
â”œâ”€â”€ stdlib/               # Standard library (40 modules)
â”‚   â””â”€â”€ docs/             # Module documentation
â”œâ”€â”€ docs/                 # Full documentation
â”‚   â”œâ”€â”€ language-guide/   # Types, strings, arrays, etc.
â”‚   â”œâ”€â”€ reference/        # API references
â”‚   â””â”€â”€ advanced/         # Async, FFI, signals, etc.
â”œâ”€â”€ tests/                # 625+ tests
â””â”€â”€ examples/             # Example programs
```

---

## Guias de Estilo de Codigo

### Constantes y Numeros Magicos

Al agregar constantes numericas al codigo base en C, siga estas guias:

1. **Defina constantes en `include/hemlock_limits.h`** - Este archivo es la ubicacion central para todos los limites de tiempo de compilacion y ejecucion, capacidades y constantes con nombre.

2. **Use nombres descriptivos con prefijo `HML_`** - Todas las constantes deben tener prefijo `HML_` para claridad de espacio de nombres.

3. **Evite numeros magicos** - Reemplace valores numericos codificados con constantes con nombre. Ejemplos:
   - Limites de rango de tipos: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`
   - Capacidades de buffer: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - Conversiones de tiempo: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`
   - Semillas de hash: `HML_DJB2_HASH_SEED`
   - Valores ASCII: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`

4. **Incluya `hemlock_limits.h`** - Los archivos fuente deben incluir este encabezado (frecuentemente via `internal.h`) para acceder a las constantes.

5. **Documente el proposito** - Agregue un comentario explicando lo que cada constante representa.

---

## Que NO Hacer

- No agregar comportamiento implicito (ASI, GC, limpieza automatica)
- No ocultar complejidad (optimizaciones magicas, conteos de referencias ocultos)
- No romper semantica existente (punto y coma, memoria manual, strings mutables)
- No perder precision en conversiones implicitas
- No usar numeros magicos - defina constantes con nombre en `hemlock_limits.h` en su lugar

---

## Pruebas

```bash
make test              # Run interpreter tests
make test-compiler     # Run compiler tests
make parity            # Run parity tests (both must match)
make test-all          # Run all test suites
```

**Importante:** Las pruebas pueden colgarse debido a problemas de async/concurrencia. Siempre use un timeout al ejecutar pruebas:
```bash
timeout 60 make test   # 60 second timeout
timeout 120 make parity
```

Categorias de pruebas: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*

---

## Arquitectura del Compilador/Interprete

Hemlock tiene dos backends de ejecucion que comparten un frontend comun:

```
Source (.hml)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SHARED FRONTEND            â”‚
â”‚  - Lexer (src/frontend/)    â”‚
â”‚  - Parser (src/frontend/)   â”‚
â”‚  - AST (src/frontend/)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INTERPRETERâ”‚    â”‚  COMPILER  â”‚
â”‚ (hemlock)  â”‚    â”‚ (hemlockc) â”‚
â”‚            â”‚    â”‚            â”‚
â”‚ Tree-walk  â”‚    â”‚ Type check â”‚
â”‚ evaluation â”‚    â”‚ AST â†’ C    â”‚
â”‚            â”‚    â”‚ gcc link   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Verificacion de Tipos del Compilador

El compilador (`hemlockc`) incluye verificacion de tipos en tiempo de compilacion, **habilitada por defecto**:

```bash
hemlockc program.hml -o program    # Type checks, then compiles
hemlockc --check program.hml       # Type check only, don't compile
hemlockc --no-type-check prog.hml  # Disable type checking
hemlockc --strict-types prog.hml   # Warn on implicit 'any' types
```

El verificador de tipos:
- Valida anotaciones de tipo en tiempo de compilacion
- Trata codigo sin tipo como dinamico (tipo `any`) - siempre valido
- Proporciona sugerencias de optimizacion para unboxing
- Usa conversiones numericas permisivas (rango validado en tiempo de ejecucion)

### Estructura de Directorios

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/           # Shared: lexer, parser, AST, modules
â”‚   â”‚   â”œâ”€â”€ lexer.c
â”‚   â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ ast.c
â”‚   â”‚   â””â”€â”€ module.c
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/    # hemlock: tree-walking interpreter
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime/
â”‚   â”‚   â”‚   â””â”€â”€ builtins/
â”‚   â”‚   â””â”€â”€ compiler/       # hemlockc: C code generator
â”‚   â”‚       â”œâ”€â”€ main.c
â”‚   â”‚       â””â”€â”€ codegen/
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/            # Language server
â”‚   â”‚   â””â”€â”€ bundler/        # Bundle/package tools
â”œâ”€â”€ runtime/                # libhemlock_runtime.a for compiled programs
â”œâ”€â”€ stdlib/                 # Shared standard library
â””â”€â”€ tests/
    â”œâ”€â”€ parity/             # Tests that MUST pass both backends
    â”œâ”€â”€ interpreter/        # Interpreter-specific tests
    â””â”€â”€ compiler/           # Compiler-specific tests
```

---

## Desarrollo con Paridad Primero

**Tanto el interprete como el compilador deben producir salida identica para la misma entrada.**

### Politica de Desarrollo

Al agregar o modificar caracteristicas del lenguaje:

1. **Disenar** - Definir el cambio AST/semantico en el frontend compartido
2. **Implementar interprete** - Agregar evaluacion tree-walking
3. **Implementar compilador** - Agregar generacion de codigo C
4. **Agregar prueba de paridad** - Escribir prueba en `tests/parity/` con archivo `.expected`
5. **Verificar** - Ejecutar `make parity` antes de fusionar

### Estructura de Pruebas de Paridad

```
tests/parity/
â”œâ”€â”€ language/       # Core language features (control flow, closures, etc.)
â”œâ”€â”€ builtins/       # Built-in functions (print, typeof, memory, etc.)
â”œâ”€â”€ methods/        # String and array methods
â””â”€â”€ modules/        # Import/export, stdlib imports
```

Cada prueba tiene dos archivos:
- `feature.hml` - El programa de prueba
- `feature.expected` - Salida esperada (debe coincidir para ambos backends)

### Resultados de Pruebas de Paridad

| Estado | Significado |
|--------|-------------|
| `âœ“ PASSED` | Tanto interprete como compilador coinciden con salida esperada |
| `â— INTERP_ONLY` | Interprete funciona, compilador falla (necesita correccion del compilador) |
| `â—‘ COMPILER_ONLY` | Compilador funciona, interprete falla (raro) |
| `âœ— FAILED` | Ambos fallan (error de prueba o implementacion) |

### Que Requiere Paridad

- Todas las construcciones del lenguaje (if, while, for, switch, defer, try/catch)
- Todos los operadores (aritmeticos, bitwise, logicos, comparacion)
- Todas las funciones incorporadas (print, typeof, alloc, etc.)
- Todos los metodos de string y array
- Reglas de coercion y promocion de tipos
- Mensajes de error para errores en tiempo de ejecucion

### Que Puede Diferir

- Caracteristicas de rendimiento
- Detalles de disposicion de memoria
- Formato de debug/stack trace
- Errores de compilacion (el compilador puede detectar mas en tiempo de compilacion)

### Agregar una Prueba de Paridad

```bash
# 1. Create test file
cat > tests/parity/language/my_feature.hml << 'EOF'
// Test description
let x = some_feature();
print(x);
EOF

# 2. Generate expected output from interpreter
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. Verify parity
make parity
```

---

## Version

**v1.8.0** - Version actual con:
- **Coincidencia de patrones** (expresiones `match`) - Desestructuracion y flujo de control poderosos:
  - Patrones literales, comodin y enlace de variables
  - Patrones OR (`1 | 2 | 3`)
  - Expresiones guard (`n if n > 0`)
  - Desestructuracion de objetos (`{ x, y }`)
  - Desestructuracion de arrays con rest (`[first, ...rest]`)
  - Patrones de tipo (`n: i32`)
  - Paridad completa entre interprete y compilador
- **Anotaciones auxiliares del compilador** - 11 anotaciones de optimizacion para control de GCC/Clang:
  - `@inline`, `@noinline` - control de inlining de funciones
  - `@hot`, `@cold` - sugerencias de prediccion de rama
  - `@pure`, `@const` - anotaciones de efectos secundarios
  - `@flatten` - hacer inline a todas las llamadas dentro de la funcion
  - `@optimize(level)` - nivel de optimizacion por funcion ("0", "1", "2", "3", "s", "fast")
  - `@warn_unused` - advertir sobre valores de retorno ignorados
  - `@section(name)` - colocacion de seccion ELF personalizada (ej., `@section(".text.hot")`)
- **Funciones con cuerpo de expresion** (`fn double(x): i32 => x * 2;`) - sintaxis concisa de funcion de una sola expresion
- **Sentencias de una linea** - sintaxis sin llaves para `if`, `while`, `for` (ej., `if (x > 0) print(x);`)
- **Alias de tipos** (`type Name = Type;`) - atajos con nombre para tipos complejos
- **Anotaciones de tipo de funcion** (`fn(i32): i32`) - tipos de funcion de primera clase
- **Parametros const** (`fn(const x: array)`) - inmutabilidad profunda para parametros
- **Parametros ref** (`fn(ref x: i32)`) - paso por referencia para mutacion directa del llamador
- **Firmas de metodos en define** (`fn method(): Type`) - contratos tipo interfaz (delimitados por coma)
- **Tipo Self** en firmas de metodos - se refiere al tipo que define
- **Palabra clave loop** (`loop { }`) - bucles infinitos mas limpios, reemplaza `while (true)`
- **Etiquetas de bucle** (`outer: while`) - break/continue dirigido para bucles anidados
- **Shorthand de objetos** (`{ name }`) - sintaxis de propiedad abreviada estilo ES6
- **Spread de objetos** (`{ ...obj }`) - copiar y fusionar campos de objetos
- **Tipos duck compuestos** (`A & B & C`) - tipos de interseccion para tipado estructural
- **Argumentos con nombre** para llamadas de funcion (`foo(name: "value", age: 30)`)
- **Operadores de coalescencia nula** (`??`, `??=`, `?.`) para manejo seguro de null
- **Literales octales** (`0o777`, `0O123`)
- **Separadores numericos** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)
- **Comentarios de bloque** (`/* ... */`)
- **Secuencias de escape hexadecimales** en strings/runes (`\x41` = 'A')
- **Secuencias de escape Unicode** en strings (`\u{1F600}` = ðŸ˜€)
- **Literales flotantes sin cero inicial** (`.5`, `.123`, `.5e2`)
- **Verificacion de tipos en tiempo de compilacion** en hemlockc (habilitada por defecto)
- **Integracion LSP** con verificacion de tipos para diagnosticos en tiempo real
- **Operadores de asignacion compuesta** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)
- **Operadores de incremento/decremento** (`++x`, `x++`, `--x`, `x--`)
- **Correccion de precision de tipos**: i64/u64 + f32 â†’ f64 para preservar precision
- Sistema de tipos unificado con sugerencias de optimizacion de unboxing
- Sistema de tipos completo (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)
- Strings UTF-8 con 19 metodos
- Arrays con 18 metodos incluyendo map/filter/reduce
- Gestion manual de memoria con `talloc()` y `sizeof()`
- Async/await con verdadero paralelismo pthread
- Operaciones atomicas para programacion concurrente sin bloqueos
- 40 modulos stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)
- FFI para interoperabilidad con C con `export extern fn` para wrappers de biblioteca reutilizables
- Soporte de struct FFI en compilador (pasar structs C por valor)
- Helpers de puntero FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)
- defer, try/catch/finally/throw, panic
- E/S de archivos, manejo de senales, ejecucion de comandos
- Gestor de paquetes [hpm](https://github.com/hemlang/hpm) con registro basado en GitHub
- Backend de compilador (generacion de codigo C) con 100% de paridad con interprete
- Servidor LSP con ir-a-definicion y encontrar-referencias
- Paso de optimizacion AST y resolucion de variables para busqueda O(1)
- Builtin apply() para llamadas de funcion dinamicas
- Canales sin buffer y soporte de muchos parametros
- 159 pruebas de paridad (100% tasa de aprobacion)

---

## Filosofia

> Le damos las herramientas para estar seguro (`buffer`, anotaciones de tipo, verificacion de limites) pero no le obligamos a usarlas (`ptr`, memoria manual, operaciones inseguras).

**Si no esta seguro de si una caracteristica encaja en Hemlock, pregunte: "Esto le da al programador mas control explicito, o esconde algo?"**

Si esconde, probablemente no pertenece a Hemlock.



################################################################################
# PRIMEROS PASOS
################################################################################

--------------------------------------------------------------------------------
## Inicio RÃ¡pido
--------------------------------------------------------------------------------

# Inicio Rapido

Ponga Hemlock en funcionamiento en minutos.

## Su Primer Programa

Cree un archivo llamado `hello.hml`:

```hemlock
print("Hello, Hemlock!");
```

Ejecute con el interprete:

```bash
./hemlock hello.hml
```

O compile a un ejecutable nativo:

```bash
./hemlockc hello.hml -o hello
./hello
```

Salida:
```
Hello, Hemlock!
```

### Interprete vs Compilador

Hemlock proporciona dos formas de ejecutar programas:

| Herramienta | Caso de Uso | Verificacion de Tipos |
|-------------|-------------|----------------------|
| `hemlock` | Scripts rapidos, REPL, desarrollo | Solo en tiempo de ejecucion |
| `hemlockc` | Binarios de produccion, mejor rendimiento | Tiempo de compilacion (por defecto) |

El compilador (`hemlockc`) verifica los tipos de su codigo antes de generar un ejecutable, detectando errores tempranamente.

## Sintaxis Basica

### Variables

```hemlock
// Las variables se declaran con 'let'
let x = 42;
let name = "Alice";
let pi = 3.14159;

// Las anotaciones de tipo son opcionales
let count: i32 = 100;
let ratio: f64 = 0.618;
```

**Importante**: Los puntos y coma son **obligatorios** en Hemlock.

### Tipos

Hemlock tiene un sistema de tipos rico:

```hemlock
// Enteros
let small: i8 = 127;          // 8 bits con signo
let byte: u8 = 255;           // 8 bits sin signo
let num: i32 = 2147483647;    // 32 bits con signo (por defecto)
let big: i64 = 9223372036854775807;  // 64 bits con signo

// Flotantes
let f: f32 = 3.14;            // flotante de 32 bits
let d: f64 = 2.71828;         // flotante de 64 bits (por defecto)

// Cadenas y caracteres
let text: string = "Hello";   // cadena UTF-8
let emoji: rune = 'ðŸš€';       // punto de codigo Unicode

// Booleano y nulo
let flag: bool = true;
let empty = null;
```

### Flujo de Control

```hemlock
// Sentencias if
if (x > 0) {
    print("positive");
} else if (x < 0) {
    print("negative");
} else {
    print("zero");
}

// Bucles while
let i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}

// Bucles for
for (let j = 0; j < 10; j = j + 1) {
    print(j);
}
```

### Funciones

```hemlock
// Funcion con nombre
fn add(a: i32, b: i32): i32 {
    return a + b;
}

let result = add(5, 3);  // 8

// Funcion anonima
let multiply = fn(x, y) {
    return x * y;
};

print(multiply(4, 7));  // 28
```

## Trabajando con Cadenas

Las cadenas en Hemlock son **mutables** y **UTF-8**:

```hemlock
let s = "hello";
s[0] = 'H';              // Ahora "Hello"
print(s);

// Metodos de cadena
let upper = s.to_upper();     // "HELLO"
let words = "a,b,c".split(","); // ["a", "b", "c"]
let sub = s.substr(1, 3);     // "ell"

// Concatenacion
let greeting = "Hello" + ", " + "World!";
print(greeting);  // "Hello, World!"
```

## Arreglos

Arreglos dinamicos con tipos mixtos:

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Metodos de arreglo
numbers.push(6);        // [1, 2, 3, 4, 5, 6]
let last = numbers.pop();  // 6
let slice = numbers.slice(1, 4);  // [2, 3, 4]

// Tipos mixtos permitidos
let mixed = [1, "two", true, null];
```

## Objetos

Objetos al estilo JavaScript:

```hemlock
// Literal de objeto
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
person.age = 31;     // Modificar campo

// Metodos con 'self'
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Gestion de Memoria

Hemlock usa **gestion de memoria manual**:

```hemlock
// Buffer seguro (recomendado)
let buf = buffer(64);   // Asignar 64 bytes
buf[0] = 65;            // Establecer primer byte a 'A'
print(buf[0]);          // 65
free(buf);              // Liberar memoria

// Puntero crudo (avanzado)
let ptr = alloc(100);
memset(ptr, 0, 100);    // Llenar con ceros
free(ptr);
```

**Importante**: Debe liberar con `free()` lo que asigna con `alloc()`.

## Manejo de Errores

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Error: " + e);
} finally {
    print("Done");
}
```

## Argumentos de Linea de Comandos

Acceda a los argumentos del programa a traves del arreglo `args`:

```hemlock
// script.hml
print("Script:", args[0]);
print(`Arguments: ${args.length - 1}`);

let i = 1;
while (i < args.length) {
    print(`  arg ${i}: ${args[i]}`);
    i = i + 1;
}
```

Ejecute con:
```bash
./hemlock script.hml hello world
```

Salida:
```
Script: script.hml
Arguments: 2
  arg 1: hello
  arg 2: world
```

## E/S de Archivos

```hemlock
// Escribir en archivo
let f = open("data.txt", "w");
f.write("Hello, File!");
f.close();

// Leer de archivo
let f2 = open("data.txt", "r");
let content = f2.read();
print(content);  // "Hello, File!"
f2.close();
```

## Que Sigue

Ahora que ha visto lo basico, explore mas:

- [Tutorial](#getting-started-tutorial) - Guia completa paso a paso
- [Guia del Lenguaje](#language-guide-syntax) - Profundice en todas las caracteristicas
- [Ejemplos](../../examples/) - Programas de ejemplo del mundo real
- [Referencia de API](#reference-builtins) - Documentacion completa de la API

## Errores Comunes

### Olvidar los Puntos y Coma

```hemlock
// âŒ ERROR: Falta punto y coma
let x = 42
let y = 10

// âœ… CORRECTO
let x = 42;
let y = 10;
```

### Olvidar Liberar Memoria

```hemlock
// âŒ FUGA DE MEMORIA
let buf = buffer(100);
// ... usar buf ...
// Olvido llamar a free(buf)!

// âœ… CORRECTO
let buf = buffer(100);
// ... usar buf ...
free(buf);
```

### Las Llaves Son Obligatorias

```hemlock
// âŒ ERROR: Faltan llaves
if (x > 0)
    print("positive");

// âœ… CORRECTO
if (x > 0) {
    print("positive");
}
```

## Obteniendo Ayuda

- Lea la [documentacion completa](../README.md)
- Revise el [directorio de ejemplos](../../examples/)
- Vea los [archivos de prueba](../../tests/) para patrones de uso
- Reporte problemas en GitHub


--------------------------------------------------------------------------------
## InstalaciÃ³n
--------------------------------------------------------------------------------

# Instalacion

Esta guia le ayudara a compilar e instalar Hemlock en su sistema.

## Instalacion Rapida (Recomendada)

La forma mas sencilla de instalar Hemlock es usando el script de instalacion de una linea:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash
```

Esto descarga e instala el binario precompilado mas reciente para su plataforma (Linux o macOS, x86_64 o arm64).

### Opciones de Instalacion

```bash
# Instalar en un prefijo personalizado (por defecto: ~/.local)
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local

# Instalar una version especifica
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0

# Instalar y actualizar automaticamente el PATH del shell
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path
```

Despues de la instalacion, verifique que funciona:

```bash
hemlock --version
```

---

## Compilacion desde el Codigo Fuente

Si prefiere compilar desde el codigo fuente o los binarios precompilados no funcionan en su sistema, siga las instrucciones a continuacion.

## Requisitos Previos

### Dependencias Requeridas

Hemlock requiere las siguientes dependencias para compilar:

- **Compilador C**: GCC o Clang (estandar C11)
- **Make**: GNU Make
- **libffi**: Biblioteca de Interfaz de Funciones Foraneas (para soporte FFI)
- **OpenSSL**: Biblioteca criptografica (para funciones hash: md5, sha1, sha256)
- **libwebsockets**: Soporte para cliente/servidor WebSocket y HTTP
- **zlib**: Biblioteca de compresion

### Instalacion de Dependencias

**macOS:**
```bash
# Instalar Homebrew si aun no esta instalado
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Instalar Xcode Command Line Tools
xcode-select --install

# Instalar dependencias via Homebrew
brew install libffi openssl@3 libwebsockets
```

**Nota para usuarios de macOS**: El Makefile detecta automaticamente las instalaciones de Homebrew y configura las rutas correctas de include/library. Hemlock soporta arquitecturas Intel (x86_64) y Apple Silicon (arm64).

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev
```

**Fedora/RHEL:**
```bash
sudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel
```

**Arch Linux:**
```bash
sudo pacman -S base-devel libffi openssl libwebsockets zlib
```

## Compilacion desde el Codigo Fuente

### 1. Clonar el Repositorio

```bash
git clone https://github.com/hemlang/hemlock.git
cd hemlock
```

### 2. Compilar Hemlock

```bash
make
```

Esto compilara el interprete de Hemlock y colocara el ejecutable en el directorio actual.

### 3. Verificar la Instalacion

```bash
./hemlock --version
```

Deberia ver la informacion de version de Hemlock.

### 4. Probar la Compilacion

Ejecute el conjunto de pruebas para asegurarse de que todo funciona correctamente:

```bash
make test
```

Todas las pruebas deberian pasar. Si ve algun fallo, por favor reportelo como un issue.

## Instalacion a Nivel del Sistema (Opcional)

Para instalar Hemlock a nivel del sistema (por ejemplo, en `/usr/local/bin`):

```bash
sudo make install
```

Esto le permite ejecutar `hemlock` desde cualquier lugar sin especificar la ruta completa.

## Ejecutando Hemlock

### REPL Interactivo

Inicie el bucle Leer-Evaluar-Imprimir (REPL):

```bash
./hemlock
```

Vera un prompt donde puede escribir codigo Hemlock:

```
Hemlock REPL
> print("Hello, World!");
Hello, World!
> let x = 42;
> print(x * 2);
84
>
```

Salga del REPL con `Ctrl+D` o `Ctrl+C`.

### Ejecutando Programas

Ejecute un script de Hemlock:

```bash
./hemlock program.hml
```

Con argumentos de linea de comandos:

```bash
./hemlock program.hml arg1 arg2 "argumento con espacios"
```

## Estructura de Directorios

Despues de compilar, su directorio de Hemlock se vera asi:

```
hemlock/
â”œâ”€â”€ hemlock           # Ejecutable del interprete compilado
â”œâ”€â”€ src/              # Codigo fuente
â”œâ”€â”€ include/          # Archivos de cabecera
â”œâ”€â”€ tests/            # Conjunto de pruebas
â”œâ”€â”€ examples/         # Programas de ejemplo
â”œâ”€â”€ docs/             # Documentacion
â”œâ”€â”€ stdlib/           # Biblioteca estandar
â”œâ”€â”€ Makefile          # Configuracion de compilacion
â””â”€â”€ README.md         # README del proyecto
```

## Opciones de Compilacion

### Compilacion de Depuracion

Compilar con simbolos de depuracion y sin optimizacion:

```bash
make debug
```

### Compilacion Limpia

Eliminar todos los archivos compilados:

```bash
make clean
```

Recompilar desde cero:

```bash
make clean && make
```

## Solucion de Problemas

### macOS: Errores de Biblioteca No Encontrada

Si obtiene errores sobre bibliotecas faltantes (`-lcrypto`, `-lffi`, etc.):

1. Asegurese de que las dependencias de Homebrew estan instaladas:
   ```bash
   brew install libffi openssl@3 libwebsockets
   ```

2. Verifique las rutas de Homebrew:
   ```bash
   brew --prefix libffi
   brew --prefix openssl
   ```

3. El Makefile deberia auto-detectar estas rutas. Si no lo hace, verifique que `brew` esta en su PATH:
   ```bash
   which brew
   ```

### macOS: Errores de Tipo BSD (`u_int`, `u_char` no encontrado)

Si ve errores sobre nombres de tipo desconocidos como `u_int` o `u_char`:

1. Esto se corrigio en v1.0.0+ usando `_DARWIN_C_SOURCE` en lugar de `_POSIX_C_SOURCE`
2. Asegurese de tener la version mas reciente del codigo
3. Limpie y recompile:
   ```bash
   make clean && make
   ```

### Linux: libffi No Encontrada

Si obtiene errores sobre `ffi.h` o `-lffi` faltantes:

1. Asegurese de que `libffi-dev` esta instalada (vea las dependencias arriba)
2. Verifique si `pkg-config` puede encontrarla:
   ```bash
   pkg-config --cflags --libs libffi
   ```
3. Si no se encuentra, puede necesitar configurar `PKG_CONFIG_PATH`:
   ```bash
   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
   ```

### Errores de Compilacion

Si encuentra errores de compilacion:

1. Asegurese de tener un compilador compatible con C11
2. En macOS, intente usar Clang (por defecto):
   ```bash
   make CC=clang
   ```
3. En Linux, intente usar GCC:
   ```bash
   make CC=gcc
   ```
4. Verifique que todas las dependencias estan instaladas
5. Intente recompilar desde cero:
   ```bash
   make clean && make
   ```

### Fallos en las Pruebas

Si las pruebas fallan:

1. Verifique que tiene la version mas reciente del codigo
2. Intente recompilar desde cero:
   ```bash
   make clean && make test
   ```
3. En macOS, asegurese de tener las Xcode Command Line Tools mas recientes:
   ```bash
   xcode-select --install
   ```
4. Reporte el problema en GitHub con:
   - Su plataforma (version de macOS / distribucion de Linux)
   - Arquitectura (x86_64 / arm64)
   - Salida de las pruebas
   - Salida de `make -v` y `gcc --version` (o `clang --version`)

## Proximos Pasos

- [Guia de Inicio Rapido](#getting-started-quick-start) - Escriba su primer programa en Hemlock
- [Tutorial](#getting-started-tutorial) - Aprenda Hemlock paso a paso
- [Guia del Lenguaje](#language-guide-syntax) - Explore las caracteristicas de Hemlock


--------------------------------------------------------------------------------
## Rutas de Aprendizaje
--------------------------------------------------------------------------------

# Rutas de Aprendizaje

Diferentes objetivos requieren diferentes conocimientos. Elija la ruta que coincida con lo que desea construir.

---

## Ruta 1: Scripts Rapidos y Automatizacion

**Objetivo:** Escribir scripts para automatizar tareas, procesar archivos y realizar trabajos.

**Tiempo para ser productivo:** Rapido - puede comenzar a escribir scripts utiles inmediatamente.

### Lo Que Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Su primer programa, sintaxis basica
2. **[Cadenas](#language-guide-strings)** - Procesamiento de texto, division, busqueda
3. **[Arreglos](#language-guide-arrays)** - Listas, filtrado, transformacion de datos
4. **[E/S de Archivos](#advanced-file-io)** - Lectura y escritura de archivos
5. **[Argumentos de Linea de Comandos](#advanced-command-line-args)** - Obtener entrada de usuarios

### Omitir Por Ahora

- Gestion de memoria (automatica para scripts)
- Async/concurrencia (excesivo para scripts simples)
- FFI (solo necesario para interoperabilidad con C)

### Proyecto de Ejemplo: Renombrador de Archivos

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// Renombrar todos los archivos .txt a .md
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Renamed: ${file} -> ${new_name}`);
    }
}
```

---

## Ruta 2: Procesamiento y Analisis de Datos

**Objetivo:** Analizar datos, transformarlos, generar informes.

**Tiempo para ser productivo:** Rapido - los metodos de cadenas y arreglos de Hemlock lo hacen facil.

### Lo Que Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos
2. **[Cadenas](#language-guide-strings)** - Analisis, division, formato
3. **[Arreglos](#language-guide-arrays)** - map, filter, reduce para transformacion de datos
4. **[Objetos](#language-guide-objects)** - Datos estructurados
5. **Biblioteca Estandar:**
   - **[@stdlib/json](#stdlib-json)** - Analisis de JSON
   - **[@stdlib/csv](#stdlib-csv)** - Archivos CSV
   - **[@stdlib/fs](#stdlib-fs)** - Operaciones de archivo

### Proyecto de Ejemplo: Analizador CSV

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("sales.csv"));

// Calcular ventas totales
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Total sales: $${total}`);

// Encontrar el mejor vendedor
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Top sale: ${top.product} - $${top.amount}`);
```

---

## Ruta 3: Programacion Web y de Redes

**Objetivo:** Construir clientes HTTP, trabajar con APIs, crear servidores.

**Tiempo para ser productivo:** Medio - requiere entender los conceptos basicos de async.

### Lo Que Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos
2. **[Funciones](#language-guide-functions)** - Callbacks y clausuras
3. **[Manejo de Errores](#language-guide-error-handling)** - try/catch para errores de red
4. **[Async y Concurrencia](#advanced-async-concurrency)** - spawn, await, canales
5. **Biblioteca Estandar:**
   - **[@stdlib/http](#stdlib-http)** - Solicitudes HTTP
   - **[@stdlib/json](#stdlib-json)** - JSON para APIs
   - **[@stdlib/net](#stdlib-net)** - Sockets TCP/UDP
   - **[@stdlib/url](#stdlib-url)** - Analisis de URL

### Proyecto de Ejemplo: Cliente de API

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// Solicitud GET
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name}: ${user.email}`);
}

// Solicitud POST
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`Created user with ID: ${parse(result.body).id}`);
```

---

## Ruta 4: Programacion de Sistemas

**Objetivo:** Escribir codigo de bajo nivel, trabajar con memoria, interfaces con bibliotecas C.

**Tiempo para ser productivo:** Mas largo - requiere entender la gestion de memoria.

### Lo Que Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos
2. **[Tipos](#language-guide-types)** - Entender i32, u8, ptr, etc.
3. **[Gestion de Memoria](#language-guide-memory)** - alloc, free, buffers
4. **[FFI](#advanced-ffi)** - Llamar funciones C
5. **[Senales](#advanced-signals)** - Manejo de senales

### Conceptos Clave

**Lista de Verificacion de Seguridad de Memoria:**
- [ ] Cada `alloc()` tiene un `free()` correspondiente
- [ ] Usar `buffer()` a menos que necesite `ptr` crudo
- [ ] Establecer punteros a `null` despues de liberar
- [ ] Usar `try/finally` para garantizar limpieza

**Mapeo de Tipos para FFI:**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long` (64-bit) |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### Proyecto de Ejemplo: Pool de Memoria Personalizado

```hemlock
// Asignador bump simple
let pool_size = 1024 * 1024;  // 1MB
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Pool exhausted";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// Usarlo
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();  // Reutilizar toda la memoria
pool_destroy();  // Limpiar
```

---

## Ruta 5: Programas Paralelos y Concurrentes

**Objetivo:** Ejecutar codigo en multiples nucleos de CPU, construir aplicaciones responsivas.

**Tiempo para ser productivo:** Medio - la sintaxis async es directa, pero razonar sobre paralelismo requiere practica.

### Lo Que Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos
2. **[Funciones](#language-guide-functions)** - Clausuras (importantes para async)
3. **[Async y Concurrencia](#advanced-async-concurrency)** - Profundizacion completa
4. **[Atomicos](#advanced-atomics)** - Programacion sin bloqueos

### Conceptos Clave

**Modelo async de Hemlock:**
- `async fn` - Definir una funcion que puede ejecutarse en otro hilo
- `spawn(fn, args...)` - Comenzar a ejecutarla, devuelve un manejador de tarea
- `join(task)` o `await task` - Esperar a que termine, obtener resultado
- `channel(size)` - Crear una cola para enviar datos entre tareas

**Importante:** Las tareas reciben *copias* de valores. Si pasa un puntero, usted es responsable de asegurar que la memoria permanezca valida hasta que la tarea complete.

### Proyecto de Ejemplo: Procesador de Archivos Paralelo

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// Procesar todos los archivos en paralelo
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// Recolectar resultados
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name}: ${count} lines`);
    total_lines = total_lines + count;
}

print(`Total: ${total_lines} lines`);
```

---

## Que Aprender Primero (Cualquier Ruta)

Sin importar su objetivo, comience con estos fundamentos:

### Semana 1: Conceptos Basicos Principales
1. **[Inicio Rapido](#getting-started-quick-start)** - Escriba y ejecute su primer programa
2. **[Sintaxis](#language-guide-syntax)** - Variables, operadores, flujo de control
3. **[Funciones](#language-guide-functions)** - Definir y llamar funciones

### Semana 2: Manejo de Datos
4. **[Cadenas](#language-guide-strings)** - Manipulacion de texto
5. **[Arreglos](#language-guide-arrays)** - Colecciones e iteracion
6. **[Objetos](#language-guide-objects)** - Datos estructurados

### Semana 3: Robustez
7. **[Manejo de Errores](#language-guide-error-handling)** - try/catch/throw
8. **[Modulos](#language-guide-modules)** - Import/export, usando stdlib

### Luego: Elija Su Ruta Arriba

---

## Hoja de Referencia: Viniendo de Otros Lenguajes

### Desde Python

| Python | Hemlock | Notas |
|--------|---------|-------|
| `x = 42` | `let x = 42;` | Punto y coma requerido |
| `def fn():` | `fn name() { }` | Llaves requeridas |
| `if x:` | `if (x) { }` | Parentesis y llaves requeridos |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Bucles for estilo C |
| `for item in list:` | `for (item in array) { }` | For-in funciona igual |
| `list.append(x)` | `array.push(x);` | Nombre de metodo diferente |
| `len(s)` | `s.length` o `len(s)` | Ambos funcionan |
| Memoria automatica | Manual para `ptr` | La mayoria de tipos auto-limpian |

### Desde JavaScript

| JavaScript | Hemlock | Notas |
|------------|---------|-------|
| `let x = 42` | `let x = 42;` | Igual (punto y coma requerido) |
| `const x = 42` | `let x = 42;` | Sin palabra clave const |
| `function fn()` | `fn name() { }` | Palabra clave diferente |
| `() => x` | `fn() { return x; }` | Sin funciones flecha |
| `async/await` | `async/await` | Misma sintaxis |
| `Promise` | `spawn/join` | Modelo diferente |
| GC automatico | Manual para `ptr` | La mayoria de tipos auto-limpian |

### Desde C/C++

| C | Hemlock | Notas |
|---|---------|-------|
| `int x = 42;` | `let x: i32 = 42;` | Tipo despues de dos puntos |
| `malloc(n)` | `alloc(n)` | Mismo concepto |
| `free(p)` | `free(p)` | Igual |
| `char* s = "hi"` | `let s = "hi";` | Las cadenas son gestionadas |
| `#include` | `import { } from` | Importaciones de modulos |
| Manual todo | Auto para la mayoria de tipos | Solo `ptr` necesita manual |

---

## Obteniendo Ayuda

- **[Glosario](../glossary.md)** - Definiciones de terminos de programacion
- **[Ejemplos](../../examples/)** - Programas completos funcionando
- **[Pruebas](../../tests/)** - Ver como se usan las caracteristicas
- **GitHub Issues** - Hacer preguntas, reportar errores

---

## Niveles de Dificultad

A lo largo de la documentacion, vera estos marcadores:

| Marcador | Significado |
|----------|-------------|
| **Principiante** | No se necesita experiencia previa en programacion |
| **Intermedio** | Asume conocimientos basicos de programacion |
| **Avanzado** | Requiere comprension de conceptos de sistemas |

Si algo marcado como "Principiante" le confunde, consulte el [Glosario](../glossary.md) para definiciones de terminos.


--------------------------------------------------------------------------------
## Tutorial
--------------------------------------------------------------------------------

# Tutorial de Hemlock

Una guia completa paso a paso para aprender Hemlock.

## Tabla de Contenidos

1. [Hola Mundo](#hola-mundo)
2. [Variables y Tipos](#variables-y-tipos)
3. [Aritmetica y Operaciones](#aritmetica-y-operaciones)
4. [Flujo de Control](#flujo-de-control)
5. [Funciones](#funciones)
6. [Cadenas y Runes](#cadenas-y-runes)
7. [Arreglos](#arreglos)
8. [Objetos](#objetos)
9. [Gestion de Memoria](#gestion-de-memoria)
10. [Manejo de Errores](#manejo-de-errores)
11. [E/S de Archivos](#es-de-archivos)
12. [Poniendolo Todo Junto](#poniendolo-todo-junto)

## Hola Mundo

Comencemos con el tradicional primer programa:

```hemlock
print("Hello, World!");
```

Guardelo como `hello.hml` y ejecute:

```bash
./hemlock hello.hml
```

**Puntos Clave:**
- `print()` es una funcion incorporada que escribe a stdout
- Las cadenas se encierran entre comillas dobles
- Los puntos y coma son **obligatorios**

## Variables y Tipos

### Declarando Variables

```hemlock
// Declaracion basica de variable
let x = 42;
let name = "Alice";
let pi = 3.14159;

print(x);      // 42
print(name);   // Alice
print(pi);     // 3.14159
```

### Anotaciones de Tipo

Aunque los tipos se infieren por defecto, puede ser explicito:

```hemlock
let age: i32 = 30;
let height: f64 = 5.9;
let initial: rune = 'A';
let active: bool = true;
```

### Inferencia de Tipos

Hemlock infiere tipos basandose en los valores:

```hemlock
let small = 42;              // i32 (cabe en 32 bits)
let large = 5000000000;      // i64 (muy grande para i32)
let decimal = 3.14;          // f64 (por defecto para flotantes)
let text = "hello";          // string
let flag = true;             // bool
```

### Verificacion de Tipos

```hemlock
// Verificar tipos con typeof()
print(typeof(42));        // "i32"
print(typeof(3.14));      // "f64"
print(typeof("hello"));   // "string"
print(typeof(true));      // "bool"
print(typeof(null));      // "null"
```

## Aritmetica y Operaciones

### Aritmetica Basica

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13
print(a - b);   // 7
print(a * b);   // 30
print(a / b);   // 3 (division entera)
print(a == b);  // false
print(a > b);   // true
```

### Promocion de Tipos

Al mezclar tipos, Hemlock promueve al tipo mas grande/preciso:

```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result es f64 (10.0 + 3.5 = 13.5)

print(result);       // 13.5
print(typeof(result)); // "f64"
```

### Operaciones de Bits

```hemlock
let a = 12;  // 1100 en binario
let b = 10;  // 1010 en binario

print(a & b);   // 8  (AND)
print(a | b);   // 14 (OR)
print(a ^ b);   // 6  (XOR)
print(a << 1);  // 24 (desplazamiento izquierda)
print(a >> 1);  // 6  (desplazamiento derecha)
print(~a);      // -13 (NOT)
```

## Flujo de Control

### Sentencias If

```hemlock
let x = 10;

if (x > 0) {
    print("positive");
} else if (x < 0) {
    print("negative");
} else {
    print("zero");
}
```

**Nota:** Las llaves son **siempre requeridas**, incluso para sentencias individuales.

### Bucles While

```hemlock
let count = 0;
while (count < 5) {
    print(`Count: ${count}`);
    count = count + 1;
}
```

### Bucles For

```hemlock
// Bucle for estilo C
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

// Bucle for-in (arreglos)
let items = [10, 20, 30, 40];
for (let item in items) {
    print(`Item: ${item}`);
}
```

### Sentencias Switch

```hemlock
let day = 3;

switch (day) {
    case 1:
        print("Monday");
        break;
    case 2:
        print("Tuesday");
        break;
    case 3:
        print("Wednesday");
        break;
    default:
        print("Other day");
        break;
}
```

### Break y Continue

```hemlock
// Break: salir del bucle anticipadamente
let i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Imprime: 0, 1, 2, 3, 4

// Continue: saltar a la siguiente iteracion
for (let j = 0; j < 5; j = j + 1) {
    if (j == 2) {
        continue;
    }
    print(j);
}
// Imprime: 0, 1, 3, 4
```

## Funciones

### Funciones con Nombre

```hemlock
fn greet(name: string): string {
    return "Hello, " + name + "!";
}

let message = greet("Alice");
print(message);  // "Hello, Alice!"
```

### Funciones Anonimas

```hemlock
let add = fn(a, b) {
    return a + b;
};

print(add(5, 3));  // 8
```

### Recursion

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Clausuras

Las funciones capturan su entorno:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

### Funciones de Orden Superior

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 21);
print(result);  // 42
```

## Cadenas y Runes

### Conceptos Basicos de Cadenas

Las cadenas son **mutables** y **UTF-8**:

```hemlock
let s = "hello";
print(s.length);      // 5 (conteo de caracteres)
print(s.byte_length); // 5 (conteo de bytes)

// Mutacion
s[0] = 'H';
print(s);  // "Hello"
```

### Metodos de Cadena

```hemlock
let text = "  Hello, World!  ";

// Conversion de mayusculas/minusculas
print(text.to_upper());  // "  HELLO, WORLD!  "
print(text.to_lower());  // "  hello, world!  "

// Recorte
print(text.trim());      // "Hello, World!"

// Extraccion de subcadena
let hello = text.substr(2, 5);  // "Hello"
let world = text.slice(9, 14);  // "World"

// Busqueda
let pos = text.find("World");   // 9
let has = text.contains("o");   // true

// Division
let parts = "a,b,c".split(","); // ["a", "b", "c"]

// Reemplazo
let s = "hello world".replace("world", "there");
print(s);  // "hello there"
```

### Runes (Puntos de Codigo Unicode)

```hemlock
let ch: rune = 'A';
let emoji: rune = 'ðŸš€';

print(ch);      // 'A'
print(emoji);   // U+1F680

// Concatenacion Rune + String
let msg = '>' + " Important";
print(msg);  // "> Important"

// Convertir entre rune y entero
let code: i32 = ch;     // 65 (codigo ASCII)
let r: rune = 128640;   // U+1F680 (ðŸš€)
```

## Arreglos

### Conceptos Basicos de Arreglos

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Modificar elementos
numbers[2] = 99;
print(numbers[2]);  // 99
```

### Metodos de Arreglo

```hemlock
let arr = [10, 20, 30];

// Agregar/eliminar al final
arr.push(40);           // [10, 20, 30, 40]
let last = arr.pop();   // 40, arr ahora es [10, 20, 30]

// Agregar/eliminar al principio
arr.unshift(5);         // [5, 10, 20, 30]
let first = arr.shift(); // 5, arr ahora es [10, 20, 30]

// Insertar/eliminar en indice
arr.insert(1, 15);      // [10, 15, 20, 30]
let removed = arr.remove(2);  // 20

// Busqueda
let index = arr.find(15);     // 1
let has = arr.contains(10);   // true

// Porcion
let slice = arr.slice(0, 2);  // [10, 15]

// Unir a cadena
let text = arr.join(", ");    // "10, 15, 30"
```

### Iteracion

```hemlock
let items = ["apple", "banana", "cherry"];

// Bucle for-in
for (let item in items) {
    print(item);
}

// Iteracion manual
let i = 0;
while (i < items.length) {
    print(items[i]);
    i = i + 1;
}
```

## Objetos

### Literales de Objeto

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
print(person.age);   // 30

// Agregar/modificar campos
person.email = "alice@example.com";
person.age = 31;
```

### Metodos y `self`

```hemlock
let calculator = {
    value: 0,
    add: fn(x) {
        self.value = self.value + x;
    },
    get: fn() {
        return self.value;
    }
};

calculator.add(10);
calculator.add(5);
print(calculator.get());  // 15
```

### Definiciones de Tipo (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,  // Opcional con valor por defecto
}

let p = { name: "Bob", age: 25 };
let typed: Person = p;  // Duck typing valida la estructura

print(typeof(typed));   // "Person"
print(typed.active);    // true (por defecto aplicado)
```

### Serializacion JSON

```hemlock
let obj = { x: 10, y: 20, name: "test" };

// Objeto a JSON
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// JSON a Objeto
let restored = json.deserialize();
print(restored.name);  // "test"
```

## Gestion de Memoria

### Buffers Seguros (Recomendado)

```hemlock
// Asignar buffer
let buf = buffer(10);
print(buf.length);    // 10
print(buf.capacity);  // 10

// Establecer valores (con verificacion de limites)
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Acceder a valores
print(buf[0]);  // 65

// Debe liberar cuando termine
free(buf);
```

### Punteros Crudos (Avanzado)

```hemlock
// Asignar memoria cruda
let ptr = alloc(100);

// Llenar con ceros
memset(ptr, 0, 100);

// Copiar datos
let src = alloc(50);
memcpy(ptr, src, 50);

// Liberar ambos
free(src);
free(ptr);
```

### Funciones de Memoria

```hemlock
// Reasignar
let p = alloc(64);
p = realloc(p, 128);  // Redimensionar a 128 bytes
free(p);

// Asignacion tipada (futuro)
// let arr = talloc(i32, 100);  // Arreglo de 100 i32s
```

## Manejo de Errores

### Try/Catch

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Error: " + e);
}
// Salida: Error: division by zero
```

### Bloque Finally

```hemlock
let file = null;

try {
    file = open("data.txt", "r");
    let content = file.read();
    print(content);
} catch (e) {
    print("Error: " + e);
} finally {
    // Siempre se ejecuta
    if (file != null) {
        file.close();
    }
}
```

### Lanzando Objetos

```hemlock
try {
    throw { code: 404, message: "Not found" };
} catch (e) {
    print(`Error ${e.code}: ${e.message}`);
}
// Salida: Error 404: Not found
```

### Panic (Errores Irrecuperables)

```hemlock
fn validate(x) {
    if (x < 0) {
        panic("x must be non-negative");
    }
    return x * 2;
}

validate(-5);  // El programa termina con: panic: x must be non-negative
```

## E/S de Archivos

### Leyendo Archivos

```hemlock
// Leer archivo completo
let f = open("data.txt", "r");
let content = f.read();
print(content);
f.close();

// Leer numero especifico de bytes
let f2 = open("data.txt", "r");
let chunk = f2.read(100);  // Leer 100 bytes
f2.close();
```

### Escribiendo Archivos

```hemlock
// Escribir texto
let f = open("output.txt", "w");
f.write("Hello, File!\n");
f.write("Second line\n");
f.close();

// Agregar al archivo
let f2 = open("output.txt", "a");
f2.write("Appended line\n");
f2.close();
```

### E/S Binaria

```hemlock
// Escribir datos binarios
let buf = buffer(256);
buf[0] = 255;
buf[1] = 128;

let f = open("data.bin", "w");
f.write_bytes(buf);
f.close();

// Leer datos binarios
let f2 = open("data.bin", "r");
let data = f2.read_bytes(256);
print(data[0]);  // 255
f2.close();

free(buf);
free(data);
```

### Propiedades de Archivo

```hemlock
let f = open("/path/to/file.txt", "r");

print(f.path);    // "/path/to/file.txt"
print(f.mode);    // "r"
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

## Poniendolo Todo Junto

Construyamos un programa simple de contador de palabras:

```hemlock
// wordcount.hml - Contar palabras en un archivo

fn count_words(filename: string): i32 {
    let file = null;
    let count = 0;

    try {
        file = open(filename, "r");
        let content = file.read();

        // Dividir por espacios en blanco y contar
        let words = content.split(" ");
        count = words.length;

    } catch (e) {
        print("Error reading file: " + e);
        return -1;
    } finally {
        if (file != null) {
            file.close();
        }
    }

    return count;
}

// Programa principal
if (args.length < 2) {
    print("Usage: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    let words = count_words(filename);

    if (words >= 0) {
        print(`Word count: ${words}`);
    }
}
```

Ejecute con:
```bash
./hemlock wordcount.hml data.txt
```

## Proximos Pasos

Felicitaciones! Ha aprendido lo basico de Hemlock. Esto es lo que puede explorar a continuacion:

- [Async y Concurrencia](#advanced-async-concurrency) - Multi-hilos verdaderos
- [FFI](#advanced-ffi) - Llamar funciones C
- [Manejo de Senales](#advanced-signals) - Senales de proceso
- [Referencia de API](#reference-builtins) - Documentacion completa de la API
- [Ejemplos](../../examples/) - Mas programas del mundo real

## Ejercicios de Practica

Intente construir estos programas para practicar:

1. **Calculadora**: Implemente una calculadora simple con +, -, *, /
2. **Copia de Archivo**: Copie un archivo a otro
3. **Fibonacci**: Genere numeros de Fibonacci
4. **Parser JSON**: Lea y analice archivos JSON
5. **Procesador de Texto**: Encuentre y reemplace texto en archivos

Feliz programacion con Hemlock!



################################################################################
# GUÃA DEL LENGUAJE
################################################################################

--------------------------------------------------------------------------------
## Arreglos
--------------------------------------------------------------------------------

# Arrays

Hemlock proporciona **arrays dinamicos** con metodos completos para manipulacion y procesamiento de datos. Los arrays pueden contener tipos mezclados y crecer automaticamente segun sea necesario.

## Resumen

```hemlock
// Literales de array
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Tipos mezclados permitidos
let mixed = [1, "hello", true, null];

// Tamano dinamico
arr.push(6);           // Crece automaticamente
arr.push(7);
print(arr.length);     // 7
```

## Literales de Array

### Sintaxis Basica

```hemlock
let numbers = [1, 2, 3, 4, 5];
let strings = ["apple", "banana", "cherry"];
let booleans = [true, false, true];
```

### Arrays Vacios

```hemlock
let arr = [];  // Array vacio

// Agregar elementos despues
arr.push(1);
arr.push(2);
arr.push(3);
```

### Tipos Mezclados

Los arrays pueden contener diferentes tipos:

```hemlock
let mixed = [
    42,
    "hello",
    true,
    null,
    [1, 2, 3],
    { x: 10, y: 20 }
];

print(mixed[0]);  // 42
print(mixed[1]);  // "hello"
print(mixed[4]);  // [1, 2, 3] (array anidado)
```

### Arrays Anidados

```hemlock
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

print(matrix[0][0]);  // 1
print(matrix[1][2]);  // 6
print(matrix[2][1]);  // 8
```

### Arrays con Tipo

Los arrays pueden tener anotaciones de tipo para imponer tipos de elementos:

```hemlock
// Sintaxis de array con tipo
let nums: array<i32> = [1, 2, 3, 4, 5];
let names: array<string> = ["Alice", "Bob", "Carol"];
let flags: array<bool> = [true, false, true];

// Verificacion de tipos en tiempo de ejecucion
let valid: array<i32> = [1, 2, 3];       // OK
let invalid: array<i32> = [1, "two", 3]; // Error de tiempo de ejecucion: incompatibilidad de tipos

// Arrays anidados con tipo
let matrix: array<array<i32>> = [
    [1, 2, 3],
    [4, 5, 6]
];
```

**Comportamiento de anotacion de tipo:**
- Los elementos se verifican por tipo cuando se agregan al array
- Las incompatibilidades de tipo causan errores de tiempo de ejecucion
- Sin anotacion de tipo, los arrays aceptan tipos mezclados

## Indexacion

### Leer Elementos

Acceso indexado desde cero:

```hemlock
let arr = [10, 20, 30, 40, 50];

print(arr[0]);  // 10 (primer elemento)
print(arr[4]);  // 50 (ultimo elemento)

// Fuera de limites retorna null (sin error)
print(arr[10]);  // null
```

### Escribir Elementos

```hemlock
let arr = [1, 2, 3];

arr[0] = 10;    // Modificar existente
arr[1] = 20;
print(arr);     // [10, 20, 3]

// Puede asignar mas alla de la longitud actual (crece el array)
arr[5] = 60;    // Crea [10, 20, 3, null, null, 60]
```

### Indices Negativos

**No soportado** - Usar solo indices positivos:

```hemlock
let arr = [1, 2, 3];
print(arr[-1]);  // ERROR o comportamiento indefinido

// Usar length para el ultimo elemento
print(arr[arr.length - 1]);  // 3
```

## Propiedades

### Propiedad `.length`

Retorna el numero de elementos:

```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);  // 5

// Array vacio
let empty = [];
print(empty.length);  // 0

// Despues de modificaciones
arr.push(6);
print(arr.length);  // 6
```

## Metodos de Array

Hemlock proporciona 18 metodos de array para manipulacion completa.

### Operaciones de Pila

**`push(value)`** - Agregar elemento al final:
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]

print(arr.length);     // 5
```

**`pop()`** - Remover y retornar ultimo elemento:
```hemlock
let arr = [1, 2, 3, 4, 5];
let last = arr.pop();  // Retorna 5, arr es ahora [1, 2, 3, 4]

print(last);           // 5
print(arr.length);     // 4
```

### Operaciones de Cola

**`shift()`** - Remover y retornar primer elemento:
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();   // Retorna 1, arr es ahora [2, 3]

print(first);              // 1
print(arr);                // [2, 3]
```

**`unshift(value)`** - Agregar elemento al principio:
```hemlock
let arr = [2, 3];
arr.unshift(1);            // [1, 2, 3]
arr.unshift(0);            // [0, 1, 2, 3]
```

### Insercion y Remocion

**`insert(index, value)`** - Insertar elemento en indice:
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // Insertar 3 en indice 2: [1, 2, 3, 4, 5]

arr.insert(0, 0);      // Insertar al principio: [0, 1, 2, 3, 4, 5]
```

**`remove(index)`** - Remover y retornar elemento en indice:
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(2);  // Retorna 3, arr es ahora [1, 2, 4, 5]

print(removed);               // 3
print(arr);                   // [1, 2, 4, 5]
```

### Operaciones de Busqueda

**`find(value)`** - Encontrar primera ocurrencia:
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2 (indice de primera ocurrencia)
let idx2 = arr.find(99);     // -1 (no encontrado)

// Funciona con cualquier tipo
let words = ["apple", "banana", "cherry"];
let idx3 = words.find("banana");  // 1
```

**`contains(value)`** - Verificar si array contiene valor:
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false
```

### Operaciones de Extraccion

**`slice(start, end)`** - Extraer subarray (end exclusivo):
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)
let first = arr.slice(0, 2); // [1, 2]

// Original sin cambios
print(arr);                  // [1, 2, 3, 4, 5]
```

**`first()`** - Obtener primer elemento (sin remover):
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1 (sin remover)
print(arr);                  // [1, 2, 3] (sin cambios)
```

**`last()`** - Obtener ultimo elemento (sin remover):
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3 (sin remover)
print(arr);                  // [1, 2, 3] (sin cambios)
```

### Operaciones de Transformacion

**`reverse()`** - Invertir array en su lugar:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]

print(arr);                  // [5, 4, 3, 2, 1] (modificado)
```

**`join(delimiter)`** - Unir elementos en cadena:
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Funciona con tipos mezclados
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"
```

**`concat(other)`** - Concatenar con otro array:
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (nuevo array)

// Originales sin cambios
print(a);                    // [1, 2, 3]
print(b);                    // [4, 5, 6]
```

### Operaciones de Utilidad

**`clear()`** - Remover todos los elementos:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();                 // []

print(arr.length);           // 0
print(arr);                  // []
```

## Encadenamiento de Metodos

Los metodos que retornan arrays o valores permiten encadenamiento:

```hemlock
let result = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);  // [3, 4, 5]

let text = ["apple", "banana", "cherry"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

let numbers = [5, 3, 8, 1, 9]
    .slice(1, 4)
    .concat([10, 11]);  // [3, 8, 1, 10, 11]
```

## Referencia Completa de Metodos

| Metodo | Parametros | Retorna | Muta | Descripcion |
|--------|------------|---------|------|-------------|
| `push(value)` | any | void | Si | Agregar elemento al final |
| `pop()` | - | any | Si | Remover y retornar ultimo |
| `shift()` | - | any | Si | Remover y retornar primero |
| `unshift(value)` | any | void | Si | Agregar elemento al principio |
| `insert(index, value)` | i32, any | void | Si | Insertar en indice |
| `remove(index)` | i32 | any | Si | Remover y retornar en indice |
| `find(value)` | any | i32 | No | Encontrar primera ocurrencia (-1 si no encontrado) |
| `contains(value)` | any | bool | No | Verificar si contiene valor |
| `slice(start, end)` | i32, i32 | array | No | Extraer subarray (nuevo array) |
| `join(delimiter)` | string | string | No | Unir en cadena |
| `concat(other)` | array | array | No | Concatenar (nuevo array) |
| `reverse()` | - | void | Si | Invertir en su lugar |
| `first()` | - | any | No | Obtener primer elemento |
| `last()` | - | any | No | Obtener ultimo elemento |
| `clear()` | - | void | Si | Remover todos los elementos |
| `map(callback)` | fn | array | No | Transformar cada elemento |
| `filter(predicate)` | fn | array | No | Seleccionar elementos coincidentes |
| `reduce(callback, initial)` | fn, any | any | No | Reducir a valor unico |

## Detalles de Implementacion

### Modelo de Memoria

- **Asignado en heap** - Capacidad dinamica
- **Crecimiento automatico** - Duplica capacidad cuando se excede
- **Sin reduccion automatica** - La capacidad no disminuye
- **Sin verificacion de limites en indexacion** - Usar metodos para seguridad

### Gestion de Capacidad

```hemlock
let arr = [];  // Capacidad inicial: 0

arr.push(1);   // Crece a capacidad 1
arr.push(2);   // Crece a capacidad 2
arr.push(3);   // Crece a capacidad 4 (duplica)
arr.push(4);   // Aun capacidad 4
arr.push(5);   // Crece a capacidad 8 (duplica)
```

### Comparacion de Valores

`find()` y `contains()` usan igualdad de valores:

```hemlock
// Primitivos: comparar por valor
let arr = [1, 2, 3];
arr.contains(2);  // true

// Cadenas: comparar por valor
let words = ["hello", "world"];
words.contains("hello");  // true

// Objetos: comparar por referencia
let obj1 = { x: 10 };
let obj2 = { x: 10 };
let arr2 = [obj1];
arr2.contains(obj1);  // true (misma referencia)
arr2.contains(obj2);  // false (diferente referencia)
```

## Patrones Comunes

### Operaciones Funcionales (map/filter/reduce)

Los arrays tienen metodos integrados `map`, `filter` y `reduce`:

```hemlock
// map - transformar cada elemento
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

// filter - seleccionar elementos coincidentes
let evens = numbers.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4]

// reduce - acumular a valor unico
let sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

// Encadenamiento de operaciones funcionales
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]
    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]
    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220
```

### Patron: Array como Pila

```hemlock
let stack = [];

// Push a la pila
stack.push(1);
stack.push(2);
stack.push(3);

// Pop de la pila
let top = stack.pop();    // 3
let next = stack.pop();   // 2
```

### Patron: Array como Cola

```hemlock
let queue = [];

// Encolar (agregar al final)
queue.push(1);
queue.push(2);
queue.push(3);

// Desencolar (remover del frente)
let first = queue.shift();   // 1
let second = queue.shift();  // 2
```

## Mejores Practicas

1. **Usar metodos sobre indexacion directa** - Verificacion de limites y claridad
2. **Verificar limites** - La indexacion directa no verifica limites
3. **Preferir operaciones inmutables** - Usar `slice()` y `concat()` sobre mutacion
4. **Inicializar con capacidad** - Si conoces el tamano (actualmente no soportado)
5. **Usar `contains()` para membresia** - Mas claro que bucles manuales
6. **Encadenar metodos** - Mas legible que llamadas anidadas

## Errores Comunes

### Error: Indice Directo Fuera de Limites

```hemlock
let arr = [1, 2, 3];

// Sin verificacion de limites!
arr[10] = 99;  // Crea array disperso con nulls
print(arr.length);  // 11 (no 3!)

// Mejor: Usar push() o verificar length
if (arr.length <= 10) {
    arr.push(99);
}
```

### Error: Mutacion vs. Nuevo Array

```hemlock
let arr = [1, 2, 3];

// Muta original
arr.reverse();
print(arr);  // [3, 2, 1]

// Retorna nuevo array
let sub = arr.slice(0, 2);
print(arr);  // [3, 2, 1] (sin cambios)
print(sub);  // [3, 2]
```

### Error: Igualdad de Referencia

```hemlock
let obj = { x: 10 };
let arr = [obj];

// Misma referencia: true
arr.contains(obj);  // true

// Diferente referencia: false
arr.contains({ x: 10 });  // false (diferente objeto)
```

### Error: Arrays de Larga Vida

```hemlock
// Los arrays en alcance local se liberan automaticamente, pero los arrays globales/de larga vida necesitan atencion
let global_cache = [];  // Nivel de modulo, persiste hasta fin del programa

fn add_to_cache(item) {
    global_cache.push(item);  // Crece indefinidamente
}

// Para datos de larga vida, considera:
// - Limpiar el array periodicamente: global_cache.clear();
// - Liberar temprano cuando termines: free(global_cache);
```

## Ejemplos

### Ejemplo: Estadisticas de Array

```hemlock
fn mean(arr) {
    let sum = 0;
    let i = 0;
    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum / arr.length;
}

fn max(arr) {
    if (arr.length == 0) {
        return null;
    }

    let max_val = arr[0];
    let i = 1;
    while (i < arr.length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    return max_val;
}

let numbers = [3, 7, 2, 9, 1];
print(mean(numbers));  // 4.4
print(max(numbers));   // 9
```

### Ejemplo: Deduplicacion de Array

```hemlock
fn unique(arr) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (!result.contains(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

let numbers = [1, 2, 2, 3, 1, 4, 3, 5];
let uniq = unique(numbers);  // [1, 2, 3, 4, 5]
```

### Ejemplo: Fragmentacion de Array

```hemlock
fn chunk(arr, size) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        let chunk = arr.slice(i, i + size);
        result.push(chunk);
        i = i + size;
    }

    return result;
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
let chunks = chunk(numbers, 3);
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### Ejemplo: Aplanamiento de Array

```hemlock
fn flatten(arr) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        if (typeof(arr[i]) == "array") {
            // Array anidado - aplanarlo
            let nested = flatten(arr[i]);
            let j = 0;
            while (j < nested.length) {
                result.push(nested[j]);
                j = j + 1;
            }
        } else {
            result.push(arr[i]);
        }
        i = i + 1;
    }

    return result;
}

let nested = [1, [2, 3], [4, [5, 6]], 7];
let flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]
```

### Ejemplo: Ordenamiento (Burbuja)

```hemlock
fn sort(arr) {
    let n = arr.length;
    let i = 0;

    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // Intercambiar
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers);  // Modifica en su lugar
print(numbers);  // [1, 2, 5, 8, 9]
```

## Limitaciones

Limitaciones actuales:

- **Sin verificacion de limites en indexacion** - El acceso directo no se verifica
- **Igualdad de referencia para objetos** - `find()` y `contains()` usan comparacion de referencia
- **Sin desestructuracion de arrays** - Sin sintaxis `let [a, b] = arr`
- **Sin operador spread** - Sin sintaxis `[...arr1, ...arr2]`

**Nota:** Los arrays tienen conteo de referencias y se liberan automaticamente cuando el alcance termina. Ver [Gestion de Memoria](memory.md#conteo-de-referencias-interno) para detalles.

## Temas Relacionados

- [Strings](#language-guide-strings) - Metodos de cadena similares a metodos de array
- [Objects](#language-guide-objects) - Los arrays tambien son similares a objetos
- [Functions](#language-guide-functions) - Funciones de orden superior con arrays
- [Control Flow](#language-guide-control-flow) - Iterando sobre arrays

## Ver Tambien

- **Tamano Dinamico**: Los arrays crecen automaticamente con duplicacion de capacidad
- **Metodos**: 18 metodos completos para manipulacion incluyendo map/filter/reduce
- **Memoria**: Ver [Memory](#language-guide-memory) para detalles de asignacion de arrays


--------------------------------------------------------------------------------
## Cadenas
--------------------------------------------------------------------------------

# Cadenas

Las cadenas de Hemlock son **secuencias mutables de primera clase codificadas en UTF-8** con soporte completo de Unicode y un amplio conjunto de metodos para procesamiento de texto. A diferencia de muchos lenguajes, las cadenas de Hemlock son mutables y trabajan nativamente con puntos de codigo Unicode.

## Resumen

```hemlock
let s = "hello";
s[0] = 'H';             // mutar con rune (ahora "Hello")
print(s.length);        // 5 (conteo de puntos de codigo)
let c = s[0];           // retorna rune (punto de codigo Unicode)
let msg = s + " world"; // concatenacion
let emoji = "rocket";
print(emoji.length);    // 1 (un punto de codigo)
print(emoji.byte_length); // 4 (cuatro bytes UTF-8)
```

## Propiedades

Las cadenas de Hemlock tienen estas caracteristicas clave:

- **Codificadas en UTF-8** - Soporte completo de Unicode (U+0000 a U+10FFFF)
- **Mutables** - A diferencia de cadenas en Python, JavaScript y Java
- **Indexacion basada en puntos de codigo** - Retorna `rune` (punto de codigo Unicode), no byte
- **Asignadas en heap** - Con seguimiento de capacidad interna
- **Dos propiedades de longitud**:
  - `.length` - Conteo de puntos de codigo (numero de caracteres)
  - `.byte_length` - Conteo de bytes (tamano de codificacion UTF-8)

## Comportamiento UTF-8

Todas las operaciones de cadena trabajan con **puntos de codigo** (caracteres), no bytes:

```hemlock
let text = "Helloroute";
print(text.length);        // 11 (puntos de codigo)
print(text.byte_length);   // 15 (bytes, el emoji son 4 bytes)

// La indexacion usa puntos de codigo
let h = text[0];           // 'H' (rune)
let rocket = text[5];      // 'rocket' (rune)
```

**Los caracteres multi-byte cuentan como uno:**
```hemlock
"Hello".length;      // 5
"rocket".length;     // 1 (un emoji)
"nihao".length;      // 2 (dos caracteres chinos)
"cafe".length;       // 4 (e con acento es un punto de codigo)
```

## Literales de Cadena

```hemlock
// Cadenas basicas
let s1 = "hello";
let s2 = "world";

// Con secuencias de escape
let s3 = "Line 1\nLine 2\ttabbed";
let s4 = "Quote: \"Hello\"";
let s5 = "Backslash: \\";

// Caracteres Unicode
let s6 = "rocket Emoji";
let s7 = "zhongwenzifu";
```

## Cadenas de Plantilla (Interpolacion de Cadenas)

Usa comillas invertidas para cadenas de plantilla con expresiones embebidas:

```hemlock
let name = "Alice";
let age = 30;

// Interpolacion basica
let greeting = `Hello, ${name}!`;           // "Hello, Alice!"
let info = `${name} is ${age} years old`;   // "Alice is 30 years old"

// Expresiones en interpolacion
let x = 5;
let y = 10;
let sum = `${x} + ${y} = ${x + y}`;         // "5 + 10 = 15"

// Llamadas a metodos
let upper = `Name: ${name.to_upper()}`;     // "Name: ALICE"

// Objetos anidados
let person = { name: "Bob", city: "NYC" };
let desc = `${person.name} lives in ${person.city}`;  // "Bob lives in NYC"

// Multi-linea (preserva saltos de linea)
let multi = `Line 1
Line 2
Line 3`;
```

**Caracteristicas de cadenas de plantilla:**
- Las expresiones dentro de `${...}` se evaluan y convierten a cadenas
- Se puede usar cualquier expresion valida (variables, llamadas a funciones, aritmetica)
- Las cadenas con comillas invertidas soportan las mismas secuencias de escape que las cadenas regulares
- Util para construir cadenas dinamicas sin concatenacion

### Escape en Cadenas de Plantilla

Para incluir un `${` literal en una cadena de plantilla, escapa el signo de dolar:

```hemlock
let price = 100;
let text = `Price: \${price} or ${price}`;
// "Price: ${price} or 100"

// Comilla invertida literal
let code = `Use \` for template strings`;
// "Use ` for template strings"
```

### Expresiones Complejas

Las cadenas de plantilla pueden contener cualquier expresion valida:

```hemlock
// Expresiones tipo ternario
let age = 25;
let status = `Status: ${age >= 18 ? "adult" : "minor"}`;

// Acceso a array
let items = ["apple", "banana", "cherry"];
let first = `First item: ${items[0]}`;

// Llamadas a funciones con argumentos
fn format_price(p) { return "$" + p; }
let msg = `Total: ${format_price(99.99)}`;  // "Total: $99.99"

// Llamadas a metodos encadenados
let name = "alice";
let formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;
// "Hello, Alice!"
```

### Cadenas de Plantilla vs Concatenacion

Las cadenas de plantilla son frecuentemente mas limpias que la concatenacion:

```hemlock
// Concatenacion (mas dificil de leer)
let msg1 = "Hello, " + name + "! You have " + count + " messages.";

// Cadena de plantilla (mas facil de leer)
let msg2 = `Hello, ${name}! You have ${count} messages.`;
```

## Indexacion y Mutacion

### Lectura de Caracteres

La indexacion retorna un `rune` (punto de codigo Unicode):

```hemlock
let s = "Hello";
let first = s[0];      // 'H' (rune)
let last = s[4];       // 'o' (rune)

// Ejemplo UTF-8
let emoji = "Hirocket!";
let rocket = emoji[2];  // 'rocket' (rune en indice de punto de codigo 2)
```

### Escritura de Caracteres

Las cadenas son mutables - puedes modificar caracteres individuales:

```hemlock
let s = "hello";
s[0] = 'H';            // Ahora "Hello"
s[4] = '!';            // Ahora "Hell!"

// Con Unicode
let msg = "Go!";
msg[0] = 'rocket';     // Ahora "rocketo!"
```

## Concatenacion

Usa `+` para concatenar cadenas:

```hemlock
let greeting = "Hello" + " " + "World";  // "Hello World"

// Con variables
let name = "Alice";
let msg = "Hi, " + name + "!";  // "Hi, Alice!"

// Con runes (ver documentacion de Runes)
let s = "Hello" + '!';          // "Hello!"
```

## Metodos de Cadena

Hemlock proporciona 19 metodos de cadena para manipulacion completa de texto.

### Subcadena y Extraccion

**`substr(start, length)`** - Extraer subcadena por posicion y longitud:
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world" (inicia en 6, longitud 5)
let first = s.substr(0, 5);     // "hello"

// Ejemplo UTF-8
let text = "Hirocket!";
let emoji = text.substr(2, 1);  // "rocket" (posicion 2, longitud 1)
```

**`slice(start, end)`** - Extraer subcadena por rango (end exclusivo):
```hemlock
let s = "hello world";
let slice = s.slice(0, 5);      // "hello" (indice 0 a 4)
let slice2 = s.slice(6, 11);    // "world"
```

**Diferencia:**
- `substr(start, length)` - Usa parametro de longitud
- `slice(start, end)` - Usa indice final (exclusivo)

### Busqueda y Encontrar

**`find(needle)`** - Encontrar primera ocurrencia:
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6 (indice de primera ocurrencia)
let pos2 = s.find("foo");       // -1 (no encontrado)
let pos3 = s.find("l");         // 2 (primera 'l')
```

**`contains(needle)`** - Verificar si la cadena contiene subcadena:
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

### Division y Recorte

**`split(delimiter)`** - Dividir en array de cadenas:
```hemlock
let csv = "apple,banana,cherry";
let parts = csv.split(",");     // ["apple", "banana", "cherry"]

let words = "one two three".split(" ");  // ["one", "two", "three"]

// Delimitador vacio divide por caracter
let chars = "abc".split("");    // ["a", "b", "c"]
```

**`trim()`** - Remover espacios al inicio/final:
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let s2 = "\t\ntext\n\t";
let clean2 = s2.trim();         // "text"
```

### Conversion de Mayusculas/Minusculas

**`to_upper()`** - Convertir a mayusculas:
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

// Preserva no-ASCII
let s2 = "cafe";
let upper2 = s2.to_upper();     // "CAFE"
```

**`to_lower()`** - Convertir a minusculas:
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"
```

### Verificacion de Prefijo/Sufijo

**`starts_with(prefix)`** - Verificar si inicia con prefijo:
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

**`ends_with(suffix)`** - Verificar si termina con sufijo:
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

### Reemplazo

**`replace(old, new)`** - Reemplazar primera ocurrencia:
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");      // "hello there"

let s3 = "foo foo foo";
let s4 = s3.replace("foo", "bar");         // "bar foo foo" (solo primera)
```

**`replace_all(old, new)`** - Reemplazar todas las ocurrencias:
```hemlock
let s = "foo foo foo";
let s2 = s.replace_all("foo", "bar");      // "bar bar bar"

let s3 = "hello world, world!";
let s4 = s3.replace_all("world", "hemlock"); // "hello hemlock, hemlock!"
```

### Repeticion

**`repeat(count)`** - Repetir cadena n veces:
```hemlock
let s = "ha";
let laugh = s.repeat(3);        // "hahaha"

let line = "=".repeat(40);      // "========================================"
```

### Acceso a Caracteres y Bytes

**`char_at(index)`** - Obtener punto de codigo Unicode en indice (retorna rune):
```hemlock
let s = "hello";
let char = s.char_at(0);        // 'h' (rune)

// Ejemplo UTF-8
let emoji = "rocket";
let rocket = emoji.char_at(0);  // Retorna rune U+1F680
```

**`chars()`** - Convertir a array de runes (puntos de codigo):
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array de runes)

// Ejemplo UTF-8
let text = "Hirocket";
let chars2 = text.chars();      // ['H', 'i', 'rocket']
```

**`byte_at(index)`** - Obtener valor de byte en indice (retorna u8):
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (valor ASCII de 'h')

// Ejemplo UTF-8
let emoji = "rocket";
let first_byte = emoji.byte_at(0);  // 240 (primer byte UTF-8)
```

**`bytes()`** - Convertir a array de bytes (valores u8):
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111] (array de u8)

// Ejemplo UTF-8
let emoji = "rocket";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)
```

**`to_bytes()`** - Convertir a buffer para acceso de bajo nivel:
```hemlock
let s = "hello";
let buf = s.to_bytes();         // Retorna buffer con bytes UTF-8
print(buf.length);              // 5
free(buf);                      // Recuerda liberar
```

## Encadenamiento de Metodos

Todos los metodos de cadena retornan nuevas cadenas, permitiendo encadenamiento:

```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ")
    .to_upper();                    // "FOO | BAR | BAZ"
```

## Referencia Completa de Metodos

| Metodo | Parametros | Retorna | Descripcion |
|--------|-----------|---------|-------------|
| `substr(start, length)` | i32, i32 | string | Extraer subcadena por posicion y longitud |
| `slice(start, end)` | i32, i32 | string | Extraer subcadena por rango (end exclusivo) |
| `find(needle)` | string | i32 | Encontrar primera ocurrencia (-1 si no encontrado) |
| `contains(needle)` | string | bool | Verificar si contiene subcadena |
| `split(delimiter)` | string | array | Dividir en array de cadenas |
| `trim()` | - | string | Remover espacios al inicio/final |
| `to_upper()` | - | string | Convertir a mayusculas |
| `to_lower()` | - | string | Convertir a minusculas |
| `starts_with(prefix)` | string | bool | Verificar si inicia con prefijo |
| `ends_with(suffix)` | string | bool | Verificar si termina con sufijo |
| `replace(old, new)` | string, string | string | Reemplazar primera ocurrencia |
| `replace_all(old, new)` | string, string | string | Reemplazar todas las ocurrencias |
| `repeat(count)` | i32 | string | Repetir cadena n veces |
| `char_at(index)` | i32 | rune | Obtener punto de codigo en indice |
| `byte_at(index)` | i32 | u8 | Obtener valor de byte en indice |
| `chars()` | - | array | Convertir a array de runes |
| `bytes()` | - | array | Convertir a array de bytes u8 |
| `to_bytes()` | - | buffer | Convertir a buffer (debe liberarse) |

## Ejemplos

### Ejemplo: Procesamiento de Texto

```hemlock
fn process_input(text: string): string {
    return text
        .trim()
        .to_lower()
        .replace_all("  ", " ");  // Normalizar espacios
}

let input = "  HELLO   WORLD  ";
let clean = process_input(input);  // "hello world"
```

### Ejemplo: Analizador CSV

```hemlock
fn parse_csv_line(line: string): array {
    let trimmed = line.trim();
    let fields = trimmed.split(",");

    let result = [];
    let i = 0;
    while (i < fields.length) {
        result.push(fields[i].trim());
        i = i + 1;
    }

    return result;
}

let csv = "apple, banana , cherry";
let fields = parse_csv_line(csv);  // ["apple", "banana", "cherry"]
```

### Ejemplo: Contador de Palabras

```hemlock
fn count_words(text: string): i32 {
    let words = text.trim().split(" ");
    return words.length;
}

let sentence = "The quick brown fox";
let count = count_words(sentence);  // 4
```

### Ejemplo: Validacion de Cadenas

```hemlock
fn is_valid_email(email: string): bool {
    if (!email.contains("@")) {
        return false;
    }

    if (!email.contains(".")) {
        return false;
    }

    if (email.starts_with("@") || email.ends_with("@")) {
        return false;
    }

    return true;
}

print(is_valid_email("user@example.com"));  // true
print(is_valid_email("invalid"));            // false
```

## Gestion de Memoria

Las cadenas se asignan en heap con conteo de referencias interno:

- **Creacion**: Asignadas en heap con seguimiento de capacidad
- **Concatenacion**: Crea nueva cadena (cadenas originales sin cambios)
- **Metodos**: La mayoria de metodos retornan nuevas cadenas
- **Tiempo de vida**: Las cadenas tienen conteo de referencias y se liberan automaticamente cuando el alcance termina

**Limpieza automatica:**
```hemlock
fn create_strings() {
    let s = "hello";
    let s2 = s + " world";  // Nueva asignacion
}  // Tanto s como s2 se liberan automaticamente cuando la funcion retorna
```

**Nota:** Las variables de cadena locales se limpian automaticamente cuando salen del alcance. Usa `free()` solo para limpieza anticipada antes de que termine el alcance o para datos de larga vida/globales. Ver [Gestion de Memoria](memory.md#conteo-de-referencias-interno) para detalles.

## Mejores Practicas

1. **Usar indexacion de puntos de codigo** - Las cadenas usan posiciones de puntos de codigo, no desplazamientos de bytes
2. **Probar con Unicode** - Siempre probar operaciones de cadena con caracteres multi-byte
3. **Preferir operaciones inmutables** - Usar metodos que retornan nuevas cadenas en vez de mutacion
4. **Verificar limites** - La indexacion de cadenas no verifica limites (retorna null/error en invalido)
5. **Normalizar entrada** - Usar `trim()` y `to_lower()` para entrada de usuario

## Errores Comunes

### Error: Confusion Byte vs. Punto de Codigo

```hemlock
let emoji = "rocket";
print(emoji.length);        // 1 (punto de codigo)
print(emoji.byte_length);   // 4 (bytes)

// No mezclar operaciones de byte y punto de codigo
let byte = emoji.byte_at(0);  // 240 (primer byte, no caracter completo)
let char = emoji.char_at(0);  // 'rocket' (punto de codigo completo)
```

### Error: Sorpresas de Mutacion

```hemlock
let s1 = "hello";
let s2 = s1;       // Copia superficial
s1[0] = 'H';       // Muta s1
print(s2);         // Sigue siendo "hello" (las cadenas son tipos de valor)
```

## Temas Relacionados

- [Runes](#language-guide-runes) - Tipo de punto de codigo Unicode usado en indexacion de cadenas
- [Arrays](#language-guide-arrays) - Los metodos de cadena frecuentemente retornan o trabajan con arrays
- [Types](#language-guide-types) - Detalles del tipo string y conversiones

## Ver Tambien

- **Codificacion UTF-8**: Ver seccion "Strings" en CLAUDE.md
- **Conversiones de Tipo**: Ver [Types](#language-guide-types) para conversiones de cadenas
- **Memoria**: Ver [Memory](#language-guide-memory) para detalles de asignacion de cadenas


--------------------------------------------------------------------------------
## Coincidencia de Patrones
--------------------------------------------------------------------------------

# Coincidencia de Patrones

Hemlock proporciona coincidencia de patrones poderosa a travÃ©s de expresiones `match`, ofreciendo una forma concisa de desestructurar valores, verificar tipos y manejar mÃºltiples casos.

## Sintaxis BÃ¡sica

```hemlock
let result = match (value) {
    pattern1 => expression1,
    pattern2 => expression2,
    _ => default_expression
};
```

Las expresiones match evalÃºan `value` contra cada patrÃ³n en orden, retornando el resultado de la expresiÃ³n del primer brazo que coincida.

## Tipos de Patrones

### Patrones Literales

Coincide contra valores exactos:

```hemlock
let x = 42;
let msg = match (x) {
    0 => "zero",
    1 => "one",
    42 => "the answer",
    _ => "other"
};
print(msg);  // "the answer"
```

Literales soportados:
- **Enteros**: `0`, `42`, `-5`
- **Flotantes**: `3.14`, `-0.5`
- **Strings**: `"hello"`, `"world"`
- **Booleanos**: `true`, `false`
- **Null**: `null`

### PatrÃ³n ComodÃ­n (`_`)

Coincide cualquier valor sin vincular:

```hemlock
let x = "anything";
let result = match (x) {
    "specific" => "found it",
    _ => "wildcard matched"
};
```

### Patrones de VinculaciÃ³n de Variables

Vincula el valor coincidente a una variable:

```hemlock
let x = 100;
let result = match (x) {
    0 => "zero",
    n => "value is " + n  // n se vincula a 100
};
print(result);  // "value is 100"
```

### Patrones OR (`|`)

Coincide mÃºltiples alternativas:

```hemlock
let x = 2;
let size = match (x) {
    1 | 2 | 3 => "small",
    4 | 5 | 6 => "medium",
    _ => "large"
};

// Funciona con strings tambiÃ©n
let cmd = "quit";
let action = match (cmd) {
    "exit" | "quit" | "q" => "exiting",
    "help" | "h" | "?" => "showing help",
    _ => "unknown"
};
```

### Expresiones de Guarda (`if`)

Agregue condiciones a los patrones:

```hemlock
let x = 15;
let category = match (x) {
    n if n < 0 => "negative",
    n if n == 0 => "zero",
    n if n < 10 => "small",
    n if n < 100 => "medium",
    n => "large: " + n
};
print(category);  // "medium"

// Guardas complejas
let y = 12;
let result = match (y) {
    n if n % 2 == 0 && n > 10 => "even and greater than 10",
    n if n % 2 == 0 => "even",
    n => "odd"
};
```

### Patrones de Tipo

Verifica y vincula basado en tipo:

```hemlock
let val = 42;
let desc = match (val) {
    num: i32 => "integer: " + num,
    str: string => "string: " + str,
    flag: bool => "boolean: " + flag,
    _ => "other type"
};
print(desc);  // "integer: 42"
```

Tipos soportados: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`

## Patrones de DesestructuraciÃ³n

### DesestructuraciÃ³n de Objetos

Extraer campos de objetos:

```hemlock
let point = { x: 10, y: 20 };
let result = match (point) {
    { x, y } => "point at " + x + "," + y
};
print(result);  // "point at 10,20"

// Con valores literales de campo
let origin = { x: 0, y: 0 };
let name = match (origin) {
    { x: 0, y: 0 } => "origin",
    { x: 0, y } => "on y-axis at " + y,
    { x, y: 0 } => "on x-axis at " + x,
    { x, y } => "point at " + x + "," + y
};
print(name);  // "origin"
```

### DesestructuraciÃ³n de Arrays

Coincide estructura y elementos de array:

```hemlock
let arr = [1, 2, 3];
let desc = match (arr) {
    [] => "empty",
    [x] => "single: " + x,
    [x, y] => "pair: " + x + "," + y,
    [x, y, z] => "triple: " + x + "," + y + "," + z,
    _ => "many elements"
};
print(desc);  // "triple: 1,2,3"

// Con valores literales
let pair = [1, 2];
let result = match (pair) {
    [0, 0] => "both zero",
    [1, x] => "starts with 1, second is " + x,
    [x, 1] => "ends with 1",
    _ => "other"
};
print(result);  // "starts with 1, second is 2"
```

### Patrones Rest de Array (`...`)

Capturar elementos restantes:

```hemlock
let nums = [1, 2, 3, 4, 5];

// Cabeza y cola
let result = match (nums) {
    [first, ...rest] => "first: " + first,
    [] => "empty"
};
print(result);  // "first: 1"

// Primeros dos elementos
let result2 = match (nums) {
    [a, b, ...rest] => "first two: " + a + "," + b,
    _ => "too short"
};
print(result2);  // "first two: 1,2"
```

### DesestructuraciÃ³n Anidada

Combine patrones para datos complejos:

```hemlock
let user = {
    name: "Alice",
    address: { city: "NYC", zip: 10001 }
};

let result = match (user) {
    { name, address: { city, zip } } => name + " lives in " + city,
    _ => "unknown"
};
print(result);  // "Alice lives in NYC"

// Objeto conteniendo array
let data = { items: [1, 2, 3], count: 3 };
let result2 = match (data) {
    { items: [first, ...rest], count } => "first: " + first + ", total: " + count,
    _ => "no items"
};
print(result2);  // "first: 1, total: 3"
```

## Match como ExpresiÃ³n

Match es una expresiÃ³n que retorna un valor:

```hemlock
// AsignaciÃ³n directa
let grade = 85;
let letter = match (grade) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    n if n >= 70 => "C",
    n if n >= 60 => "D",
    _ => "F"
};

// En concatenaciÃ³n de strings
let msg = "Grade: " + match (grade) {
    n if n >= 70 => "passing",
    _ => "failing"
};

// En retorno de funciÃ³n
fn classify(n: i32): string {
    return match (n) {
        0 => "zero",
        n if n > 0 => "positive",
        _ => "negative"
    };
}
```

## Mejores PrÃ¡cticas de Coincidencia de Patrones

1. **El orden importa**: Los patrones se verifican de arriba hacia abajo; coloque patrones especÃ­ficos antes de los generales
2. **Use comodines para exhaustividad**: Siempre incluya un `_` de respaldo a menos que estÃ© seguro de que todos los casos estÃ¡n cubiertos
3. **Prefiera guardas sobre condiciones anidadas**: Las guardas hacen la intenciÃ³n mÃ¡s clara
4. **Use desestructuraciÃ³n sobre acceso manual de campos**: MÃ¡s conciso y seguro

```hemlock
// Bien: Guardas para verificaciÃ³n de rangos
match (score) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    _ => "below B"
}

// Bien: Desestructurar en lugar de acceder campos
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// Evitar: Patrones anidados excesivamente complejos
// En su lugar, considere dividir en mÃºltiples matches o usar guardas
```

## ComparaciÃ³n con Otros Lenguajes

| CaracterÃ­stica | Hemlock | Rust | JavaScript |
|----------------|---------|------|------------|
| Coincidencia bÃ¡sica | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |
| DesestructuraciÃ³n | SÃ­ | SÃ­ | Parcial (switch no desestructura) |
| Guardas | `n if n > 0 =>` | `n if n > 0 =>` | N/A |
| Patrones OR | `1 \| 2 \| 3 =>` | `1 \| 2 \| 3 =>` | `case 1: case 2: case 3:` |
| Patrones rest | `[a, ...rest]` | `[a, rest @ ..]` | N/A |
| Patrones de tipo | `n: i32` | Tipo vÃ­a brazo `match` | N/A |
| Retorna valor | SÃ­ | SÃ­ | No (sentencia) |

## Notas de ImplementaciÃ³n

La coincidencia de patrones estÃ¡ implementada tanto en el backend del intÃ©rprete como del compilador con paridad completa - ambos producen resultados idÃ©nticos para la misma entrada. La caracterÃ­stica estÃ¡ disponible en Hemlock v1.8.0+.


--------------------------------------------------------------------------------
## Flujo de Control
--------------------------------------------------------------------------------

# Flujo de Control

Hemlock proporciona flujo de control estilo C familiar con llaves obligatorias y sintaxis explÃ­cita. Esta guÃ­a cubre condicionales, bucles, sentencias switch y operadores.

## Resumen

CaracterÃ­sticas de flujo de control disponibles:

- `if`/`else`/`else if` - Ramas condicionales
- Bucles `while` - IteraciÃ³n basada en condiciones
- Bucles `for` - IteraciÃ³n estilo C y for-in
- `loop` - Bucles infinitos (mÃ¡s limpio que `while (true)`)
- Sentencias `switch` - RamificaciÃ³n mÃºltiple
- `break`/`continue` - Control de bucles
- Etiquetas de bucle - break/continue dirigido para bucles anidados
- `defer` - EjecuciÃ³n diferida (limpieza)
- Operadores booleanos: `&&`, `||`, `!`
- Operadores de comparaciÃ³n: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Operadores bit a bit: `&`, `|`, `^`, `<<`, `>>`, `~`

## Sentencias If

### If/Else BÃ¡sico

```hemlock
if (x > 10) {
    print("large");
} else {
    print("small");
}
```

**Reglas:**
- Las llaves son **siempre requeridas** para todas las ramas
- Las condiciones deben estar encerradas en parÃ©ntesis
- Sin llaves opcionales (a diferencia de C)

### If Sin Else

```hemlock
if (x > 0) {
    print("positive");
}
// No se necesita rama else
```

### Cadenas Else-If

```hemlock
if (x > 100) {
    print("very large");
} else if (x > 50) {
    print("large");
} else if (x > 10) {
    print("medium");
} else {
    print("small");
}
```

**Nota:** `else if` es azÃºcar sintÃ¡ctico para sentencias if anidadas. Estos son equivalentes:

```hemlock
// else if (azÃºcar sintÃ¡ctico)
if (a) {
    foo();
} else if (b) {
    bar();
}

// If anidado equivalente
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### Sentencias If Anidadas

```hemlock
if (x > 0) {
    if (x < 10) {
        print("single digit positive");
    } else {
        print("multi-digit positive");
    }
} else {
    print("non-positive");
}
```

## Bucles While

IteraciÃ³n basada en condiciones:

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**Bucles infinitos (estilo antiguo):**
```hemlock
while (true) {
    // ... hacer trabajo
    if (should_exit) {
        break;
    }
}
```

**Nota:** Para bucles infinitos, prefiera la palabra clave `loop` (ver abajo).

## Loop (Bucle Infinito)

La palabra clave `loop` proporciona una sintaxis mÃ¡s limpia para bucles infinitos:

```hemlock
loop {
    // ... hacer trabajo
    if (should_exit) {
        break;
    }
}
```

**Equivalente a `while (true)` pero mÃ¡s explÃ­cito sobre la intenciÃ³n.**

### Bucle BÃ¡sico con Break

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Imprime: 0, 1, 2, 3, 4
```

### Bucle con Continue

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // Omite imprimir 3
    }
    print(i);
}
// Imprime: 1, 2, 4, 5
```

### Bucles Anidados

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// Imprime: 0, 1, 2, 10, 11, 12
```

### CuÃ¡ndo Usar Loop

- **Use `loop`** para bucles intencionalmente infinitos que salen vÃ­a `break`
- **Use `while`** cuando hay una condiciÃ³n de terminaciÃ³n natural
- **Use `for`** cuando itera un nÃºmero conocido de veces o sobre una colecciÃ³n

## Bucles For

### For Estilo C

Bucle for clÃ¡sico de tres partes:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**Componentes:**
- **Inicializador**: `let i = 0` - Se ejecuta una vez antes del bucle
- **CondiciÃ³n**: `i < 10` - Se verifica antes de cada iteraciÃ³n
- **ActualizaciÃ³n**: `i = i + 1` - Se ejecuta despuÃ©s de cada iteraciÃ³n

**Ãmbito:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// i no es accesible aquÃ­ (Ã¡mbito del bucle)
```

### Bucles For-In

Iterar sobre elementos de array:

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // Imprime cada elemento
}
```

**Con Ã­ndice y valor:**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`Index: ${i}, Value: ${arr[i]}`);
}
```

## Sentencias Switch

RamificaciÃ³n mÃºltiple basada en valor:

### Switch BÃ¡sico

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("one");
        break;
    case 2:
        print("two");
        break;
    case 3:
        print("three");
        break;
}
```

### Switch con Default

```hemlock
let color = "blue";

switch (color) {
    case "red":
        print("stop");
        break;
    case "yellow":
        print("slow");
        break;
    case "green":
        print("go");
        break;
    default:
        print("unknown color");
        break;
}
```

**Reglas:**
- `default` coincide cuando ningÃºn otro caso coincide
- `default` puede aparecer en cualquier lugar del cuerpo del switch
- Solo se permite un caso default

### Comportamiento de Fall-Through

Los casos sin `break` caen al siguiente caso (comportamiento estilo C). Esto es **intencional** y puede usarse para agrupar casos:

```hemlock
let grade = 85;

switch (grade) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C or below");
        break;
}
```

**Ejemplo de fallthrough explÃ­cito:**
```hemlock
let day = 3;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Weekday");
        break;
    case 6:
    case 7:
        print("Weekend");
        break;
}
```

**Importante:** A diferencia de algunos lenguajes modernos, Hemlock NO requiere una palabra clave `fallthrough` explÃ­cita. Los casos automÃ¡ticamente caen al siguiente a menos que terminen con `break`, `return` o `throw`. Siempre use `break` para prevenir fallthrough no intencionado.

### Switch con Return

En funciones, `return` sale del switch inmediatamente:

```hemlock
fn get_day_name(day: i32): string {
    switch (day) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        default:
            return "Unknown";
    }
}
```

### Tipos de Valor en Switch

Switch funciona con cualquier tipo de valor:

```hemlock
// Enteros
switch (count) {
    case 0: print("zero"); break;
    case 1: print("one"); break;
}

// Strings
switch (name) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// Booleanos
switch (flag) {
    case true: print("on"); break;
    case false: print("off"); break;
}
```

**Nota:** Los casos se comparan usando igualdad de valores.

## Break y Continue

### Break

Sale del bucle o switch mÃ¡s interno:

```hemlock
// En bucles
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // Sale del bucle
    }
    print(i);
    i = i + 1;
}

// En switch
switch (x) {
    case 1:
        print("one");
        break;  // Sale del switch
    case 2:
        print("two");
        break;
}
```

### Continue

Salta a la siguiente iteraciÃ³n del bucle:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // Omite la iteraciÃ³n cuando i es 5
    }
    print(i);  // Imprime 0,1,2,3,4,6,7,8,9
}
```

**Diferencia:**
- `break` - Sale del bucle completamente
- `continue` - Salta a la siguiente iteraciÃ³n

## Etiquetas de Bucle

Las etiquetas de bucle permiten que `break` y `continue` apunten a bucles externos especÃ­ficos en lugar de solo al bucle mÃ¡s interno. Esto es Ãºtil para bucles anidados donde necesita controlar un bucle externo desde uno interno.

### Break con Etiqueta

Salir de un bucle externo desde un bucle interno:

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // Sale del bucle while externo
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// Imprime: 0, 1, 2, 10 (se detiene en i=1, j=1)
```

### Continue con Etiqueta

Saltar a la siguiente iteraciÃ³n de un bucle externo:

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // Omite el resto del bucle interno, continÃºa el externo
        }
        print(i * 10 + j);
    }
}
// Cuando i=2, j=1: salta a la siguiente iteraciÃ³n externa
```

### Etiquetas con Bucles For

Las etiquetas funcionan con todos los tipos de bucle:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### Etiquetas con Bucles For-In

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### Etiquetas con Palabra Clave Loop

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### MÃºltiples Etiquetas

Puede tener etiquetas en diferentes niveles de anidamiento:

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // Salta a la siguiente iteraciÃ³n del bucle medio
            }
            if (a == 1 && b == 1) {
                break outer;      // Sale del bucle mÃ¡s externo
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### Break/Continue Sin Etiqueta con Bucles Etiquetados

`break` y `continue` sin etiqueta siguen funcionando normalmente (afectando al bucle mÃ¡s interno), incluso cuando los bucles externos tienen etiquetas:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // Solo sale del bucle interno
        }
        print(x * 10 + y);
    }
}
// Imprime: 0, 1, 10, 11, 20, 21
```

### Sintaxis de Etiquetas

- Las etiquetas son identificadores seguidos de dos puntos
- Las etiquetas deben preceder inmediatamente a una sentencia de bucle (`while`, `for`, `loop`)
- Los nombres de etiquetas siguen las reglas de identificadores (letras, dÃ­gitos, guiones bajos)
- Convenciones comunes: `outer`, `inner`, `row`, `col`, nombres descriptivos

## Sentencia Defer

La sentencia `defer` programa cÃ³digo para ejecutarse cuando la funciÃ³n actual retorna. Esto es Ãºtil para operaciones de limpieza como cerrar archivos, liberar recursos o liberar bloqueos.

### Defer BÃ¡sico

```hemlock
fn example() {
    print("start");
    defer print("cleanup");  // Se ejecuta cuando la funciÃ³n retorna
    print("end");
}

example();
// Salida:
// start
// end
// cleanup
```

**Comportamiento clave:**
- Las sentencias diferidas se ejecutan **despuÃ©s** de que el cuerpo de la funciÃ³n se complete
- Las sentencias diferidas se ejecutan **antes** de que la funciÃ³n retorne a su llamador
- Las sentencias diferidas siempre se ejecutan, incluso si la funciÃ³n lanza una excepciÃ³n

### MÃºltiples Defers (Orden LIFO)

Cuando se usan mÃºltiples sentencias `defer`, se ejecutan en **orden inverso** (Ãšltimo en Entrar, Primero en Salir):

```hemlock
fn example() {
    defer print("first");   // Se ejecuta Ãºltimo
    defer print("second");  // Se ejecuta segundo
    defer print("third");   // Se ejecuta primero
    print("body");
}

example();
// Salida:
// body
// third
// second
// first
```

Este orden LIFO es intencional - coincide con el orden natural para la limpieza de recursos anidados (cerrar recursos internos antes que los externos).

### Defer con Return

Las sentencias diferidas se ejecutan antes de que `return` transfiera el control:

```hemlock
fn get_value(): i32 {
    defer print("cleanup");
    print("before return");
    return 42;
}

let result = get_value();
print("result:", result);
// Salida:
// before return
// cleanup
// result: 42
```

### Defer con Excepciones

Las sentencias diferidas se ejecutan incluso cuando se lanza una excepciÃ³n:

```hemlock
fn risky() {
    defer print("cleanup 1");
    defer print("cleanup 2");
    print("before throw");
    throw "error!";
    print("after throw");  // Nunca se alcanza
}

try {
    risky();
} catch (e) {
    print("Caught:", e);
}
// Salida:
// before throw
// cleanup 2
// cleanup 1
// Caught: error!
```

### PatrÃ³n de Limpieza de Recursos

El caso de uso principal para `defer` es asegurar que los recursos se limpien:

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // Siempre cierra, incluso en error

    let content = file.read();
    // ... procesar contenido ...

    // El archivo se cierra automÃ¡ticamente cuando la funciÃ³n retorna
}
```

**Sin defer (propenso a errores):**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // Si esto lanza, file.close() nunca se llama!
    process(content);
    file.close();
}
```

### Defer con Closures

Defer puede usar closures para capturar estado:

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Releasing resource");
        release(resource);
    }();  // Nota: expresiÃ³n de funciÃ³n invocada inmediatamente

    use_resource(resource);
}
```

### CuÃ¡ndo Usar Defer

**Use defer para:**
- Cerrar archivos y conexiones de red
- Liberar memoria asignada
- Liberar bloqueos y mutexes
- Limpieza en cualquier funciÃ³n que adquiera recursos

**Defer vs Finally:**
- `defer` es mÃ¡s simple para limpieza de un solo recurso
- `try/finally` es mejor para manejo de errores complejo con recuperaciÃ³n

### Mejores PrÃ¡cticas

1. **Coloque defer inmediatamente despuÃ©s de adquirir un recurso:**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... usar archivo ...
   ```

2. **Use mÃºltiples defers para mÃºltiples recursos:**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // Ambos archivos se cerrarÃ¡n en orden inverso
   ```

3. **Recuerde el orden LIFO para recursos dependientes:**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // inner se libera antes que outer (orden de dependencia correcto)
   ```

## Operadores Booleanos

### AND LÃ³gico (`&&`)

Ambas condiciones deben ser verdaderas:

```hemlock
if (x > 0 && x < 10) {
    print("single digit positive");
}
```

**EvaluaciÃ³n de cortocircuito:**
```hemlock
if (false && expensive_check()) {
    // expensive_check() nunca se llama
}
```

### OR LÃ³gico (`||`)

Al menos una condiciÃ³n debe ser verdadera:

```hemlock
if (x < 0 || x > 100) {
    print("out of range");
}
```

**EvaluaciÃ³n de cortocircuito:**
```hemlock
if (true || expensive_check()) {
    // expensive_check() nunca se llama
}
```

### NOT LÃ³gico (`!`)

Niega el valor booleano:

```hemlock
if (!is_valid) {
    print("invalid");
}

if (!(x > 10)) {
    // Igual que: if (x <= 10)
}
```

## Operadores de ComparaciÃ³n

### Igualdad

```hemlock
if (x == 10) { }    // Igual
if (x != 10) { }    // No igual
```

Funciona con todos los tipos:
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### Relacionales

```hemlock
if (x < 10) { }     // Menor que
if (x > 10) { }     // Mayor que
if (x <= 10) { }    // Menor o igual
if (x >= 10) { }    // Mayor o igual
```

**Se aplica promociÃ³n de tipos:**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true (i32 promovido a i64)
```

## Operadores Bit a Bit

Hemlock proporciona operadores bit a bit para manipulaciÃ³n de enteros. Estos funcionan **solo con tipos enteros** (i8-i64, u8-u64).

### Operadores Bit a Bit Binarios

**AND Bit a Bit (`&`)**
```hemlock
let a = 12;  // 1100 en binario
let b = 10;  // 1010 en binario
print(a & b);   // 8 (1000)
```

**OR Bit a Bit (`|`)**
```hemlock
print(a | b);   // 14 (1110)
```

**XOR Bit a Bit (`^`)**
```hemlock
print(a ^ b);   // 6 (0110)
```

**Desplazamiento a la Izquierda (`<<`)**
```hemlock
print(a << 2);  // 48 (110000) - desplaza a la izquierda 2
```

**Desplazamiento a la Derecha (`>>`)**
```hemlock
print(a >> 1);  // 6 (110) - desplaza a la derecha 1
```

### Operador Bit a Bit Unario

**NOT Bit a Bit (`~`)**
```hemlock
let a = 12;
print(~a);      // -13 (complemento a dos)

let c: u8 = 15;   // 00001111 en binario
print(~c);        // 240 (11110000) en u8
```

### Ejemplos Bit a Bit

**Con tipos sin signo:**
```hemlock
let c: u8 = 15;   // 00001111 en binario
let d: u8 = 7;    // 00000111 en binario

print(c & d);     // 7  (00000111)
print(c | d);     // 15 (00001111)
print(c ^ d);     // 8  (00001000)
print(~c);        // 240 (11110000) - en u8
```

**PreservaciÃ³n de tipos:**
```hemlock
// Las operaciones bit a bit preservan el tipo de los operandos
let x: u8 = 255;
let result = ~x;  // result es u8 con valor 0

let y: i32 = 100;
let result2 = y << 2;  // result2 es i32 con valor 400
```

**Patrones comunes:**
```hemlock
// Verificar si un bit estÃ¡ establecido
if (flags & 0x04) {
    print("bit 2 is set");
}

// Establecer un bit
flags = flags | 0x08;

// Limpiar un bit
flags = flags & ~0x02;

// Alternar un bit
flags = flags ^ 0x01;
```

### Precedencia de Operadores

Los operadores bit a bit siguen la precedencia estilo C:

1. `~` (NOT unario) - mÃ¡s alta, mismo nivel que `!` y `-`
2. `<<`, `>>` (desplazamientos) - mayor que comparaciones, menor que `+`/`-`
3. `&` (AND bit a bit) - mayor que `^` y `|`
4. `^` (XOR bit a bit) - entre `&` y `|`
5. `|` (OR bit a bit) - menor que `&` y `^`, mayor que `&&`
6. `&&`, `||` (lÃ³gicos) - precedencia mÃ¡s baja

**Ejemplos:**
```hemlock
// & tiene mayor precedencia que |
let result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// Desplazamiento tiene mayor precedencia que operadores bit a bit
let result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// Use parÃ©ntesis para claridad
let result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**Notas importantes:**
- Los operadores bit a bit solo funcionan con tipos enteros (no flotantes, strings, etc.)
- La promociÃ³n de tipos sigue las reglas estÃ¡ndar (tipos mÃ¡s pequeÃ±os se promueven a mÃ¡s grandes)
- El desplazamiento a la derecha (`>>`) es aritmÃ©tico para tipos con signo, lÃ³gico para sin signo
- Las cantidades de desplazamiento no se verifican por rango (el comportamiento depende de la plataforma para desplazamientos grandes)

## Precedencia de Operadores (Completa)

De mayor a menor precedencia:

1. **Unarios**: `!`, `-`, `~`
2. **Multiplicativos**: `*`, `/`, `%`
3. **Aditivos**: `+`, `-`
4. **Desplazamiento**: `<<`, `>>`
5. **Relacionales**: `<`, `>`, `<=`, `>=`
6. **Igualdad**: `==`, `!=`
7. **AND Bit a Bit**: `&`
8. **XOR Bit a Bit**: `^`
9. **OR Bit a Bit**: `|`
10. **AND LÃ³gico**: `&&`
11. **OR LÃ³gico**: `||`

**Use parÃ©ntesis para claridad:**
```hemlock
// Poco claro
if (a || b && c) { }

// Claro
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## Patrones Comunes

### PatrÃ³n: ValidaciÃ³n de Entrada

```hemlock
fn validate_age(age: i32): bool {
    if (age < 0 || age > 150) {
        return false;
    }
    return true;
}
```

### PatrÃ³n: VerificaciÃ³n de Rango

```hemlock
fn in_range(value: i32, min: i32, max: i32): bool {
    return value >= min && value <= max;
}

if (in_range(score, 0, 100)) {
    print("valid score");
}
```

### PatrÃ³n: MÃ¡quina de Estados

```hemlock
let state = "start";

while (true) {
    switch (state) {
        case "start":
            print("Starting...");
            state = "running";
            break;

        case "running":
            if (should_pause) {
                state = "paused";
            } else if (should_stop) {
                state = "stopped";
            }
            break;

        case "paused":
            if (should_resume) {
                state = "running";
            }
            break;

        case "stopped":
            print("Stopped");
            break;
    }

    if (state == "stopped") {
        break;
    }
}
```

### PatrÃ³n: IteraciÃ³n con Filtrado

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Imprimir solo nÃºmeros pares
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // Omitir nÃºmeros impares
    }
    print(arr[i]);
}
```

### PatrÃ³n: Salida Temprana

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Salida temprana
        }
    }
    return -1;  // No encontrado
}
```

## Mejores PrÃ¡cticas

1. **Siempre use llaves** - Incluso para bloques de una sola sentencia (requerido por sintaxis)
2. **Condiciones explÃ­citas** - Use `x == 0` en lugar de `!x` para claridad
3. **Evite anidamiento profundo** - Extraiga condiciones anidadas a funciones
4. **Use retornos tempranos** - Reduzca el anidamiento con clÃ¡usulas de guarda
5. **Divida condiciones complejas** - SepÃ¡relas en variables booleanas nombradas
6. **Default en switch** - Siempre incluya un caso default
7. **Comente fall-through** - Haga explÃ­cito el fall-through intencional

## Errores Comunes

### Error: AsignaciÃ³n en CondiciÃ³n

```hemlock
// Esto NO estÃ¡ permitido (sin asignaciÃ³n en condiciones)
if (x = 10) { }  // ERROR: Error de sintaxis

// Use comparaciÃ³n en su lugar
if (x == 10) { }  // OK
```

### Error: Break Faltante en Switch

```hemlock
// Fall-through no intencional
switch (x) {
    case 1:
        print("one");
        // Falta break - cae al siguiente!
    case 2:
        print("two");  // Se ejecuta tanto para 1 como para 2
        break;
}

// CorrecciÃ³n: Agregar break
switch (x) {
    case 1:
        print("one");
        break;  // Ahora correcto
    case 2:
        print("two");
        break;
}
```

### Error: Ãmbito de Variable de Bucle

```hemlock
// i tiene Ã¡mbito del bucle
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // ERROR: i no estÃ¡ definida aquÃ­
```

## Ejemplos

### Ejemplo: FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### Ejemplo: Verificador de Primos

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### Ejemplo: Sistema de MenÃº

```hemlock
fn menu() {
    while (true) {
        print("1. Start");
        print("2. Settings");
        print("3. Exit");

        let choice = get_input();

        switch (choice) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("Goodbye!");
                return;
            default:
                print("Invalid choice");
                break;
        }
    }
}
```

## Temas Relacionados

- [Funciones](#language-guide-functions) - Flujo de control con llamadas a funciones y retornos
- [Manejo de Errores](#language-guide-error-handling) - Flujo de control con excepciones
- [Tipos](#language-guide-types) - Conversiones de tipos en condiciones

## Ver TambiÃ©n

- **Sintaxis**: Consulte [Sintaxis](#language-guide-syntax) para detalles de sintaxis de sentencias
- **Operadores**: Consulte [Tipos](#language-guide-types) para promociÃ³n de tipos en operaciones


--------------------------------------------------------------------------------
## Funciones
--------------------------------------------------------------------------------

# Funciones

Las funciones en Hemlock son **valores de primera clase** que pueden asignarse a variables, pasarse como argumentos y retornarse desde otras funciones. Esta guia cubre la sintaxis de funciones, clausuras, recursion y patrones avanzados.

## Resumen

```hemlock
// Sintaxis de funcion con nombre
fn add(a: i32, b: i32): i32 {
    return a + b;
}

// Funcion anonima
let multiply = fn(x, y) {
    return x * y;
};

// Clausuras
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
print(add5(3));  // 8
```

## Declaracion de Funciones

### Funciones con Nombre

```hemlock
fn greet(name: string): string {
    return "Hello, " + name;
}

let msg = greet("Alice");  // "Hello, Alice"
```

**Componentes:**
- `fn` - Palabra clave de funcion
- `greet` - Nombre de la funcion
- `(name: string)` - Parametros con tipos opcionales
- `: string` - Tipo de retorno opcional
- `{ ... }` - Cuerpo de la funcion

### Funciones Anonimas

Funciones sin nombre, asignadas a variables:

```hemlock
let square = fn(x) {
    return x * x;
};

print(square(5));  // 25
```

**Con nombre vs. Anonima:**
```hemlock
// Estas son equivalentes:
fn add(a, b) { return a + b; }

let add = fn(a, b) { return a + b; };
```

**Nota:** Las funciones con nombre se descomponen en asignaciones de variables con funciones anonimas.

## Parametros

### Parametros Basicos

```hemlock
fn example(a, b, c) {
    return a + b + c;
}

let result = example(1, 2, 3);  // 6
```

### Anotaciones de Tipo

Anotaciones de tipo opcionales en parametros:

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);      // OK
add(5, 10.5);    // La verificacion de tipo en tiempo de ejecucion promueve a f64
```

**Verificacion de tipos:**
- Los tipos de parametros se verifican en el momento de la llamada si estan anotados
- Las conversiones implicitas de tipo siguen reglas estandar de promocion
- Las incompatibilidades de tipo causan errores de tiempo de ejecucion

### Paso por Valor

Todos los argumentos se **copian** (paso por valor):

```hemlock
fn modify(x) {
    x = 100;  // Solo modifica la copia local
}

let a = 10;
modify(a);
print(a);  // Sigue siendo 10 (sin cambios)
```

**Nota:** Los objetos y arrays se pasan por referencia (la referencia se copia), por lo que su contenido puede modificarse:

```hemlock
fn modify_array(arr) {
    arr[0] = 99;  // Modifica el array original
}

let a = [1, 2, 3];
modify_array(a);
print(a[0]);  // 99 (modificado)
```

## Valores de Retorno

### Sentencia Return

```hemlock
fn get_max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

### Anotaciones de Tipo de Retorno

Anotacion de tipo opcional para el valor de retorno:

```hemlock
fn calculate(): f64 {
    return 3.14159;
}

fn get_name(): string {
    return "Alice";
}
```

**Verificacion de tipos:**
- Los tipos de retorno se verifican cuando la funcion retorna (si estan anotados)
- Las conversiones de tipo siguen reglas estandar de promocion

### Retorno Implicito

Las funciones sin anotacion de tipo de retorno retornan implicitamente `null`:

```hemlock
fn print_message(msg) {
    print(msg);
    // Retorna implicitamente null
}

let result = print_message("hello");  // result es null
```

### Retorno Temprano

```hemlock
fn find_first_negative(arr) {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Salida temprana
        }
    }
    return -1;  // No encontrado
}
```

### Retorno Sin Valor

`return;` sin valor retorna `null`:

```hemlock
fn maybe_process(value) {
    if (value < 0) {
        return;  // Retorna null
    }
    return value * 2;
}
```

## Funciones de Primera Clase

Las funciones pueden asignarse, pasarse y retornarse como cualquier otro valor.

### Funciones como Variables

```hemlock
let operation = fn(x, y) { return x + y; };

print(operation(5, 3));  // 8

// Reasignar
operation = fn(x, y) { return x * y; };
print(operation(5, 3));  // 15
```

### Funciones como Argumentos

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 5);  // 10
```

### Funciones como Valores de Retorno

```hemlock
fn get_operation(op: string) {
    if (op == "add") {
        return fn(a, b) { return a + b; };
    } else if (op == "multiply") {
        return fn(a, b) { return a * b; };
    } else {
        return fn(a, b) { return 0; };
    }
}

let add = get_operation("add");
print(add(5, 3));  // 8
```

## Clausuras

Las funciones capturan su entorno de definicion (alcance lexico).

### Clausuras Basicas

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

**Como funciona:**
- La funcion interna captura `count` del alcance externo
- `count` persiste entre llamadas a la funcion retornada
- Cada llamada a `makeCounter()` crea una nueva clausura con su propio `count`

### Clausura con Parametros

```hemlock
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

print(add5(3));   // 8
print(add10(3));  // 13
```

### Clausuras Multiples

```hemlock
fn makeOperations(x) {
    let add = fn(y) { return x + y; };
    let multiply = fn(y) { return x * y; };

    return { add: add, multiply: multiply };
}

let ops = makeOperations(5);
print(ops.add(3));       // 8
print(ops.multiply(3));  // 15
```

### Alcance Lexico

Las funciones pueden acceder a variables del alcance externo a traves del alcance lexico:

```hemlock
let global = 10;

fn outer() {
    let outer_var = 20;

    fn inner() {
        // Puede leer global y outer_var
        print(global);      // 10
        print(outer_var);   // 20
    }

    inner();
}

outer();
```

Las clausuras capturan variables por referencia, permitiendo tanto lectura como mutacion de variables del alcance externo (como se muestra en el ejemplo `makeCounter` anterior).

## Recursion

Las funciones pueden llamarse a si mismas.

### Recursion Basica

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Recursion Mutua

Las funciones pueden llamarse entre si:

```hemlock
fn is_even(n: i32): bool {
    if (n == 0) {
        return true;
    }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) {
        return false;
    }
    return is_even(n - 1);
}

print(is_even(4));  // true
print(is_odd(4));   // false
```

### Procesamiento Recursivo de Datos

```hemlock
fn sum_array(arr: array, index: i32): i32 {
    if (index >= arr.length) {
        return 0;
    }
    return arr[index] + sum_array(arr, index + 1);
}

let numbers = [1, 2, 3, 4, 5];
print(sum_array(numbers, 0));  // 15
```

**Nota:** Aun no hay optimizacion de llamada de cola - la recursion profunda puede causar desbordamiento de pila.

## Funciones de Orden Superior

Funciones que toman o retornan otras funciones.

### Patron Map

```hemlock
fn map(arr, f) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        result.push(f(arr[i]));
        i = i + 1;
    }
    return result;
}

fn double(x) { return x * 2; }

let numbers = [1, 2, 3, 4, 5];
let doubled = map(numbers, double);  // [2, 4, 6, 8, 10]
```

### Patron Filter

```hemlock
fn filter(arr, predicate) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (predicate(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

fn is_even(x) { return x % 2 == 0; }

let numbers = [1, 2, 3, 4, 5, 6];
let evens = filter(numbers, is_even);  // [2, 4, 6]
```

### Patron Reduce

```hemlock
fn reduce(arr, f, initial) {
    let accumulator = initial;
    let i = 0;
    while (i < arr.length) {
        accumulator = f(accumulator, arr[i]);
        i = i + 1;
    }
    return accumulator;
}

fn add(a, b) { return a + b; }

let numbers = [1, 2, 3, 4, 5];
let sum = reduce(numbers, add, 0);  // 15
```

### Composicion de Funciones

```hemlock
fn compose(f, g) {
    return fn(x) {
        return f(g(x));
    };
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }

let double_then_increment = compose(increment, double);
print(double_then_increment(5));  // 11 (5*2 + 1)
```

## Patrones Comunes

### Patron: Funciones Fabrica

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### Patron: Funciones Callback

```hemlock
fn process_async(data, callback) {
    // ... hacer procesamiento
    callback(data);
}

process_async("test", fn(result) {
    print("Processing complete: " + result);
});
```

### Patron: Aplicacion Parcial

```hemlock
fn partial(f, x) {
    return fn(y) {
        return f(x, y);
    };
}

fn multiply(a, b) {
    return a * b;
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

print(double(5));  // 10
print(triple(5));  // 15
```

### Patron: Memorizacion

```hemlock
fn memoize(f) {
    let cache = {};

    return fn(x) {
        if (cache.has(x)) {
            return cache[x];
        }

        let result = f(x);
        cache[x] = result;
        return result;
    };
}

fn expensive_fibonacci(n) {
    if (n <= 1) { return n; }
    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);
}

let fast_fib = memoize(expensive_fibonacci);
print(fast_fib(10));  // Mucho mas rapido con cache
```

## Semantica de Funciones

### Requisitos de Tipo de Retorno

Las funciones con anotacion de tipo de retorno **deben** retornar un valor:

```hemlock
fn get_value(): i32 {
    // ERROR: Falta sentencia return
}

fn get_value(): i32 {
    return 42;  // OK
}
```

### Verificacion de Tipos

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);        // OK
add(5.5, 10.5);    // Promueve a f64, retorna f64
add("a", "b");     // Error de tiempo de ejecucion: incompatibilidad de tipos
```

### Reglas de Alcance

```hemlock
let global = "global";

fn outer() {
    let outer_var = "outer";

    fn inner() {
        let inner_var = "inner";
        // Puede acceder: inner_var, outer_var, global
    }

    // Puede acceder: outer_var, global
    // No puede acceder: inner_var
}

// Puede acceder: global
// No puede acceder: outer_var, inner_var
```

## Mejores Practicas

1. **Usar anotaciones de tipo** - Ayuda a detectar errores y documenta la intencion
2. **Mantener funciones pequenas** - Cada funcion debe hacer una cosa
3. **Preferir funciones puras** - Evitar efectos secundarios cuando sea posible
4. **Nombrar funciones claramente** - Usar nombres verbales descriptivos
5. **Retornar temprano** - Usar clausulas de guarda para reducir anidamiento
6. **Documentar clausuras complejas** - Hacer explicitas las variables capturadas
7. **Evitar recursion profunda** - Aun no hay optimizacion de llamada de cola

## Errores Comunes

### Error: Profundidad de Recursion

```hemlock
// La recursion profunda puede causar desbordamiento de pila
fn count_down(n) {
    if (n == 0) { return; }
    count_down(n - 1);
}

count_down(100000);  // Puede fallar con desbordamiento de pila
```

### Error: Modificar Variables Capturadas

```hemlock
fn make_counter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Puede leer y modificar variables capturadas
        return count;
    };
}
```

**Nota:** Esto funciona, pero ten en cuenta que todas las clausuras comparten el mismo entorno capturado.

## Ejemplos

### Ejemplo: Pipeline de Funciones

```hemlock
fn pipeline(value, ...functions) {
    let result = value;
    for (f in functions) {
        result = f(result);
    }
    return result;
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }
fn square(x) { return x * x; }

let result = pipeline(3, double, increment, square);
print(result);  // 49 ((3*2+1)^2)
```

### Ejemplo: Manejador de Eventos

```hemlock
let handlers = [];

fn on_event(name: string, handler) {
    handlers.push({ name: name, handler: handler });
}

fn trigger_event(name: string, data) {
    let i = 0;
    while (i < handlers.length) {
        if (handlers[i].name == name) {
            handlers[i].handler(data);
        }
        i = i + 1;
    }
}

on_event("click", fn(data) {
    print("Clicked: " + data);
});

trigger_event("click", "button1");
```

### Ejemplo: Ordenamiento con Comparador Personalizado

```hemlock
fn sort(arr, compare) {
    // Ordenamiento burbuja con comparador personalizado
    let n = arr.length;
    let i = 0;
    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (compare(arr[j], arr[j + 1]) > 0) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn ascending(a, b) {
    if (a < b) { return -1; }
    if (a > b) { return 1; }
    return 0;
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers, ascending);
print(numbers);  // [1, 2, 5, 8, 9]
```

## Parametros Opcionales (Argumentos por Defecto)

Las funciones pueden tener parametros opcionales con valores por defecto usando la sintaxis `?:`:

```hemlock
fn greet(name, greeting?: "Hello") {
    return greeting + " " + name;
}

print(greet("Alice"));           // "Hello Alice"
print(greet("Bob", "Hi"));       // "Hi Bob"

fn add(a, b?: 10, c?: 100) {
    return a + b + c;
}

print(add(1));          // 111 (1 + 10 + 100)
print(add(1, 2));       // 103 (1 + 2 + 100)
print(add(1, 2, 3));    // 6   (1 + 2 + 3)
```

**Reglas:**
- Los parametros opcionales deben venir despues de los parametros requeridos
- Los valores por defecto pueden ser cualquier expresion
- Los argumentos omitidos usan el valor por defecto

## Funciones Variadicas (Parametros Rest)

Las funciones pueden aceptar un numero variable de argumentos usando parametros rest (`...`):

```hemlock
fn sum(...args) {
    let total = 0;
    for (arg in args) {
        total = total + arg;
    }
    return total;
}

print(sum(1, 2, 3));        // 6
print(sum(1, 2, 3, 4, 5));  // 15
print(sum());               // 0

fn log(prefix, ...messages) {
    for (msg in messages) {
        print(prefix + ": " + msg);
    }
}

log("INFO", "Starting", "Running", "Done");
// INFO: Starting
// INFO: Running
// INFO: Done
```

**Reglas:**
- El parametro rest debe ser el ultimo parametro
- El parametro rest recolecta todos los argumentos restantes en un array
- Puede combinarse con parametros regulares y opcionales

## Anotaciones de Tipo de Funcion

Los tipos de funcion te permiten especificar la firma exacta esperada para parametros de funcion y valores de retorno:

### Tipos de Funcion Basicos

```hemlock
// Sintaxis de tipo de funcion: fn(param_types): return_type
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

let double = fn(n) { return n * 2; };
let result = apply(double, 5);  // 10
```

### Tipos de Funciones de Orden Superior

```hemlock
// Funcion que retorna una funcion
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

let add5 = make_adder(5);
print(add5(10));  // 15
```

### Tipos de Funcion Async

```hemlock
// Tipo de funcion async
fn run_task(handler: async fn(): void) {
    spawn(handler);
}

run_task(async fn() {
    print("Running async!");
});
```

### Alias de Tipo de Funcion

```hemlock
// Crear tipos de funcion nombrados para claridad
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

fn filter_with(arr: array, pred: Predicate): array {
    return arr.filter(pred);
}
```

## Parametros Const

El modificador `const` previene que un parametro sea mutado dentro de la funcion:

### Parametros Const Basicos

```hemlock
fn print_all(const items: array) {
    // items.push(4);  // ERROR: no se puede mutar parametro const
    for (item in items) {
        print(item);   // OK: leer esta permitido
    }
}

let nums = [1, 2, 3];
print_all(nums);
```

### Inmutabilidad Profunda

Los parametros const imponen inmutabilidad profunda - ninguna mutacion a traves de ninguna ruta:

```hemlock
fn describe(const person: object) {
    print(person.name);       // OK: leer esta permitido
    // person.name = "Bob";   // ERROR: no se puede mutar
    // person.address.city = "NYC";  // ERROR: const profundo
}
```

### Lo Que Const Previene

| Tipo | Bloqueado por Const | Permitido |
|------|---------------------|-----------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |
| object | asignacion de campo | lectura de campo |
| buffer | asignacion de indice | lectura de indice |
| string | asignacion de indice | todos los metodos (retornan nuevas cadenas) |

## Argumentos con Nombre

Las funciones pueden llamarse con argumentos con nombre para claridad y flexibilidad:

### Argumentos con Nombre Basicos

```hemlock
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// Argumentos posicionales (tradicional)
create_user("Alice", 25, false);

// Argumentos con nombre - pueden estar en cualquier orden
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);
```

### Mezclar Posicionales y con Nombre

```hemlock
// Saltar parametros opcionales nombrando lo que necesitas
create_user("David", active: false);  // Usa age=18 por defecto

// Los argumentos con nombre deben venir despues de los posicionales
create_user("Eve", age: 21);          // OK
// create_user(name: "Bad", 25);      // ERROR: posicional despues de nombrado
```

### Reglas para Argumentos con Nombre

- Usar sintaxis `name: value` para argumentos con nombre
- Los argumentos con nombre pueden aparecer en cualquier orden despues de los argumentos posicionales
- Los argumentos posicionales no pueden seguir a los argumentos con nombre
- Funciona con parametros por defecto/opcionales
- Nombres de parametros desconocidos causan errores de tiempo de ejecucion

## Limitaciones

Limitaciones actuales a tener en cuenta:

- **Sin paso por referencia** - La palabra clave `ref` se analiza pero no esta implementada
- **Sin sobrecarga de funciones** - Una funcion por nombre
- **Sin optimizacion de llamada de cola** - La recursion profunda limitada por tamano de pila

## Temas Relacionados

- [Flujo de Control](#language-guide-control-flow) - Usando funciones con estructuras de control
- [Objetos](#language-guide-objects) - Los metodos son funciones almacenadas en objetos
- [Manejo de Errores](#language-guide-error-handling) - Funciones y manejo de excepciones
- [Tipos](#language-guide-types) - Anotaciones de tipo y conversiones

## Ver Tambien

- **Clausuras**: Ver la seccion "Funciones" en CLAUDE.md para semantica de clausuras
- **Valores de Primera Clase**: Las funciones son valores como cualquier otro
- **Alcance Lexico**: Las funciones capturan su entorno de definicion


--------------------------------------------------------------------------------
## GestiÃ³n de Memoria
--------------------------------------------------------------------------------

# GestiÃ³n de Memoria

Hemlock adopta la **gestiÃ³n manual de memoria** con control explÃ­cito sobre la asignaciÃ³n y liberaciÃ³n. Esta guÃ­a cubre el modelo de memoria de Hemlock, los dos tipos de punteros y la API completa de memoria.

---

## Memoria 101: Lo BÃ¡sico

**Nuevo en programaciÃ³n?** Comience aquÃ­. Si ya entiende la gestiÃ³n de memoria, salte a [FilosofÃ­a](#filosofÃ­a).

### QuÃ© es la GestiÃ³n de Memoria?

Cuando su programa necesita almacenar datos (texto, nÃºmeros, listas), necesita espacio para colocarlos. Ese espacio viene de la memoria de su computadora (RAM). La gestiÃ³n de memoria trata sobre:

1. **Obtener espacio** - solicitar memoria cuando la necesita
2. **Usar espacio** - leer y escribir sus datos
3. **Devolverla** - retornar la memoria cuando haya terminado

### Por QuÃ© Importa?

Imagine una biblioteca con libros limitados:
- Si sigue sacando libros y nunca los devuelve, eventualmente no quedan
- Si intenta leer un libro que ya devolviÃ³, se confundirÃ¡ o causarÃ¡ problemas

La memoria funciona de la misma manera. Si olvida devolver la memoria, su programa lentamente usa mÃ¡s y mÃ¡s (una "fuga de memoria"). Si intenta usar memoria despuÃ©s de devolverla, suceden cosas malas.

### Las Buenas Noticias

**La mayor parte del tiempo, no necesita pensar en esto!**

Hemlock limpia automÃ¡ticamente la mayorÃ­a de los tipos comunes:

```hemlock
fn example() {
    let name = "Alice";       // Hemlock maneja esto
    let numbers = [1, 2, 3];  // Y esto
    let person = { age: 30 }; // Y esto tambiÃ©n

    // Cuando la funciÃ³n termina, todo esto se limpia automÃ¡ticamente!
}
```

### CuÃ¡ndo SÃ Necesita Pensar en Ello

Solo necesita gestiÃ³n manual de memoria cuando usa:

1. **`alloc()`** - asignaciÃ³n de memoria cruda (retorna `ptr`)
2. **`buffer()`** - cuando quiere liberar temprano (opcional - se auto-libera al final del Ã¡mbito)

```hemlock
// Esto necesita limpieza manual:
let raw = alloc(100);   // Memoria cruda - USTED debe liberarla
// ... usar raw ...
free(raw);              // Requerido! O tiene una fuga de memoria

// Esto se limpia automÃ¡ticamente (pero PUEDE liberar temprano):
let buf = buffer(100);  // Buffer seguro
// ... usar buf ...
// free(buf);           // Opcional - se auto-liberarÃ¡ cuando el Ã¡mbito termine
```

### La Regla Simple

> **Si llama a `alloc()`, debe llamar a `free()`.**
>
> Todo lo demÃ¡s se maneja por usted.

### CuÃ¡l DeberÃ­a Usar?

| SituaciÃ³n | Use Esto | Por QuÃ© |
|-----------|----------|---------|
| **ReciÃ©n comenzando** | `buffer()` | Seguro, con verificaciÃ³n de lÃ­mites, auto-limpieza |
| **Necesita almacenamiento de bytes** | `buffer()` | Seguro y fÃ¡cil |
| **Trabajando con bibliotecas C (FFI)** | `alloc()` / `ptr` | Requerido para interoperabilidad con C |
| **MÃ¡ximo rendimiento** | `alloc()` / `ptr` | Sin overhead de verificaciÃ³n de lÃ­mites |
| **No estÃ¡ seguro** | `buffer()` | Siempre la opciÃ³n mÃ¡s segura |

### Ejemplo RÃ¡pido: Seguro vs Crudo

```hemlock
// RECOMENDADO: Buffer seguro
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // ERROR - Hemlock lo detiene (verificaciÃ³n de lÃ­mites)
    free(data);             // Limpiar
}

// AVANZADO: Puntero crudo (solo cuando lo necesita)
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // PELIGRO - Sin verificaciÃ³n de lÃ­mites, corrompe memoria!
    free(data);             // Limpiar
}
```

**Comience con `buffer()`. Solo use `alloc()` cuando especÃ­ficamente necesite punteros crudos.**

---

## FilosofÃ­a

Hemlock sigue el principio de gestiÃ³n explÃ­cita de memoria con valores por defecto sensatos:
- Sin recolecciÃ³n de basura (sin pausas impredecibles)
- Conteo de referencias interno para tipos comunes (string, array, object, buffer)
- Los punteros crudos (`ptr`) requieren `free()` manual

Este enfoque hÃ­brido le da control completo cuando lo necesita (punteros crudos) mientras previene errores comunes para casos de uso tÃ­picos (tipos con conteo de referencias auto-liberados al salir del Ã¡mbito).

## Conteo de Referencias Interno

El runtime usa **conteo de referencias interno** para gestionar tiempos de vida de objetos. Para la mayorÃ­a de las variables locales de tipos con conteo de referencias, la limpieza es automÃ¡tica y determinista.

### QuÃ© Maneja el Conteo de Referencias

El runtime automÃ¡ticamente gestiona conteos de referencias cuando:

1. **Las variables se reasignan** - el valor antiguo se libera:
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first" liberado internamente, "second" ref_count = 1
   ```

2. **Los Ã¡mbitos terminan** - las variables locales se liberan:
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // arr liberado cuando la funciÃ³n retorna
   ```

3. **Los contenedores se liberan** - los elementos se liberan:
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // obj1 y obj2 obtienen sus ref_counts decrementados
   ```

### CuÃ¡ndo Necesita `free()` vs CuÃ¡ndo Es AutomÃ¡tico

**AutomÃ¡tico (no necesita `free()`):** Las variables locales de tipos con conteo de referencias se liberan cuando el Ã¡mbito termina:

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... usarlos ...
}  // Todos liberados automÃ¡ticamente cuando la funciÃ³n retorna - no necesita free()
```

**Se requiere `free()` manual:**

1. **Punteros crudos** - `alloc()` no tiene conteo de referencias:
   ```hemlock
   let p = alloc(64);
   // ... usar p ...
   free(p);  // Siempre requerido - fugarÃ¡ de otro modo
   ```

2. **Limpieza temprana** - liberar antes de que el Ã¡mbito termine para liberar memoria mÃ¡s pronto:
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... terminado con big ...
       free(big);  // Liberar ahora, no esperar a que la funciÃ³n retorne
       // ... mÃ¡s trabajo que no necesita big ...
   }
   ```

3. **Datos de larga vida** - globales o datos almacenados en estructuras persistentes:
   ```hemlock
   let cache = {};  // Nivel de mÃ³dulo, vive hasta que el programa termine a menos que se libere

   fn cleanup() {
       free(cache);  // Limpieza manual para datos de larga vida
   }
   ```

### Conteo de Referencias vs RecolecciÃ³n de Basura

| Aspecto | Conteo de Referencias Hemlock | RecolecciÃ³n de Basura |
|---------|------------------------------|----------------------|
| Momento de limpieza | Determinista (inmediato cuando ref llega a 0) | No determinista (GC decide cuÃ¡ndo) |
| Responsabilidad del usuario | Debe llamar `free()` | Completamente automÃ¡tico |
| Pausas del runtime | Ninguna | Pausas "detener el mundo" |
| Visibilidad | Detalle de implementaciÃ³n oculto | Usualmente invisible |
| Ciclos | Manejados con seguimiento de conjunto visitado | Manejados por rastreo |

### QuÃ© Tipos Tienen Conteo de Referencias

| Tipo | Con Conteo | Notas |
|------|------------|-------|
| `ptr` | No | Siempre requiere `free()` manual |
| `buffer` | SÃ­ | Auto-liberado al salir del Ã¡mbito; `free()` manual para limpieza temprana |
| `array` | SÃ­ | Auto-liberado al salir del Ã¡mbito; `free()` manual para limpieza temprana |
| `object` | SÃ­ | Auto-liberado al salir del Ã¡mbito; `free()` manual para limpieza temprana |
| `string` | SÃ­ | Completamente automÃ¡tico, no necesita `free()` |
| `function` | SÃ­ | Completamente automÃ¡tico (entornos de closure) |
| `task` | SÃ­ | Conteo de referencias atÃ³mico thread-safe |
| `channel` | SÃ­ | Conteo de referencias atÃ³mico thread-safe |
| Primitivos | No | Asignados en stack, sin asignaciÃ³n de heap |

### Por QuÃ© Este DiseÃ±o?

Este enfoque hÃ­brido le da:
- **Control explÃ­cito** - Usted decide cuÃ¡ndo liberar
- **Seguridad contra bugs de Ã¡mbito** - La reasignaciÃ³n no fuga
- **Rendimiento predecible** - Sin pausas de GC
- **Soporte de closures** - Las funciones pueden capturar variables de forma segura

La filosofÃ­a permanece: usted tiene el control, pero el runtime ayuda a prevenir errores comunes como fugas en reasignaciÃ³n o double-free en contenedores.

## Los Dos Tipos de Punteros

Hemlock proporciona dos tipos de punteros distintos, cada uno con diferentes caracterÃ­sticas de seguridad:

### `ptr` - Puntero Crudo (Peligroso)

Los punteros crudos son **solo direcciones** con garantÃ­as de seguridad mÃ­nimas:

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Debe recordar liberar
```

**CaracterÃ­sticas:**
- Solo una direcciÃ³n de 8 bytes
- Sin verificaciÃ³n de lÃ­mites
- Sin seguimiento de longitud
- El usuario gestiona el tiempo de vida completamente
- Para expertos y FFI

**Casos de uso:**
- ProgramaciÃ³n de sistemas de bajo nivel
- Interfaz de Funciones ForÃ¡neas (FFI)
- CÃ³digo crÃ­tico para rendimiento
- Cuando necesita control completo

**Peligros:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Muy pasado el lÃ­mite de asignaciÃ³n - permitido pero peligroso
free(p);
let x = *p;       // Puntero colgante - comportamiento indefinido
free(p);          // Double-free - fallarÃ¡
```

### `buffer` - Envoltorio Seguro (Recomendado)

Los buffers proporcionan **acceso con verificaciÃ³n de lÃ­mites** mientras aÃºn requieren liberaciÃ³n manual:

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // verificado por lÃ­mites
print(b.length);        // 64
free(b);                // aÃºn manual
```

**CaracterÃ­sticas:**
- Puntero + longitud + capacidad
- VerificaciÃ³n de lÃ­mites en acceso
- AÃºn requiere `free()` manual
- Mejor opciÃ³n por defecto para la mayorÃ­a del cÃ³digo

**Propiedades:**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100 (tamaÃ±o actual)
print(buf.capacity);    // 100 (capacidad asignada)
```

**VerificaciÃ³n de lÃ­mites:**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // ERROR: Index out of bounds
```

## API de Memoria

### AsignaciÃ³n BÃ¡sica

**`alloc(bytes)` - Asignar memoria cruda**
```hemlock
let p = alloc(1024);  // Asignar 1KB, retorna ptr
// ... usar memoria
free(p);
```

**`buffer(size)` - Asignar buffer seguro**
```hemlock
let buf = buffer(256);  // Asignar buffer de 256 bytes
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - Liberar memoria**
```hemlock
let p = alloc(100);
free(p);  // Debe liberar para evitar fuga de memoria

let buf = buffer(100);
free(buf);  // Funciona tanto en ptr como en buffer
```

**Importante:** `free()` funciona tanto en tipos `ptr` como `buffer`.

### Operaciones de Memoria

**`memset(ptr, byte, size)` - Llenar memoria**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // Poner a cero 100 bytes
memset(p, 65, 10);     // Llenar los primeros 10 bytes con 'A'
free(p);
```

**`memcpy(dest, src, size)` - Copiar memoria**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // Copiar 50 bytes de src a dst
free(src);
free(dst);
```

**`realloc(ptr, size)` - Redimensionar asignaciÃ³n**
```hemlock
let p = alloc(100);
// ... usar 100 bytes
p = realloc(p, 200);   // Redimensionar a 200 bytes
// ... usar 200 bytes
free(p);
```

**Nota:** DespuÃ©s de `realloc()`, el puntero antiguo puede ser invÃ¡lido. Siempre use el puntero retornado.

### AsignaciÃ³n Tipada

Hemlock proporciona ayudantes de asignaciÃ³n tipada por conveniencia:

```hemlock
let arr = talloc(i32, 100);  // Asignar 100 valores i32 (400 bytes)
let size = sizeof(i32);      // Retorna 4 (bytes)
```

**`sizeof(type)`** retorna el tamaÃ±o en bytes de un tipo:
- `sizeof(i8)` / `sizeof(u8)` â†’ 1
- `sizeof(i16)` / `sizeof(u16)` â†’ 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` â†’ 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` â†’ 8
- `sizeof(ptr)` â†’ 8 (en sistemas de 64 bits)

**`talloc(type, count)`** asigna `count` elementos de `type`:

```hemlock
let ints = talloc(i32, 10);   // 40 bytes para 10 valores i32
let floats = talloc(f64, 5);  // 40 bytes para 5 valores f64
free(ints);
free(floats);
```

## Patrones Comunes

### PatrÃ³n: Asignar, Usar, Liberar

El patrÃ³n bÃ¡sico para gestiÃ³n de memoria:

```hemlock
// 1. Asignar
let data = alloc(1024);

// 2. Usar
memset(data, 0, 1024);
// ... hacer trabajo

// 3. Liberar
free(data);
```

### PatrÃ³n: Uso de Buffer Seguro

Prefiera buffers para acceso con verificaciÃ³n de lÃ­mites:

```hemlock
let buf = buffer(256);

// IteraciÃ³n segura
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### PatrÃ³n: GestiÃ³n de Recursos con try/finally

Asegure la limpieza incluso en errores:

```hemlock
let data = alloc(1024);
try {
    // ... operaciones riesgosas
    process(data);
} finally {
    free(data);  // Siempre liberado, incluso en error
}
```

## Consideraciones de Seguridad de Memoria

### Double-Free

**Permitido pero fallarÃ¡:**
```hemlock
let p = alloc(100);
free(p);
free(p);  // FALLA: Double-free detectado
```

**PrevenciÃ³n:**
```hemlock
let p = alloc(100);
free(p);
p = null;  // Establecer a null despuÃ©s de liberar

if (p != null) {
    free(p);  // No se ejecutarÃ¡
}
```

### Punteros Colgantes

**Permitido pero comportamiento indefinido:**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // INDEFINIDO: Leyendo memoria liberada
```

**PrevenciÃ³n:** No acceda a memoria despuÃ©s de liberar.

### Fugas de Memoria

**FÃ¡ciles de crear, difÃ­ciles de depurar:**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // OlvidÃ³ liberar!
    return;  // Memoria fugada
}
```

**PrevenciÃ³n:** Siempre empareje `alloc()` con `free()`:
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... usar p
    } finally {
        free(p);  // Siempre liberado
    }
}
```

### AritmÃ©tica de Punteros

**Permitida pero peligrosa:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Muy pasado el lÃ­mite de asignaciÃ³n
*q = 42;          // INDEFINIDO: Escritura fuera de lÃ­mites
free(p);
```

**Use buffers para verificaciÃ³n de lÃ­mites:**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // ERROR: La verificaciÃ³n de lÃ­mites previene el desbordamiento
```

## Mejores PrÃ¡cticas

1. **Por defecto use `buffer`** - Use `buffer` a menos que especÃ­ficamente necesite `ptr` crudo
2. **Empareje alloc/free** - Cada `alloc()` debe tener exactamente un `free()`
3. **Use try/finally** - Asegure limpieza con manejo de excepciones
4. **Null despuÃ©s de free** - Establezca punteros a `null` despuÃ©s de liberar para detectar uso despuÃ©s de liberaciÃ³n
5. **VerificaciÃ³n de lÃ­mites** - Use indexaciÃ³n de buffer para verificaciÃ³n automÃ¡tica de lÃ­mites
6. **Documente propiedad** - Deje claro quÃ© cÃ³digo posee y libera cada asignaciÃ³n

## Ejemplos

### Ejemplo: Constructor de Strings DinÃ¡mico

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // El llamador debe liberar
}

let msg = build_message(5);
// ... usar msg
free(msg);
```

### Ejemplo: Operaciones de Array Seguras

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // Llenar array
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // Procesar
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // Siempre limpiar
    }
}
```

### Ejemplo: PatrÃ³n de Pool de Memoria

```hemlock
// Pool de memoria simple (simplificado)
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool exhausted";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// Usar pool
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// Liberar todo el pool de una vez
free(pool);
```

## Limitaciones

Limitaciones actuales a tener en cuenta:

- **Los punteros crudos requieren free manual** - `alloc()` retorna `ptr` sin conteo de referencias
- **Sin asignadores personalizados** - Solo malloc/free del sistema

**Nota:** Los tipos con conteo de referencias (string, array, object, buffer) SÃ se liberan automÃ¡ticamente cuando el Ã¡mbito termina. Solo `ptr` crudo de `alloc()` requiere `free()` explÃ­cito.

## Temas Relacionados

- [Strings](#language-guide-strings) - GestiÃ³n de memoria de strings y codificaciÃ³n UTF-8
- [Arrays](#language-guide-arrays) - Arrays dinÃ¡micos y sus caracterÃ­sticas de memoria
- [Objetos](#language-guide-objects) - AsignaciÃ³n y tiempo de vida de objetos
- [Manejo de Errores](#language-guide-error-handling) - Usando try/finally para limpieza

## Ver TambiÃ©n

- **FilosofÃ­a de DiseÃ±o**: Consulte la secciÃ³n "Memory Management" de CLAUDE.md
- **Sistema de Tipos**: Consulte [Tipos](#language-guide-types) para detalles de tipos `ptr` y `buffer`
- **FFI**: Los punteros crudos son esenciales para la Interfaz de Funciones ForÃ¡neas


--------------------------------------------------------------------------------
## Manejo de Errores
--------------------------------------------------------------------------------

# Manejo de Errores

Hemlock soporta manejo de errores basado en excepciones con `try`, `catch`, `finally`, `throw` y `panic`. Esta guÃ­a cubre errores recuperables con excepciones y errores irrecuperables con panic.

## Resumen

```hemlock
// Manejo bÃ¡sico de errores
try {
    risky_operation();
} catch (e) {
    print("Error: " + e);
}

// Con limpieza
try {
    process_file();
} catch (e) {
    print("Failed: " + e);
} finally {
    cleanup();
}

// Lanzando errores
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

## Try-Catch-Finally

### Sintaxis

**Try/catch bÃ¡sico:**
```hemlock
try {
    // cÃ³digo riesgoso
} catch (e) {
    // manejar error, e contiene el valor lanzado
}
```

**Try/finally:**
```hemlock
try {
    // cÃ³digo riesgoso
} finally {
    // siempre se ejecuta, incluso si se lanza excepciÃ³n
}
```

**Try/catch/finally:**
```hemlock
try {
    // cÃ³digo riesgoso
} catch (e) {
    // manejar error
} finally {
    // cÃ³digo de limpieza
}
```

### Bloque Try

El bloque try ejecuta sentencias secuencialmente:

```hemlock
try {
    print("Starting...");
    risky_operation();
    print("Success!");  // Solo si no hay excepciÃ³n
}
```

**Comportamiento:**
- Ejecuta sentencias en orden
- Si se lanza excepciÃ³n: salta a `catch` o `finally`
- Si no hay excepciÃ³n: ejecuta `finally` (si estÃ¡ presente) y luego continÃºa

### Bloque Catch

El bloque catch recibe el valor lanzado:

```hemlock
try {
    throw "oops";
} catch (error) {
    print("Caught: " + error);  // error = "oops"
    // error solo accesible aquÃ­
}
// error no accesible aquÃ­
```

**ParÃ¡metro catch:**
- Recibe el valor lanzado (cualquier tipo)
- Con Ã¡mbito del bloque catch
- Puede tener cualquier nombre (convencionalmente `e`, `err` o `error`)

**QuÃ© puede hacer en catch:**
```hemlock
try {
    risky_operation();
} catch (e) {
    // Registrar el error
    print("Error: " + e);

    // Relanzar el mismo error
    throw e;

    // Lanzar error diferente
    throw "different error";

    // Retornar un valor por defecto
    return null;

    // Manejar y continuar
    // (sin relanzar)
}
```

### Bloque Finally

El bloque finally **siempre se ejecuta**:

```hemlock
try {
    print("1: try");
    throw "error";
} catch (e) {
    print("2: catch");
} finally {
    print("3: finally");  // Siempre se ejecuta
}
print("4: after");

// Salida: 1: try, 2: catch, 3: finally, 4: after
```

**CuÃ¡ndo se ejecuta finally:**
- DespuÃ©s del bloque try (si no hay excepciÃ³n)
- DespuÃ©s del bloque catch (si se capturÃ³ excepciÃ³n)
- Incluso si try/catch contiene `return`, `break` o `continue`
- Antes de que el flujo de control salga del try/catch

**Finally con return:**
```hemlock
fn example() {
    try {
        return 1;  // Retorna 1 despuÃ©s de que finally se ejecute
    } finally {
        print("cleanup");  // Se ejecuta antes de retornar
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // El return de finally sobrescribe - retorna 2
    }
}
```

**Finally con flujo de control:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) {
            break;  // Sale despuÃ©s de que finally se ejecute
        }
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

## Sentencia Throw

### Throw BÃ¡sico

Lanza cualquier valor como excepciÃ³n:

```hemlock
throw "error message";
throw 404;
throw { code: 500, message: "Internal error" };
throw null;
throw ["error", "details"];
```

**EjecuciÃ³n:**
1. EvalÃºa la expresiÃ³n
2. Inmediatamente salta al `catch` mÃ¡s cercano
3. Si no hay `catch`, propaga hacia arriba en la pila de llamadas

### Lanzando Errores

```hemlock
fn validate_age(age: i32) {
    if (age < 0) {
        throw "Age cannot be negative";
    }
    if (age > 150) {
        throw "Age is unrealistic";
    }
}

try {
    validate_age(-5);
} catch (e) {
    print("Validation error: " + e);
}
```

### Lanzando Objetos de Error

Cree informaciÃ³n de error estructurada:

```hemlock
fn read_file(path: string) {
    if (!file_exists(path)) {
        throw {
            type: "FileNotFound",
            path: path,
            message: "File does not exist"
        };
    }
    // ... leer archivo
}

try {
    read_file("missing.txt");
} catch (e) {
    if (e.type == "FileNotFound") {
        print("File not found: " + e.path);
    }
}
```

### Relanzamiento

Capturar y relanzar errores:

```hemlock
fn wrapper() {
    try {
        risky_operation();
    } catch (e) {
        print("Logging error: " + e);
        throw e;  // Relanzar al llamador
    }
}

try {
    wrapper();
} catch (e) {
    print("Caught in main: " + e);
}
```

## Excepciones No Capturadas

Si una excepciÃ³n propaga hasta el tope de la pila de llamadas sin ser capturada:

```hemlock
fn foo() {
    throw "uncaught!";
}

foo();  // Falla con: Runtime error: uncaught!
```

**Comportamiento:**
- El programa falla
- Imprime mensaje de error a stderr
- Sale con cÃ³digo de estado distinto de cero
- Traza de pila a ser agregada en versiones futuras

## Panic - Errores Irrecuperables

### QuÃ© es Panic?

`panic()` es para **errores irrecuperables** que deben terminar el programa inmediatamente:

```hemlock
panic();                    // Mensaje por defecto: "panic!"
panic("custom message");    // Mensaje personalizado
panic(42);                  // Valores no string se imprimen
```

**SemÃ¡ntica:**
- **Sale inmediatamente** del programa con cÃ³digo de salida 1
- Imprime mensaje de error a stderr: `panic: <mensaje>`
- **NO es capturable** con try/catch
- Usar para bugs y errores irrecuperables

### Panic vs Throw

```hemlock
// throw - Error recuperable (puede ser capturado)
try {
    throw "recoverable error";
} catch (e) {
    print("Caught: " + e);  // Capturado exitosamente
}

// panic - Error irrecuperable (no puede ser capturado)
try {
    panic("unrecoverable error");  // El programa sale inmediatamente
} catch (e) {
    print("This never runs");       // Nunca se ejecuta
}
```

### CuÃ¡ndo Usar Panic

**Use panic para:**
- **Bugs**: Se alcanzÃ³ cÃ³digo inalcanzable
- **Estado invÃ¡lido**: Se detectÃ³ corrupciÃ³n de estructura de datos
- **Errores irrecuperables**: Recurso crÃ­tico no disponible
- **Fallos de aserciÃ³n**: Cuando `assert()` no es suficiente

**Ejemplos:**
```hemlock
// CÃ³digo inalcanzable
fn process_state(state: i32) {
    if (state == 1) {
        return "ready";
    } else if (state == 2) {
        return "running";
    } else if (state == 3) {
        return "stopped";
    } else {
        panic("invalid state: " + typeof(state));  // Nunca deberÃ­a pasar
    }
}

// VerificaciÃ³n de recurso crÃ­tico
fn init_system() {
    let config = read_file("config.json");
    if (config == null) {
        panic("config.json not found - cannot start");
    }
    // ...
}

// Invariante de estructura de datos
fn pop_stack(stack) {
    if (stack.length == 0) {
        panic("pop() called on empty stack");
    }
    return stack.pop();
}
```

### CuÃ¡ndo NO Usar Panic

**Use throw en su lugar para:**
- ValidaciÃ³n de entrada de usuario
- Archivo no encontrado
- Errores de red
- Condiciones de error esperadas

```hemlock
// MAL: Panic para errores esperados
fn divide(a, b) {
    if (b == 0) {
        panic("division by zero");  // Demasiado severo
    }
    return a / b;
}

// BIEN: Throw para errores esperados
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";  // Recuperable
    }
    return a / b;
}
```

## Interacciones de Flujo de Control

### Return Dentro de Try/Catch/Finally

```hemlock
fn example() {
    try {
        return 1;  // Retorna 1 despuÃ©s de que finally se ejecute
    } finally {
        print("cleanup");
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // El return de finally sobrescribe el return de try - retorna 2
    }
}
```

**Regla:** Los valores de retorno del bloque finally sobrescriben los valores de retorno de try/catch.

### Break/Continue Dentro de Try/Catch/Finally

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) { break; }  // Sale despuÃ©s de que finally se ejecute
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

**Regla:** Break/continue se ejecutan despuÃ©s del bloque finally.

### Try/Catch Anidados

```hemlock
try {
    try {
        throw "inner";
    } catch (e) {
        print("Caught: " + e);  // Imprime: Caught: inner
        throw "outer";  // Relanza error diferente
    }
} catch (e) {
    print("Caught: " + e);  // Imprime: Caught: outer
}
```

**Regla:** Los bloques try/catch anidados funcionan como se espera, las capturas internas suceden primero.

## Patrones Comunes

### PatrÃ³n: Limpieza de Recursos

Siempre use `finally` para limpieza:

```hemlock
fn process_file(filename) {
    let file = null;
    try {
        file = open(filename);
        let content = file.read();
        process(content);
    } catch (e) {
        print("Error processing file: " + e);
    } finally {
        if (file != null) {
            file.close();  // Siempre cierra, incluso en error
        }
    }
}
```

### PatrÃ³n: Envolvimiento de Errores

Envuelva errores de nivel inferior con contexto:

```hemlock
fn load_config(path) {
    try {
        let content = read_file(path);
        return parse_json(content);
    } catch (e) {
        throw "Failed to load config from " + path + ": " + e;
    }
}
```

### PatrÃ³n: RecuperaciÃ³n de Errores

Proporcione alternativa en caso de error:

```hemlock
fn safe_divide(a, b) {
    try {
        if (b == 0) {
            throw "division by zero";
        }
        return a / b;
    } catch (e) {
        print("Error: " + e);
        return null;  // Valor alternativo
    }
}
```

### PatrÃ³n: ValidaciÃ³n

Use excepciones para validaciÃ³n:

```hemlock
fn validate_user(user) {
    if (user.name == null || user.name == "") {
        throw "Name is required";
    }
    if (user.age < 0 || user.age > 150) {
        throw "Invalid age";
    }
    if (user.email == null || !user.email.contains("@")) {
        throw "Invalid email";
    }
}

try {
    validate_user({ name: "Alice", age: -5, email: "invalid" });
} catch (e) {
    print("Validation failed: " + e);
}
```

### PatrÃ³n: MÃºltiples Tipos de Error

Use objetos de error para distinguir tipos de error:

```hemlock
fn process_data(data) {
    if (data == null) {
        throw { type: "NullData", message: "Data is null" };
    }

    if (typeof(data) != "array") {
        throw { type: "TypeError", message: "Expected array" };
    }

    if (data.length == 0) {
        throw { type: "EmptyData", message: "Array is empty" };
    }

    // ... procesar
}

try {
    process_data(null);
} catch (e) {
    if (e.type == "NullData") {
        print("No data provided");
    } else if (e.type == "TypeError") {
        print("Wrong data type: " + e.message);
    } else {
        print("Error: " + e.message);
    }
}
```

## Mejores PrÃ¡cticas

1. **Use excepciones para casos excepcionales** - No para flujo de control normal
2. **Lance errores significativos** - Use strings u objetos con contexto
3. **Siempre use finally para limpieza** - Asegura que los recursos se liberen
4. **No capture e ignore** - Al menos registre el error
5. **Relance cuando sea apropiado** - Deje que el llamador maneje si usted no puede
6. **Panic para bugs** - Use panic para errores irrecuperables
7. **Documente las excepciones** - Deje claro quÃ© funciones pueden lanzar

## Errores Comunes

### Error: Tragarse Errores

```hemlock
// MAL: Fallo silencioso
try {
    risky_operation();
} catch (e) {
    // Error ignorado - fallo silencioso
}

// BIEN: Registrar o manejar
try {
    risky_operation();
} catch (e) {
    print("Operation failed: " + e);
    // Manejar apropiadamente
}
```

### Error: Sobrescritura de Finally

```hemlock
// MAL: Finally sobrescribe return
fn get_value() {
    try {
        return 42;
    } finally {
        return 0;  // Retorna 0, no 42!
    }
}

// BIEN: No retornar en finally
fn get_value() {
    try {
        return 42;
    } finally {
        cleanup();  // Solo limpieza, sin return
    }
}
```

### Error: Olvidar Limpieza

```hemlock
// MAL: El archivo puede no cerrarse en error
fn process() {
    let file = open("data.txt");
    let content = file.read();  // Puede lanzar
    file.close();  // Nunca se alcanza si hay error
}

// BIEN: Usar finally
fn process() {
    let file = null;
    try {
        file = open("data.txt");
        let content = file.read();
    } finally {
        if (file != null) {
            file.close();
        }
    }
}
```

### Error: Usar Panic para Errores Esperados

```hemlock
// MAL: Panic para error esperado
fn read_config(path) {
    if (!file_exists(path)) {
        panic("Config file not found");  // Demasiado severo
    }
    return read_file(path);
}

// BIEN: Throw para error esperado
fn read_config(path) {
    if (!file_exists(path)) {
        throw "Config file not found: " + path;  // Recuperable
    }
    return read_file(path);
}
```

## Ejemplos

### Ejemplo: Manejo BÃ¡sico de Errores

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    print(divide(10, 0));
} catch (e) {
    print("Error: " + e);  // Imprime: Error: division by zero
}
```

### Ejemplo: GestiÃ³n de Recursos

```hemlock
fn copy_file(src, dst) {
    let src_file = null;
    let dst_file = null;

    try {
        src_file = open(src, "r");
        dst_file = open(dst, "w");

        let content = src_file.read();
        dst_file.write(content);

        print("File copied successfully");
    } catch (e) {
        print("Failed to copy file: " + e);
        throw e;  // Relanzar
    } finally {
        if (src_file != null) { src_file.close(); }
        if (dst_file != null) { dst_file.close(); }
    }
}
```

### Ejemplo: Manejo de Errores Anidado

```hemlock
fn process_users(users) {
    let success_count = 0;
    let error_count = 0;

    let i = 0;
    while (i < users.length) {
        try {
            validate_user(users[i]);
            save_user(users[i]);
            success_count = success_count + 1;
        } catch (e) {
            print("Failed to process user: " + e);
            error_count = error_count + 1;
        }
        i = i + 1;
    }

    print("Processed: " + typeof(success_count) + " success, " + typeof(error_count) + " errors");
}
```

### Ejemplo: Tipos de Error Personalizados

```hemlock
fn create_error(type, message, details) {
    return {
        type: type,
        message: message,
        details: details,
        toString: fn() {
            return self.type + ": " + self.message;
        }
    };
}

fn divide(a, b) {
    if (typeof(a) != "i32" && typeof(a) != "f64") {
        throw create_error("TypeError", "a must be a number", { value: a });
    }
    if (typeof(b) != "i32" && typeof(b) != "f64") {
        throw create_error("TypeError", "b must be a number", { value: b });
    }
    if (b == 0) {
        throw create_error("DivisionByZero", "Cannot divide by zero", { a: a, b: b });
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    print(e.toString());
    if (e.type == "DivisionByZero") {
        print("Details: a=" + typeof(e.details.a) + ", b=" + typeof(e.details.b));
    }
}
```

### Ejemplo: LÃ³gica de Reintento

```hemlock
fn retry(operation, max_attempts) {
    let attempt = 0;

    while (attempt < max_attempts) {
        try {
            return operation();  // Ã‰xito!
        } catch (e) {
            attempt = attempt + 1;
            if (attempt >= max_attempts) {
                throw "Operation failed after " + typeof(max_attempts) + " attempts: " + e;
            }
            print("Attempt " + typeof(attempt) + " failed, retrying...");
        }
    }
}

fn unreliable_operation() {
    // OperaciÃ³n no confiable simulada
    if (random() < 0.7) {
        throw "Operation failed";
    }
    return "Success";
}

try {
    let result = retry(unreliable_operation, 3);
    print(result);
} catch (e) {
    print("All retries failed: " + e);
}
```

## Orden de EjecuciÃ³n

Entendiendo el orden de ejecuciÃ³n:

```hemlock
try {
    print("1: try block start");
    throw "error";
    print("2: never reached");
} catch (e) {
    print("3: catch block");
} finally {
    print("4: finally block");
}
print("5: after try/catch/finally");

// Salida:
// 1: try block start
// 3: catch block
// 4: finally block
// 5: after try/catch/finally
```

## Limitaciones Actuales

- **Sin traza de pila** - Las excepciones no capturadas no muestran traza de pila (planificado)
- **Algunos builtins salen** - Algunas funciones integradas todavÃ­a usan `exit()` en lugar de lanzar (a revisar)
- **Sin tipos de excepciÃ³n personalizados** - Cualquier valor puede ser lanzado, pero no hay jerarquÃ­a formal de excepciones

## Temas Relacionados

- [Funciones](#language-guide-functions) - Excepciones y retornos de funciones
- [Flujo de Control](#language-guide-control-flow) - CÃ³mo las excepciones afectan el flujo de control
- [Memoria](#language-guide-memory) - Usando finally para limpieza de memoria

## Ver TambiÃ©n

- **SemÃ¡ntica de Excepciones**: Consulte la secciÃ³n "Error Handling" de CLAUDE.md
- **Panic vs Throw**: Diferentes casos de uso para diferentes tipos de error
- **GarantÃ­a de Finally**: Siempre se ejecuta, incluso con return/break/continue


--------------------------------------------------------------------------------
## MÃ³dulos
--------------------------------------------------------------------------------

# Sistema de MÃ³dulos de Hemlock

Este documento describe el sistema de mÃ³dulos de importaciÃ³n/exportaciÃ³n estilo ES6 implementado para Hemlock.

## Resumen

Hemlock soporta un sistema de mÃ³dulos basado en archivos con sintaxis de importaciÃ³n/exportaciÃ³n estilo ES6. Los mÃ³dulos son:
- **Singletons**: Cada mÃ³dulo se carga una vez y se almacena en cachÃ©
- **Basados en archivos**: Los mÃ³dulos corresponden a archivos .hml en disco
- **Importados explÃ­citamente**: Las dependencias se declaran con sentencias import
- **Ejecutados topolÃ³gicamente**: Las dependencias se ejecutan antes que los dependientes

Para gestiÃ³n de paquetes y dependencias de terceros, consulte [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).

## Sintaxis

### Sentencias Export

**Exportaciones con nombre en lÃ­nea:**
```hemlock
export fn add(a, b) {
    return a + b;
}

export const PI = 3.14159;
export let counter = 0;
```

**Lista de exportaciÃ³n:**
```hemlock
fn add(a, b) { return a + b; }
fn subtract(a, b) { return a - b; }

export { add, subtract };
```

**Export Extern (Funciones FFI):**
```hemlock
import "libc.so.6";

// Exportar funciones FFI para uso en otros mÃ³dulos
export extern fn strlen(s: string): i32;
export extern fn getpid(): i32;
```

Consulte la [DocumentaciÃ³n FFI](../advanced/ffi.md#exporting-ffi-functions) para mÃ¡s detalles sobre la exportaciÃ³n de funciones FFI.

**Export Define (Tipos Struct):**
```hemlock
// Exportar definiciones de tipos struct
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}
```

**Importante:** Los tipos struct exportados se registran globalmente cuando el mÃ³dulo se carga. Se vuelven disponibles automÃ¡ticamente cuando importa cualquier cosa del mÃ³dulo - NO necesita (y no puede) importarlos explÃ­citamente por nombre:

```hemlock
// BIEN - los tipos struct estÃ¡n auto-disponibles despuÃ©s de cualquier importaciÃ³n
import { some_function } from "./my_module.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };  // Funciona!

// MAL - no puede importar explÃ­citamente tipos struct
import { Vector2 } from "./my_module.hml";  // Error: Undefined variable 'Vector2'
```

Consulte la [DocumentaciÃ³n FFI](../advanced/ffi.md#exporting-struct-types) para mÃ¡s detalles sobre la exportaciÃ³n de tipos struct.

**Re-exportaciones:**
```hemlock
// Re-exportar desde otro mÃ³dulo
export { add, subtract } from "./math.hml";
```

### Sentencias Import

**Importaciones con nombre:**
```hemlock
import { add, subtract } from "./math.hml";
print(add(1, 2));  // 3
```

**ImportaciÃ³n de espacio de nombres:**
```hemlock
import * as math from "./math.hml";
print(math.add(1, 2));  // 3
print(math.PI);  // 3.14159
```

**Alias:**
```hemlock
import { add as sum, subtract as diff } from "./math.hml";
print(sum(1, 2));  // 3
```

## ResoluciÃ³n de MÃ³dulos

### Tipos de Ruta

**Rutas relativas:**
```hemlock
import { foo } from "./module.hml";       // Mismo directorio
import { bar } from "../parent.hml";      // Directorio padre
import { baz } from "./sub/nested.hml";   // Subdirectorio
```

**Rutas absolutas:**
```hemlock
import { foo } from "/absolute/path/to/module.hml";
```

**Manejo de extensiones:**
- La extensiÃ³n `.hml` puede omitirse - se agregarÃ¡ automÃ¡ticamente
- `./math` se resuelve a `./math.hml`

## CaracterÃ­sticas

### DetecciÃ³n de Dependencias Circulares

El sistema de mÃ³dulos detecta dependencias circulares y reporta un error:

```
Error: Circular dependency detected when loading '/path/to/a.hml'
```

### CachÃ© de MÃ³dulos

Los mÃ³dulos se cargan una vez y se almacenan en cachÃ©. MÃºltiples importaciones del mismo mÃ³dulo retornan la misma instancia:

```hemlock
// counter.hml
export let count = 0;
export fn increment() {
    count = count + 1;
}

// a.hml
import { count, increment } from "./counter.hml";
increment();
print(count);  // 1

// b.hml
import { count } from "./counter.hml";  // Misma instancia!
print(count);  // TodavÃ­a 1 (estado compartido)
```

### Inmutabilidad de Importaciones

Los bindings importados no pueden ser reasignados:

```hemlock
import { add } from "./math.hml";
add = fn() { };  // ERROR: cannot reassign imported binding
```

## Detalles de ImplementaciÃ³n

### Arquitectura

**Archivos:**
- `include/module.h` - API del sistema de mÃ³dulos
- `src/module.c` - Carga, cachÃ© y ejecuciÃ³n de mÃ³dulos
- Soporte del parser en `src/parser.c`
- Soporte del runtime en `src/interpreter/runtime.c`

**Componentes clave:**
1. **ModuleCache**: Mantiene mÃ³dulos cargados indexados por ruta absoluta
2. **Module**: Representa un mÃ³dulo cargado con su AST y exportaciones
3. **ResoluciÃ³n de Rutas**: Resuelve rutas relativas/absolutas a rutas canÃ³nicas
4. **EjecuciÃ³n TopolÃ³gica**: Ejecuta mÃ³dulos en orden de dependencias

### Proceso de Carga de MÃ³dulos

1. **Fase de AnÃ¡lisis**: Tokenizar y parsear el archivo del mÃ³dulo
2. **ResoluciÃ³n de Dependencias**: Cargar recursivamente mÃ³dulos importados
3. **DetecciÃ³n de Ciclos**: Verificar si el mÃ³dulo ya estÃ¡ siendo cargado
4. **CachÃ©**: Almacenar mÃ³dulo en cachÃ© por ruta absoluta
5. **Fase de EjecuciÃ³n**: Ejecutar en orden topolÃ³gico (dependencias primero)

### API

```c
// API de alto nivel
int execute_file_with_modules(const char *file_path,
                               int argc, char **argv,
                               ExecutionContext *ctx);

// API de bajo nivel
ModuleCache* module_cache_new(const char *initial_dir);
void module_cache_free(ModuleCache *cache);
Module* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);
void execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);
```

## Pruebas

Los mÃ³dulos de prueba estÃ¡n ubicados en `tests/modules/` y `tests/parity/modules/`:

- `math.hml` - MÃ³dulo bÃ¡sico con exportaciones
- `test_import_named.hml` - Prueba de importaciÃ³n con nombre
- `test_import_namespace.hml` - Prueba de importaciÃ³n de espacio de nombres
- `test_import_alias.hml` - Prueba de alias de importaciÃ³n
- `export_extern.hml` - Prueba de exportaciÃ³n de funciÃ³n FFI extern (Linux)

## Importaciones de Paquetes (hpm)

Con [hpm](https://github.com/hemlang/hpm) instalado, puede importar paquetes de terceros desde GitHub:

```hemlock
// Importar desde la raÃ­z del paquete (usa "main" de package.json)
import { app, router } from "hemlang/sprout";

// Importar desde subruta
import { middleware } from "hemlang/sprout/middleware";

// Biblioteca estÃ¡ndar (incorporada en Hemlock)
import { HashMap } from "@stdlib/collections";
```

Los paquetes se instalan en `hem_modules/` y se resuelven usando la sintaxis `owner/repo` de GitHub.

```bash
# Instalar un paquete
hpm install hemlang/sprout

# Instalar con restricciÃ³n de versiÃ³n
hpm install hemlang/sprout@^1.0.0
```

Consulte la [documentaciÃ³n de hpm](https://github.com/hemlang/hpm) para detalles completos.

## Limitaciones Actuales

1. **Sin Importaciones DinÃ¡micas**: `import()` como funciÃ³n en tiempo de ejecuciÃ³n no estÃ¡ soportado
2. **Sin Exportaciones Condicionales**: Las exportaciones deben estar en el nivel superior
3. **Rutas de Biblioteca EstÃ¡ticas**: Las importaciones de bibliotecas FFI usan rutas estÃ¡ticas (especÃ­ficas de plataforma)

## Trabajo Futuro

- Importaciones dinÃ¡micas con funciÃ³n `import()`
- Exportaciones condicionales
- Metadatos de mÃ³dulo (`import.meta`)
- Tree shaking y eliminaciÃ³n de cÃ³digo muerto

## Ejemplos

Consulte `tests/modules/` para ejemplos funcionales del sistema de mÃ³dulos.

Estructura de mÃ³dulos de ejemplo:
```
project/
â”œâ”€â”€ main.hml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ math.hml
â”‚   â”œâ”€â”€ string.hml
â”‚   â””â”€â”€ index.hml (mÃ³dulo barrel)
â””â”€â”€ utils/
    â””â”€â”€ helpers.hml
```

Uso de ejemplo:
```hemlock
// lib/math.hml
export fn add(a, b) { return a + b; }
export fn multiply(a, b) { return a * b; }

// lib/index.hml (barrel)
export { add, multiply } from "./math.hml";

// main.hml
import { add } from "./lib/index.hml";
print(add(2, 3));  // 5
```


--------------------------------------------------------------------------------
## Objetos
--------------------------------------------------------------------------------

# Objetos

Hemlock implementa objetos estilo JavaScript con asignacion en heap, campos dinamicos, metodos y duck typing. Los objetos son estructuras de datos flexibles que combinan datos y comportamiento.

## Resumen

```hemlock
// Objeto anonimo
let person = { name: "Alice", age: 30, city: "NYC" };
print(person.name);  // "Alice"

// Objeto con metodos
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Literales de Objeto

### Sintaxis Basica

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};
```

**Sintaxis:**
- Llaves `{}` encierran el objeto
- Pares clave-valor separados por comas
- Las claves son identificadores (no necesitan comillas)
- Los valores pueden ser de cualquier tipo

### Objetos Vacios

```hemlock
let obj = {};  // Objeto vacio

// Agregar campos despues
obj.name = "Alice";
obj.age = 30;
```

### Objetos Anidados

```hemlock
let user = {
    info: {
        name: "Bob",
        age: 25
    },
    active: true,
    settings: {
        theme: "dark",
        notifications: true
    }
};

print(user.info.name);           // "Bob"
print(user.settings.theme);      // "dark"
```

### Tipos de Valor Mezclados

```hemlock
let mixed = {
    number: 42,
    text: "hello",
    flag: true,
    data: null,
    items: [1, 2, 3],
    config: { x: 10, y: 20 }
};
```

### Sintaxis de Propiedad Abreviada

Cuando el nombre de variable coincide con el nombre de propiedad, usa sintaxis abreviada:

```hemlock
let name = "Alice";
let age = 30;
let active = true;

// Abreviado: { name } es equivalente a { name: name }
let person = { name, age, active };

print(person.name);   // "Alice"
print(person.age);    // 30
print(person.active); // true
```

**Mezclar abreviado con propiedades regulares:**
```hemlock
let city = "NYC";
let obj = { name, age, city, role: "admin" };
```

### Operador Spread

El operador spread (`...`) copia todos los campos de un objeto a otro:

```hemlock
let base = { x: 1, y: 2 };
let extended = { ...base, z: 3 };

print(extended.x);  // 1
print(extended.y);  // 2
print(extended.z);  // 3
```

**Sobrescribir valores con spread:**
```hemlock
let defaults = { theme: "light", size: "medium", debug: false };
let custom = { ...defaults, theme: "dark" };

print(custom.theme);  // "dark" (sobrescrito)
print(custom.size);   // "medium" (de defaults)
print(custom.debug);  // false (de defaults)
```

**Multiples spreads (los posteriores sobrescriben a los anteriores):**
```hemlock
let a = { x: 1 };
let b = { y: 2 };
let merged = { ...a, ...b, z: 3 };

print(merged.x);  // 1
print(merged.y);  // 2
print(merged.z);  // 3

// El spread posterior sobrescribe al anterior
let first = { val: "first" };
let second = { val: "second" };
let combined = { ...first, ...second };
print(combined.val);  // "second"
```

**Combinar abreviado y spread:**
```hemlock
let status = "active";
let data = { id: 1, name: "Item" };
let full = { ...data, status };

print(full.id);      // 1
print(full.name);    // "Item"
print(full.status);  // "active"
```

**Patron de sobrescritura de configuracion:**
```hemlock
let defaultConfig = {
    debug: false,
    timeout: 30,
    retries: 3
};

let prodConfig = { ...defaultConfig, timeout: 60 };
let devConfig = { ...defaultConfig, debug: true };

print(prodConfig.timeout);  // 60
print(devConfig.debug);     // true
```

**Nota:** Spread realiza una copia superficial. Los objetos anidados comparten referencias:
```hemlock
let nested = { inner: { val: 42 } };
let copied = { ...nested };
print(copied.inner.val);  // 42 (misma referencia que nested.inner)
```

## Acceso a Campos

### Notacion de Punto

```hemlock
let person = { name: "Alice", age: 30 };

// Leer campo
let name = person.name;      // "Alice"
let age = person.age;        // 30

// Modificar campo
person.age = 31;
print(person.age);           // 31
```

### Adicion Dinamica de Campos

Agregar nuevos campos en tiempo de ejecucion:

```hemlock
let person = { name: "Alice" };

// Agregar nuevo campo
person.email = "alice@example.com";
person.phone = "555-1234";

print(person.email);  // "alice@example.com"
```

### Eliminacion de Campos

**Nota:** La eliminacion de campos no esta soportada actualmente. Establece a `null` en su lugar:

```hemlock
let obj = { x: 10, y: 20 };

// No se pueden eliminar campos (no soportado)
// obj.x = undefined;  // No hay 'undefined' en Hemlock

// Alternativa: Establecer a null
obj.x = null;
```

## Metodos y `self`

### Definiendo Metodos

Los metodos son funciones almacenadas en campos de objeto:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
    decrement: fn() {
        self.count = self.count - 1;
    },
    get: fn() {
        return self.count;
    }
};
```

### La Palabra Clave `self`

Cuando una funcion se llama como metodo, `self` se vincula automaticamente al objeto:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;  // self se refiere a counter
    }
};

counter.increment();  // self se vincula a counter
print(counter.count);  // 1
```

**Como funciona:**
- Las llamadas a metodos se detectan verificando si la expresion de funcion es acceso a propiedad
- `self` se vincula automaticamente al objeto en el momento de la llamada
- `self` es de solo lectura (no se puede reasignar `self` en si)

### Deteccion de Llamada a Metodo

```hemlock
let obj = {
    value: 10,
    method: fn() {
        return self.value;
    }
};

// Llamado como metodo - self se vincula
print(obj.method());  // 10

// Llamado como funcion - self es null (error)
let f = obj.method;
print(f());  // ERROR: self no esta definido
```

### Metodos con Parametros

```hemlock
let calculator = {
    result: 0,
    add: fn(x) {
        self.result = self.result + x;
    },
    multiply: fn(x) {
        self.result = self.result * x;
    },
    get: fn() {
        return self.result;
    }
};

calculator.add(5);
calculator.multiply(2);
print(calculator.get());  // 10
```

## Definiciones de Tipo con `define`

### Definicion de Tipo Basica

Define formas de objeto con `define`:

```hemlock
define Person {
    name: string,
    age: i32,
    active: bool,
}

// Crear objeto y asignar a variable tipada
let p = { name: "Alice", age: 30, active: true };
let typed_p: Person = p;  // Duck typing valida la estructura

print(typeof(typed_p));  // "Person"
```

**Que hace `define`:**
- Declara un tipo con campos requeridos
- Habilita validacion por duck typing
- Establece el nombre de tipo del objeto para `typeof()`

### Duck Typing

Los objetos se validan contra `define` usando **compatibilidad estructural**:

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Tiene todos los campos requeridos
let p1: Person = { name: "Alice", age: 30 };

// OK: Campos extra estan permitidos
let p2: Person = {
    name: "Bob",
    age: 25,
    city: "NYC",
    active: true
};

// ERROR: Falta campo requerido 'age'
let p3: Person = { name: "Carol" };

// ERROR: Tipo incorrecto para 'age'
let p4: Person = { name: "Dave", age: "thirty" };
```

**Reglas de duck typing:**
- Todos los campos requeridos deben estar presentes
- Los tipos de campo deben coincidir
- Los campos extra estan permitidos y se preservan
- La validacion ocurre en el momento de la asignacion

### Campos Opcionales

Los campos pueden ser opcionales con valores por defecto:

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,       // Opcional con valor por defecto
    nickname?: string,   // Opcional, por defecto null
}

// Objeto con solo campos requeridos
let p = { name: "Alice", age: 30 };
let typed_p: Person = p;

print(typed_p.active);    // true (por defecto aplicado)
print(typed_p.nickname);  // null (sin por defecto)

// Puede sobrescribir campos opcionales
let p2: Person = { name: "Bob", age: 25, active: false };
print(p2.active);  // false (sobrescrito)
```

**Sintaxis de campo opcional:**
- `field?: default_value` - Opcional con valor por defecto
- `field?: type` - Opcional con anotacion de tipo, por defecto null
- Los campos opcionales se agregan durante duck typing si faltan

### Verificacion de Tipos

```hemlock
define Point {
    x: i32,
    y: i32,
}

let p = { x: 10, y: 20 };
let point: Point = p;  // Verificacion de tipo ocurre aqui

print(typeof(point));  // "Point"
print(typeof(p));      // "object" (el original sigue siendo anonimo)
```

**Cuando ocurre la verificacion de tipo:**
- En el momento de asignacion a variable tipada
- Valida que todos los campos requeridos esten presentes
- Valida que los tipos de campo coincidan (con conversiones implicitas)
- Establece el nombre de tipo del objeto

## Firmas de Metodo en Define

Los bloques define pueden especificar firmas de metodo, creando contratos tipo interfaz:

### Metodos Requeridos

```hemlock
define Comparable {
    value: i32,
    fn compare(other: Self): i32;  // Firma de metodo requerida
}

// Los objetos deben proporcionar el metodo requerido
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};
```

### Metodos Opcionales

```hemlock
define Serializable {
    fn serialize(): string;       // Requerido
    fn pretty?(): string;         // Metodo opcional (puede estar ausente)
}
```

### El Tipo `Self`

`Self` se refiere al tipo que se esta definiendo, habilitando definiciones de tipo recursivas:

```hemlock
define Cloneable {
    fn clone(): Self;  // Retorna el mismo tipo que el objeto
}

define Comparable {
    fn compare(other: Self): i32;  // Toma el mismo tipo como parametro
    fn equals(other: Self): bool;
}

let item: Cloneable = {
    value: 42,
    clone: fn() {
        return { value: self.value, clone: self.clone };
    }
};
```

### Campos y Metodos Mezclados

```hemlock
define Entity {
    id: i32,
    name: string,
    fn validate(): bool;
    fn serialize(): string;
}

let user: Entity = {
    id: 1,
    name: "Alice",
    validate: fn() { return self.id > 0 && self.name != ""; },
    serialize: fn() { return '{"id":' + self.id + ',"name":"' + self.name + '"}'; }
};
```

## Tipos Compuestos (Tipos de Interseccion)

Los tipos compuestos usan `&` para requerir que un objeto satisfaga multiples definiciones de tipo:

### Tipos Compuestos Basicos

```hemlock
define HasName { name: string }
define HasAge { age: i32 }

// Tipo compuesto: el objeto debe satisfacer TODOS los tipos
let person: HasName & HasAge = { name: "Alice", age: 30 };
```

### Parametros de Funcion con Tipos Compuestos

```hemlock
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

greet({ name: "Bob", age: 25, city: "NYC" });  // Campos extra OK
```

### Tres o Mas Tipos

```hemlock
define HasEmail { email: string }

fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

### Alias de Tipo para Tipos Compuestos

```hemlock
// Crear un alias nombrado para un tipo compuesto
type Person = HasName & HasAge;
type Employee = HasName & HasAge & HasEmail;

let emp: Employee = {
    name: "Charlie",
    age: 35,
    email: "charlie@example.com"
};
```

**Duck typing con compuestos:** Los campos extra siempre estan permitidos - el objeto solo necesita tener al menos los campos requeridos por todos los tipos componentes.

## Serializacion JSON

### Serializar a JSON

Convertir objetos a cadenas JSON:

```hemlock
// obj.serialize() - Convertir objeto a cadena JSON
let obj = { x: 10, y: 20, name: "test" };
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// Objetos anidados
let nested = { inner: { a: 1, b: 2 }, outer: 3 };
print(nested.serialize());  // {"inner":{"a":1,"b":2},"outer":3}
```

### Deserializar desde JSON

Analizar cadenas JSON de vuelta a objetos:

```hemlock
// json.deserialize() - Analizar cadena JSON a objeto
let json_str = '{"x":10,"y":20,"name":"test"}';
let obj = json_str.deserialize();

print(obj.name);   // "test"
print(obj.x);      // 10
```

### Deteccion de Ciclos

Las referencias circulares se detectan y causan errores:

```hemlock
let obj = { x: 10 };
obj.me = obj;  // Crear referencia circular

obj.serialize();  // ERROR: serialize() detecto referencia circular
```

### Tipos Soportados

La serializacion JSON soporta:

- **Numeros**: i8-i32, u8-u32, f32, f64
- **Booleanos**: true, false
- **Cadenas**: Con secuencias de escape
- **Null**: valor null
- **Objetos**: Objetos anidados
- **Arrays**: Arrays anidados

**No soportado:**
- Funciones (omitidas silenciosamente)
- Punteros (error)
- Buffers (error)

### Manejo de Errores

La serializacion y deserializacion pueden lanzar errores:

```hemlock
// JSON invalido lanza un error
try {
    let bad = "not valid json".deserialize();
} catch (e) {
    print("Parse error:", e);
}

// Los punteros no se pueden serializar
let obj = { ptr: alloc(10) };
try {
    obj.serialize();
} catch (e) {
    print("Serialize error:", e);
}
```

### Ejemplo de Ida y Vuelta

Ejemplo completo de serializar y deserializar:

```hemlock
define Config {
    host: string,
    port: i32,
    debug: bool
}

// Crear y serializar
let config: Config = {
    host: "localhost",
    port: 8080,
    debug: true
};
let json = config.serialize();
print(json);  // {"host":"localhost","port":8080,"debug":true}

// Deserializar de vuelta
let restored = json.deserialize();
print(restored.host);  // "localhost"
print(restored.port);  // 8080
```

## Funciones Integradas

### `typeof(value)`

Retorna el nombre del tipo como cadena:

```hemlock
let obj = { x: 10 };
print(typeof(obj));  // "object"

define Person { name: string, age: i32 }
let p: Person = { name: "Alice", age: 30 };
print(typeof(p));    // "Person"
```

**Valores de retorno:**
- Objetos anonimos: `"object"`
- Objetos tipados: Nombre de tipo personalizado (ej., `"Person"`)

## Detalles de Implementacion

### Modelo de Memoria

- **Asignado en heap** - Todos los objetos se asignan en el heap
- **Copia superficial** - La asignacion copia la referencia, no el objeto
- **Campos dinamicos** - Almacenados como arrays dinamicos de pares nombre/valor
- **Conteo de referencias** - Los objetos se liberan automaticamente cuando el alcance termina

### Semantica de Referencia

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Copia superficial (misma referencia)

obj2.x = 20;
print(obj1.x);  // 20 (ambos refieren al mismo objeto)
```

### Almacenamiento de Metodos

Los metodos son simplemente funciones almacenadas en campos:

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// method es una funcion almacenada en obj.method
print(typeof(obj.method));  // "function"
```

## Patrones Comunes

### Patron: Funcion Constructora

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### Patron: Constructor de Objetos

```hemlock
fn PersonBuilder() {
    return {
        name: null,
        age: null,

        setName: fn(n) {
            self.name = n;
            return self;  // Habilitar encadenamiento
        },

        setAge: fn(a) {
            self.age = a;
            return self;
        },

        build: fn() {
            return { name: self.name, age: self.age };
        }
    };
}

let person = PersonBuilder()
    .setName("Alice")
    .setAge(30)
    .build();
```

### Patron: Objeto de Estado

```hemlock
let state = {
    status: "idle",
    data: null,
    error: null,

    setState: fn(new_status) {
        self.status = new_status;
    },

    setData: fn(new_data) {
        self.data = new_data;
        self.status = "success";
    },

    setError: fn(err) {
        self.error = err;
        self.status = "error";
    }
};
```

### Patron: Objeto de Configuracion

```hemlock
let config = {
    defaults: {
        timeout: 30,
        retries: 3,
        debug: false
    },

    get: fn(key) {
        if (self.defaults[key] != null) {
            return self.defaults[key];
        }
        return null;
    },

    set: fn(key, value) {
        self.defaults[key] = value;
    }
};
```

## Mejores Practicas

1. **Usar `define` para estructura** - Documentar formas esperadas de objetos
2. **Preferir funciones fabrica** - Crear objetos con constructores
3. **Mantener objetos simples** - No anidar demasiado profundamente
4. **Documentar uso de `self`** - Hacer claro el comportamiento de metodos
5. **Validar en asignacion** - Usar duck typing para detectar errores temprano
6. **Evitar referencias circulares** - Causaran errores de serializacion
7. **Usar campos opcionales** - Proporcionar valores por defecto sensatos

## Errores Comunes

### Error: Referencia vs. Valor

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Copia superficial

obj2.x = 20;
print(obj1.x);  // 20 (sorpresa! ambos cambiaron)

// Para evitar: Crear nuevo objeto
let obj3 = { x: obj1.x };  // Copia profunda (manual)
```

### Error: `self` en Llamadas No-Metodo

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// Funciona: Llamado como metodo
print(obj.method());  // 10

// ERROR: Llamado como funcion
let f = obj.method;
print(f());  // ERROR: self no esta definido
```

### Error: Punteros Crudos en Objetos

```hemlock
// Los objetos se liberan automaticamente, pero los punteros crudos dentro NO
fn create_objects() {
    let obj = { data: alloc(1000) };  // ptr crudo necesita free manual
    // obj se libera automaticamente cuando el alcance termina, pero obj.data tiene fuga!
}

// Solucion: Liberar punteros crudos antes de que termine el alcance
fn safe_create() {
    let obj = { data: alloc(1000) };
    // ... usar obj.data ...
    free(obj.data);  // Liberar el puntero crudo explicitamente
}  // obj en si se libera automaticamente
```

### Error: Confusion de Tipos

```hemlock
let obj = { x: 10 };

define Point { x: i32, y: i32 }

// ERROR: Falta campo requerido 'y'
let p: Point = obj;
```

## Ejemplos

### Ejemplo: Matematica Vectorial

```hemlock
fn createVector(x, y) {
    return {
        x: x,
        y: y,

        add: fn(other) {
            return createVector(
                self.x + other.x,
                self.y + other.y
            );
        },

        length: fn() {
            return sqrt(self.x * self.x + self.y * self.y);
        },

        toString: fn() {
            return "(" + typeof(self.x) + ", " + typeof(self.y) + ")";
        }
    };
}

let v1 = createVector(3, 4);
let v2 = createVector(1, 2);
let v3 = v1.add(v2);

print(v3.toString());  // "(4, 6)"
```

### Ejemplo: Base de Datos Simple

```hemlock
fn createDatabase() {
    let records = [];
    let next_id = 1;

    return {
        insert: fn(data) {
            let record = { id: next_id, data: data };
            records.push(record);
            next_id = next_id + 1;
            return record.id;
        },

        find: fn(id) {
            let i = 0;
            while (i < records.length) {
                if (records[i].id == id) {
                    return records[i];
                }
                i = i + 1;
            }
            return null;
        },

        count: fn() {
            return records.length;
        }
    };
}

let db = createDatabase();
let id = db.insert({ name: "Alice", age: 30 });
let record = db.find(id);
print(record.data.name);  // "Alice"
```

### Ejemplo: Emisor de Eventos

```hemlock
fn createEventEmitter() {
    let listeners = {};

    return {
        on: fn(event, handler) {
            if (listeners[event] == null) {
                listeners[event] = [];
            }
            listeners[event].push(handler);
        },

        emit: fn(event, data) {
            if (listeners[event] != null) {
                let i = 0;
                while (i < listeners[event].length) {
                    listeners[event][i](data);
                    i = i + 1;
                }
            }
        }
    };
}

let emitter = createEventEmitter();

emitter.on("message", fn(data) {
    print("Received: " + data);
});

emitter.emit("message", "Hello!");
```

## Limitaciones

Limitaciones actuales:

- **Sin copia profunda** - Debe copiar manualmente objetos anidados (spread es superficial)
- **Sin paso por valor** - Los objetos siempre se pasan por referencia
- **Sin propiedades computadas** - Sin sintaxis `{[key]: value}`
- **`self` es de solo lectura** - No se puede reasignar `self` en metodos
- **Sin eliminacion de propiedades** - No se pueden remover campos una vez agregados

**Nota:** Los objetos tienen conteo de referencias y se liberan automaticamente cuando el alcance termina. Ver [Gestion de Memoria](memory.md#conteo-de-referencias-interno) para detalles.

## Temas Relacionados

- [Functions](#language-guide-functions) - Los metodos son funciones almacenadas en objetos
- [Arrays](#language-guide-arrays) - Los arrays tambien son tipo objeto
- [Types](#language-guide-types) - Duck typing y definiciones de tipo
- [Error Handling](#language-guide-error-handling) - Lanzar objetos de error

## Ver Tambien

- **Duck Typing**: Ver seccion "Objects" en CLAUDE.md para detalles de duck typing
- **JSON**: Ver CLAUDE.md para detalles de serializacion JSON
- **Memoria**: Ver [Memory](#language-guide-memory) para asignacion de objetos


--------------------------------------------------------------------------------
## Runas
--------------------------------------------------------------------------------

# Runes

Los runes representan **puntos de cÃ³digo Unicode** (U+0000 a U+10FFFF) como un tipo distinto para manipulaciÃ³n de caracteres en Hemlock. A diferencia de los bytes (u8), los runes son caracteres Unicode completos que pueden representar cualquier caracter en cualquier idioma o emoji.

## Resumen

```hemlock
let ch = 'A';           // Literal rune
let emoji = 'ðŸš€';       // Caracter multi-byte como rune Ãºnico
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // ConcatenaciÃ³n string + rune
let r = '>' + " msg";   // ConcatenaciÃ³n rune + string
```

## QuÃ© es un Rune?

Un rune es un **valor de 32 bits** que representa un punto de cÃ³digo Unicode:

- **Rango:** 0 a 0x10FFFF (1,114,111 puntos de cÃ³digo vÃ¡lidos)
- **No es un tipo numÃ©rico** - Usado para representaciÃ³n de caracteres
- **Distinto de u8/char** - Los runes son Unicode completo, u8 es solo bytes
- **Retornado por indexaciÃ³n de strings** - `str[0]` retorna un rune, no un byte

**Por quÃ© runes?**
- Los strings de Hemlock estÃ¡n codificados en UTF-8
- Un solo caracter Unicode puede ser 1-4 bytes en UTF-8
- Los runes permiten trabajar con caracteres completos, no bytes parciales

## Literales Rune

### Sintaxis BÃ¡sica

Las comillas simples denotan literales rune:

```hemlock
let a = 'A';            // Caracter ASCII
let b = '0';            // Caracter dÃ­gito
let c = '!';            // PuntuaciÃ³n
let d = ' ';            // Espacio
```

### Caracteres UTF-8 Multi-byte

Los runes pueden representar cualquier caracter Unicode:

```hemlock
// Emoji
let rocket = 'ðŸš€';      // Emoji (U+1F680)
let heart = 'â¤';        // CorazÃ³n (U+2764)
let smile = 'ðŸ˜€';       // Cara sonriente (U+1F600)

// Caracteres CJK
let chinese = 'ä¸­';     // Chino (U+4E2D)
let japanese = 'ã‚';    // Hiragana (U+3042)
let korean = 'í•œ';      // Hangul (U+D55C)

// SÃ­mbolos
let check = 'âœ“';        // Marca de verificaciÃ³n (U+2713)
let arrow = 'â†’';        // Flecha derecha (U+2192)
```

### Secuencias de Escape

Secuencias de escape comunes para caracteres especiales:

```hemlock
let newline = '\n';     // Nueva lÃ­nea (U+000A)
let tab = '\t';         // TabulaciÃ³n (U+0009)
let backslash = '\\';   // Barra invertida (U+005C)
let quote = '\'';       // Comilla simple (U+0027)
let dquote = '"';       // Comilla doble (U+0022)
let null_char = '\0';   // Caracter nulo (U+0000)
let cr = '\r';          // Retorno de carro (U+000D)
```

**Secuencias de escape disponibles:**
- `\n` - Nueva lÃ­nea (line feed)
- `\t` - TabulaciÃ³n horizontal
- `\r` - Retorno de carro
- `\0` - Caracter nulo
- `\\` - Barra invertida
- `\'` - Comilla simple
- `\"` - Comilla doble

### Escapes Unicode

Use la sintaxis `\u{XXXXXX}` para puntos de cÃ³digo Unicode (hasta 6 dÃ­gitos hexadecimales):

```hemlock
let rocket = '\u{1F680}';   // ðŸš€ Emoji vÃ­a escape Unicode
let heart = '\u{2764}';     // â¤ CorazÃ³n
let ascii = '\u{41}';       // 'A' vÃ­a escape
let max = '\u{10FFFF}';     // Punto de cÃ³digo Unicode mÃ¡ximo

// Ceros iniciales opcionales
let a = '\u{41}';           // Igual que '\u{0041}'
let b = '\u{0041}';
```

**Reglas:**
- Rango: `\u{0}` a `\u{10FFFF}`
- DÃ­gitos hexadecimales: 1 a 6 dÃ­gitos
- Insensible a mayÃºsculas: `\u{1F680}` o `\u{1f680}`
- Valores fuera del rango Unicode vÃ¡lido causan error

## ConcatenaciÃ³n String + Rune

Los runes pueden concatenarse con strings:

```hemlock
// String + rune
let greeting = "Hello" + '!';       // "Hello!"
let decorated = "Text" + 'âœ“';       // "Textâœ“"

// Rune + string
let prefix = '>' + " Message";      // "> Message"
let bullet = 'â€¢' + " Item";         // "â€¢ Item"

// MÃºltiples concatenaciones
let msg = "Hi " + 'ðŸ‘‹' + " World " + 'ðŸŒ';  // "Hi ðŸ‘‹ World ðŸŒ"

// El encadenamiento de mÃ©todos funciona
let result = ('>' + " Important").to_upper();  // "> IMPORTANT"
```

**CÃ³mo funciona:**
- Los runes se codifican automÃ¡ticamente a UTF-8
- Se convierten a strings durante la concatenaciÃ³n
- El operador de concatenaciÃ³n de strings maneja esto transparentemente

## Conversiones de Tipo

Los runes pueden convertirse hacia/desde otros tipos.

### Entero â†” Rune

Convertir entre enteros y runes para trabajar con valores de puntos de cÃ³digo:

```hemlock
// Entero a rune (valor de punto de cÃ³digo)
let code: rune = 65;            // 'A' (ASCII 65)
let emoji_code: rune = 128640;  // U+1F680 (ðŸš€)

// Rune a entero (obtener valor de punto de cÃ³digo)
let r = 'Z';
let value: i32 = r;             // 90 (valor ASCII)

let rocket = 'ðŸš€';
let code: i32 = rocket;         // 128640 (U+1F680)
```

**VerificaciÃ³n de rango:**
- Entero a rune: Debe estar en [0, 0x10FFFF]
- Valores fuera de rango causan error en tiempo de ejecuciÃ³n
- Rune a entero: Siempre tiene Ã©xito (retorna punto de cÃ³digo)

### Rune â†’ String

Los runes pueden convertirse explÃ­citamente a strings:

```hemlock
// ConversiÃ³n explÃ­cita
let ch: string = 'H';           // "H"
let emoji: string = 'ðŸš€';       // "ðŸš€"

// AutomÃ¡tico durante concatenaciÃ³n
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8 (Byte) â†’ Rune

Cualquier valor u8 (0-255) puede convertirse a rune:

```hemlock
// Rango ASCII (0-127)
let byte: u8 = 65;
let rune_val: rune = byte;      // 'A'

// ASCII extendido / Latin-1 (128-255)
let extended: u8 = 200;
let r: rune = extended;         // U+00C8 (Ãˆ)

// Nota: Valores 0-127 son ASCII, 128-255 son Latin-1
```

### Conversiones Encadenadas

Las conversiones de tipo pueden encadenarse:

```hemlock
// i32 â†’ rune â†’ string
let code: i32 = 128512;         // Punto de cÃ³digo de cara sonriente
let r: rune = code;             // ðŸ˜€
let s: string = r;              // "ðŸ˜€"

// Todo en una expresiÃ³n
let emoji: string = 128640;     // ImplÃ­cito i32 â†’ rune â†’ string (ðŸš€)
```

## Operaciones con Runes

### ImpresiÃ³n

CÃ³mo se muestran los runes depende del punto de cÃ³digo:

```hemlock
let ascii = 'A';
print(ascii);                   // 'A' (entre comillas, ASCII imprimible)

let emoji = 'ðŸš€';
print(emoji);                   // U+1F680 (notaciÃ³n Unicode para no-ASCII)

let tab = '\t';
print(tab);                     // U+0009 (no imprimible como hex)

let space = ' ';
print(space);                   // ' ' (imprimible)
```

**Formato de impresiÃ³n:**
- ASCII imprimible (32-126): Caracter entre comillas `'A'`
- No imprimible o Unicode: NotaciÃ³n hexadecimal `U+XXXX`

### VerificaciÃ³n de Tipo

Use `typeof()` para verificar si un valor es un rune:

```hemlock
let r = 'ðŸš€';
print(typeof(r));               // "rune"

let s = "text";
let ch = s[0];
print(typeof(ch));              // "rune" (la indexaciÃ³n retorna runes)

let num = 65;
print(typeof(num));             // "i32"
```

### ComparaciÃ³n

Los runes pueden compararse por igualdad:

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// Sensible a mayÃºsculas
let upper = 'A';
let lower = 'a';
print(upper == lower);          // false

// Los runes pueden compararse con enteros (valores de punto de cÃ³digo)
print(a == 65);                 // true (conversiÃ³n implÃ­cita)
print('ðŸš€' == 128640);          // true
```

**Operadores de comparaciÃ³n:**
- `==` - Igual
- `!=` - No igual
- `<`, `>`, `<=`, `>=` - Orden de punto de cÃ³digo

```hemlock
print('A' < 'B');               // true (65 < 66)
print('a' > 'Z');               // true (97 > 90)
```

## Trabajando con IndexaciÃ³n de Strings

La indexaciÃ³n de strings retorna runes, no bytes:

```hemlock
let s = "HelloðŸš€";
let h = s[0];                   // 'H' (rune)
let rocket = s[5];              // 'ðŸš€' (rune)

print(typeof(h));               // "rune"
print(typeof(rocket));          // "rune"

// Convertir a string si es necesario
let h_str: string = h;          // "H"
let rocket_str: string = rocket; // "ðŸš€"
```

**Importante:** La indexaciÃ³n de strings usa posiciones de punto de cÃ³digo, no offsets de bytes:

```hemlock
let text = "HiðŸš€!";
// Posiciones de punto de cÃ³digo: 0='H', 1='i', 2='ðŸš€', 3='!'
// Posiciones de byte:            0='H', 1='i', 2-5='ðŸš€', 6='!'

let r = text[2];                // 'ðŸš€' (punto de cÃ³digo 2)
print(typeof(r));               // "rune"
```

## Ejemplos

### Ejemplo: ClasificaciÃ³n de Caracteres

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### Ejemplo: ConversiÃ³n de MayÃºsculas/MinÃºsculas

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // Convertir a mayÃºscula (restar 32)
        let code: i32 = r;
        code = code - 32;
        return code;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // Convertir a minÃºscula (sumar 32)
        let code: i32 = r;
        code = code + 32;
        return code;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### Ejemplo: IteraciÃ³n de Caracteres

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Position " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("HiðŸš€");
// Position 0: 'H'
// Position 1: 'i'
// Position 2: U+1F680
```

### Ejemplo: Construyendo Strings desde Runes

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let result = "";
    let i = 0;
    while (i < count) {
        result = result + ch;
        i = i + 1;
    }
    return result;
}

let line = repeat_char('=', 40);  // "========================================"
let stars = repeat_char('â­', 5);  // "â­â­â­â­â­"
```

## Patrones Comunes

### PatrÃ³n: Filtro de Caracteres

```hemlock
fn filter_digits(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

let text = "abc123def456";
let digits = filter_digits(text);  // "123456"
```

### PatrÃ³n: Conteo de Caracteres

```hemlock
fn count_char(s: string, target: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == target) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = "hello world";
let l_count = count_char(text, 'l');  // 3
let o_count = count_char(text, 'o');  // 2
```

## Mejores PrÃ¡cticas

1. **Use runes para operaciones de caracteres** - No intente trabajar con bytes para texto
2. **La indexaciÃ³n de strings retorna runes** - Recuerde que `str[i]` le da un rune
3. **Comparaciones conscientes de Unicode** - Los runes manejan cualquier caracter Unicode
4. **Convierta cuando sea necesario** - Los runes se convierten fÃ¡cilmente a strings y enteros
5. **Pruebe con emoji** - Siempre pruebe operaciones de caracteres con caracteres multi-byte

## Errores Comunes

### Error: ConfusiÃ³n entre Rune y Byte

```hemlock
// NO: Tratar runes como bytes
let r: rune = 'ðŸš€';
let b: u8 = r;              // ERROR: El punto de cÃ³digo 128640 no cabe en u8

// SÃ: Usar conversiones apropiadas
let r: rune = 'ðŸš€';
let code: i32 = r;          // OK: 128640
```

### Error: IndexaciÃ³n de Bytes de String

```hemlock
// NO: Asumir indexaciÃ³n de bytes
let s = "ðŸš€";
let byte = s.byte_at(0);    // 240 (primer byte UTF-8, no caracter completo)

// SÃ: Usar indexaciÃ³n de punto de cÃ³digo
let s = "ðŸš€";
let rune = s[0];            // 'ðŸš€' (caracter completo)
let rune2 = s.char_at(0);   // 'ðŸš€' (mÃ©todo explÃ­cito)
```

## Temas Relacionados

- [Strings](#language-guide-strings) - Operaciones de strings y manejo UTF-8
- [Tipos](#language-guide-types) - Sistema de tipos y conversiones
- [Flujo de Control](#language-guide-control-flow) - Usando runes en comparaciones

## Ver TambiÃ©n

- **EstÃ¡ndar Unicode**: Los puntos de cÃ³digo Unicode son definidos por el Consorcio Unicode
- **CodificaciÃ³n UTF-8**: Consulte [Strings](#language-guide-strings) para detalles de UTF-8
- **Conversiones de Tipo**: Consulte [Tipos](#language-guide-types) para reglas de conversiÃ³n


--------------------------------------------------------------------------------
## Sintaxis
--------------------------------------------------------------------------------

# Resumen de Sintaxis

Este documento cubre las reglas fundamentales de sintaxis y la estructura de los programas Hemlock.

## Reglas Fundamentales de Sintaxis

### Los Punto y Coma Son Obligatorios

A diferencia de JavaScript o Python, los punto y coma son **siempre requeridos** al final de las sentencias:

```hemlock
let x = 42;
let y = 10;
print(x + y);
```

**Esto causara un error:**
```hemlock
let x = 42  // ERROR: Falta punto y coma
let y = 10  // ERROR: Falta punto y coma
```

### Las Llaves Son Siempre Requeridas

Todos los bloques de flujo de control deben usar llaves, incluso para sentencias individuales:

```hemlock
// CORRECTO
if (x > 0) {
    print("positivo");
}

// ERROR: Faltan llaves
if (x > 0)
    print("positivo");
```

### Comentarios

```hemlock
// Este es un comentario de una linea

/*
   Este es un
   comentario de multiples lineas
*/

let x = 42;  // Comentario en linea
```

## Variables

### Declaracion

Las variables se declaran con `let`:

```hemlock
let count = 0;
let name = "Alice";
let pi = 3.14159;
```

### Anotaciones de Tipo (Opcionales)

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let flag: bool = true;
let text: string = "hello";
```

### Constantes

Usa `const` para valores inmutables:

```hemlock
const MAX_SIZE: i32 = 1000;
const PI: f64 = 3.14159;
```

Intentar reasignar una constante resultara en un error de tiempo de ejecucion: "Cannot assign to const variable".

## Expresiones

### Operadores Aritmeticos

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13 - Suma
print(a - b);   // 7  - Resta
print(a * b);   // 30 - Multiplicacion
print(a / b);   // 3  - Division (entera)
```

### Operadores de Comparacion

```hemlock
print(a == b);  // false - Igual
print(a != b);  // true  - No igual
print(a > b);   // true  - Mayor que
print(a < b);   // false - Menor que
print(a >= b);  // true  - Mayor o igual
print(a <= b);  // false - Menor o igual
```

### Operadores Logicos

```hemlock
let x = true;
let y = false;

print(x && y);  // false - AND
print(x || y);  // true  - OR
print(!x);      // false - NOT
```

### Operadores de Bits

```hemlock
let a = 12;  // 1100
let b = 10;  // 1010

print(a & b);   // 8  - AND de bits
print(a | b);   // 14 - OR de bits
print(a ^ b);   // 6  - XOR de bits
print(a << 2);  // 48 - Desplazamiento a la izquierda
print(a >> 1);  // 6  - Desplazamiento a la derecha
print(~a);      // -13 - NOT de bits
```

### Precedencia de Operadores

De mayor a menor:

1. `()` - Agrupacion
2. `!`, `~`, `-` (unario) - Operadores unarios
3. `*`, `/` - Multiplicacion, Division
4. `+`, `-` - Suma, Resta
5. `<<`, `>>` - Desplazamientos de bits
6. `<`, `<=`, `>`, `>=` - Comparaciones
7. `==`, `!=` - Igualdad
8. `&` - AND de bits
9. `^` - XOR de bits
10. `|` - OR de bits
11. `&&` - AND logico
12. `||` - OR logico

**Ejemplos:**
```hemlock
let x = 2 + 3 * 4;      // 14 (no 20)
let y = (2 + 3) * 4;    // 20
let z = 5 << 2 + 1;     // 40 (5 << 3)
```

## Flujo de Control

### Sentencias If

```hemlock
if (condition) {
    // cuerpo
}

if (condition) {
    // rama then
} else {
    // rama else
}

if (condition1) {
    // rama 1
} else if (condition2) {
    // rama 2
} else {
    // rama por defecto
}
```

### Bucles While

```hemlock
while (condition) {
    // cuerpo
}
```

**Ejemplo:**
```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

### Bucles For

**For estilo C:**
```hemlock
for (initializer; condition; increment) {
    // cuerpo
}
```

**Ejemplo:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**For-in (arrays):**
```hemlock
for (let item in array) {
    // cuerpo
}
```

**Ejemplo:**
```hemlock
let items = [10, 20, 30];
for (let x in items) {
    print(x);
}
```

### Sentencias Switch

```hemlock
switch (expression) {
    case value1:
        // cuerpo
        break;
    case value2:
        // cuerpo
        break;
    default:
        // cuerpo por defecto
        break;
}
```

**Ejemplo:**
```hemlock
let day = 3;
switch (day) {
    case 1:
        print("Monday");
        break;
    case 2:
        print("Tuesday");
        break;
    case 3:
        print("Wednesday");
        break;
    default:
        print("Other");
        break;
}
```

### Break y Continue

```hemlock
// Break: salir del bucle
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        break;
    }
    print(i);
}

// Continue: saltar a la siguiente iteracion
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;
    }
    print(i);
}
```

## Funciones

### Funciones con Nombre

```hemlock
fn function_name(param1: type1, param2: type2): return_type {
    // cuerpo
    return value;
}
```

**Ejemplo:**
```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Funciones Anonimas

```hemlock
let func = fn(params) {
    // cuerpo
};
```

**Ejemplo:**
```hemlock
let multiply = fn(x, y) {
    return x * y;
};
```

### Anotaciones de Tipo (Opcionales)

```hemlock
// Sin anotaciones (tipos inferidos)
fn greet(name) {
    return "Hello, " + name;
}

// Con anotaciones (verificados en tiempo de ejecucion)
fn divide(a: i32, b: i32): f64 {
    return a / b;
}
```

## Objetos

### Literales de Objeto

```hemlock
let obj = {
    field1: value1,
    field2: value2,
};
```

**Ejemplo:**
```hemlock
let person = {
    name: "Alice",
    age: 30,
    active: true,
};
```

### Metodos

```hemlock
let obj = {
    method: fn() {
        self.field = value;
    },
};
```

**Ejemplo:**
```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
};
```

### Definiciones de Tipo

```hemlock
define TypeName {
    field1: type1,
    field2: type2,
    optional_field?: default_value,
}
```

**Ejemplo:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,
}
```

## Arrays

### Literales de Array

```hemlock
let arr = [element1, element2, element3];
```

**Ejemplo:**
```hemlock
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];
let empty = [];
```

### Indexacion de Arrays

```hemlock
let arr = [10, 20, 30];
print(arr[0]);   // 10
arr[1] = 99;     // Modificar elemento
```

## Manejo de Errores

### Try/Catch

```hemlock
try {
    // codigo riesgoso
} catch (e) {
    // manejar error
}
```

### Try/Finally

```hemlock
try {
    // codigo riesgoso
} finally {
    // siempre se ejecuta
}
```

### Try/Catch/Finally

```hemlock
try {
    // codigo riesgoso
} catch (e) {
    // manejar error
} finally {
    // limpieza
}
```

### Throw

```hemlock
throw expression;
```

**Ejemplo:**
```hemlock
if (x < 0) {
    throw "x must be positive";
}
```

### Panic

```hemlock
panic(message);
```

**Ejemplo:**
```hemlock
panic("unrecoverable error");
```

## Modulos (Experimental)

### Sentencias Export

```hemlock
export fn function_name() { }
export const CONSTANT = value;
export let variable = value;
export { name1, name2 };
```

### Sentencias Import

```hemlock
import { name1, name2 } from "./module.hml";
import * as namespace from "./module.hml";
import { name as alias } from "./module.hml";
```

## Async (Experimental)

### Funciones Async

```hemlock
async fn function_name(params): return_type {
    // cuerpo
}
```

### Spawn/Join

```hemlock
let task = spawn(async_function, arg1, arg2);
let result = join(task);
```

### Canales

```hemlock
let ch = channel(capacity);
ch.send(value);
let value = ch.recv();
ch.close();
```

## FFI (Interfaz de Funcion Foranea)

### Importar Biblioteca Compartida

```hemlock
import "library_name.so";
```

### Declarar Funcion Externa

```hemlock
extern fn function_name(param: type): return_type;
```

**Ejemplo:**
```hemlock
import "libc.so.6";
extern fn strlen(s: string): i32;
```

## Literales

### Literales Enteros

```hemlock
let decimal = 42;
let negative = -100;
let large = 5000000000;  // Auto i64

// Hexadecimal (prefijo 0x)
let hex = 0xDEADBEEF;
let hex2 = 0xFF;

// Binario (prefijo 0b)
let bin = 0b1010;
let bin2 = 0b11110000;

// Octal (prefijo 0o)
let oct = 0o777;
let oct2 = 0O123;

// Separadores numericos para legibilidad
let million = 1_000_000;
let hex_sep = 0xFF_FF_FF;
let bin_sep = 0b1111_0000_1010_0101;
let oct_sep = 0o77_77;
```

### Literales de Punto Flotante

```hemlock
let f = 3.14;
let e = 2.71828;
let sci = 1.5e-10;       // Notacion cientifica
let sci2 = 2.5E+3;       // E mayuscula tambien funciona
let no_lead = .5;        // Sin cero inicial (0.5)
let sep = 3.14_159_265;  // Separadores numericos
```

### Literales de Cadena

```hemlock
let s = "hello";
let escaped = "line1\nline2\ttabbed";
let quote = "She said \"hello\"";

// Secuencias de escape hexadecimales
let hex_esc = "\x48\x65\x6c\x6c\x6f";  // "Hello"

// Secuencias de escape Unicode
let emoji = "\u{1F600}";               // grinning face
let heart = "\u{2764}";                // heart
let mixed = "Hello \u{1F30D}!";        // Hello earth!
```

**Secuencias de escape:**
- `\n` - nueva linea
- `\t` - tabulador
- `\r` - retorno de carro
- `\\` - barra invertida
- `\"` - comilla doble
- `\'` - comilla simple
- `\0` - caracter nulo
- `\xNN` - escape hexadecimal (2 digitos)
- `\u{XXXX}` - escape unicode (1-6 digitos)

### Literales Rune

```hemlock
let ch = 'A';
let emoji = 'rocket';
let escaped = '\n';
let unicode = '\u{1F680}';
let hex_rune = '\x41';      // 'A'
```

### Literales Booleanos

```hemlock
let t = true;
let f = false;
```

### Literal Null

```hemlock
let nothing = null;
```

## Reglas de Alcance

### Alcance de Bloque

Las variables tienen alcance en el bloque mas cercano:

```hemlock
let x = 1;  // Alcance externo

if (true) {
    let x = 2;  // Alcance interno (oculta el externo)
    print(x);   // 2
}

print(x);  // 1
```

### Alcance de Funcion

Las funciones crean su propio alcance:

```hemlock
let global = "global";

fn foo() {
    let local = "local";
    print(global);  // Puede leer alcance externo
}

foo();
// print(local);  // ERROR: 'local' no definido aqui
```

### Alcance de Clausura

Las clausuras capturan variables del alcance que las contiene:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Captura 'count'
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
```

## Espacios en Blanco y Formato

### Indentacion

Hemlock no impone una indentacion especifica, pero se recomiendan 4 espacios:

```hemlock
fn example() {
    if (true) {
        print("indented");
    }
}
```

### Saltos de Linea

Las sentencias pueden abarcar multiples lineas:

```hemlock
let result =
    very_long_function_name(
        arg1,
        arg2,
        arg3
    );
```

## Sentencia Loop

La palabra clave `loop` proporciona una sintaxis mas limpia para bucles infinitos:

```hemlock
loop {
    // ... hacer trabajo
    if (done) {
        break;
    }
}
```

Esto es equivalente a `while (true)` pero hace la intencion mas clara.

## Palabras Clave Reservadas

Las siguientes palabras clave estan reservadas en Hemlock:

```
let, const, fn, if, else, while, for, in, loop, break, continue,
return, true, false, null, typeof, import, export, from,
try, catch, finally, throw, panic, async, await, spawn, join,
detach, channel, define, switch, case, default, extern, self,
type, defer, enum, ref, buffer, Self
```

## Siguientes Pasos

- [Sistema de Tipos](#language-guide-types) - Aprende sobre el sistema de tipos de Hemlock
- [Flujo de Control](#language-guide-control-flow) - Profundiza en las estructuras de control
- [Funciones](#language-guide-functions) - Domina funciones y clausuras
- [Gestion de Memoria](#language-guide-memory) - Entiende punteros y buffers


--------------------------------------------------------------------------------
## Tipos
--------------------------------------------------------------------------------

# Sistema de Tipos

Hemlock presenta un **sistema de tipos dinamico** con anotaciones de tipo opcionales y verificacion de tipos en tiempo de ejecucion.

---

## Guia de Seleccion de Tipos: Que Tipo Debo Usar?

**Nuevo en tipos?** Comienza aqui. Si estas familiarizado con sistemas de tipos, salta a [Filosofia](#filosofia).

### La Respuesta Corta

**Simplemente deja que Hemlock lo descubra:**

```hemlock
let count = 42;        // Hemlock sabe que esto es un entero
let price = 19.99;     // Hemlock sabe que esto es un decimal
let name = "Alice";    // Hemlock sabe que esto es texto
let active = true;     // Hemlock sabe que esto es si/no
```

Hemlock automaticamente elige el tipo correcto para tus valores. No *necesitas* especificar tipos.

### Cuando Agregar Anotaciones de Tipo

Agrega tipos cuando quieras:

1. **Ser especifico sobre el tamano** - `i8` vs `i64` importa para memoria o FFI
2. **Documentar tu codigo** - Los tipos muestran lo que espera una funcion
3. **Detectar errores temprano** - Hemlock verifica tipos en tiempo de ejecucion

```hemlock
// Sin tipos (funciona bien):
fn add(a, b) {
    return a + b;
}

// Con tipos (mas explicito):
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Referencia Rapida: Eligiendo Tipos Numericos

| Lo que almacenas | Tipo sugerido | Ejemplo |
|------------------|---------------|---------|
| Numeros enteros regulares | `i32` (por defecto) | `let count = 42;` |
| Numeros muy grandes | `i64` | `let population = 8000000000;` |
| Conteos nunca negativos | `u32` | `let items: u32 = 100;` |
| Bytes (0-255) | `u8` | `let pixel: u8 = 255;` |
| Decimales/fracciones | `f64` (por defecto) | `let price = 19.99;` |
| Decimales criticos para rendimiento | `f32` | `let x: f32 = 1.5;` |

### Referencia Rapida: Todos los Tipos

| Categoria | Tipos | Cuando usar |
|-----------|-------|-------------|
| **Numeros enteros** | `i8`, `i16`, `i32`, `i64` | Conteo, IDs, edades, etc. |
| **Numeros solo positivos** | `u8`, `u16`, `u32`, `u64` | Bytes, tamanos, longitudes de array |
| **Decimales** | `f32`, `f64` | Dinero, medidas, matematicas |
| **Si/No** | `bool` | Banderas, condiciones |
| **Texto** | `string` | Nombres, mensajes, cualquier texto |
| **Caracter individual** | `rune` | Letras individuales, emoji |
| **Listas** | `array` | Colecciones de valores |
| **Campos nombrados** | `object` | Agrupar datos relacionados |
| **Memoria cruda** | `ptr`, `buffer` | Programacion de bajo nivel |
| **Nada** | `null` | Ausencia de un valor |

### Escenarios Comunes

**"Solo necesito un numero"**
```hemlock
let x = 42;  // Listo! Hemlock elige i32
```

**"Necesito decimales"**
```hemlock
let price = 19.99;  // Listo! Hemlock elige f64
```

**"Estoy trabajando con bytes (archivos, red)"**
```hemlock
let byte: u8 = 255;  // rango 0-255
```

**"Necesito numeros realmente grandes"**
```hemlock
let big = 9000000000000;  // Hemlock auto-elige i64 (> max de i32)
// O se explicito:
let big: i64 = 9000000000000;
```

**"Estoy almacenando dinero"**
```hemlock
// Opcion 1: Float (simple, pero tiene limites de precision)
let price: f64 = 19.99;

// Opcion 2: Almacenar como centavos (mas preciso)
let price_cents: i32 = 1999;  // $19.99 como centavos enteros
```

**"Estoy pasando datos a codigo C (FFI)"**
```hemlock
// Coincidir tipos C exactamente
let c_int: i32 = 100;      // C 'int'
let c_long: i64 = 100;     // C 'long' (en 64-bit)
let c_char: u8 = 65;       // C 'char'
let c_double: f64 = 3.14;  // C 'double'
```

### Que Pasa Cuando Se Mezclan Tipos?

Cuando combinas diferentes tipos, Hemlock promueve al tipo "mayor":

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // result es f64 (12.5)
// El entero se convirtio en decimal automaticamente
```

**Regla general:** Los floats siempre "ganan" - mezclar cualquier entero con un float te da un float.

### Errores de Tipo

Si intentas usar el tipo incorrecto, Hemlock te lo dice en tiempo de ejecucion:

```hemlock
let age: i32 = "thirty";  // ERROR: incompatibilidad de tipos - esperaba i32, obtuvo string
```

Para convertir tipos, usa funciones constructoras de tipo:

```hemlock
let text = "42";
let number = i32(text);   // Analizar cadena a entero: 42
let back = text + "";     // Ya es una cadena
```

---

## Filosofia

- **Dinamico por defecto** - Cada valor tiene una etiqueta de tipo en tiempo de ejecucion
- **Tipado por eleccion** - Anotaciones de tipo opcionales imponen verificaciones en tiempo de ejecucion
- **Conversiones explicitas** - Las conversiones implicitas siguen reglas de promocion claras
- **Honesto sobre tipos** - `typeof()` siempre dice la verdad

## Tipos Primitivos

### Tipos Enteros

**Enteros con signo:**
```hemlock
let tiny: i8 = 127;              // 8-bit  (-128 a 127)
let small: i16 = 32767;          // 16-bit (-32768 a 32767)
let normal: i32 = 2147483647;    // 32-bit (por defecto)
let large: i64 = 9223372036854775807;  // 64-bit
```

**Enteros sin signo:**
```hemlock
let byte: u8 = 255;              // 8-bit  (0 a 255)
let word: u16 = 65535;           // 16-bit (0 a 65535)
let dword: u32 = 4294967295;     // 32-bit (0 a 4294967295)
let qword: u64 = 18446744073709551615;  // 64-bit
```

**Alias de tipo:**
```hemlock
let i: integer = 42;   // Alias para i32
let b: byte = 255;     // Alias para u8
```

### Tipos de Punto Flotante

```hemlock
let f: f32 = 3.14159;        // float de 32-bit
let d: f64 = 2.718281828;    // float de 64-bit (por defecto)
let n: number = 1.618;       // Alias para f64
```

### Tipo Booleano

```hemlock
let flag: bool = true;
let active: bool = false;
```

### Tipo String

```hemlock
let text: string = "Hello, World!";
let empty: string = "";
```

Las cadenas son **mutables**, **codificadas en UTF-8** y **asignadas en el heap**.

Ver [Strings](#language-guide-strings) para detalles completos.

### Tipo Rune

```hemlock
let ch: rune = 'A';
let emoji: rune = 'rocket';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

Los runes representan **puntos de codigo Unicode** (U+0000 a U+10FFFF).

Ver [Runes](#language-guide-runes) para detalles completos.

### Tipo Null

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null` es su propio tipo con un unico valor.

## Tipos Compuestos

### Tipo Array

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];  // Tipos mezclados permitidos
let empty: array = [];
```

Ver [Arrays](#language-guide-arrays) para detalles completos.

### Tipo Object

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

Ver [Objects](#language-guide-objects) para detalles completos.

### Tipos de Puntero

**Puntero crudo:**
```hemlock
let p: ptr = alloc(64);
// Sin verificacion de limites, gestion manual de tiempo de vida
free(p);
```

**Buffer seguro:**
```hemlock
let buf: buffer = buffer(64);
// Con verificacion de limites, rastrea longitud y capacidad
free(buf);
```

Ver [Gestion de Memoria](#language-guide-memory) para detalles completos.

## Tipos Enum

Los enums definen un conjunto de constantes nombradas:

### Enums Basicos

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// Comparacion
if (c == Color.RED) {
    print("It's red!");
}

// Switch sobre enum
switch (c) {
    case Color.RED:
        print("Stop");
        break;
    case Color.GREEN:
        print("Go");
        break;
    case Color.BLUE:
        print("Blue?");
        break;
}
```

### Enums con Valores

Los enums pueden tener valores enteros explicitos:

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### Valores Auto-incrementales

Sin valores explicitos, los enums auto-incrementan desde 0:

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// Puede mezclar valores explicitos y auto
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### Patrones de Uso de Enum

```hemlock
// Como parametros de funcion
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Urgent!");
    }
}

set_priority(Priority.HIGH);

// En objetos
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Fix bug",
    priority: Priority.HIGH
};
```

## Tipos Especiales

### Tipo File

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

Representa un manejador de archivo abierto.

### Tipo Task

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

Representa un manejador de tarea asincrona.

### Tipo Channel

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

Representa un canal de comunicacion entre tareas.

### Tipo Void

```hemlock
extern fn exit(code: i32): void;
```

Usado para funciones que no retornan un valor (solo FFI).

## Inferencia de Tipos

### Inferencia de Literales Enteros

Hemlock infiere tipos enteros basado en el rango de valores:

```hemlock
let a = 42;              // i32 (cabe en 32-bit)
let b = 5000000000;      // i64 (> max de i32)
let c = 128;             // i32
let d: u8 = 128;         // u8 (anotacion explicita)
```

**Reglas:**
- Valores en rango i32 (-2147483648 a 2147483647): inferir como `i32`
- Valores fuera del rango i32 pero dentro de i64: inferir como `i64`
- Usar anotaciones explicitas para otros tipos (i8, i16, u8, u16, u32, u64)

### Inferencia de Literales Float

```hemlock
let x = 3.14;        // f64 (por defecto)
let y: f32 = 3.14;   // f32 (explicito)
```

### Notacion Cientifica

Hemlock soporta notacion cientifica para literales numericos:

```hemlock
let a = 1e10;        // 10000000000.0 (f64)
let b = 1e-12;       // 0.000000000001 (f64)
let c = 3.14e2;      // 314.0 (f64)
let d = 2.5e-3;      // 0.0025 (f64)
let e = 1E10;        // Insensible a mayusculas
let f = 1e+5;        // Exponente positivo explicito
```

**Nota:** Cualquier literal usando notacion cientifica siempre se infiere como `f64`.

### Otra Inferencia de Tipos

```hemlock
let s = "hello";     // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## Anotaciones de Tipo

### Anotaciones de Variable

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### Anotaciones de Parametros de Funcion

```hemlock
fn greet(name: string, age: i32) {
    print("Hello, " + name + "!");
}
```

### Anotaciones de Tipo de Retorno de Funcion

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Anotaciones de Tipo de Objeto (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## Verificacion de Tipos

### Verificacion de Tipos en Tiempo de Ejecucion

Las anotaciones de tipo se verifican en **tiempo de ejecucion**, no en tiempo de compilacion:

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // Error de tiempo de ejecucion: incompatibilidad de tipos

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "hello");     // Error de tiempo de ejecucion: incompatibilidad de tipos
```

### Consultas de Tipo

Usa `typeof()` para verificar tipos de valores:

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("hello"));    // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## Conversiones de Tipo

### Promocion Implicita de Tipo

Cuando se mezclan tipos en operaciones, Hemlock promueve al tipo "superior":

**Jerarquia de Promocion (menor a mayor):**
```
i8 -> i16 -> i32 -> u32 -> i64 -> u64 -> f32 -> f64
      ^      ^      ^
     u8    u16
```

**Float siempre gana:**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result es f64 (13.5)
```

**El tamano mayor gana:**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sum es i64 (300)
```

**Preservacion de precision:** Cuando se mezclan enteros de 64-bit con f32, Hemlock promueve
a f64 para evitar perdida de precision (f32 tiene solo mantisa de 24-bit, insuficiente para i64/u64):
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // result es f64, no f32!
```

**Ejemplos:**
```hemlock
u8 + i32  -> i32
i32 + i64 -> i64
u32 + u64 -> u64
i32 + f32 -> f32    // f32 suficiente para i32
i64 + f32 -> f64    // f64 necesario para preservar precision de i64
i64 + f64 -> f64
i8 + f64  -> f64
```

### Conversion Explicita de Tipo

**Entero <-> Float:**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 -> f64 (42.0)

let x: f64 = 3.14;
let n: i32 = x;      // f64 -> i32 (3, truncado)
```

**Entero <-> Rune:**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 -> rune ('A')

let r: rune = 'Z';
let value: i32 = r;   // rune -> i32 (90)
```

**Rune -> String:**
```hemlock
let ch: rune = 'rocket';
let s: string = ch;   // rune -> string ("rocket")
```

**u8 -> Rune:**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 -> rune ('A')
```

### Funciones Constructoras de Tipo

Los nombres de tipo pueden usarse como funciones para convertir o analizar valores:

**Analizar cadenas a numeros:**
```hemlock
let n = i32("42");       // Analizar cadena a i32: 42
let f = f64("3.14159");  // Analizar cadena a f64: 3.14159
let b = bool("true");    // Analizar cadena a bool: true

// Todos los tipos numericos soportados
let a = i8("-128");      // Analizar a i8
let c = u8("255");       // Analizar a u8
let d = i16("1000");     // Analizar a i16
let e = u16("50000");    // Analizar a u16
let g = i64("9000000000000"); // Analizar a i64
let h = u64("18000000000000"); // Analizar a u64
let j = f32("1.5");      // Analizar a f32
```

**Hex y numeros negativos:**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10 (binario)
```

**Alias de tipo tambien funcionan:**
```hemlock
let x = integer("100");  // Igual que i32("100")
let y = number("1.5");   // Igual que f64("1.5")
let z = byte("200");     // Igual que u8("200")
```

**Convertir entre tipos numericos:**
```hemlock
let big = i64(42);           // i32 a i64
let truncated = i32(3.99);   // f64 a i32 (trunca a 3)
let promoted = f64(100);     // i32 a f64 (100.0)
let narrowed = i8(127);      // i32 a i8
```

**Las anotaciones de tipo realizan coercion numerica (pero NO analisis de cadenas):**
```hemlock
let f: f64 = 100;        // i32 a f64 via anotacion (OK)
let s: string = 'A';     // Rune a string via anotacion (OK)
let code: i32 = 'A';     // Rune a i32 via anotacion (obtiene codepoint, OK)

// Analisis de cadenas requiere constructores de tipo explicitos:
let n = i32("42");       // Usar constructor de tipo para analisis de cadenas
// let x: i32 = "42";    // ERROR - las anotaciones de tipo no analizan cadenas
```

**Manejo de errores:**
```hemlock
// Cadenas invalidas lanzan errores cuando usan constructores de tipo
let bad = i32("hello");  // Error de tiempo de ejecucion: no se puede analizar "hello" como i32
let overflow = u8("256"); // Error de tiempo de ejecucion: 256 fuera de rango para u8
```

**Analisis de booleanos:**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("yes");   // Error de tiempo de ejecucion: debe ser "true" o "false"
```

## Verificacion de Rango

Las anotaciones de tipo imponen verificaciones de rango en la asignacion:

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // ERROR: fuera de rango para u8

let a: i8 = 127;    // OK
let b: i8 = 128;    // ERROR: fuera de rango para i8

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // ERROR: u64 no puede ser negativo
```

## Ejemplos de Promocion de Tipo

### Tipos Enteros Mezclados

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32 (30)

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32 (300)
```

### Entero + Float

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32 (12.5)
```

### Expresiones Complejas

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64 (70.0)
// Evaluacion: b * c -> f64(60.0)
//             a + f64(60.0) -> f64(70.0)
```

## Duck Typing (Objetos)

Los objetos usan **tipado estructural** (duck typing):

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Tiene todos los campos requeridos
let p1: Person = { name: "Alice", age: 30 };

// OK: Campos extra permitidos
let p2: Person = { name: "Bob", age: 25, city: "NYC" };

// ERROR: Falta campo 'age'
let p3: Person = { name: "Carol" };

// ERROR: Tipo incorrecto para 'age'
let p4: Person = { name: "Dave", age: "thirty" };
```

**La verificacion de tipo ocurre en la asignacion:**
- Valida que todos los campos requeridos esten presentes
- Valida que los tipos de campo coincidan
- Los campos extra estan permitidos y preservados
- Establece el nombre de tipo del objeto para `typeof()`

## Campos Opcionales

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // Opcional con valor por defecto
    timeout?: i32,     // Opcional, por defecto null
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false (por defecto)
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true (sobrescrito)
```

## Alias de Tipo

Hemlock soporta alias de tipo personalizados usando la palabra clave `type`:

### Alias de Tipo Basicos

```hemlock
// Alias de tipo simple
type Integer = i32;
type Text = string;

// Usando el alias
let x: Integer = 42;
let msg: Text = "hello";
```

### Alias de Tipo de Funcion

```hemlock
// Alias de tipo de funcion
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Usando alias de tipo de funcion
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### Alias de Tipo Compuesto

```hemlock
// Combinar multiples defines en un tipo
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### Alias de Tipo Generico

```hemlock
// Alias de tipo generico
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Usando alias genericos
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Nota:** Los alias de tipo son transparentes - `typeof()` retorna el nombre del tipo subyacente, no el alias.

## Limitaciones del Sistema de Tipos

Limitaciones actuales:

- **Sin genericos en funciones** - Parametros de tipo en funciones aun no soportados
- **Sin tipos union** - No se puede expresar "A o B"
- **Sin tipos nullable** - Todos los tipos pueden ser null (usar sufijo `?` para nulabilidad explicita)

**Nota:** El compilador (`hemlockc`) proporciona verificacion de tipos en tiempo de compilacion. El interprete realiza verificacion de tipos solo en tiempo de ejecucion. Ver la [documentacion del compilador](#design-implementation) para detalles.

## Mejores Practicas

### Cuando Usar Anotaciones de Tipo

**USA anotaciones cuando:**
- El tipo preciso importa (ej., `u8` para valores de byte)
- Documentar interfaces de funciones
- Imponer restricciones (ej., verificaciones de rango)

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // Implementacion
}
```

**NO uses anotaciones cuando:**
- El tipo es obvio del literal
- Detalles de implementacion interna
- Ceremonia innecesaria

```hemlock
// Innecesario
let x: i32 = 42;

// Mejor
let x = 42;
```

### Patrones de Seguridad de Tipo

**Verificar antes de usar:**
```hemlock
if (typeof(value) == "i32") {
    // Seguro usar como i32
}
```

**Validar argumentos de funcion:**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "arguments must be integers";
    }
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

**Usar duck typing para flexibilidad:**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## Siguientes Pasos

- [Strings](#language-guide-strings) - Tipo string UTF-8 y operaciones
- [Runes](#language-guide-runes) - Tipo de punto de codigo Unicode
- [Arrays](#language-guide-arrays) - Tipo de array dinamico
- [Objects](#language-guide-objects) - Literales de objeto y duck typing
- [Memory](#language-guide-memory) - Tipos de puntero y buffer



################################################################################
# TEMAS AVANZADOS
################################################################################

--------------------------------------------------------------------------------
## Argumentos de LÃ­nea de Comandos
--------------------------------------------------------------------------------

# Argumentos de Linea de Comandos en Hemlock

Los programas de Hemlock pueden acceder a los argumentos de linea de comandos a traves de un **array `args` integrado** que se llena automaticamente al iniciar el programa.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [El Array args](#el-array-args)
- [Propiedades](#propiedades)
- [Patrones de Iteracion](#patrones-de-iteracion)
- [Casos de Uso Comunes](#casos-de-uso-comunes)
- [Patrones de Analisis de Argumentos](#patrones-de-analisis-de-argumentos)
- [Mejores Practicas](#mejores-practicas)
- [Ejemplos Completos](#ejemplos-completos)

## Vision General

El array `args` proporciona acceso a los argumentos de linea de comandos pasados a tu programa de Hemlock:

- **Siempre disponible** - Variable global integrada en todos los programas de Hemlock
- **Nombre del script incluido** - `args[0]` siempre contiene la ruta/nombre del script
- **Array de strings** - Todos los argumentos son strings
- **Indexado desde cero** - Indexacion estandar de array (0, 1, 2, ...)

## El Array args

### Estructura Basica

```hemlock
// args[0] es siempre el nombre del archivo de script
// args[1] a args[n-1] son los argumentos reales
print(args[0]);        // "script.hml"
print(args.length);    // Numero total de argumentos (incluyendo nombre del script)
```

### Ejemplo de Uso

**Comando:**
```bash
./hemlock script.hml hello world "test 123"
```

**En script.hml:**
```hemlock
print("Script name: " + args[0]);     // "script.hml"
print("Total args: " + typeof(args.length));  // "4"
print("First arg: " + args[1]);       // "hello"
print("Second arg: " + args[2]);      // "world"
print("Third arg: " + args[3]);       // "test 123"
```

### Referencia de Indices

| Indice | Contiene | Valor de Ejemplo |
|--------|----------|------------------|
| `args[0]` | Ruta/nombre del script | `"script.hml"` o `"./script.hml"` |
| `args[1]` | Primer argumento | `"hello"` |
| `args[2]` | Segundo argumento | `"world"` |
| `args[3]` | Tercer argumento | `"test 123"` |
| ... | ... | ... |
| `args[n-1]` | Ultimo argumento | (varia) |

## Propiedades

### Siempre Presente

`args` es un array global disponible en **todos** los programas de Hemlock:

```hemlock
// No necesita declararse o importarse
print(args.length);  // Funciona inmediatamente
```

### Nombre del Script Incluido

`args[0]` siempre contiene la ruta/nombre del script:

```hemlock
print("Running: " + args[0]);
```

**Valores posibles para args[0]:**
- `"script.hml"` - Solo el nombre del archivo
- `"./script.hml"` - Ruta relativa
- `"/home/user/script.hml"` - Ruta absoluta
- Depende de como se invoco el script

### Tipo: Array de Strings

Todos los argumentos se almacenan como strings:

```hemlock
// Argumentos: ./hemlock script.hml 42 3.14 true

print(args[1]);  // "42" (string, no numero)
print(args[2]);  // "3.14" (string, no numero)
print(args[3]);  // "true" (string, no booleano)

// Convertir segun necesidad:
let num = 42;  // Parsear manualmente si es necesario
```

### Longitud Minima

Siempre al menos 1 (el nombre del script):

```hemlock
print(args.length);  // Minimo: 1
```

**Incluso sin argumentos:**
```bash
./hemlock script.hml
```

```hemlock
// En script.hml:
print(args.length);  // 1 (solo nombre del script)
```

### Comportamiento en REPL

En el REPL, `args.length` es 0 (array vacio):

```hemlock
# Sesion REPL
> print(args.length);
0
```

## Patrones de Iteracion

### Iteracion Basica

Saltar `args[0]` (nombre del script) y procesar argumentos reales:

```hemlock
let i = 1;
while (i < args.length) {
    print("Argument " + typeof(i) + ": " + args[i]);
    i = i + 1;
}
```

**Salida para: `./hemlock script.hml foo bar baz`**
```
Argument 1: foo
Argument 2: bar
Argument 3: baz
```

### Iteracion For-In (Incluyendo Nombre del Script)

```hemlock
for (let arg in args) {
    print(arg);
}
```

**Salida:**
```
script.hml
foo
bar
baz
```

### Verificando Cantidad de Argumentos

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <argument>");
    // salir o retornar
} else {
    let arg = args[1];
    // procesar arg
}
```

### Procesando Todos los Argumentos Excepto el Nombre del Script

```hemlock
let actual_args = args.slice(1, args.length);

for (let arg in actual_args) {
    print("Processing: " + arg);
}
```

## Casos de Uso Comunes

### 1. Procesamiento Simple de Argumentos

Verificar argumento requerido:

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    print("Processing file: " + filename);
    // ... procesar archivo
}
```

**Uso:**
```bash
./hemlock script.hml data.txt
# Salida: Processing file: data.txt
```

### 2. Multiples Argumentos

```hemlock
if (args.length < 3) {
    print("Usage: " + args[0] + " <input> <output>");
} else {
    let input_file = args[1];
    let output_file = args[2];

    print("Input: " + input_file);
    print("Output: " + output_file);

    // Procesar archivos...
}
```

**Uso:**
```bash
./hemlock convert.hml input.txt output.txt
```

### 3. Numero Variable de Argumentos

Procesar todos los argumentos proporcionados:

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        print("  " + args[i]);
        process_file(args[i]);
        i = i + 1;
    }
}
```

**Uso:**
```bash
./hemlock batch.hml file1.txt file2.txt file3.txt
```

### 4. Mensaje de Ayuda

```hemlock
if (args.length < 2 || args[1] == "--help" || args[1] == "-h") {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show this help message");
    print("  -v, --verbose  Enable verbose output");
} else {
    // Procesar normalmente
}
```

### 5. Validacion de Argumentos

```hemlock
fn validate_file(filename: string): bool {
    // Verificar si el archivo existe (ejemplo)
    return filename != "";
}

if (args.length < 2) {
    print("Error: No filename provided");
} else if (!validate_file(args[1])) {
    print("Error: Invalid file: " + args[1]);
} else {
    print("Processing: " + args[1]);
}
```

## Patrones de Analisis de Argumentos

### Argumentos con Nombre (Flags)

Patron simple para argumentos con nombre:

```hemlock
let verbose = false;
let output_file = "";
let input_file = "";

let i = 1;
while (i < args.length) {
    if (args[i] == "--verbose" || args[i] == "-v") {
        verbose = true;
    } else if (args[i] == "--output" || args[i] == "-o") {
        i = i + 1;
        if (i < args.length) {
            output_file = args[i];
        }
    } else {
        input_file = args[i];
    }
    i = i + 1;
}

if (verbose) {
    print("Verbose mode enabled");
}
print("Input: " + input_file);
print("Output: " + output_file);
```

**Uso:**
```bash
./hemlock script.hml --verbose --output out.txt input.txt
./hemlock script.hml -v -o out.txt input.txt
```

### Flags Booleanos

```hemlock
let debug = false;
let verbose = false;
let force = false;

let i = 1;
while (i < args.length) {
    if (args[i] == "--debug") {
        debug = true;
    } else if (args[i] == "--verbose") {
        verbose = true;
    } else if (args[i] == "--force") {
        force = true;
    }
    i = i + 1;
}
```

### Argumentos con Valor

```hemlock
let config_file = "default.conf";
let port = 8080;

let i = 1;
while (i < args.length) {
    if (args[i] == "--config") {
        i = i + 1;
        if (i < args.length) {
            config_file = args[i];
        }
    } else if (args[i] == "--port") {
        i = i + 1;
        if (i < args.length) {
            port = 8080;  // Necesitaria parsear string a int
        }
    }
    i = i + 1;
}
```

### Argumentos Posicionales y con Nombre Mezclados

```hemlock
let input_file = "";
let output_file = "";
let verbose = false;

let i = 1;
let positional = [];

while (i < args.length) {
    if (args[i] == "--verbose") {
        verbose = true;
    } else {
        // Tratar como argumento posicional
        positional.push(args[i]);
    }
    i = i + 1;
}

// Asignar argumentos posicionales
if (positional.length > 0) {
    input_file = positional[0];
}
if (positional.length > 1) {
    output_file = positional[1];
}
```

### Funcion Auxiliar de Analizador de Argumentos

```hemlock
fn parse_args() {
    let options = {
        verbose: false,
        output: "",
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                options.output = args[i];
            }
        } else {
            // Argumento posicional
            options.files.push(arg);
        }

        i = i + 1;
    }

    return options;
}

let opts = parse_args();
print("Verbose: " + typeof(opts.verbose));
print("Output: " + opts.output);
print("Files: " + typeof(opts.files.length));
```

## Mejores Practicas

### 1. Siempre Verificar Cantidad de Argumentos

```hemlock
// Bueno
if (args.length < 2) {
    print("Usage: " + args[0] + " <file>");
} else {
    process_file(args[1]);
}

// Malo - puede fallar si no hay argumentos
process_file(args[1]);  // Error si args.length == 1
```

### 2. Proporcionar Informacion de Uso

```hemlock
fn show_usage() {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show help");
    print("  -v, --verbose  Verbose output");
}

if (args.length < 2) {
    show_usage();
}
```

### 3. Validar Argumentos

```hemlock
fn validate_args() {
    if (args.length < 2) {
        print("Error: Missing required argument");
        return false;
    }

    if (args[1] == "") {
        print("Error: Empty argument");
        return false;
    }

    return true;
}

if (!validate_args()) {
    // salir o mostrar uso
}
```

### 4. Usar Nombres de Variables Descriptivos

```hemlock
// Bueno
let input_filename = args[1];
let output_filename = args[2];
let max_iterations = args[3];

// Malo
let a = args[1];
let b = args[2];
let c = args[3];
```

### 5. Manejar Argumentos con Comillas y Espacios

El shell maneja esto automaticamente:

```bash
./hemlock script.hml "file with spaces.txt"
```

```hemlock
print(args[1]);  // "file with spaces.txt"
```

### 6. Crear Objetos de Argumentos

```hemlock
fn get_args() {
    return {
        script: args[0],
        input: args[1],
        output: args[2]
    };
}

let arguments = get_args();
print("Input: " + arguments.input);
```

## Ejemplos Completos

### Ejemplo 1: Procesador de Archivos

```hemlock
// Uso: ./hemlock process.hml <input> <output>

fn show_usage() {
    print("Usage: " + args[0] + " <input_file> <output_file>");
}

if (args.length < 3) {
    show_usage();
} else {
    let input = args[1];
    let output = args[2];

    print("Processing " + input + " -> " + output);

    // Procesar archivos
    let f_in = open(input, "r");
    let f_out = open(output, "w");

    try {
        let content = f_in.read();
        let processed = content.to_upper();  // Procesamiento de ejemplo
        f_out.write(processed);

        print("Done!");
    } finally {
        f_in.close();
        f_out.close();
    }
}
```

### Ejemplo 2: Procesador de Archivos por Lotes

```hemlock
// Uso: ./hemlock batch.hml <file1> <file2> <file3> ...

if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        let filename = args[i];
        print("  Processing: " + filename);

        try {
            let f = open(filename, "r");
            let content = f.read();
            f.close();

            // Procesar contenido...
            print("    " + typeof(content.length) + " bytes");
        } catch (e) {
            print("    Error: " + e);
        }

        i = i + 1;
    }

    print("Done!");
}
```

### Ejemplo 3: Analizador de Argumentos Avanzado

```hemlock
// Uso: ./hemlock app.hml [OPTIONS] <files...>
// Opciones:
//   --verbose, -v     Habilitar salida detallada
//   --output, -o FILE Establecer archivo de salida
//   --help, -h        Mostrar ayuda

fn parse_arguments() {
    let config = {
        verbose: false,
        output: "output.txt",
        help: false,
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            config.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                config.output = args[i];
            } else {
                print("Error: --output requires a value");
            }
        } else if (arg == "--help" || arg == "-h") {
            config.help = true;
        } else if (arg.starts_with("--")) {
            print("Error: Unknown option: " + arg);
        } else {
            config.files.push(arg);
        }

        i = i + 1;
    }

    return config;
}

fn show_help() {
    print("Usage: " + args[0] + " [OPTIONS] <files...>");
    print("Options:");
    print("  --verbose, -v     Enable verbose output");
    print("  --output, -o FILE Set output file");
    print("  --help, -h        Show this help");
}

let config = parse_arguments();

if (config.help) {
    show_help();
} else if (config.files.length == 0) {
    print("Error: No input files specified");
    show_help();
} else {
    if (config.verbose) {
        print("Verbose mode enabled");
        print("Output file: " + config.output);
        print("Input files: " + typeof(config.files.length));
    }

    // Procesar archivos
    for (let file in config.files) {
        if (config.verbose) {
            print("Processing: " + file);
        }
        // ... procesar archivo
    }
}
```

### Ejemplo 4: Herramienta de Configuracion

```hemlock
// Uso: ./hemlock config.hml <action> [arguments]
// Acciones:
//   get <key>
//   set <key> <value>
//   list

fn show_usage() {
    print("Usage: " + args[0] + " <action> [arguments]");
    print("Actions:");
    print("  get <key>         Get configuration value");
    print("  set <key> <value> Set configuration value");
    print("  list              List all configuration");
}

if (args.length < 2) {
    show_usage();
} else {
    let action = args[1];

    if (action == "get") {
        if (args.length < 3) {
            print("Error: 'get' requires a key");
        } else {
            let key = args[2];
            print("Getting: " + key);
            // ... obtener de configuracion
        }
    } else if (action == "set") {
        if (args.length < 4) {
            print("Error: 'set' requires key and value");
        } else {
            let key = args[2];
            let value = args[3];
            print("Setting " + key + " = " + value);
            // ... establecer en configuracion
        }
    } else if (action == "list") {
        print("Listing all configuration:");
        // ... listar configuracion
    } else {
        print("Error: Unknown action: " + action);
        show_usage();
    }
}
```

## Resumen

El soporte de argumentos de linea de comandos de Hemlock proporciona:

- âœ… Array `args` integrado disponible globalmente
- âœ… Acceso simple basado en array a los argumentos
- âœ… Nombre del script en `args[0]`
- âœ… Todos los argumentos como strings
- âœ… Metodos de array disponibles (.length, .slice, etc.)

Recuerda:
- Siempre verificar `args.length` antes de acceder a elementos
- `args[0]` es el nombre del script
- Los argumentos reales comienzan en `args[1]`
- Todos los argumentos son strings - convertir segun necesidad
- Proporcionar informacion de uso para herramientas amigables
- Validar argumentos antes de procesar

Patrones comunes:
- Argumentos posicionales simples
- Argumentos con nombre/flags (--flag)
- Argumentos con valor (--option value)
- Mensajes de ayuda (--help)
- Validacion de argumentos


--------------------------------------------------------------------------------
## AsincronÃ­a y Concurrencia
--------------------------------------------------------------------------------

# Async/Concurrencia en Hemlock

Hemlock proporciona **concurrencia estructurada** con sintaxis async/await, creacion de tareas y canales para comunicacion. La implementacion utiliza hilos POSIX (pthreads) para **VERDADERO paralelismo multihilo**.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [Modelo de Hilos](#modelo-de-hilos)
- [Funciones Async](#funciones-async)
- [Creacion de Tareas](#creacion-de-tareas)
- [Canales](#canales)
- [Propagacion de Excepciones](#propagacion-de-excepciones)
- [Detalles de Implementacion](#detalles-de-implementacion)
- [Mejores Practicas](#mejores-practicas)
- [Caracteristicas de Rendimiento](#caracteristicas-de-rendimiento)
- [Limitaciones Actuales](#limitaciones-actuales)

## Vision General

**Lo que esto significa:**
- âœ… **Hilos reales del SO** - Cada tarea creada se ejecuta en un pthread separado (hilo POSIX)
- âœ… **Verdadero paralelismo** - Las tareas se ejecutan simultaneamente en multiples nucleos de CPU
- âœ… **Planificado por el kernel** - El planificador del SO distribuye las tareas entre los nucleos disponibles
- âœ… **Canales seguros para hilos** - Utiliza mutexes y variables de condicion de pthread para sincronizacion

**Lo que esto NO es:**
- âŒ **NO son hilos verdes** - No es multitarea cooperativa en espacio de usuario
- âŒ **NO son corrutinas async/await** - No es un bucle de eventos de un solo hilo como JavaScript/Python asyncio
- âŒ **NO es concurrencia emulada** - No es paralelismo simulado

Este es el **mismo modelo de hilos que C, C++ y Rust** cuando se usan hilos del SO. Obtienes ejecucion paralela real a traves de multiples nucleos.

## Modelo de Hilos

### Hilos 1:1

Hemlock utiliza un **modelo de hilos 1:1**, donde:
- Cada tarea creada crea un hilo dedicado del SO via `pthread_create()`
- El kernel del SO planifica los hilos a traves de los nucleos de CPU disponibles
- Multitarea preventiva - el SO puede interrumpir y cambiar entre hilos
- **Sin GIL** - A diferencia de Python, no hay un Bloqueo Global del Interprete limitando el paralelismo

### Mecanismos de Sincronizacion

- **Mutexes** - Los canales usan `pthread_mutex_t` para acceso seguro entre hilos
- **Variables de condicion** - send/recv bloqueantes usan `pthread_cond_t` para espera eficiente
- **Operaciones sin bloqueo** - Las transiciones de estado de tareas son atomicas

## Funciones Async

Las funciones pueden declararse como `async` para indicar que estan disenadas para ejecucion concurrente:

```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
```

### Puntos Clave

- `async fn` declara una funcion asincrona
- Las funciones async pueden crearse como tareas concurrentes usando `spawn()`
- Las funciones async tambien pueden llamarse directamente (se ejecuta sincronicamente en el hilo actual)
- Cuando se crean, cada tarea se ejecuta en su **propio hilo del SO** (no es una corrutina!)
- La palabra clave `await` esta reservada para uso futuro

### Ejemplo: Llamada Directa vs Spawn

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Llamada directa - se ejecuta sincronicamente
let result1 = factorial(5);  // 120

// Tarea creada - se ejecuta en hilo separado
let task = spawn(factorial, 5);
let result2 = join(task);  // 120
```

## Creacion de Tareas

Usa `spawn()` para ejecutar funciones async **en paralelo en hilos separados del SO**:

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Crear multiples tareas - estas se ejecutan en PARALELO en diferentes nucleos de CPU!
let t1 = spawn(factorial, 5);  // Hilo 1
let t2 = spawn(factorial, 6);  // Hilo 2
let t3 = spawn(factorial, 7);  // Hilo 3

// Las tres estan computando simultaneamente ahora mismo!

// Esperar resultados
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
```

### Funciones Integradas

#### spawn(async_fn, arg1, arg2, ...)

Crea una nueva tarea en un nuevo pthread, retorna el manejador de tarea.

**Parametros:**
- `async_fn` - La funcion async a ejecutar
- `arg1, arg2, ...` - Argumentos a pasar a la funcion

**Retorna:** Manejador de tarea (valor opaco usado con `join()` o `detach()`)

**Ejemplo:**
```hemlock
async fn process(data: string, count: i32): i32 {
    // ... logica de procesamiento
    return count * 2;
}

let task = spawn(process, "test", 42);
```

#### join(task)

Espera a que la tarea complete (bloquea hasta que el hilo termine), retorna el resultado.

**Parametros:**
- `task` - Manejador de tarea retornado por `spawn()`

**Retorna:** El valor retornado por la funcion async

**Ejemplo:**
```hemlock
let task = spawn(compute, 1000);
let result = join(task);  // Bloquea hasta que compute() termine
print(result);
```

**Importante:** Cada tarea solo puede unirse una vez. Uniones posteriores daran error.

#### detach(task)

Ejecucion de disparar y olvidar (el hilo se ejecuta independientemente, no se permite union).

**Parametros:**
- `task` - Manejador de tarea retornado por `spawn()`

**Retorna:** `null`

**Ejemplo:**
```hemlock
async fn background_work() {
    // Tarea de fondo de larga duracion
    // ...
}

let task = spawn(background_work);
detach(task);  // La tarea se ejecuta independientemente, no se puede unir
```

**Importante:** Las tareas desacopladas no pueden unirse. Tanto el pthread como la estructura Task se limpian automaticamente cuando la tarea completa.

## Canales

Los canales proporcionan comunicacion segura entre hilos usando un buffer limitado con semantica de bloqueo.

### Creando Canales

```hemlock
let ch = channel(10);  // Crear canal con tamano de buffer de 10
```

**Parametros:**
- `capacity` (i32) - Numero maximo de valores que el canal puede contener

**Retorna:** Objeto Canal

### Metodos de Canal

#### send(value)

Enviar valor al canal (bloquea si esta lleno).

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let task = spawn(producer, ch, 5);
```

**Comportamiento:**
- Si el canal tiene espacio, el valor se agrega inmediatamente
- Si el canal esta lleno, el emisor bloquea hasta que haya espacio disponible
- Si el canal esta cerrado, lanza una excepcion

#### recv()

Recibir valor del canal (bloquea si esta vacio).

```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let task = spawn(consumer, ch, 5);
```

**Comportamiento:**
- Si el canal tiene valores, retorna el siguiente valor inmediatamente
- Si el canal esta vacio, el receptor bloquea hasta que haya un valor disponible
- Si el canal esta cerrado y vacio, retorna `null`

#### close()

Cerrar canal (recv en canal cerrado retorna null).

```hemlock
ch.close();
```

**Comportamiento:**
- Previene futuras operaciones `send()` (lanzara excepcion)
- Permite que las operaciones `recv()` pendientes completen
- Una vez vacio, `recv()` retorna `null`

### Multiplexacion con select()

La funcion `select()` permite esperar en multiples canales simultaneamente, retornando cuando cualquier canal tiene datos disponibles.

**Firma:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parametros:**
- `channels` - Array de valores de canal
- `timeout_ms` (opcional) - Tiempo de espera en milisegundos (-1 u omitir para espera infinita)

**Retorna:**
- `{ channel, value }` - Objeto con el canal que tenia datos y el valor recibido
- `null` - En tiempo de espera agotado (si se especifico timeout)

**Ejemplo:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Tareas productoras
spawn(fn() {
    sleep(100);
    ch1.send("from channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("from channel 2");
});

// Esperar primer resultado (ch2 deberia ser mas rapido)
let result = select([ch1, ch2]);
print(result.value);  // "from channel 2"

// Esperar segundo resultado
let result2 = select([ch1, ch2]);
print(result2.value);  // "from channel 1"
```

**Con tiempo de espera:**
```hemlock
let ch = channel(1);

// Sin emisor, se agotara el tiempo
let result = select([ch], 100);  // 100ms de timeout
if (result == null) {
    print("Timed out!");
}
```

**Casos de uso:**
- Esperar el mas rapido de multiples fuentes de datos
- Implementar tiempos de espera en operaciones de canal
- Patrones de bucle de eventos con multiples fuentes de eventos
- Fan-in: fusionar multiples canales en uno

**Patron fan-in:**
```hemlock
fn fan_in(channels: array, output: channel) {
    while (true) {
        let result = select(channels);
        if (result == null) {
            break;  // Todos los canales cerrados
        }
        output.send(result.value);
    }
    output.close();
}
```

### Ejemplo Completo de Productor-Consumidor

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Crear canal con tamano de buffer
let ch = channel(10);

// Crear productor y consumidor
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Esperar finalizacion
join(p);
let total = join(c);  // 100 (0+10+20+30+40)
print(total);
```

### Multi-Productor, Multi-Consumidor

Los canales pueden compartirse de forma segura entre multiples productores y consumidores:

```hemlock
async fn producer(id: i32, ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(id * 100 + i);
        i = i + 1;
    }
}

async fn consumer(id: i32, ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(20);

// Multiples productores
let p1 = spawn(producer, 1, ch, 5);
let p2 = spawn(producer, 2, ch, 5);

// Multiples consumidores
let c1 = spawn(consumer, 1, ch, 5);
let c2 = spawn(consumer, 2, ch, 5);

// Esperar a todos
join(p1);
join(p2);
let sum1 = join(c1);
let sum2 = join(c2);
print(sum1 + sum2);
```

## Propagacion de Excepciones

Las excepciones lanzadas en tareas creadas se propagan cuando se unen:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task failed!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Caught: " + e);  // "Caught: Task failed!"
}
```

### Patrones de Manejo de Excepciones

**Patron 1: Manejar en la tarea**
```hemlock
async fn safe_task() {
    try {
        // operacion riesgosa
    } catch (e) {
        print("Error in task: " + e);
        return null;
    }
}

let task = spawn(safe_task);
join(task);  // Sin excepcion propagada
```

**Patron 2: Propagar al llamador**
```hemlock
async fn task_that_throws() {
    throw "error";
}

let task = spawn(task_that_throws);
try {
    join(task);
} catch (e) {
    print("Caught from task: " + e);
}
```

**Patron 3: Tareas desacopladas con excepciones**
```hemlock
async fn detached_task() {
    try {
        // trabajo
    } catch (e) {
        // Debe manejarse internamente - no puede propagarse
        print("Error: " + e);
    }
}

let task = spawn(detached_task);
detach(task);  // No se pueden capturar excepciones de tareas desacopladas
```

## Detalles de Implementacion

### Arquitectura de Hilos

- **Hilos 1:1** - Cada tarea creada crea un hilo dedicado del SO via `pthread_create()`
- **Planificado por el kernel** - El kernel del SO planifica los hilos a traves de los nucleos de CPU disponibles
- **Multitarea preventiva** - El SO puede interrumpir y cambiar entre hilos
- **Sin GIL** - A diferencia de Python, no hay un Bloqueo Global del Interprete limitando el paralelismo

### Implementacion de Canales

Los canales usan un buffer circular con sincronizacion de pthread:

```
Estructura de Canal:
- buffer[] - Array de tamano fijo de Values
- capacity - Numero maximo de elementos
- size - Numero actual de elementos
- head - Posicion de lectura
- tail - Posicion de escritura
- mutex - pthread_mutex_t para acceso seguro entre hilos
- not_empty - pthread_cond_t para recv bloqueante
- not_full - pthread_cond_t para send bloqueante
- closed - Flag booleano
- refcount - Contador de referencias para limpieza
```

**Comportamiento de bloqueo:**
- `send()` en canal lleno: espera en la variable de condicion `not_full`
- `recv()` en canal vacio: espera en la variable de condicion `not_empty`
- Ambas son senalizadas cuando corresponde por la operacion opuesta

### Memoria y Limpieza

- **Tareas unidas:** Limpiadas automaticamente despues de que `join()` retorna
- **Tareas desacopladas:** Limpiadas automaticamente cuando la tarea completa
- **Canales:** Contados por referencia y liberados cuando ya no se usan

## Mejores Practicas

### 1. Siempre Cerrar Canales

```hemlock
async fn producer(ch) {
    // ... enviar valores
    ch.close();  // Importante: senalar que no hay mas valores
}
```

### 2. Usar Concurrencia Estructurada

Crear tareas y unirlas en el mismo ambito:

```hemlock
fn process_data(data) {
    // Crear tareas
    let t1 = spawn(worker, data);
    let t2 = spawn(worker, data);

    // Siempre unir antes de retornar
    let r1 = join(t1);
    let r2 = join(t2);

    return r1 + r2;
}
```

### 3. Manejar Excepciones Apropiadamente

```hemlock
async fn task() {
    try {
        // operacion riesgosa
    } catch (e) {
        // Registrar error
        throw e;  // Re-lanzar si el llamador debe saberlo
    }
}
```

### 4. Usar Capacidad de Canal Apropiada

- **Capacidad pequena (1-10):** Para coordinacion/senalizacion
- **Capacidad media (10-100):** Para productor-consumidor general
- **Capacidad grande (100+):** Para escenarios de alto rendimiento

```hemlock
let signal_ch = channel(1);      // Coordinacion
let work_ch = channel(50);       // Cola de trabajo
let buffer_ch = channel(1000);   // Alto rendimiento
```

### 5. Desacoplar Solo Cuando Sea Necesario

Preferir `join()` sobre `detach()` para mejor gestion de recursos:

```hemlock
// Bueno: Unir y obtener resultado
let task = spawn(work);
let result = join(task);

// Usar detach solo para verdadero disparar y olvidar
let bg_task = spawn(background_logging);
detach(bg_task);  // Se ejecutara independientemente
```

## Caracteristicas de Rendimiento

### Verdadero Paralelismo

- **N tareas creadas pueden utilizar N nucleos de CPU simultaneamente**
- Aceleracion probada - pruebas de estres muestran 8-9x tiempo de CPU vs tiempo real (multiples nucleos trabajando)
- Escalado lineal con numero de nucleos (hasta el conteo de hilos)

### Sobrecarga de Hilos

- Cada tarea tiene ~8KB de pila + sobrecarga de pthread
- Costo de creacion de hilo: ~10-20us
- Costo de cambio de contexto: ~1-5us

### Cuando Usar Async

**Buenos casos de uso:**
- Computaciones intensivas de CPU que pueden paralelizarse
- Operaciones limitadas por I/O (aunque I/O sigue siendo bloqueante)
- Procesamiento concurrente de datos independientes
- Arquitecturas de pipeline con canales

**No ideal para:**
- Tareas muy cortas (la sobrecarga de hilos domina)
- Tareas con sincronizacion pesada (sobrecarga de contencion)
- Sistemas de un solo nucleo (sin beneficio de paralelismo)

### I/O Bloqueante Seguro

Las operaciones bloqueantes en una tarea no bloquean otras:

```hemlock
async fn reader(filename: string) {
    let f = open(filename, "r");  // Bloquea solo este hilo
    let content = f.read();       // Bloquea solo este hilo
    f.close();
    return content;
}

// Ambos leen concurrentemente (en diferentes hilos)
let t1 = spawn(reader, "file1.txt");
let t2 = spawn(reader, "file2.txt");

let c1 = join(t1);
let c2 = join(t2);
```

## Modelo de Seguridad de Hilos

Hemlock usa un modelo de concurrencia de **paso de mensajes** donde las tareas se comunican via canales en lugar de estado mutable compartido.

### Aislamiento de Argumentos

Cuando creas una tarea, **los argumentos se copian profundamente** para prevenir carreras de datos:

```hemlock
async fn modify_array(arr: array): array {
    arr.push(999);    // Modifica la COPIA, no el original
    arr[0] = -1;
    return arr;
}

let original = [1, 2, 3];
let task = spawn(modify_array, original);
let modified = join(task);

print(original.length);  // 3 - sin cambios!
print(modified.length);  // 4 - tiene nuevo elemento
```

**Lo que se copia profundamente:**
- Arrays (y todos los elementos recursivamente)
- Objetos (y todos los campos recursivamente)
- Strings
- Buffers

**Lo que se comparte (referencia retenida):**
- Canales (el mecanismo de comunicacion - compartido intencionalmente)
- Manejadores de tarea (para coordinacion)
- Funciones (el codigo es inmutable)
- Manejadores de archivo (el SO gestiona acceso concurrente)
- Manejadores de socket (el SO gestiona acceso concurrente)

**Lo que no puede pasarse:**
- Punteros crudos (`ptr`) - usar `buffer` en su lugar

### Por Que Paso de Mensajes?

Esto sigue la filosofia de Hemlock de "explicito sobre implicito":

```hemlock
// MAL: Estado mutable compartido (causaria carreras de datos)
let counter = { value: 0 };
let t1 = spawn(fn() { counter.value = counter.value + 1; });  // Carrera!
let t2 = spawn(fn() { counter.value = counter.value + 1; });  // Carrera!

// BIEN: Paso de mensajes via canales
async fn increment(ch) {
    let val = ch.recv();
    ch.send(val + 1);
}

let ch = channel(1);
ch.send(0);
let t1 = spawn(increment, ch);
join(t1);
let result = ch.recv();  // 1 - sin condicion de carrera
```

### Seguridad de Hilos en Conteo de Referencias

Todas las operaciones de conteo de referencias usan **operaciones atomicas** para prevenir errores de uso despues de liberar:
- `string_retain/release` - atomico
- `array_retain/release` - atomico
- `object_retain/release` - atomico
- `buffer_retain/release` - atomico
- `function_retain/release` - atomico
- `channel_retain/release` - atomico
- `task_retain/release` - atomico

Esto asegura gestion de memoria segura incluso cuando los valores se comparten entre hilos.

### Acceso al Entorno de Clausura

Las tareas tienen acceso al entorno de clausura para:
- Funciones integradas (`print`, `len`, etc.)
- Definiciones de funciones globales
- Constantes y variables

El entorno de clausura esta protegido por un mutex por entorno, haciendo
las lecturas y escrituras concurrentes seguras para hilos:

```hemlock
let x = 10;

async fn read_closure(): i32 {
    return x;  // OK: leyendo variable de clausura (seguro para hilos)
}

async fn modify_closure() {
    x = 20;  // OK: escribiendo variable de clausura (sincronizado con mutex)
}
```

**Nota:** Aunque el acceso concurrente esta sincronizado, modificar estado compartido desde
multiples tareas todavia puede llevar a condiciones de carrera logicas (ordenamiento
no determinista). Para comportamiento predecible, usa canales para comunicacion de tareas o
valores de retorno de tareas.

Si necesitas retornar datos de una tarea, usa el valor de retorno o canales.

## Limitaciones Actuales

### 1. Sin Planificador con Robo de Trabajo

Usa 1 hilo por tarea, lo cual puede ser ineficiente para muchas tareas cortas.

**Actual:** 1000 tareas = 1000 hilos (sobrecarga pesada)

**Planeado:** Pool de hilos con robo de trabajo para mejor eficiencia

### 3. Sin Integracion de I/O Async

Las operaciones de archivo/red todavia bloquean el hilo:

```hemlock
async fn read_file(path: string) {
    let f = open(path, "r");
    let content = f.read();  // Bloquea el hilo
    f.close();
    return content;
}
```

**Solucion temporal:** Usar multiples hilos para operaciones de I/O concurrentes

### 4. Capacidad de Canal Fija

La capacidad del canal se establece en la creacion y no puede redimensionarse:

```hemlock
let ch = channel(10);
// No puede redimensionarse dinamicamente a 20
```

### 5. El Tamano del Canal es Fijo

El tamano del buffer del canal no puede cambiarse despues de la creacion.

## Patrones Comunes

### Map Paralelo

```hemlock
async fn map_worker(ch_in, ch_out, fn_transform) {
    while (true) {
        let val = ch_in.recv();
        if (val == null) { break; }

        let result = fn_transform(val);
        ch_out.send(result);
    }
    ch_out.close();
}

fn parallel_map(data, fn_transform, workers: i32) {
    let ch_in = channel(100);
    let ch_out = channel(100);

    // Crear workers
    let tasks = [];
    let i = 0;
    while (i < workers) {
        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));
        i = i + 1;
    }

    // Enviar datos
    let i = 0;
    while (i < data.length) {
        ch_in.send(data[i]);
        i = i + 1;
    }
    ch_in.close();

    // Recolectar resultados
    let results = [];
    let i = 0;
    while (i < data.length) {
        results.push(ch_out.recv());
        i = i + 1;
    }

    // Esperar a los workers
    let i = 0;
    while (i < tasks.length) {
        join(tasks[i]);
        i = i + 1;
    }

    return results;
}
```

### Arquitectura de Pipeline

```hemlock
async fn stage1(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val * 2);
    }
    output_ch.close();
}

async fn stage2(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val + 10);
    }
    output_ch.close();
}

// Crear pipeline
let ch1 = channel(10);
let ch2 = channel(10);
let ch3 = channel(10);

let s1 = spawn(stage1, ch1, ch2);
let s2 = spawn(stage2, ch2, ch3);

// Alimentar entrada
ch1.send(1);
ch1.send(2);
ch1.send(3);
ch1.close();

// Recolectar salida
print(ch3.recv());  // 12 (1 * 2 + 10)
print(ch3.recv());  // 14 (2 * 2 + 10)
print(ch3.recv());  // 16 (3 * 2 + 10)

join(s1);
join(s2);
```

### Fan-Out, Fan-In

```hemlock
async fn worker(id: i32, input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }

        // Procesar valor
        let result = val * id;
        output_ch.send(result);
    }
}

let input = channel(10);
let output = channel(10);

// Fan-out: Multiples workers
let workers = 4;
let tasks = [];
let i = 0;
while (i < workers) {
    tasks.push(spawn(worker, i, input, output));
    i = i + 1;
}

// Enviar trabajo
let i = 0;
while (i < 10) {
    input.send(i);
    i = i + 1;
}
input.close();

// Fan-in: Recolectar todos los resultados
let results = [];
let i = 0;
while (i < 10) {
    results.push(output.recv());
    i = i + 1;
}

// Esperar a todos los workers
let i = 0;
while (i < tasks.length) {
    join(tasks[i]);
    i = i + 1;
}
```

## Resumen

El modelo de async/concurrencia de Hemlock proporciona:

- âœ… Verdadero paralelismo multihilo usando hilos del SO
- âœ… Primitivas de concurrencia estructurada simples
- âœ… Canales seguros para hilos para comunicacion
- âœ… Propagacion de excepciones a traves de tareas
- âœ… Rendimiento probado en sistemas multinucleo
- âœ… **Aislamiento de argumentos** - copia profunda previene carreras de datos
- âœ… **Conteo de referencias atomico** - gestion de memoria segura a traves de hilos

Esto hace que Hemlock sea adecuado para:
- Computaciones paralelas
- Operaciones de I/O concurrentes
- Arquitecturas de pipeline
- Patrones productor-consumidor

Mientras evita la complejidad de:
- Gestion manual de hilos
- Primitivas de sincronizacion de bajo nivel
- Disenos basados en bloqueos propensos a deadlocks
- Errores de estado mutable compartido


--------------------------------------------------------------------------------
## EjecuciÃ³n de Comandos
--------------------------------------------------------------------------------

# Ejecucion de Comandos en Hemlock

Hemlock proporciona la **funcion integrada `exec()`** para ejecutar comandos de shell y capturar su salida.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [La Funcion exec()](#la-funcion-exec)
- [Objeto de Resultado](#objeto-de-resultado)
- [Uso Basico](#uso-basico)
- [Ejemplos Avanzados](#ejemplos-avanzados)
- [Manejo de Errores](#manejo-de-errores)
- [Detalles de Implementacion](#detalles-de-implementacion)
- [Consideraciones de Seguridad](#consideraciones-de-seguridad)
- [Limitaciones](#limitaciones)
- [Casos de Uso](#casos-de-uso)
- [Mejores Practicas](#mejores-practicas)
- [Ejemplos Completos](#ejemplos-completos)

## Vision General

La funcion `exec()` permite a los programas de Hemlock:
- Ejecutar comandos de shell
- Capturar salida estandar (stdout)
- Verificar codigos de estado de salida
- Usar caracteristicas del shell (pipes, redirecciones, etc.)
- Integrarse con utilidades del sistema

**Importante:** Los comandos se ejecutan via `/bin/sh`, dando capacidades completas del shell pero tambien introduciendo consideraciones de seguridad.

## La Funcion exec()

### Firma

```hemlock
exec(command: string): object
```

**Parametros:**
- `command` (string) - Comando de shell a ejecutar

**Retorna:** Un objeto con dos campos:
- `output` (string) - La salida stdout del comando
- `exit_code` (i32) - El codigo de estado de salida del comando

### Ejemplo Basico

```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0
```

## Objeto de Resultado

El objeto retornado por `exec()` tiene la siguiente estructura:

```hemlock
{
    output: string,      // stdout del comando (salida capturada)
    exit_code: i32       // Estado de salida del proceso (0 = exito)
}
```

### Campo output

Contiene todo el texto escrito a stdout por el comando.

**Propiedades:**
- Cadena vacia si el comando no produce salida
- Incluye saltos de linea y espacios en blanco tal cual
- Salida multi-linea preservada
- Sin limite de tamano (asignado dinamicamente)

**Ejemplos:**
```hemlock
let r1 = exec("echo test");
print(r1.output);  // "test\n"

let r2 = exec("ls");
print(r2.output);  // Listado de directorio con saltos de linea

let r3 = exec("true");
print(r3.output);  // "" (cadena vacia)
```

### Campo exit_code

El codigo de estado de salida del comando.

**Valores:**
- `0` tipicamente indica exito
- `1-255` indican errores (la convencion varia por comando)
- `-1` si el comando no pudo ejecutarse o termino anormalmente

**Ejemplos:**
```hemlock
let r1 = exec("true");
print(r1.exit_code);  // 0 (exito)

let r2 = exec("false");
print(r2.exit_code);  // 1 (fallo)

let r3 = exec("ls /nonexistent");
print(r3.exit_code);  // 2 (archivo no encontrado, varia por comando)
```

## Uso Basico

### Comando Simple

```hemlock
let r = exec("ls -la");
print(r.output);
print("Exit code: " + typeof(r.exit_code));
```

### Verificando Estado de Salida

```hemlock
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Found: " + r.output);
} else {
    print("Pattern not found");
}
```

### Comandos con Pipes

```hemlock
let r = exec("ps aux | grep hemlock");
print(r.output);
```

### Multiples Comandos

```hemlock
let r = exec("cd /tmp && ls -la");
print(r.output);
```

### Sustitucion de Comandos

```hemlock
let r = exec("echo $(date)");
print(r.output);  // Fecha actual
```

## Ejemplos Avanzados

### Manejando Fallos

```hemlock
let r = exec("ls /nonexistent");
if (r.exit_code != 0) {
    print("Command failed with code: " + typeof(r.exit_code));
    print("Error output: " + r.output);  // Nota: stderr no se captura
}
```

### Procesando Salida Multi-Linea

```hemlock
let r = exec("cat file.txt");
let lines = r.output.split("\n");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Encadenamiento de Comandos

**Con && (AND):**
```hemlock
let r1 = exec("mkdir -p /tmp/test && touch /tmp/test/file.txt");
if (r1.exit_code == 0) {
    print("Setup complete");
}
```

**Con || (OR):**
```hemlock
let r = exec("command1 || command2");
// Ejecuta command2 solo si command1 falla
```

**Con ; (secuencia):**
```hemlock
let r = exec("command1; command2");
// Ejecuta ambos independientemente del exito/fallo
```

### Usando Pipes

```hemlock
let r = exec("echo 'data' | base64");
print("Base64: " + r.output);
```

**Pipelines complejos:**
```hemlock
let r = exec("cat /etc/passwd | grep root | cut -d: -f1");
print(r.output);
```

### Patrones de Codigo de Salida

Diferentes codigos de salida indican diferentes condiciones:

```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
} else if (r.exit_code == 1) {
    print("File does not exist");
} else {
    print("Test command failed: " + typeof(r.exit_code));
}
```

### Redirecciones de Salida

```hemlock
// Redirigir stdout a archivo (dentro del shell)
let r1 = exec("echo 'test' > /tmp/output.txt");

// Redirigir stderr a stdout (Nota: stderr todavia no se captura por Hemlock)
let r2 = exec("command 2>&1");
```

### Variables de Entorno

```hemlock
let r = exec("export VAR=value && echo $VAR");
print(r.output);  // "value\n"
```

### Cambios de Directorio de Trabajo

```hemlock
let r = exec("cd /tmp && pwd");
print(r.output);  // "/tmp\n"
```

## Manejo de Errores

### Cuando exec() Lanza Excepciones

La funcion `exec()` lanza una excepcion si el comando no puede ejecutarse:

```hemlock
try {
    let r = exec("nonexistent_command_xyz");
} catch (e) {
    print("Failed to execute: " + e);
}
```

**Se lanzan excepciones cuando:**
- `popen()` falla (ej. no puede crear pipe)
- Se exceden los limites de recursos del sistema
- Fallos de asignacion de memoria

### Cuando exec() NO Lanza

```hemlock
// El comando se ejecuta pero retorna codigo de salida no cero
let r1 = exec("false");
print(r1.exit_code);  // 1 (no es una excepcion)

// El comando no produce salida
let r2 = exec("true");
print(r2.output);  // "" (no es una excepcion)

// Comando no encontrado por el shell
let r3 = exec("nonexistent_cmd");
print(r3.exit_code);  // 127 (no es una excepcion)
```

### Patron de Ejecucion Segura

```hemlock
fn safe_exec(command: string) {
    try {
        let r = exec(command);
        if (r.exit_code != 0) {
            print("Warning: Command failed with code " + typeof(r.exit_code));
            return "";
        }
        return r.output;
    } catch (e) {
        print("Error executing command: " + e);
        return "";
    }
}

let output = safe_exec("ls -la");
```

## Detalles de Implementacion

### Como Funciona

**Bajo el capo:**
- Usa `popen()` para ejecutar comandos via `/bin/sh`
- Captura solo stdout (stderr no se captura)
- Salida almacenada dinamicamente (comienza en 4KB, crece segun necesidad)
- Estado de salida extraido usando macros `WIFEXITED()` y `WEXITSTATUS()`
- Cadena de salida correctamente terminada en null

**Flujo del proceso:**
1. `popen(command, "r")` crea pipe y bifurca el proceso
2. El proceso hijo ejecuta `/bin/sh -c "command"`
3. El padre lee stdout via pipe a buffer creciente
4. `pclose()` espera al hijo y retorna estado de salida
5. Estado de salida se extrae y almacena en objeto de resultado

### Consideraciones de Rendimiento

**Costos:**
- Crea un nuevo proceso de shell para cada llamada (~1-5ms de sobrecarga)
- Salida almacenada completamente en memoria (no transmitida)
- Sin soporte de streaming (espera a que el comando complete)
- Adecuado para comandos con tamanos de salida razonables

**Optimizaciones:**
- Buffer comienza en 4KB y se duplica cuando esta lleno (uso eficiente de memoria)
- Bucle de lectura unico minimiza llamadas al sistema
- Sin copia adicional de strings

**Cuando usar:**
- Comandos de corta duracion (< 1 segundo)
- Tamano de salida moderado (< 10MB)
- Operaciones por lotes con intervalos razonables

**Cuando NO usar:**
- Daemons o servicios de larga duracion
- Comandos que producen gigabytes de salida
- Procesamiento de datos de streaming en tiempo real
- Ejecucion de alta frecuencia (> 100 llamadas/segundo)

## Consideraciones de Seguridad

### Riesgo de Inyeccion de Shell

âš ï¸ **CRITICO:** Los comandos son ejecutados por el shell (`/bin/sh`), lo que significa que **la inyeccion de shell es posible**.

**Codigo vulnerable:**
```hemlock
// PELIGROSO - NO HACER ESTO
let filename = args[1];  // Entrada de usuario
let r = exec("cat " + filename);  // Inyeccion de shell!
```

**Ataque:**
```bash
./hemlock script.hml "; rm -rf /; echo pwned"
# Ejecuta: cat ; rm -rf /; echo pwned
```

### Practicas Seguras

**1. Nunca usar entrada de usuario sin sanitizar:**
```hemlock
// Malo
let user_input = args[1];
let r = exec("process " + user_input);  // PELIGROSO

// Bueno - validar primero
fn is_safe_filename(name: string): bool {
    // Solo permitir alfanumericos, guion, guion bajo, punto
    let i = 0;
    while (i < name.length) {
        let c = name[i];
        if (!(c >= 'a' && c <= 'z') &&
            !(c >= 'A' && c <= 'Z') &&
            !(c >= '0' && c <= '9') &&
            c != '-' && c != '_' && c != '.') {
            return false;
        }
        i = i + 1;
    }
    return true;
}

let filename = args[1];
if (is_safe_filename(filename)) {
    let r = exec("cat " + filename);
} else {
    print("Invalid filename");
}
```

**2. Usar listas permitidas, no listas denegadas:**
```hemlock
// Bueno - lista estricta de permitidos
let allowed_commands = ["status", "start", "stop", "restart"];
let cmd = args[1];

let found = false;
for (let allowed in allowed_commands) {
    if (cmd == allowed) {
        found = true;
        break;
    }
}

if (found) {
    exec("service myapp " + cmd);
} else {
    print("Invalid command");
}
```

**3. Escapar caracteres especiales:**
```hemlock
fn shell_escape(s: string): string {
    // Escape simple - envolver en comillas simples y escapar comillas simples
    let escaped = s.replace_all("'", "'\\''");
    return "'" + escaped + "'";
}

let user_file = args[1];
let safe = shell_escape(user_file);
let r = exec("cat " + safe);
```

**4. Evitar exec() para operaciones de archivo:**
```hemlock
// Malo - usar exec para operaciones de archivo
let r = exec("cat file.txt");

// Bueno - usar API de archivos de Hemlock
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### Consideraciones de Permisos

Los comandos se ejecutan con los mismos permisos que el proceso de Hemlock:

```hemlock
// Si Hemlock se ejecuta como root, los comandos exec() tambien se ejecutan como root!
let r = exec("rm -rf /important");  // PELIGROSO si se ejecuta como root
```

**Mejor practica:** Ejecutar Hemlock con los privilegios minimos necesarios.

## Limitaciones

### 1. Sin Captura de stderr

Solo stdout se captura, stderr va a la terminal:

```hemlock
let r = exec("ls /nonexistent");
// r.output esta vacio
// El mensaje de error aparece en la terminal, no se captura
```

**Solucion - redirigir stderr a stdout:**
```hemlock
let r = exec("ls /nonexistent 2>&1");
// Ahora los mensajes de error estan en r.output
```

### 2. Sin Streaming

Debe esperar a que el comando complete:

```hemlock
let r = exec("long_running_command");
// Bloquea hasta que el comando termine
// No puede procesar salida incrementalmente
```

### 3. Sin Timeout

Los comandos pueden ejecutarse indefinidamente:

```hemlock
let r = exec("sleep 1000");
// Bloquea por 1000 segundos
// No hay forma de hacer timeout o cancelar
```

**Solucion - usar comando timeout:**
```hemlock
let r = exec("timeout 5 long_command");
// Hara timeout despues de 5 segundos
```

### 4. Sin Manejo de Senales

No se pueden enviar senales a comandos en ejecucion:

```hemlock
let r = exec("long_command");
// No se puede enviar SIGINT, SIGTERM, etc. al comando
```

### 5. Sin Control de Proceso

No se puede interactuar con el comando despues de iniciarlo:

```hemlock
let r = exec("interactive_program");
// No se puede enviar entrada al programa
// No se puede controlar la ejecucion
```

## Casos de Uso

### Buenos Casos de Uso

**1. Ejecutar utilidades del sistema:**
```hemlock
let r = exec("ls -la");
let r = exec("grep pattern file.txt");
let r = exec("find /path -name '*.txt'");
```

**2. Procesamiento rapido de datos con herramientas Unix:**
```hemlock
let r = exec("cat data.txt | sort | uniq | wc -l");
print("Unique lines: " + r.output);
```

**3. Verificar estado del sistema:**
```hemlock
let r = exec("df -h");
print("Disk usage:\n" + r.output);
```

**4. Verificaciones de existencia de archivos:**
```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
}
```

**5. Generar reportes:**
```hemlock
let r = exec("ps aux | grep myapp | wc -l");
let count = r.output.trim();
print("Running instances: " + count);
```

**6. Scripts de automatizacion:**
```hemlock
exec("git add .");
exec("git commit -m 'Auto commit'");
let r = exec("git push");
if (r.exit_code != 0) {
    print("Push failed");
}
```

### No Recomendado Para

**1. Servicios de larga duracion:**
```hemlock
// Malo
let r = exec("nginx");  // Bloquea para siempre
```

**2. Comandos interactivos:**
```hemlock
// Malo - no puede proporcionar entrada
let r = exec("ssh user@host");
```

**3. Comandos que producen salida enorme:**
```hemlock
// Malo - carga toda la salida en memoria
let r = exec("cat 10GB_file.log");
```

**4. Streaming en tiempo real:**
```hemlock
// Malo - no puede procesar salida incrementalmente
let r = exec("tail -f /var/log/app.log");
```

**5. Manejo de errores criticos para la mision:**
```hemlock
// Malo - stderr no se captura
let r = exec("critical_operation");
// No puede ver mensajes de error detallados
```

## Mejores Practicas

### 1. Siempre Verificar Codigos de Salida

```hemlock
let r = exec("important_command");
if (r.exit_code != 0) {
    print("Command failed!");
    // Manejar error
}
```

### 2. Recortar Salida Cuando Sea Necesario

```hemlock
let r = exec("echo test");
let clean = r.output.trim();  // Remover salto de linea final
print(clean);  // "test" (sin salto de linea)
```

### 3. Validar Antes de Ejecutar

```hemlock
fn is_valid_command(cmd: string): bool {
    // Validar que el comando es seguro
    return true;  // Tu logica de validacion
}

if (is_valid_command(user_cmd)) {
    exec(user_cmd);
}
```

### 4. Usar try/catch para Operaciones Criticas

```hemlock
try {
    let r = exec("critical_command");
    if (r.exit_code != 0) {
        throw "Command failed";
    }
} catch (e) {
    print("Error: " + e);
    // Limpieza o recuperacion
}
```

### 5. Preferir APIs de Hemlock Sobre exec()

```hemlock
// Malo - usar exec para operaciones de archivo
let r = exec("cat file.txt");

// Bueno - usar API de archivos de Hemlock
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### 6. Capturar stderr Cuando Sea Necesario

```hemlock
// Redirigir stderr a stdout
let r = exec("command 2>&1");
// Ahora r.output contiene tanto stdout como stderr
```

### 7. Usar Caracteristicas del Shell Sabiamente

```hemlock
// Usar pipes para eficiencia
let r = exec("cat large.txt | grep pattern | head -n 10");

// Usar sustitucion de comandos
let r = exec("echo Current user: $(whoami)");

// Usar ejecucion condicional
let r = exec("test -f file.txt && cat file.txt");
```

## Ejemplos Completos

### Ejemplo 1: Recopilador de Informacion del Sistema

```hemlock
fn get_system_info() {
    print("=== System Information ===");

    // Nombre de host
    let r1 = exec("hostname");
    print("Hostname: " + r1.output.trim());

    // Uptime
    let r2 = exec("uptime");
    print("Uptime: " + r2.output.trim());

    // Uso de disco
    let r3 = exec("df -h /");
    print("\nDisk Usage:");
    print(r3.output);

    // Uso de memoria
    let r4 = exec("free -h");
    print("Memory Usage:");
    print(r4.output);
}

get_system_info();
```

### Ejemplo 2: Analizador de Logs

```hemlock
fn analyze_log(logfile: string) {
    print("Analyzing log: " + logfile);

    // Contar lineas totales
    let r1 = exec("wc -l " + logfile);
    print("Total lines: " + r1.output.trim());

    // Contar errores
    let r2 = exec("grep -c ERROR " + logfile + " 2>/dev/null");
    let errors = r2.output.trim();
    if (r2.exit_code == 0) {
        print("Errors: " + errors);
    } else {
        print("Errors: 0");
    }

    // Contar advertencias
    let r3 = exec("grep -c WARN " + logfile + " 2>/dev/null");
    let warnings = r3.output.trim();
    if (r3.exit_code == 0) {
        print("Warnings: " + warnings);
    } else {
        print("Warnings: 0");
    }

    // Errores recientes
    print("\nRecent errors:");
    let r4 = exec("grep ERROR " + logfile + " | tail -n 5");
    print(r4.output);
}

if (args.length < 2) {
    print("Usage: " + args[0] + " <logfile>");
} else {
    analyze_log(args[1]);
}
```

### Ejemplo 3: Ayudante de Git

```hemlock
fn git_status() {
    let r = exec("git status --short");
    if (r.exit_code != 0) {
        print("Error: Not a git repository");
        return;
    }

    if (r.output == "") {
        print("Working directory clean");
    } else {
        print("Changes:");
        print(r.output);
    }
}

fn git_quick_commit(message: string) {
    print("Adding all changes...");
    let r1 = exec("git add -A");
    if (r1.exit_code != 0) {
        print("Error adding files");
        return;
    }

    print("Committing...");
    let safe_msg = message.replace_all("'", "'\\''");
    let r2 = exec("git commit -m '" + safe_msg + "'");
    if (r2.exit_code != 0) {
        print("Error committing");
        return;
    }

    print("Committed successfully");
    print(r2.output);
}

// Uso
git_status();
if (args.length > 1) {
    git_quick_commit(args[1]);
}
```

### Ejemplo 4: Script de Respaldo

```hemlock
fn backup_directory(source: string, dest: string) {
    print("Backing up " + source + " to " + dest);

    // Crear directorio de respaldo
    let r1 = exec("mkdir -p " + dest);
    if (r1.exit_code != 0) {
        print("Error creating backup directory");
        return false;
    }

    // Crear tarball con marca de tiempo
    let r2 = exec("date +%Y%m%d_%H%M%S");
    let timestamp = r2.output.trim();
    let backup_file = dest + "/backup_" + timestamp + ".tar.gz";

    print("Creating archive: " + backup_file);
    let r3 = exec("tar -czf " + backup_file + " " + source + " 2>&1");
    if (r3.exit_code != 0) {
        print("Error creating backup:");
        print(r3.output);
        return false;
    }

    print("Backup completed successfully");

    // Mostrar tamano del respaldo
    let r4 = exec("du -h " + backup_file);
    print("Backup size: " + r4.output.trim());

    return true;
}

if (args.length < 3) {
    print("Usage: " + args[0] + " <source> <destination>");
} else {
    backup_directory(args[1], args[2]);
}
```

## Resumen

La funcion `exec()` de Hemlock proporciona:

- âœ… Ejecucion simple de comandos de shell
- âœ… Captura de salida (stdout)
- âœ… Verificacion de codigo de salida
- âœ… Acceso completo a caracteristicas del shell (pipes, redirecciones, etc.)
- âœ… Integracion con utilidades del sistema

Recuerda:
- Siempre verificar codigos de salida
- Estar consciente de las implicaciones de seguridad (inyeccion de shell)
- Validar entrada de usuario antes de usar en comandos
- Preferir APIs de Hemlock sobre exec() cuando esten disponibles
- stderr no se captura (usar `2>&1` para redirigir)
- Los comandos bloquean hasta completar
- Usar para utilidades de corta duracion, no servicios de larga duracion

**Lista de verificacion de seguridad:**
- âŒ Nunca usar entrada de usuario sin sanitizar
- âœ… Validar toda entrada
- âœ… Usar listas de permitidos para comandos
- âœ… Escapar caracteres especiales cuando sea necesario
- âœ… Ejecutar con privilegios minimos
- âœ… Preferir APIs de Hemlock sobre comandos de shell


--------------------------------------------------------------------------------
## Empaquetado y DistribuciÃ³n
--------------------------------------------------------------------------------

# Empaquetado y Distribucion

Hemlock proporciona herramientas integradas para empaquetar proyectos de multiples archivos en archivos distribuibles unicos y crear ejecutables autocontenidos.

## Vision General

| Comando | Salida | Caso de Uso |
|---------|--------|-------------|
| `--bundle` | `.hmlc` o `.hmlb` | Distribuir bytecode (requiere Hemlock para ejecutar) |
| `--package` | Ejecutable | Binario independiente (sin dependencias) |
| `--compile` | `.hmlc` | Compilar archivo unico (sin resolucion de imports) |

## Empaquetado (Bundling)

El empaquetador resuelve todas las sentencias `import` desde un punto de entrada y las aplana en un solo archivo.

### Uso Basico

```bash
# Empaquetar app.hml y todos sus imports en app.hmlc
hemlock --bundle app.hml

# Especificar ruta de salida
hemlock --bundle app.hml -o dist/app.hmlc

# Crear paquete comprimido (.hmlb) - tamano de archivo mas pequeno
hemlock --bundle app.hml --compress -o app.hmlb

# Salida detallada (muestra modulos resueltos)
hemlock --bundle app.hml --verbose
```

### Formatos de Salida

**`.hmlc` (Sin comprimir)**
- Formato AST serializado
- Rapido de cargar y ejecutar
- Formato de salida por defecto

**`.hmlb` (Comprimido)**
- `.hmlc` comprimido con zlib
- Tamano de archivo mas pequeno (tipicamente 50-70% de reduccion)
- Inicio ligeramente mas lento debido a la descompresion

### Ejecutando Archivos Empaquetados

```bash
# Ejecutar paquete sin comprimir
hemlock app.hmlc

# Ejecutar paquete comprimido
hemlock app.hmlb

# Pasar argumentos
hemlock app.hmlc arg1 arg2
```

### Ejemplo: Proyecto Multi-Modulo

```
myapp/
â”œâ”€â”€ main.hml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ math.hml
â”‚   â””â”€â”€ utils.hml
â””â”€â”€ config.hml
```

```hemlock
// main.hml
import { add, multiply } from "./lib/math.hml";
import { log } from "./lib/utils.hml";
import { VERSION } from "./config.hml";

log(`App v${VERSION}`);
print(add(2, 3));
```

```bash
hemlock --bundle myapp/main.hml -o myapp.hmlc
hemlock myapp.hmlc  # Se ejecuta con todas las dependencias empaquetadas
```

### Imports de stdlib

El empaquetador resuelve automaticamente imports de `@stdlib/`:

```hemlock
import { HashMap } from "@stdlib/collections";
import { now } from "@stdlib/time";
```

Cuando se empaqueta, los modulos de stdlib se incluyen en la salida.

## Empaquetado como Ejecutable

El empaquetado crea un ejecutable autocontenido incrustando el bytecode empaquetado en una copia del interprete de Hemlock.

### Uso Basico

```bash
# Crear ejecutable desde app.hml
hemlock --package app.hml

# Especificar nombre de salida
hemlock --package app.hml -o myapp

# Saltar compresion (inicio mas rapido, archivo mas grande)
hemlock --package app.hml --no-compress

# Salida detallada
hemlock --package app.hml --verbose
```

### Ejecutando Ejecutables Empaquetados

```bash
# El ejecutable empaquetado se ejecuta directamente
./myapp

# Los argumentos se pasan al script
./myapp arg1 arg2
```

### Formato de Paquete

Los ejecutables empaquetados usan el formato HMLP:

```
[binario hemlock][carga HMLB/HMLC][tamano_carga:u64][magic HMLP:u32]
```

Cuando un ejecutable empaquetado se ejecuta:
1. Verifica si hay una carga incrustada al final del archivo
2. Si la encuentra, descomprime y ejecuta la carga
3. Si no la encuentra, se comporta como un interprete normal de Hemlock

### Opciones de Compresion

| Flag | Formato | Inicio | Tamano |
|------|---------|--------|--------|
| (por defecto) | HMLB | Normal | Mas pequeno |
| `--no-compress` | HMLC | Mas rapido | Mas grande |

Para herramientas CLI donde el tiempo de inicio importa, usa `--no-compress`.

## Inspeccionando Paquetes

Usa `--info` para inspeccionar archivos empaquetados o compilados:

```bash
hemlock --info app.hmlc
```

Salida:
```
=== File Info: app.hmlc ===
Size: 12847 bytes
Format: HMLC (compiled AST)
Version: 1
Flags: 0x0001 [DEBUG]
Strings: 42
Statements: 156
```

```bash
hemlock --info app.hmlb
```

Salida:
```
=== File Info: app.hmlb ===
Size: 5234 bytes
Format: HMLB (compressed bundle)
Version: 1
Uncompressed: 12847 bytes
Compressed: 5224 bytes
Ratio: 59.3% reduction
```

## Compilacion Nativa

Para ejecutables verdaderamente nativos (sin interprete), usa el compilador de Hemlock:

```bash
# Compilar a ejecutable nativo via C
hemlockc app.hml -o app

# Mantener codigo C generado
hemlockc app.hml -o app --keep-c

# Emitir solo C (no compilar)
hemlockc app.hml -c -o app.c

# Nivel de optimizacion
hemlockc app.hml -o app -O2
```

El compilador genera codigo C e invoca GCC para producir un binario nativo. Esto requiere:
- La biblioteca de runtime de Hemlock (`libhemlock_runtime`)
- Un compilador de C (GCC por defecto)

### Opciones del Compilador

| Opcion | Descripcion |
|--------|-------------|
| `-o <file>` | Nombre del ejecutable de salida |
| `-c` | Emitir solo codigo C |
| `--emit-c <file>` | Escribir C al archivo especificado |
| `-k, --keep-c` | Mantener C generado despues de compilacion |
| `-O<level>` | Nivel de optimizacion (0-3) |
| `--cc <path>` | Compilador de C a usar |
| `--runtime <path>` | Ruta a la biblioteca de runtime |
| `-v, --verbose` | Salida detallada |

## Comparacion

| Enfoque | Portabilidad | Inicio | Tamano | Dependencias |
|---------|--------------|--------|--------|--------------|
| `.hml` | Solo fuente | Tiempo de parseo | Mas pequeno | Hemlock |
| `.hmlc` | Solo Hemlock | Rapido | Pequeno | Hemlock |
| `.hmlb` | Solo Hemlock | Rapido | Mas pequeno | Hemlock |
| `--package` | Independiente | Rapido | Mas grande | Ninguna |
| `hemlockc` | Nativo | Mas rapido | Variable | Libs de runtime |

## Mejores Practicas

1. **Desarrollo**: Ejecutar archivos `.hml` directamente para iteracion rapida
2. **Distribucion (con Hemlock)**: Empaquetar con `--compress` para archivos mas pequenos
3. **Distribucion (independiente)**: Empaquetar como ejecutable para despliegue sin dependencias
4. **Critico en rendimiento**: Usar `hemlockc` para compilacion nativa

## Solucion de Problemas

### "Cannot find stdlib"

El empaquetador busca stdlib en:
1. `./stdlib` (relativo al ejecutable)
2. `../stdlib` (relativo al ejecutable)
3. `/usr/local/lib/hemlock/stdlib`

Asegurate de que Hemlock este correctamente instalado o ejecuta desde el directorio fuente.

### Dependencias Circulares

```
Error: Circular dependency detected when loading 'path/to/module.hml'
```

Refactoriza tus imports para romper el ciclo. Considera usar un modulo compartido para tipos comunes.

### Tamano Grande de Paquete

- Usa compresion por defecto (no uses `--no-compress`)
- El tamano empaquetado incluye el interprete completo (~500KB-1MB base)
- Para tamano minimo, usa `hemlockc` para compilacion nativa


--------------------------------------------------------------------------------
## FFI
--------------------------------------------------------------------------------

# Interfaz de Funciones Foraneas (FFI) en Hemlock

Hemlock proporciona **FFI (Interfaz de Funciones Foraneas)** para llamar funciones de C desde bibliotecas compartidas usando libffi, habilitando la integracion con bibliotecas C existentes y APIs del sistema.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [Estado Actual](#estado-actual)
- [Tipos Soportados](#tipos-soportados)
- [Conceptos Basicos](#conceptos-basicos)
- [Exportando Funciones FFI](#exportando-funciones-ffi)
- [Casos de Uso](#casos-de-uso)
- [Desarrollo Futuro](#desarrollo-futuro)
- [Callbacks FFI](#callbacks-ffi)
- [Structs FFI](#structs-ffi)
- [Exportando Tipos de Struct](#exportando-tipos-de-struct)
- [Limitaciones Actuales](#limitaciones-actuales)
- [Mejores Practicas](#mejores-practicas)

## Vision General

La Interfaz de Funciones Foraneas (FFI) permite a los programas de Hemlock:
- Llamar funciones de C desde bibliotecas compartidas (.so, .dylib, .dll)
- Usar bibliotecas C existentes sin escribir codigo envolvente
- Acceder a APIs del sistema directamente
- Integrarse con bibliotecas nativas de terceros
- Conectar Hemlock con funcionalidad de bajo nivel del sistema

**Capacidades clave:**
- Carga dinamica de bibliotecas
- Vinculacion de funciones C
- Conversion automatica de tipos entre Hemlock y tipos C
- Soporte para todos los tipos primitivos
- Implementacion basada en libffi para portabilidad

## Estado Actual

El soporte FFI esta disponible en Hemlock con las siguientes caracteristicas:

**Implementado:**
- âœ… Llamar funciones C desde bibliotecas compartidas
- âœ… Soporte para todos los tipos primitivos (enteros, flotantes, punteros)
- âœ… Conversion automatica de tipos
- âœ… Implementacion basada en libffi
- âœ… Carga dinamica de bibliotecas
- âœ… **Callbacks de punteros a funcion** - Pasar funciones de Hemlock a C
- âœ… **Exportar funciones extern** - Compartir bindings FFI entre modulos
- âœ… **Paso de structs y valores de retorno** - Pasar structs compatibles con C por valor
- âœ… **Ayudantes de puntero completos** - Leer/escribir todos los tipos (i8-i64, u8-u64, f32, f64, ptr)
- âœ… **Conversion buffer/puntero** - `buffer_ptr()`, `ptr_to_buffer()`
- âœ… **Tamanos de tipos FFI** - `ffi_sizeof()` para tamanos de tipo conscientes de la plataforma
- âœ… **Tipos de plataforma** - Soporte para `size_t`, `usize`, `isize`, `intptr_t`

**En Desarrollo:**
- ðŸ”„ Ayudantes de marshaling de strings
- ðŸ”„ Mejoras en manejo de errores

**Cobertura de Pruebas:**
- Pruebas FFI pasando incluyendo pruebas de callback
- Llamada basica de funciones verificada
- Conversion de tipos probada
- Integracion de callback qsort probada

## Tipos Soportados

### Tipos Primitivos

Los siguientes tipos de Hemlock pueden pasarse a/desde funciones C:

| Tipo Hemlock | Tipo C | Tamano | Notas |
|--------------|--------|--------|-------|
| `i8` | `int8_t` | 1 byte | Entero con signo de 8 bits |
| `i16` | `int16_t` | 2 bytes | Entero con signo de 16 bits |
| `i32` | `int32_t` | 4 bytes | Entero con signo de 32 bits |
| `i64` | `int64_t` | 8 bytes | Entero con signo de 64 bits |
| `u8` | `uint8_t` | 1 byte | Entero sin signo de 8 bits |
| `u16` | `uint16_t` | 2 bytes | Entero sin signo de 16 bits |
| `u32` | `uint32_t` | 4 bytes | Entero sin signo de 32 bits |
| `u64` | `uint64_t` | 8 bytes | Entero sin signo de 64 bits |
| `f32` | `float` | 4 bytes | Punto flotante de 32 bits |
| `f64` | `double` | 8 bytes | Punto flotante de 64 bits |
| `ptr` | `void*` | 8 bytes | Puntero crudo |

### Conversion de Tipos

**Conversiones automaticas:**
- Enteros de Hemlock â†’ Enteros de C (con verificacion de rango)
- Flotantes de Hemlock â†’ Flotantes de C
- Punteros de Hemlock â†’ Punteros de C
- Valores de retorno de C â†’ Valores de Hemlock

**Mapeos de tipo de ejemplo:**
```hemlock
// Hemlock â†’ C
let i: i32 = 42;         // â†’ int32_t (4 bytes)
let f: f64 = 3.14;       // â†’ double (8 bytes)
let p: ptr = alloc(64);  // â†’ void* (8 bytes)

// C â†’ Hemlock (valores de retorno)
// int32_t foo() â†’ i32
// double bar() â†’ f64
// void* baz() â†’ ptr
```

## Conceptos Basicos

### Bibliotecas Compartidas

FFI funciona con bibliotecas compartidas compiladas:

**Linux:** archivos `.so`
```
libexample.so
/usr/lib/libm.so
```

**macOS:** archivos `.dylib`
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows:** archivos `.dll`
```
example.dll
kernel32.dll
```

### Firmas de Funcion

Las funciones C deben tener firmas conocidas para que FFI funcione correctamente:

```c
// Firmas de funcion C de ejemplo
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

Estas pueden llamarse desde Hemlock una vez que la biblioteca este cargada y las funciones vinculadas.

### Compatibilidad de Plataforma

FFI usa **libffi** para portabilidad:
- Funciona en x86, x86-64, ARM, ARM64
- Maneja convenciones de llamada automaticamente
- Abstrae detalles ABI especificos de la plataforma
- Soporta Linux, macOS, Windows (con libffi apropiado)

## Exportando Funciones FFI

Las funciones FFI declaradas con `extern fn` pueden exportarse desde modulos, permitiendote crear envoltorios de biblioteca reutilizables que pueden compartirse entre multiples archivos.

### Sintaxis Basica de Exportacion

```hemlock
// string_utils.hml - Un modulo de biblioteca envolviendo funciones de strings de C
import "libc.so.6";

// Exportar la funcion extern directamente
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// Tambien puedes exportar funciones envolventes junto con funciones extern
export fn string_length(s: string): i32 {
    return strlen(s);
}

export fn strings_equal(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### Importando Funciones FFI Exportadas

```hemlock
// main.hml - Usando las funciones FFI exportadas
import { strlen, string_length, strings_equal } from "./string_utils.hml";

let msg = "Hello, World!";
print(strlen(msg));           // 13 - llamada extern directa
print(string_length(msg));    // 13 - funcion envolvente

print(strings_equal("foo", "foo"));  // true
print(strings_equal("foo", "bar"));  // false
```

### Casos de Uso para Export Extern

**1. Abstraccion de Plataforma**
```hemlock
// platform.hml - Abstraer diferencias de plataforma
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. Envoltorios de Biblioteca**
```hemlock
// crypto_lib.hml - Envolver funciones de biblioteca crypto
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Agregar envoltorios amigables para Hemlock
export fn sha256_string(s: string): string {
    // Implementacion usando la funcion extern
}
```

**3. Declaraciones FFI Centralizadas**
```hemlock
// libc.hml - Modulo central para bindings de libc
import "libc.so.6";

// Funciones de string
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// Funciones de memoria
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// Funciones de proceso
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

Luego usar en todo tu proyecto:
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

### Combinando con Exportaciones Regulares

Puedes mezclar funciones extern exportadas con exportaciones de funciones regulares:

```hemlock
// math_extended.hml
import "libm.so.6";

// Exportar funciones C crudas
export extern fn sin(x: f64): f64;
export extern fn cos(x: f64): f64;
export extern fn tan(x: f64): f64;

// Exportar funciones de Hemlock que las usan
export fn deg_to_rad(degrees: f64): f64 {
    return degrees * 3.14159265359 / 180.0;
}

export fn sin_degrees(degrees: f64): f64 {
    return sin(deg_to_rad(degrees));
}
```

### Bibliotecas Especificas de Plataforma

Al exportar funciones extern, recuerda que los nombres de biblioteca difieren por plataforma:

```hemlock
// Para Linux
import "libc.so.6";

// Para macOS (enfoque diferente necesario)
import "libSystem.B.dylib";
```

Actualmente, la sintaxis `import "library"` de Hemlock usa rutas de biblioteca estaticas, por lo que pueden necesitarse modulos especificos de plataforma para codigo FFI multiplataforma.

## Casos de Uso

### 1. Bibliotecas del Sistema

Acceder a funciones de la biblioteca estandar de C:

**Funciones matematicas:**
```hemlock
// Llamar sqrt desde libm
let result = sqrt(16.0);  // 4.0
```

**Asignacion de memoria:**
```hemlock
// Llamar malloc/free desde libc
let ptr = malloc(1024);
free(ptr);
```

### 2. Bibliotecas de Terceros

Usar bibliotecas C existentes:

**Ejemplo: Procesamiento de imagenes**
```hemlock
// Cargar libpng o libjpeg
// Procesar imagenes usando funciones de biblioteca C
```

**Ejemplo: Criptografia**
```hemlock
// Usar OpenSSL o libsodium
// Encriptacion/desencriptacion via FFI
```

### 3. APIs del Sistema

Llamadas al sistema directas:

**Ejemplo: APIs POSIX**
```hemlock
// Llamar getpid, getuid, etc.
// Acceder a funcionalidad de bajo nivel del sistema
```

### 4. Codigo Critico en Rendimiento

Llamar implementaciones C optimizadas:

```hemlock
// Usar bibliotecas C altamente optimizadas
// Operaciones SIMD, codigo vectorizado
// Funciones aceleradas por hardware
```

### 5. Acceso a Hardware

Interfaz con bibliotecas de hardware:

```hemlock
// Control GPIO en sistemas embebidos
// Comunicacion con dispositivos USB
// Acceso a puerto serial
```

### 6. Integracion de Codigo Legado

Reutilizar bases de codigo C existentes:

```hemlock
// Llamar funciones de aplicaciones C legadas
// Migrar gradualmente a Hemlock
// Preservar codigo C funcionando
```

## Desarrollo Futuro

### Caracteristicas Planeadas

**1. Soporte de Structs**
```hemlock
// Futuro: Pasar/retornar structs de C
define Point {
    x: f64,
    y: f64,
}

let p = Point { x: 1.0, y: 2.0 };
c_function_with_struct(p);
```

**2. Manejo de Arrays/Buffers**
```hemlock
// Futuro: Mejor paso de arrays
let arr = [1, 2, 3, 4, 5];
process_array(arr);  // Pasar a funcion C
```

**3. Callbacks de Punteros a Funcion** âœ… (Implementado!)
```hemlock
// Pasar funciones de Hemlock a C como callbacks
fn my_compare(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    return va - vb;
}

// Crear un puntero a funcion llamable desde C
let cmp = callback(my_compare, ["ptr", "ptr"], "i32");

// Usar con qsort o cualquier funcion C que espera un callback
qsort(arr, count, elem_size, cmp);

// Limpiar cuando termines
callback_free(cmp);
```

**4. Marshaling de Strings**
```hemlock
// Futuro: Conversion automatica de strings
let s = "hello";
c_string_function(s);  // Auto-convertir a string C
```

**5. Manejo de Errores**
```hemlock
// Futuro: Mejor reporte de errores
try {
    let result = risky_c_function();
} catch (e) {
    print("FFI error: " + e);
}
```

**6. Seguridad de Tipos**
```hemlock
// Futuro: Anotaciones de tipo para FFI
@ffi("libm.so")
fn sqrt(x: f64): f64;

let result = sqrt(16.0);  // Verificado por tipos
```

### Caracteristicas

**v1.0:**
- âœ… FFI basico con tipos primitivos
- âœ… Carga dinamica de bibliotecas
- âœ… Llamada de funciones
- âœ… Soporte de callbacks via clausuras libffi

**Futuro:**
- Soporte de structs
- Mejoras en manejo de arrays
- Generacion automatica de bindings

## Callbacks FFI

Hemlock soporta pasar funciones a codigo C como callbacks usando clausuras libffi. Esto habilita la integracion con APIs de C que esperan punteros a funcion, como `qsort`, bucles de eventos y bibliotecas basadas en callbacks.

### Creando Callbacks

Usa `callback()` para crear un puntero a funcion llamable desde C a partir de una funcion de Hemlock:

```hemlock
// callback(function, param_types, return_type) -> ptr
let cb = callback(my_function, ["ptr", "ptr"], "i32");
```

**Parametros:**
- `function`: Una funcion de Hemlock para envolver
- `param_types`: Array de strings de nombres de tipo (ej. `["ptr", "i32"]`)
- `return_type`: String de tipo de retorno (ej. `"i32"`, `"void"`)

**Tipos de callback soportados:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Enteros con signo
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Enteros sin signo
- `"f32"`, `"f64"` - Punto flotante
- `"ptr"` - Puntero
- `"void"` - Sin valor de retorno
- `"bool"` - Booleano

### Ejemplo: qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// Funcion de comparacion para enteros (orden ascendente)
fn compare_ints(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// Asignar array de 5 enteros
let arr = alloc(20);  // 5 * 4 bytes
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// Crear callback y ordenar
let cmp = callback(compare_ints, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// El array ahora esta ordenado: [1, 2, 5, 8, 9]

// Limpiar
callback_free(cmp);
free(arr);
```

### Funciones Auxiliares de Puntero

Hemlock proporciona funciones auxiliares completas para trabajar con punteros crudos. Estas son esenciales para callbacks FFI y manipulacion directa de memoria.

#### Auxiliares de Tipos Enteros

| Funcion | Descripcion |
|---------|-------------|
| `ptr_deref_i8(ptr)` | Dereferenciar puntero, leer i8 |
| `ptr_deref_i16(ptr)` | Dereferenciar puntero, leer i16 |
| `ptr_deref_i32(ptr)` | Dereferenciar puntero, leer i32 |
| `ptr_deref_i64(ptr)` | Dereferenciar puntero, leer i64 |
| `ptr_deref_u8(ptr)` | Dereferenciar puntero, leer u8 |
| `ptr_deref_u16(ptr)` | Dereferenciar puntero, leer u16 |
| `ptr_deref_u32(ptr)` | Dereferenciar puntero, leer u32 |
| `ptr_deref_u64(ptr)` | Dereferenciar puntero, leer u64 |
| `ptr_write_i8(ptr, value)` | Escribir i8 en ubicacion del puntero |
| `ptr_write_i16(ptr, value)` | Escribir i16 en ubicacion del puntero |
| `ptr_write_i32(ptr, value)` | Escribir i32 en ubicacion del puntero |
| `ptr_write_i64(ptr, value)` | Escribir i64 en ubicacion del puntero |
| `ptr_write_u8(ptr, value)` | Escribir u8 en ubicacion del puntero |
| `ptr_write_u16(ptr, value)` | Escribir u16 en ubicacion del puntero |
| `ptr_write_u32(ptr, value)` | Escribir u32 en ubicacion del puntero |
| `ptr_write_u64(ptr, value)` | Escribir u64 en ubicacion del puntero |

#### Auxiliares de Tipos Flotantes

| Funcion | Descripcion |
|---------|-------------|
| `ptr_deref_f32(ptr)` | Dereferenciar puntero, leer f32 (float) |
| `ptr_deref_f64(ptr)` | Dereferenciar puntero, leer f64 (double) |
| `ptr_write_f32(ptr, value)` | Escribir f32 en ubicacion del puntero |
| `ptr_write_f64(ptr, value)` | Escribir f64 en ubicacion del puntero |

#### Auxiliares de Tipos Puntero

| Funcion | Descripcion |
|---------|-------------|
| `ptr_deref_ptr(ptr)` | Dereferenciar puntero a puntero |
| `ptr_write_ptr(ptr, value)` | Escribir puntero en ubicacion del puntero |
| `ptr_offset(ptr, index, size)` | Calcular desplazamiento: `ptr + index * size` |
| `ptr_read_i32(ptr)` | Leer i32 a traves de puntero a puntero (para callbacks qsort) |
| `ptr_null()` | Obtener una constante de puntero nulo |

#### Auxiliares de Conversion de Buffer

| Funcion | Descripcion |
|---------|-------------|
| `buffer_ptr(buffer)` | Obtener puntero crudo de un buffer |
| `ptr_to_buffer(ptr, size)` | Copiar datos de puntero a un nuevo buffer |

#### Funciones de Utilidad FFI

| Funcion | Descripcion |
|---------|-------------|
| `ffi_sizeof(type_name)` | Obtener tamano en bytes de un tipo FFI |

**Nombres de tipo soportados para `ffi_sizeof`:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Enteros con signo (1, 2, 4, 8 bytes)
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Enteros sin signo (1, 2, 4, 8 bytes)
- `"f32"`, `"f64"` - Flotantes (4, 8 bytes)
- `"ptr"` - Puntero (8 bytes en 64-bit)
- `"size_t"`, `"usize"` - Tipo de tamano dependiente de plataforma
- `"intptr_t"`, `"isize"` - Tipo de puntero con signo dependiente de plataforma

#### Ejemplo: Trabajando con Diferentes Tipos

```hemlock
let p = alloc(64);

// Escribir y leer enteros
ptr_write_i8(p, 42);
print(ptr_deref_i8(p));  // 42

ptr_write_i64(ptr_offset(p, 1, 8), 9000000000);
print(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000

// Escribir y leer flotantes
ptr_write_f64(p, 3.14159);
print(ptr_deref_f64(p));  // 3.14159

// Puntero a puntero
let inner = alloc(4);
ptr_write_i32(inner, 999);
ptr_write_ptr(p, inner);
let retrieved = ptr_deref_ptr(p);
print(ptr_deref_i32(retrieved));  // 999

// Obtener tamanos de tipo
print(ffi_sizeof("i64"));  // 8
print(ffi_sizeof("ptr"));  // 8 (en 64-bit)

// Conversion de buffer
let buf = buffer(64);
ptr_write_i32(buffer_ptr(buf), 12345);
print(ptr_deref_i32(buffer_ptr(buf)));  // 12345

free(inner);
free(p);
```

### Liberando Callbacks

**Importante:** Siempre liberar callbacks cuando termines para prevenir fugas de memoria:

```hemlock
let cb = callback(my_fn, ["ptr"], "void");
// ... usar callback ...
callback_free(cb);  // Liberar cuando termines
```

Los callbacks tambien se liberan automaticamente cuando el programa termina.

### Clausuras en Callbacks

Los callbacks capturan su entorno de clausura, por lo que pueden acceder a variables del ambito exterior:

```hemlock
let multiplier = 10;

fn scale(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // Puede acceder a 'multiplier' del ambito exterior
    return (va * multiplier) - (vb * multiplier);
}

let cmp = callback(scale, ["ptr", "ptr"], "i32");
```

### Seguridad de Hilos

Las invocaciones de callback se serializan con un mutex para asegurar seguridad de hilos, ya que el interprete de Hemlock no es completamente seguro para hilos. Esto significa:
- Solo un callback puede ejecutarse a la vez
- Seguro de usar con bibliotecas C multihilo
- Puede impactar rendimiento si los callbacks se llaman muy frecuentemente desde multiples hilos

### Manejo de Errores en Callbacks

Las excepciones lanzadas en callbacks no pueden propagarse a codigo C. En su lugar:
- Se imprime una advertencia a stderr
- El callback retorna un valor por defecto (0 o NULL)
- La excepcion se registra pero no se propaga

```hemlock
fn risky_callback(a: ptr): i32 {
    throw "Something went wrong";  // Advertencia impresa, retorna 0
}
```

Para manejo de errores robusto, valida las entradas y evita lanzar en callbacks.

## Structs FFI

Hemlock soporta pasar structs por valor a funciones C. Los tipos de struct se registran automaticamente para FFI cuando los defines con anotaciones de tipo.

### Definiendo Structs Compatibles con FFI

Un struct es compatible con FFI cuando todos los campos tienen anotaciones de tipo explicitas usando tipos compatibles con FFI:

```hemlock
// Struct compatible con FFI
define Point {
    x: f64,
    y: f64,
}

// Struct compatible con FFI con multiples tipos de campo
define Rectangle {
    top_left: Point,      // Struct anidado
    width: f64,
    height: f64,
}

// NO compatible con FFI (campo sin anotacion de tipo)
define DynamicObject {
    name,                 // Sin tipo - no usable en FFI
    value,
}
```

### Usando Structs en FFI

Declarar funciones extern que usan tipos de struct:

```hemlock
// Definir el tipo de struct
define Vector2D {
    x: f64,
    y: f64,
}

// Importar la biblioteca C
import "libmath.so";

// Declarar funcion extern que toma/retorna structs
extern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;
extern fn vector_length(v: Vector2D): f64;

// Usarlo naturalmente
let a: Vector2D = { x: 3.0, y: 0.0 };
let b: Vector2D = { x: 0.0, y: 4.0 };
let result = vector_add(a, b);
print(result.x);  // 3.0
print(result.y);  // 4.0

let len = vector_length(result);
print(len);       // 5.0
```

### Tipos de Campo Soportados

Los campos de struct deben usar estos tipos compatibles con FFI:

| Tipo Hemlock | Tipo C | Tamano |
|--------------|--------|--------|
| `i8` | `int8_t` | 1 byte |
| `i16` | `int16_t` | 2 bytes |
| `i32` | `int32_t` | 4 bytes |
| `i64` | `int64_t` | 8 bytes |
| `u8` | `uint8_t` | 1 byte |
| `u16` | `uint16_t` | 2 bytes |
| `u32` | `uint32_t` | 4 bytes |
| `u64` | `uint64_t` | 8 bytes |
| `f32` | `float` | 4 bytes |
| `f64` | `double` | 8 bytes |
| `ptr` | `void*` | 8 bytes |
| `string` | `char*` | 8 bytes |
| `bool` | `int` | varia |
| Struct anidado | struct | varia |

### Layout de Struct

Hemlock usa las reglas de layout de struct nativas de la plataforma (coincidiendo con la ABI de C):
- Los campos se alinean segun su tipo
- Se inserta padding segun necesidad
- El tamano total se rellena para alinear al miembro mas grande

```hemlock
// Ejemplo: layout compatible con C
define Mixed {
    a: i8,    // offset 0, tamano 1
              // 3 bytes padding
    b: i32,   // offset 4, tamano 4
}
// Tamano total: 8 bytes (con padding)

define Point3D {
    x: f64,   // offset 0, tamano 8
    y: f64,   // offset 8, tamano 8
    z: f64,   // offset 16, tamano 8
}
// Tamano total: 24 bytes (sin padding necesario)
```

### Structs Anidados

Los structs pueden contener otros structs:

```hemlock
define Inner {
    x: i32,
    y: i32,
}

define Outer {
    inner: Inner,
    z: i32,
}

import "mylib.so";
extern fn process_nested(data: Outer): i32;

let obj: Outer = {
    inner: { x: 1, y: 2 },
    z: 3,
};
let result = process_nested(obj);
```

### Valores de Retorno de Struct

Las funciones C pueden retornar structs:

```hemlock
define Point {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn get_origin(): Point;

let p = get_origin();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### Limitaciones

- **Los campos de struct deben tener anotaciones de tipo** - campos sin tipos no son compatibles con FFI
- **Sin arrays en structs** - usar punteros en su lugar
- **Sin unions** - solo tipos struct son soportados
- **Los callbacks no pueden retornar structs** - usar punteros para valores de retorno de callback

### Exportando Tipos de Struct

Puedes exportar definiciones de tipo de struct desde un modulo usando `export define`:

```hemlock
// geometry.hml
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}

export fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {
    return { x: x, y: y, width: w, height: h };
}
```

**Importante:** Los tipos de struct exportados se registran **globalmente** cuando el modulo se carga. Se vuelven disponibles automaticamente cuando importas cualquier cosa del modulo. NO necesitas (y no puedes) importarlos explicitamente por nombre:

```hemlock
// main.hml

// BUENO - los tipos de struct estan auto-disponibles despues de cualquier import del modulo
import { create_rect } from "./geometry.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };      // Funciona - Vector2 esta globalmente disponible
let r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Funciona

// MALO - no se pueden importar tipos de struct explicitamente por nombre
import { Vector2 } from "./geometry.hml";  // Error: Undefined variable 'Vector2'
```

Este comportamiento existe porque los tipos de struct se registran en el registro global de tipos cuando el modulo carga, en lugar de almacenarse como valores en el entorno de exportacion del modulo. El tipo se vuelve disponible para todo el codigo que importa del modulo.

## Limitaciones Actuales

FFI tiene las siguientes limitaciones:

**1. Conversion Manual de Tipos**
- Debe gestionar manualmente conversiones de strings
- Sin conversion automatica de string Hemlock â†” string C

**2. Manejo de Errores Limitado**
- Reporte basico de errores
- Las excepciones en callbacks no pueden propagarse a C

**3. Carga Manual de Bibliotecas**
- Debe cargar manualmente las bibliotecas
- Sin generacion automatica de bindings

**4. Codigo Especifico de Plataforma**
- Las rutas de biblioteca difieren por plataforma
- Debe manejar .so vs .dylib vs .dll

## Mejores Practicas

Mientras la documentacion completa de FFI todavia esta siendo desarrollada, aqui hay mejores practicas generales:

### 1. Seguridad de Tipos

```hemlock
// Ser explicito sobre tipos
let x: i32 = 42;
let result: f64 = c_function(x);
```

### 2. Gestion de Memoria

```hemlock
// Recordar liberar memoria asignada
let ptr = c_malloc(1024);
// ... usar ptr
c_free(ptr);
```

### 3. Verificacion de Errores

```hemlock
// Verificar valores de retorno
let result = c_function();
if (result == null) {
    print("C function failed");
}
```

### 4. Compatibilidad de Plataforma

```hemlock
// Manejar diferencias de plataforma
// Usar extensiones de biblioteca apropiadas (.so, .dylib, .dll)
```

## Ejemplos

Para ejemplos funcionales, referirse a:
- Pruebas de callback: `/tests/ffi_callbacks/` - ejemplos de callback qsort
- Uso de FFI en stdlib: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`
- Programas de ejemplo: `/examples/` (si estan disponibles)

## Obteniendo Ayuda

FFI es una caracteristica mas nueva en Hemlock. Para preguntas o problemas:

1. Verificar la suite de pruebas para ejemplos funcionales
2. Referirse a documentacion de libffi para detalles de bajo nivel
3. Reportar bugs o solicitar caracteristicas via issues del proyecto

## Resumen

El FFI de Hemlock proporciona:

- âœ… Llamada de funciones C desde bibliotecas compartidas
- âœ… Soporte de tipos primitivos (i8-i64, u8-u64, f32, f64, ptr)
- âœ… Conversion automatica de tipos
- âœ… Portabilidad basada en libffi
- âœ… Base para integracion de bibliotecas nativas
- âœ… **Callbacks de punteros a funcion** - pasar funciones de Hemlock a C
- âœ… **Exportar funciones extern** - compartir bindings FFI entre modulos
- âœ… **Paso y retorno de structs** - pasar structs compatibles con C por valor
- âœ… **Export define** - compartir definiciones de tipo de struct entre modulos (auto-importados globalmente)
- âœ… **Auxiliares de puntero completos** - leer/escribir todos los tipos (i8-i64, u8-u64, f32, f64, ptr)
- âœ… **Conversion buffer/puntero** - `buffer_ptr()`, `ptr_to_buffer()` para marshaling de datos
- âœ… **Tamanos de tipos FFI** - `ffi_sizeof()` para tamanos de tipo conscientes de plataforma
- âœ… **Tipos de plataforma** - soporte para `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`

**Estado actual:** FFI completamente caracterizado con tipos primitivos, structs, callbacks, exportaciones de modulo y funciones auxiliares de puntero completas

**Futuro:** Ayudantes de marshaling de strings

**Casos de uso:** Bibliotecas del sistema, bibliotecas de terceros, qsort, bucles de eventos, APIs basadas en callbacks, envoltorios de biblioteca reutilizables

## Contribuyendo

La documentacion de FFI esta siendo expandida. Si trabajas con FFI:
- Documenta tus casos de uso
- Comparte codigo de ejemplo
- Reporta problemas o limitaciones
- Sugiere mejoras

El sistema FFI esta disenado para ser practico y seguro mientras proporciona acceso de bajo nivel cuando se necesita, siguiendo la filosofia de Hemlock de "explicito sobre implicito" y "unsafe es una caracteristica, no un bug."


--------------------------------------------------------------------------------
## File IO
--------------------------------------------------------------------------------

# E/S de Archivos en Hemlock

Hemlock proporciona una **API de objeto File** para operaciones de archivo con manejo de errores apropiado y gestion de recursos.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [Abriendo Archivos](#abriendo-archivos)
- [Metodos de File](#metodos-de-file)
- [Propiedades de File](#propiedades-de-file)
- [Manejo de Errores](#manejo-de-errores)
- [Gestion de Recursos](#gestion-de-recursos)
- [Referencia Completa de API](#referencia-completa-de-api)
- [Patrones Comunes](#patrones-comunes)
- [Mejores Practicas](#mejores-practicas)

## Vision General

La API de objeto File proporciona:

- **Gestion explicita de recursos** - Los archivos deben cerrarse manualmente
- **Multiples modos de apertura** - Lectura, escritura, anexar, lectura/escritura
- **Operaciones de texto y binario** - Leer/escribir tanto texto como datos binarios
- **Soporte de busqueda** - Acceso aleatorio dentro de archivos
- **Mensajes de error completos** - Reporte de errores consciente del contexto

**Importante:** Los archivos no se cierran automaticamente. Debes llamar `f.close()` para evitar fugas de descriptores de archivo.

## Abriendo Archivos

Usa `open(path, mode?)` para abrir un archivo:

```hemlock
let f = open("data.txt", "r");     // Modo lectura (por defecto)
let f2 = open("output.txt", "w");  // Modo escritura (trunca)
let f3 = open("log.txt", "a");     // Modo anexar
let f4 = open("data.bin", "r+");   // Modo lectura/escritura
```

### Modos de Apertura

| Modo | Descripcion | Archivo Debe Existir | Trunca | Posicion |
|------|-------------|---------------------|--------|----------|
| `"r"` | Lectura (por defecto) | Si | No | Inicio |
| `"w"` | Escritura | No (crea) | Si | Inicio |
| `"a"` | Anexar | No (crea) | No | Final |
| `"r+"` | Leer y escribir | Si | No | Inicio |
| `"w+"` | Leer y escribir | No (crea) | Si | Inicio |
| `"a+"` | Leer y anexar | No (crea) | No | Final |

### Ejemplos

**Leyendo un archivo existente:**
```hemlock
let f = open("config.json", "r");
// o simplemente:
let f = open("config.json");  // "r" es por defecto
```

**Creando un nuevo archivo para escritura:**
```hemlock
let f = open("output.txt", "w");  // Crea o trunca
```

**Anexando a un archivo:**
```hemlock
let f = open("log.txt", "a");  // Crea si no existe
```

**Modo lectura y escritura:**
```hemlock
let f = open("data.bin", "r+");  // Archivo existente, puede leer/escribir
```

## Metodos de File

### Lectura

#### read(size?: i32): string

Leer texto del archivo (parametro size opcional).

**Sin size (leer todo):**
```hemlock
let f = open("data.txt", "r");
let all = f.read();  // Leer desde posicion actual hasta EOF
f.close();
```

**Con size (leer bytes especificos):**
```hemlock
let f = open("data.txt", "r");
let chunk = f.read(1024);  // Leer hasta 1024 bytes
let next = f.read(1024);   // Leer siguientes 1024 bytes
f.close();
```

**Retorna:** String conteniendo los datos leidos, o string vacio si esta en EOF

**Ejemplo - Leyendo archivo completo:**
```hemlock
let f = open("poem.txt", "r");
let content = f.read();
print(content);
f.close();
```

**Ejemplo - Leyendo en chunks:**
```hemlock
let f = open("large.txt", "r");
while (true) {
    let chunk = f.read(4096);  // Chunks de 4KB
    if (chunk == "") { break; }  // EOF alcanzado
    process(chunk);
}
f.close();
```

#### read_bytes(size: i32): buffer

Leer datos binarios (retorna buffer).

**Parametros:**
- `size` (i32) - Numero de bytes a leer

**Retorna:** Buffer conteniendo los bytes leidos

```hemlock
let f = open("image.png", "r");
let binary = f.read_bytes(256);  // Leer 256 bytes
print(binary.length);  // 256 (o menos si EOF)

// Acceder a bytes individuales
let first_byte = binary[0];
print(first_byte);

f.close();
```

**Ejemplo - Leyendo archivo binario completo:**
```hemlock
let f = open("data.bin", "r");
let size = 10240;  // Tamano esperado
let data = f.read_bytes(size);
f.close();

// Procesar datos binarios
let i = 0;
while (i < data.length) {
    let byte = data[i];
    // ... procesar byte
    i = i + 1;
}
```

### Escritura

#### write(data: string): i32

Escribir texto al archivo (retorna bytes escritos).

**Parametros:**
- `data` (string) - Texto a escribir

**Retorna:** Numero de bytes escritos (i32)

```hemlock
let f = open("output.txt", "w");
let written = f.write("Hello, World!\n");
print("Wrote " + typeof(written) + " bytes");  // "Wrote 14 bytes"
f.close();
```

**Ejemplo - Escribiendo multiples lineas:**
```hemlock
let f = open("output.txt", "w");
f.write("Line 1\n");
f.write("Line 2\n");
f.write("Line 3\n");
f.close();
```

**Ejemplo - Anexando a archivo de log:**
```hemlock
let f = open("app.log", "a");
f.write("[INFO] Application started\n");
f.write("[INFO] User logged in\n");
f.close();
```

#### write_bytes(data: buffer): i32

Escribir datos binarios (retorna bytes escritos).

**Parametros:**
- `data` (buffer) - Datos binarios a escribir

**Retorna:** Numero de bytes escritos (i32)

```hemlock
let f = open("output.bin", "w");

// Crear datos binarios
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

let bytes = f.write_bytes(buf);
print("Wrote " + typeof(bytes) + " bytes");

f.close();
```

**Ejemplo - Copiando archivo binario:**
```hemlock
let src = open("input.bin", "r");
let dst = open("output.bin", "w");

let data = src.read_bytes(1024);
while (data.length > 0) {
    dst.write_bytes(data);
    data = src.read_bytes(1024);
}

src.close();
dst.close();
```

### Busqueda

#### seek(position: i32): i32

Moverse a posicion especifica (retorna nueva posicion).

**Parametros:**
- `position` (i32) - Desplazamiento en bytes desde el inicio del archivo

**Retorna:** Nueva posicion (i32)

```hemlock
let f = open("data.txt", "r");

// Moverse al byte 100
f.seek(100);

// Leer desde posicion 100
let data = f.read(50);

// Restablecer al inicio
f.seek(0);

f.close();
```

**Ejemplo - Acceso aleatorio:**
```hemlock
let f = open("records.dat", "r");

// Leer registro en offset 1000
f.seek(1000);
let record1 = f.read_bytes(100);

// Leer registro en offset 2000
f.seek(2000);
let record2 = f.read_bytes(100);

f.close();
```

#### tell(): i32

Obtener posicion actual en el archivo.

**Retorna:** Desplazamiento actual en bytes (i32)

```hemlock
let f = open("data.txt", "r");

let pos1 = f.tell();  // 0 (al inicio)

f.read(100);
let pos2 = f.tell();  // 100 (despues de leer 100 bytes)

f.seek(500);
let pos3 = f.tell();  // 500 (despues de busqueda)

f.close();
```

**Ejemplo - Midiendo cantidad leida:**
```hemlock
let f = open("data.txt", "r");

let start = f.tell();
let content = f.read();
let end = f.tell();

let bytes_read = end - start;
print("Read " + typeof(bytes_read) + " bytes");

f.close();
```

### Cierre

#### close()

Cerrar archivo (idempotente, puede llamarse multiples veces).

```hemlock
let f = open("data.txt", "r");
// ... usar archivo
f.close();
f.close();  // Seguro - sin error en segundo cierre
```

**Notas importantes:**
- Siempre cerrar archivos cuando termines para evitar fugas de descriptores de archivo
- El cierre es idempotente - puede llamarse multiples veces de forma segura
- Despues de cerrar, todas las otras operaciones daran error
- Usar bloques `finally` para asegurar que los archivos se cierren incluso en errores

## Propiedades de File

Los objetos File tienen tres propiedades de solo lectura:

### path: string

La ruta del archivo usada para abrirlo.

```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);  // "/path/to/file.txt"
f.close();
```

### mode: string

El modo con el que se abrio el archivo.

```hemlock
let f = open("data.txt", "r");
print(f.mode);  // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);  // "w"
f2.close();
```

### closed: bool

Si el archivo esta cerrado.

```hemlock
let f = open("data.txt", "r");
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

**Ejemplo - Verificando si el archivo esta abierto:**
```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... procesar contenido
}

f.close();

if (f.closed) {
    print("File is now closed");
}
```

## Manejo de Errores

Todas las operaciones de archivo incluyen mensajes de error apropiados con contexto.

### Errores Comunes

**Archivo no encontrado:**
```hemlock
let f = open("missing.txt", "r");
// Error: Failed to open 'missing.txt': No such file or directory
```

**Leyendo de archivo cerrado:**
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Error: Cannot read from closed file 'data.txt'
```

**Escribiendo a archivo de solo lectura:**
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Error: Cannot write to file 'readonly.txt' opened in read-only mode
```

**Leyendo de archivo de solo escritura:**
```hemlock
let f = open("output.txt", "w");
f.read();
// Error: Cannot read from file 'output.txt' opened in write-only mode
```

### Usando try/catch

```hemlock
try {
    let f = open("data.txt", "r");
    let content = f.read();
    f.close();
    process(content);
} catch (e) {
    print("Error reading file: " + e);
}
```

## Gestion de Recursos

### Patron Basico

Siempre cerrar archivos explicitamente:

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Con Manejo de Errores (Recomendado)

Usar `finally` para asegurar que los archivos se cierren incluso en errores:

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Siempre cerrar, incluso en error
}
```

### Multiples Archivos

```hemlock
let src = null;
let dst = null;

try {
    src = open("input.txt", "r");
    dst = open("output.txt", "w");

    let content = src.read();
    dst.write(content);
} finally {
    if (src != null) { src.close(); }
    if (dst != null) { dst.close(); }
}
```

### Patron de Funcion Auxiliar

```hemlock
fn with_file(path: string, mode: string, callback) {
    let f = open(path, mode);
    try {
        return callback(f);
    } finally {
        f.close();
    }
}

// Uso:
with_file("data.txt", "r", fn(f) {
    return f.read();
});
```

## Referencia Completa de API

### Funciones

| Funcion | Parametros | Retorna | Descripcion |
|---------|-----------|---------|-------------|
| `open(path, mode?)` | path: string, mode?: string | File | Abrir archivo (modo por defecto es "r") |

### Metodos

| Metodo | Parametros | Retorna | Descripcion |
|--------|-----------|---------|-------------|
| `read(size?)` | size?: i32 | string | Leer texto (todo o bytes especificos) |
| `read_bytes(size)` | size: i32 | buffer | Leer datos binarios |
| `write(data)` | data: string | i32 | Escribir texto, retorna bytes escritos |
| `write_bytes(data)` | data: buffer | i32 | Escribir datos binarios, retorna bytes escritos |
| `seek(position)` | position: i32 | i32 | Buscar posicion, retorna nueva posicion |
| `tell()` | - | i32 | Obtener posicion actual |
| `close()` | - | null | Cerrar archivo (idempotente) |

### Propiedades (solo lectura)

| Propiedad | Tipo | Descripcion |
|-----------|------|-------------|
| `path` | string | Ruta del archivo |
| `mode` | string | Modo de apertura |
| `closed` | bool | Si el archivo esta cerrado |

## Patrones Comunes

### Leyendo Archivo Completo

```hemlock
fn read_file(path: string): string {
    let f = open(path, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

let content = read_file("config.json");
```

### Escribiendo Archivo Completo

```hemlock
fn write_file(path: string, content: string) {
    let f = open(path, "w");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

write_file("output.txt", "Hello, World!");
```

### Anexando a Archivo

```hemlock
fn append_file(path: string, content: string) {
    let f = open(path, "a");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

append_file("log.txt", "[INFO] Event occurred\n");
```

### Leyendo Lineas

```hemlock
fn read_lines(path: string) {
    let f = open(path, "r");
    try {
        let content = f.read();
        return content.split("\n");
    } finally {
        f.close();
    }
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Procesando Archivos Grandes en Chunks

```hemlock
fn process_large_file(path: string) {
    let f = open(path, "r");
    try {
        while (true) {
            let chunk = f.read(4096);  // Chunks de 4KB
            if (chunk == "") { break; }

            // Procesar chunk
            process_chunk(chunk);
        }
    } finally {
        f.close();
    }
}
```

### Copia de Archivo Binario

```hemlock
fn copy_file(src_path: string, dst_path: string) {
    let src = null;
    let dst = null;

    try {
        src = open(src_path, "r");
        dst = open(dst_path, "w");

        while (true) {
            let chunk = src.read_bytes(4096);
            if (chunk.length == 0) { break; }

            dst.write_bytes(chunk);
        }
    } finally {
        if (src != null) { src.close(); }
        if (dst != null) { dst.close(); }
    }
}

copy_file("input.dat", "output.dat");
```

### Truncar Archivo

```hemlock
fn truncate_file(path: string) {
    let f = open(path, "w");  // Modo "w" trunca
    f.close();
}

truncate_file("empty_me.txt");
```

### Lectura de Acceso Aleatorio

```hemlock
fn read_at_offset(path: string, offset: i32, size: i32): string {
    let f = open(path, "r");
    try {
        f.seek(offset);
        return f.read(size);
    } finally {
        f.close();
    }
}

let data = read_at_offset("records.dat", 1000, 100);
```

### Tamano de Archivo

```hemlock
fn file_size(path: string): i32 {
    let f = open(path, "r");
    try {
        // Buscar al final
        let end = f.seek(999999999);  // Numero grande
        f.seek(0);  // Restablecer
        return end;
    } finally {
        f.close();
    }
}

let size = file_size("data.txt");
print("File size: " + typeof(size) + " bytes");
```

### Lectura/Escritura Condicional

```hemlock
fn update_file(path: string, condition, new_content: string) {
    let f = open(path, "r+");
    try {
        let content = f.read();

        if (condition(content)) {
            f.seek(0);  // Restablecer al inicio
            f.write(new_content);
        }
    } finally {
        f.close();
    }
}
```

## Mejores Practicas

### 1. Siempre Usar try/finally

```hemlock
// Bueno
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();
}

// Malo - el archivo podria no cerrarse en error
let f = open("data.txt", "r");
let content = f.read();
process(content);  // Si esto lanza, el archivo tiene fuga
f.close();
```

### 2. Verificar Estado del Archivo Antes de Operaciones

```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... usar contenido
}

f.close();
```

### 3. Usar Modos Apropiados

```hemlock
// Solo lectura? Usar "r"
let f = open("config.json", "r");

// Reemplazando completamente? Usar "w"
let f = open("output.txt", "w");

// Agregando al final? Usar "a"
let f = open("log.txt", "a");
```

### 4. Manejar Errores Graciosamente

```hemlock
fn safe_read_file(path: string): string {
    try {
        let f = open(path, "r");
        try {
            return f.read();
        } finally {
            f.close();
        }
    } catch (e) {
        print("Warning: Could not read " + path + ": " + e);
        return "";
    }
}
```

### 5. Cerrar Archivos en Orden Inverso de Apertura

```hemlock
let f1 = null;
let f2 = null;
let f3 = null;

try {
    f1 = open("file1.txt", "r");
    f2 = open("file2.txt", "r");
    f3 = open("file3.txt", "r");

    // ... usar archivos
} finally {
    // Cerrar en orden inverso
    if (f3 != null) { f3.close(); }
    if (f2 != null) { f2.close(); }
    if (f1 != null) { f1.close(); }
}
```

### 6. Evitar Leer Archivos Grandes Completamente

```hemlock
// Malo para archivos grandes
let f = open("huge.log", "r");
let content = f.read();  // Carga archivo completo en memoria
f.close();

// Bueno - procesar en chunks
let f = open("huge.log", "r");
try {
    while (true) {
        let chunk = f.read(4096);
        if (chunk == "") { break; }
        process_chunk(chunk);
    }
} finally {
    f.close();
}
```

## Resumen

La API de E/S de Archivos de Hemlock proporciona:

- âœ… Operaciones de archivo simples y explicitas
- âœ… Soporte de texto y binario
- âœ… Acceso aleatorio con seek/tell
- âœ… Mensajes de error claros con contexto
- âœ… Operacion de cierre idempotente

Recuerda:
- Siempre cerrar archivos manualmente
- Usar try/finally para seguridad de recursos
- Elegir modos de apertura apropiados
- Manejar errores graciosamente
- Procesar archivos grandes en chunks


--------------------------------------------------------------------------------
## Operaciones AtÃ³micas
--------------------------------------------------------------------------------

# Operaciones Atomicas

Hemlock proporciona operaciones atomicas para **programacion concurrente sin bloqueos**. Estas operaciones permiten la manipulacion segura de memoria compartida a traves de multiples hilos sin bloqueos o mutexes tradicionales.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [Cuando Usar Atomicos](#cuando-usar-atomicos)
- [Modelo de Memoria](#modelo-de-memoria)
- [Carga y Almacenamiento Atomico](#carga-y-almacenamiento-atomico)
- [Operaciones Fetch-and-Modify](#operaciones-fetch-and-modify)
- [Compare-and-Swap (CAS)](#compare-and-swap-cas)
- [Intercambio Atomico](#intercambio-atomico)
- [Barrera de Memoria](#barrera-de-memoria)
- [Referencia de Funciones](#referencia-de-funciones)
- [Patrones Comunes](#patrones-comunes)
- [Mejores Practicas](#mejores-practicas)
- [Limitaciones](#limitaciones)

---

## Vision General

Las operaciones atomicas son operaciones **indivisibles** que se completan sin posibilidad de interrupcion. Cuando un hilo realiza una operacion atomica, ningun otro hilo puede observar la operacion en un estado parcialmente completado.

**Caracteristicas clave:**
- Todas las operaciones usan **consistencia secuencial** (`memory_order_seq_cst`)
- Tipos soportados: **i32** e **i64**
- Las operaciones trabajan con punteros crudos asignados con `alloc()`
- Seguro para hilos sin bloqueos explicitos

**Operaciones disponibles:**
- Load/Store - Leer y escribir valores atomicamente
- Add/Sub - Operaciones aritmeticas que retornan el valor anterior
- And/Or/Xor - Operaciones de bits que retornan el valor anterior
- CAS - Compare-and-swap para actualizaciones condicionales
- Exchange - Intercambiar valores atomicamente
- Fence - Barrera de memoria completa

---

## Cuando Usar Atomicos

**Usar atomicos para:**
- Contadores compartidos entre tareas (ej. conteos de solicitudes, seguimiento de progreso)
- Flags e indicadores de estado
- Estructuras de datos sin bloqueos
- Primitivas de sincronizacion simples
- Codigo concurrente critico en rendimiento

**Usar canales en su lugar cuando:**
- Pasar datos complejos entre tareas
- Implementar patrones productor-consumidor
- Necesitas semantica de paso de mensajes

**Caso de uso de ejemplo - Contador compartido:**
```hemlock
// Asignar contador compartido
let counter = alloc(4);
ptr_write_i32(counter, 0);

async fn worker(counter: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(counter, 1);
        i = i + 1;
    }
}

// Crear multiples workers
let t1 = spawn(worker, counter, 1);
let t2 = spawn(worker, counter, 2);
let t3 = spawn(worker, counter, 3);

join(t1);
join(t2);
join(t3);

// El contador sera exactamente 3000 (sin carreras de datos)
print(atomic_load_i32(counter));

free(counter);
```

---

## Modelo de Memoria

Todas las operaciones atomicas de Hemlock usan **consistencia secuencial** (`memory_order_seq_cst`), que proporciona las garantias de ordenamiento de memoria mas fuertes:

1. **Atomicidad**: Cada operacion es indivisible
2. **Ordenamiento total**: Todos los hilos ven el mismo orden de operaciones
3. **Sin reordenamiento**: Las operaciones no son reordenadas por el compilador o la CPU

Esto hace que razonar sobre codigo concurrente sea mas simple, a costa de algo de rendimiento potencial comparado con ordenamientos de memoria mas debiles.

---

## Carga y Almacenamiento Atomico

### atomic_load_i32 / atomic_load_i64

Leer atomicamente un valor de memoria.

**Firma:**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**Parametros:**
- `ptr` - Puntero a la ubicacion de memoria (debe estar correctamente alineado)

**Retorna:** El valor en la ubicacion de memoria

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let value = atomic_load_i32(p);
print(value);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

Escribir atomicamente un valor a memoria.

**Firma:**
```hemlock
atomic_store_i32(ptr: ptr, value: i32): null
atomic_store_i64(ptr: ptr, value: i64): null
```

**Parametros:**
- `ptr` - Puntero a la ubicacion de memoria
- `value` - Valor a almacenar

**Retorna:** `null`

**Ejemplo:**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## Operaciones Fetch-and-Modify

Estas operaciones modifican atomicamente un valor y retornan el valor **anterior** (previo).

### atomic_add_i32 / atomic_add_i64

Sumar atomicamente a un valor.

**Firma:**
```hemlock
atomic_add_i32(ptr: ptr, value: i32): i32
atomic_add_i64(ptr: ptr, value: i64): i64
```

**Retorna:** El valor **anterior** (antes de la suma)

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_add_i32(p, 10);
print(old);                    // 100 (valor anterior)
print(atomic_load_i32(p));     // 110 (valor nuevo)

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

Restar atomicamente de un valor.

**Firma:**
```hemlock
atomic_sub_i32(ptr: ptr, value: i32): i32
atomic_sub_i64(ptr: ptr, value: i64): i64
```

**Retorna:** El valor **anterior** (antes de la resta)

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_sub_i32(p, 25);
print(old);                    // 100 (valor anterior)
print(atomic_load_i32(p));     // 75 (valor nuevo)

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

Realizar atomicamente AND de bits.

**Firma:**
```hemlock
atomic_and_i32(ptr: ptr, value: i32): i32
atomic_and_i64(ptr: ptr, value: i64): i64
```

**Retorna:** El valor **anterior** (antes del AND)

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // 255 en binario: 11111111

let old = atomic_and_i32(p, 0x0F);  // AND con 00001111
print(old);                    // 255 (valor anterior)
print(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

Realizar atomicamente OR de bits.

**Firma:**
```hemlock
atomic_or_i32(ptr: ptr, value: i32): i32
atomic_or_i64(ptr: ptr, value: i64): i64
```

**Retorna:** El valor **anterior** (antes del OR)

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // 15 en binario: 00001111

let old = atomic_or_i32(p, 0xF0);  // OR con 11110000
print(old);                    // 15 (valor anterior)
print(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

Realizar atomicamente XOR de bits.

**Firma:**
```hemlock
atomic_xor_i32(ptr: ptr, value: i32): i32
atomic_xor_i64(ptr: ptr, value: i64): i64
```

**Retorna:** El valor **anterior** (antes del XOR)

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // 170 en binario: 10101010

let old = atomic_xor_i32(p, 0xFF);  // XOR con 11111111
print(old);                    // 170 (valor anterior)
print(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)

free(p);
```

---

## Compare-and-Swap (CAS)

La operacion atomica mas poderosa. Compara atomicamente el valor actual con un valor esperado y, si coinciden, lo reemplaza con un nuevo valor.

### atomic_cas_i32 / atomic_cas_i64

**Firma:**
```hemlock
atomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool
atomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool
```

**Parametros:**
- `ptr` - Puntero a la ubicacion de memoria
- `expected` - Valor que esperamos encontrar
- `desired` - Valor a almacenar si la expectativa coincide

**Retorna:**
- `true` - El intercambio tuvo exito (el valor era `expected`, ahora es `desired`)
- `false` - El intercambio fallo (el valor no era `expected`, sin cambios)

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS exitoso: el valor es 100, intercambiar a 999
let success1 = atomic_cas_i32(p, 100, 999);
print(success1);               // true
print(atomic_load_i32(p));     // 999

// CAS fallido: el valor es 999, no 100
let success2 = atomic_cas_i32(p, 100, 888);
print(success2);               // false
print(atomic_load_i32(p));     // 999 (sin cambios)

free(p);
```

**Casos de uso:**
- Implementar bloqueos y semaforos
- Estructuras de datos sin bloqueos
- Control de concurrencia optimista
- Actualizaciones condicionales atomicas

---

## Intercambio Atomico

Intercambiar atomicamente un valor, retornando el valor anterior.

### atomic_exchange_i32 / atomic_exchange_i64

**Firma:**
```hemlock
atomic_exchange_i32(ptr: ptr, value: i32): i32
atomic_exchange_i64(ptr: ptr, value: i64): i64
```

**Parametros:**
- `ptr` - Puntero a la ubicacion de memoria
- `value` - Nuevo valor a almacenar

**Retorna:** El valor **anterior** (antes del intercambio)

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_exchange_i32(p, 200);
print(old);                    // 100 (valor anterior)
print(atomic_load_i32(p));     // 200 (valor nuevo)

free(p);
```

---

## Barrera de Memoria

Una barrera de memoria completa que asegura que todas las operaciones de memoria antes de la barrera sean visibles para todos los hilos antes de cualquier operacion despues de la barrera.

### atomic_fence

**Firma:**
```hemlock
atomic_fence(): null
```

**Retorna:** `null`

**Ejemplo:**
```hemlock
// Asegurar que todas las escrituras anteriores sean visibles
atomic_fence();
```

**Nota:** En la mayoria de los casos, no necesitas barreras explicitas porque todas las operaciones atomicas ya usan consistencia secuencial. Las barreras son utiles cuando necesitas sincronizar operaciones de memoria no atomicas.

---

## Referencia de Funciones

### Operaciones i32

| Funcion | Firma | Retorna | Descripcion |
|---------|-------|---------|-------------|
| `atomic_load_i32` | `(ptr)` | `i32` | Cargar valor atomicamente |
| `atomic_store_i32` | `(ptr, value)` | `null` | Almacenar valor atomicamente |
| `atomic_add_i32` | `(ptr, value)` | `i32` | Sumar y retornar valor anterior |
| `atomic_sub_i32` | `(ptr, value)` | `i32` | Restar y retornar valor anterior |
| `atomic_and_i32` | `(ptr, value)` | `i32` | AND de bits y retornar valor anterior |
| `atomic_or_i32` | `(ptr, value)` | `i32` | OR de bits y retornar valor anterior |
| `atomic_xor_i32` | `(ptr, value)` | `i32` | XOR de bits y retornar valor anterior |
| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Intercambiar y retornar valor anterior |

### Operaciones i64

| Funcion | Firma | Retorna | Descripcion |
|---------|-------|---------|-------------|
| `atomic_load_i64` | `(ptr)` | `i64` | Cargar valor atomicamente |
| `atomic_store_i64` | `(ptr, value)` | `null` | Almacenar valor atomicamente |
| `atomic_add_i64` | `(ptr, value)` | `i64` | Sumar y retornar valor anterior |
| `atomic_sub_i64` | `(ptr, value)` | `i64` | Restar y retornar valor anterior |
| `atomic_and_i64` | `(ptr, value)` | `i64` | AND de bits y retornar valor anterior |
| `atomic_or_i64` | `(ptr, value)` | `i64` | OR de bits y retornar valor anterior |
| `atomic_xor_i64` | `(ptr, value)` | `i64` | XOR de bits y retornar valor anterior |
| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Intercambiar y retornar valor anterior |

### Barrera de Memoria

| Funcion | Firma | Retorna | Descripcion |
|---------|-------|---------|-------------|
| `atomic_fence` | `()` | `null` | Barrera de memoria completa |

---

## Patrones Comunes

### Patron: Contador Atomico

```hemlock
// Contador seguro para hilos
let counter = alloc(4);
ptr_write_i32(counter, 0);

fn increment(): i32 {
    return atomic_add_i32(counter, 1);
}

fn decrement(): i32 {
    return atomic_sub_i32(counter, 1);
}

fn get_count(): i32 {
    return atomic_load_i32(counter);
}

// Uso
increment();  // Retorna 0 (valor anterior)
increment();  // Retorna 1
increment();  // Retorna 2
print(get_count());  // 3

free(counter);
```

### Patron: Spinlock

```hemlock
// Implementacion simple de spinlock
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = desbloqueado, 1 = bloqueado

fn acquire() {
    // Girar hasta que establezcamos exitosamente el bloqueo de 0 a 1
    while (!atomic_cas_i32(lock, 0, 1)) {
        // Espera activa
    }
}

fn release() {
    atomic_store_i32(lock, 0);
}

// Uso
acquire();
// ... seccion critica ...
release();

free(lock);
```

### Patron: Inicializacion Unica

```hemlock
let initialized = alloc(4);
ptr_write_i32(initialized, 0);  // 0 = no inicializado, 1 = inicializado

fn ensure_initialized() {
    // Intentar ser el que inicializa
    if (atomic_cas_i32(initialized, 0, 1)) {
        // Ganamos la carrera, hacer inicializacion
        do_expensive_init();
    }
    // De lo contrario, ya inicializado
}
```

### Patron: Flag Atomico

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn set_flag() {
    atomic_store_i32(flag, 1);
}

fn clear_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // Retorna true si el flag ya estaba establecido
    return atomic_exchange_i32(flag, 1) == 1;
}

fn check_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### Patron: Contador Acotado

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);
let max_value = 100;

fn try_increment(): bool {
    while (true) {
        let current = atomic_load_i32(counter);
        if (current >= max_value) {
            return false;  // En el maximo
        }
        if (atomic_cas_i32(counter, current, current + 1)) {
            return true;  // Incrementado exitosamente
        }
        // CAS fallo, otro hilo modifico - reintentar
    }
}
```

---

## Mejores Practicas

### 1. Usar Alineacion Apropiada

Los punteros deben estar correctamente alineados para el tipo de datos:
- i32: alineacion de 4 bytes
- i64: alineacion de 8 bytes

La memoria de `alloc()` tipicamente esta correctamente alineada.

### 2. Preferir Abstracciones de Nivel Superior

Cuando sea posible, usa canales para comunicacion entre tareas. Los atomicos son de nivel mas bajo y requieren razonamiento cuidadoso.

```hemlock
// Preferir esto:
let ch = channel(10);
spawn(fn() { ch.send(result); });
let value = ch.recv();

// Sobre coordinacion atomica manual cuando sea apropiado
```

### 3. Estar Consciente del Problema ABA

CAS puede sufrir del problema ABA: un valor cambia de A a B y vuelve a A. Tu CAS tiene exito, pero el estado puede haber cambiado entre medio.

### 4. Inicializar Antes de Compartir

Siempre inicializa las variables atomicas antes de crear tareas que las accedan:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);  // Inicializar ANTES de crear tareas

let task = spawn(worker, counter);
```

### 5. Liberar Despues de que Todas las Tareas Completen

No liberes memoria atomica mientras las tareas todavia podrian accederla:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);

let t1 = spawn(worker, counter);
let t2 = spawn(worker, counter);

join(t1);
join(t2);

// Ahora es seguro liberar
free(counter);
```

---

## Limitaciones

### Limitaciones Actuales

1. **Solo i32 e i64 soportados** - Sin operaciones atomicas para otros tipos
2. **Sin atomicos de puntero** - No se pueden cargar/almacenar punteros atomicamente
3. **Solo consistencia secuencial** - Sin ordenamientos de memoria mas debiles disponibles
4. **Sin punto flotante atomico** - Usar representacion entera si es necesario

### Notas de Plataforma

- Las operaciones atomicas usan `<stdatomic.h>` de C11 internamente
- Disponible en todas las plataformas que soportan hilos POSIX
- Garantizado estar libre de bloqueos en sistemas modernos de 64 bits

---

## Ver Tambien

- [Async/Concurrencia](#advanced-async-concurrency) - Creacion de tareas y canales
- [Gestion de Memoria](#language-guide-memory) - Asignacion de punteros y buffers
- [API de Memoria](#reference-memory-api) - Funciones de asignacion


--------------------------------------------------------------------------------
## Perfilado
--------------------------------------------------------------------------------

# Perfilado

Hemlock incluye un perfilador integrado para **analisis de tiempo de CPU**, **seguimiento de memoria** y **deteccion de fugas**. El perfilador ayuda a identificar cuellos de botella de rendimiento y problemas de memoria en tus programas.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [Inicio Rapido](#inicio-rapido)
- [Modos de Perfilado](#modos-de-perfilado)
- [Formatos de Salida](#formatos-de-salida)
- [Deteccion de Fugas](#deteccion-de-fugas)
- [Entendiendo los Reportes](#entendiendo-los-reportes)
- [Generacion de Flamegraph](#generacion-de-flamegraph)
- [Mejores Practicas](#mejores-practicas)

---

## Vision General

El perfilador se accede via el subcomando `profile`:

```bash
hemlock profile [OPTIONS] <FILE>
```

**Caracteristicas clave:**
- **Perfilado de CPU** - Medir tiempo gastado en cada funcion (tiempo propio y tiempo total)
- **Perfilado de memoria** - Rastrear todas las asignaciones con ubicaciones de codigo fuente
- **Deteccion de fugas** - Identificar memoria que nunca fue liberada
- **Multiples formatos de salida** - Texto, JSON y salida compatible con flamegraph
- **Estadisticas de memoria por funcion** - Ver que funciones asignan mas memoria

---

## Inicio Rapido

### Perfilar tiempo de CPU (por defecto)

```bash
hemlock profile script.hml
```

### Perfilar asignaciones de memoria

```bash
hemlock profile --memory script.hml
```

### Detectar fugas de memoria

```bash
hemlock profile --leaks script.hml
```

### Generar datos de flamegraph

```bash
hemlock profile --flamegraph script.hml > profile.folded
flamegraph.pl profile.folded > profile.svg
```

---

## Modos de Perfilado

### Perfilado de CPU (por defecto)

Mide el tiempo gastado en cada funcion, distinguiendo entre:
- **Tiempo propio** - Tiempo gastado ejecutando el codigo propio de la funcion
- **Tiempo total** - Tiempo propio mas tiempo gastado en funciones llamadas

```bash
hemlock profile script.hml
hemlock profile --cpu script.hml  # Explicito
```

**Ejemplo de salida:**
```
=== Hemlock Profiler Report ===

Total time: 1.234ms
Functions called: 5 unique

--- Top 5 by Self Time ---

Function                        Self      Total   Calls
--------                        ----      -----   -----
expensive_calc              0.892ms    0.892ms     100  (72.3%)
process_data                0.234ms    1.126ms      10  (19.0%)
helper                      0.067ms    0.067ms     500  (5.4%)
main                        0.041ms    1.234ms       1  (3.3%)
```

---

### Perfilado de Memoria

Rastrea todas las asignaciones de memoria (`alloc`, `buffer`, `talloc`, `realloc`) con ubicaciones de codigo fuente.

```bash
hemlock profile --memory script.hml
```

**Ejemplo de salida:**
```
=== Hemlock Profiler Report ===

Total time: 0.543ms
Functions called: 3 unique
Total allocations: 15 (4.2KB)

--- Top 3 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
allocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)
buffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)
main                        0.075ms    0.543ms       1        0B          0  (13.8%)

--- Top 10 Allocation Sites ---

Location                                      Total    Count
--------                                      -----    -----
src/data.hml:42                               1.5KB        5
src/data.hml:67                               1.0KB       10
src/main.hml:15                               512B         1
```

---

### Modo de Conteo de Llamadas

Modo de sobrecarga minima que solo cuenta llamadas a funciones (sin tiempos).

```bash
hemlock profile --calls script.hml
```

---

## Formatos de Salida

### Texto (por defecto)

Resumen legible por humanos con tablas.

```bash
hemlock profile script.hml
```

---

### JSON

Formato legible por maquina para integracion con otras herramientas.

```bash
hemlock profile --json script.hml
```

**Ejemplo de salida:**
```json
{
  "total_time_ns": 1234567,
  "function_count": 5,
  "total_alloc_bytes": 4096,
  "total_alloc_count": 15,
  "functions": [
    {
      "name": "expensive_calc",
      "source_file": "script.hml",
      "line": 10,
      "self_time_ns": 892000,
      "total_time_ns": 892000,
      "call_count": 100,
      "alloc_bytes": 0,
      "alloc_count": 0
    }
  ],
  "alloc_sites": [
    {
      "source_file": "script.hml",
      "line": 42,
      "total_bytes": 1536,
      "alloc_count": 5,
      "current_bytes": 0
    }
  ]
}
```

---

### Flamegraph

Genera formato de pila colapsada compatible con [flamegraph.pl](https://github.com/brendangregg/FlameGraph).

```bash
hemlock profile --flamegraph script.hml > profile.folded

# Generar SVG con flamegraph.pl
flamegraph.pl profile.folded > profile.svg
```

**Ejemplo de salida colapsada:**
```
main;process_data;expensive_calc 892
main;process_data;helper 67
main;process_data 234
main 41
```

---

## Deteccion de Fugas

El flag `--leaks` muestra solo asignaciones que nunca fueron liberadas, haciendo facil identificar fugas de memoria.

```bash
hemlock profile --leaks script.hml
```

**Programa de ejemplo con fugas:**
```hemlock
fn leaky() {
    let p1 = alloc(100);    // Fuga - nunca liberado
    let p2 = alloc(200);    // OK - liberado abajo
    free(p2);
}

fn clean() {
    let b = buffer(64);
    free(b);                // Correctamente liberado
}

leaky();
clean();
```

**Salida con --leaks:**
```
=== Hemlock Profiler Report ===

Total time: 0.034ms
Functions called: 2 unique
Total allocations: 3 (388B)

--- Top 2 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
leaky                       0.021ms    0.021ms       1       300B          2  (61.8%)
clean                       0.013ms    0.013ms       1        88B          1  (38.2%)

--- Memory Leaks (1 site) ---

Location                                     Leaked      Total    Count
--------                                     ------      -----    -----
script.hml:2                                   100B       100B        1
```

El reporte de fugas muestra:
- **Leaked** - Bytes actualmente sin liberar al terminar el programa
- **Total** - Total de bytes alguna vez asignados en este sitio
- **Count** - Numero de asignaciones en este sitio

---

## Entendiendo los Reportes

### Estadisticas de Funcion

| Columna | Descripcion |
|---------|-------------|
| Function | Nombre de funcion |
| Self | Tiempo en funcion excluyendo funciones llamadas |
| Total | Tiempo incluyendo todas las funciones llamadas |
| Calls | Numero de veces que la funcion fue llamada |
| Alloc | Total de bytes asignados por esta funcion |
| Count | Numero de asignaciones por esta funcion |
| (%) | Porcentaje del tiempo total del programa |

### Sitios de Asignacion

| Columna | Descripcion |
|---------|-------------|
| Location | Archivo fuente y numero de linea |
| Total | Total de bytes asignados en esta ubicacion |
| Count | Numero de asignaciones |
| Leaked | Bytes todavia asignados al terminar el programa (solo --leaks) |

### Unidades de Tiempo

El perfilador selecciona automaticamente unidades apropiadas:
- `ns` - Nanosegundos (< 1us)
- `us` - Microsegundos (< 1ms)
- `ms` - Milisegundos (< 1s)
- `s` - Segundos

---

## Referencia de Comandos

```
hemlock profile [OPTIONS] <FILE>

OPTIONS:
    --cpu           Perfilado de CPU/tiempo (por defecto)
    --memory        Perfilado de asignacion de memoria
    --calls         Solo conteo de llamadas (sobrecarga minima)
    --leaks         Mostrar solo asignaciones sin liberar (implica --memory)
    --json          Salida en formato JSON
    --flamegraph    Salida en formato compatible con flamegraph
    --top N         Mostrar top N entradas (por defecto: 20)
```

---

## Generacion de Flamegraph

Los flamegraphs visualizan donde tu programa pasa tiempo, con barras mas anchas indicando mas tiempo gastado.

### Generar un Flamegraph

1. Instalar flamegraph.pl:
   ```bash
   git clone https://github.com/brendangregg/FlameGraph
   ```

2. Perfilar tu programa:
   ```bash
   hemlock profile --flamegraph script.hml > profile.folded
   ```

3. Generar SVG:
   ```bash
   ./FlameGraph/flamegraph.pl profile.folded > profile.svg
   ```

4. Abrir `profile.svg` en un navegador para una visualizacion interactiva.

### Leyendo Flamegraphs

- **Eje X**: Porcentaje de tiempo total (ancho = proporcion de tiempo)
- **Eje Y**: Profundidad de pila de llamadas (abajo = punto de entrada, arriba = funciones hoja)
- **Color**: Aleatorio, solo para distincion visual
- **Click**: Hacer zoom en una funcion para ver sus funciones llamadas

---

## Mejores Practicas

### 1. Perfilar Cargas de Trabajo Representativas

Perfilar con datos y patrones de uso realistas. Casos de prueba pequenos pueden no revelar cuellos de botella reales.

```bash
# Bueno: Perfilar con datos similares a produccion
hemlock profile --memory process_large_file.hml large_input.txt

# Menos util: Caso de prueba pequeno
hemlock profile quick_test.hml
```

### 2. Usar --leaks Durante Desarrollo

Ejecutar deteccion de fugas regularmente para detectar fugas de memoria temprano:

```bash
hemlock profile --leaks my_program.hml
```

### 3. Comparar Antes y Despues

Perfilar antes y despues de optimizaciones para medir impacto:

```bash
# Antes de optimizacion
hemlock profile --json script.hml > before.json

# Despues de optimizacion
hemlock profile --json script.hml > after.json

# Comparar resultados
```

### 4. Usar --top para Programas Grandes

Limitar salida para enfocarse en las funciones mas significativas:

```bash
hemlock profile --top 10 large_program.hml
```

### 5. Combinar con Flamegraphs

Para patrones de llamada complejos, los flamegraphs proporcionan mejor visualizacion que salida de texto:

```bash
hemlock profile --flamegraph complex_app.hml > app.folded
flamegraph.pl app.folded > app.svg
```

---

## Sobrecarga del Perfilador

El perfilador agrega algo de sobrecarga a la ejecucion del programa:

| Modo | Sobrecarga | Caso de Uso |
|------|------------|-------------|
| `--calls` | Minima | Solo contar llamadas a funciones |
| `--cpu` | Baja | Perfilado de rendimiento general |
| `--memory` | Moderada | Analisis de memoria y deteccion de fugas |

Para resultados mas precisos, perfilar multiples veces y buscar patrones consistentes.

---

## Ver Tambien

- [Gestion de Memoria](#language-guide-memory) - Punteros y buffers
- [API de Memoria](#reference-memory-api) - Funciones alloc, free, buffer
- [Async/Concurrencia](#advanced-async-concurrency) - Perfilando codigo async


--------------------------------------------------------------------------------
## SeÃ±ales
--------------------------------------------------------------------------------

# Manejo de Senales en Hemlock

Hemlock proporciona **manejo de senales POSIX** para gestionar senales del sistema como SIGINT (Ctrl+C), SIGTERM y senales personalizadas. Esto habilita control de procesos de bajo nivel y comunicacion entre procesos.

## Tabla de Contenidos

- [Vision General](#vision-general)
- [API de Senales](#api-de-senales)
- [Constantes de Senal](#constantes-de-senal)
- [Manejo Basico de Senales](#manejo-basico-de-senales)
- [Patrones Avanzados](#patrones-avanzados)
- [Comportamiento del Manejador de Senales](#comportamiento-del-manejador-de-senales)
- [Consideraciones de Seguridad](#consideraciones-de-seguridad)
- [Casos de Uso Comunes](#casos-de-uso-comunes)
- [Ejemplos Completos](#ejemplos-completos)

## Vision General

El manejo de senales permite a los programas:
- Responder a interrupciones de usuario (Ctrl+C, Ctrl+Z)
- Implementar apagado gracioso
- Manejar solicitudes de terminacion
- Usar senales personalizadas para comunicacion entre procesos
- Crear mecanismos de alarma/temporizador

**Importante:** El manejo de senales es **inherentemente inseguro** en la filosofia de Hemlock. Los manejadores pueden llamarse en cualquier momento, interrumpiendo la ejecucion normal. El usuario es responsable de la sincronizacion apropiada.

## API de Senales

### signal(signum, handler_fn)

Registrar una funcion manejadora de senal.

**Parametros:**
- `signum` (i32) - Numero de senal (constante como SIGINT, SIGTERM)
- `handler_fn` (funcion o null) - Funcion a llamar cuando se recibe la senal, o `null` para restablecer al comportamiento por defecto

**Retorna:** La funcion manejadora anterior (o `null` si no habia ninguna)

**Ejemplo:**
```hemlock
fn my_handler(sig) {
    print("Caught signal: " + typeof(sig));
}

let old_handler = signal(SIGINT, my_handler);
```

**Restableciendo al comportamiento por defecto:**
```hemlock
signal(SIGINT, null);  // Restablecer SIGINT al comportamiento por defecto
```

### raise(signum)

Enviar una senal al proceso actual.

**Parametros:**
- `signum` (i32) - Numero de senal a enviar

**Retorna:** `null`

**Ejemplo:**
```hemlock
raise(SIGUSR1);  // Disparar manejador de SIGUSR1
```

## Constantes de Senal

Hemlock proporciona constantes de senal POSIX estandar como valores i32.

### Interrupcion y Terminacion

| Constante | Valor | Descripcion | Disparador Comun |
|-----------|-------|-------------|------------------|
| `SIGINT` | 2 | Interrupcion desde teclado | Ctrl+C |
| `SIGTERM` | 15 | Solicitud de terminacion | Comando `kill` |
| `SIGQUIT` | 3 | Salir desde teclado | Ctrl+\ |
| `SIGHUP` | 1 | Hangup detectado | Terminal cerrada |
| `SIGABRT` | 6 | Senal de aborto | Funcion `abort()` |

**Ejemplos:**
```hemlock
signal(SIGINT, handle_interrupt);   // Ctrl+C
signal(SIGTERM, handle_terminate);  // Comando kill
signal(SIGHUP, handle_hangup);      // Terminal se cierra
```

### Senales Definidas por Usuario

| Constante | Valor | Descripcion | Caso de Uso |
|-----------|-------|-------------|-------------|
| `SIGUSR1` | 10 | Senal definida por usuario 1 | IPC personalizado |
| `SIGUSR2` | 12 | Senal definida por usuario 2 | IPC personalizado |

**Ejemplos:**
```hemlock
// Usar para comunicacion personalizada
signal(SIGUSR1, reload_config);
signal(SIGUSR2, rotate_logs);
```

### Control de Proceso

| Constante | Valor | Descripcion | Notas |
|-----------|-------|-------------|-------|
| `SIGALRM` | 14 | Temporizador de alarma | Despues de `alarm()` |
| `SIGCHLD` | 17 | Cambio de estado de proceso hijo | Gestion de procesos |
| `SIGCONT` | 18 | Continuar si esta detenido | Reanudar despues de SIGSTOP |
| `SIGSTOP` | 19 | Detener proceso | **No puede capturarse** |
| `SIGTSTP` | 20 | Detener desde terminal | Ctrl+Z |

**Ejemplos:**
```hemlock
signal(SIGALRM, handle_timeout);
signal(SIGCHLD, handle_child_exit);
```

### Senales de E/S

| Constante | Valor | Descripcion | Cuando se Envia |
|-----------|-------|-------------|-----------------|
| `SIGPIPE` | 13 | Pipe roto | Escribir a pipe cerrado |
| `SIGTTIN` | 21 | Lectura en segundo plano desde terminal | Proceso BG lee TTY |
| `SIGTTOU` | 22 | Escritura en segundo plano a terminal | Proceso BG escribe TTY |

**Ejemplos:**
```hemlock
signal(SIGPIPE, handle_broken_pipe);
```

## Manejo Basico de Senales

### Capturando Ctrl+C

```hemlock
let interrupted = false;

fn handle_interrupt(sig) {
    print("Caught SIGINT!");
    interrupted = true;
}

signal(SIGINT, handle_interrupt);

// El programa continua ejecutandose...
// El usuario presiona Ctrl+C -> handle_interrupt() es llamada

while (!interrupted) {
    // Hacer trabajo...
}

print("Exiting due to interrupt");
```

### Firma de Funcion Manejadora

Los manejadores de senal reciben un argumento: el numero de senal (i32)

```hemlock
fn my_handler(signum) {
    print("Received signal: " + typeof(signum));
    // signum contiene el numero de senal (ej. 2 para SIGINT)

    if (signum == SIGINT) {
        print("This is SIGINT");
    }
}

signal(SIGINT, my_handler);
signal(SIGTERM, my_handler);  // Mismo manejador para multiples senales
```

### Multiples Manejadores de Senal

Diferentes manejadores para diferentes senales:

```hemlock
fn handle_int(sig) {
    print("SIGINT received");
}

fn handle_term(sig) {
    print("SIGTERM received");
}

fn handle_usr1(sig) {
    print("SIGUSR1 received");
}

signal(SIGINT, handle_int);
signal(SIGTERM, handle_term);
signal(SIGUSR1, handle_usr1);
```

### Restableciendo al Comportamiento por Defecto

Pasar `null` como manejador para restablecer al comportamiento por defecto:

```hemlock
// Registrar manejador personalizado
signal(SIGINT, my_handler);

// Despues, restablecer al comportamiento por defecto (terminar en SIGINT)
signal(SIGINT, null);
```

### Enviando Senales Manualmente

Enviar senales a tu propio proceso:

```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

// Disparar manejador manualmente
raise(SIGUSR1);
raise(SIGUSR1);

print(count);  // 2
```

## Patrones Avanzados

### Patron de Apagado Gracioso

Patron comun para limpieza en terminacion:

```hemlock
let should_exit = false;

fn handle_shutdown(sig) {
    print("Shutting down gracefully...");
    should_exit = true;
}

signal(SIGINT, handle_shutdown);
signal(SIGTERM, handle_shutdown);

// Bucle principal
while (!should_exit) {
    // Hacer trabajo...
    // Verificar flag should_exit periodicamente
}

print("Cleanup complete");
```

### Contador de Senales

Rastrear numero de senales recibidas:

```hemlock
let signal_count = 0;

fn count_signals(sig) {
    signal_count = signal_count + 1;
    print("Received " + typeof(signal_count) + " signals");
}

signal(SIGUSR1, count_signals);

// Despues...
print("Total signals: " + typeof(signal_count));
```

### Recarga de Configuracion en Senal

```hemlock
let config = load_config();

fn reload_config(sig) {
    print("Reloading configuration...");
    config = load_config();
    print("Configuration reloaded");
}

signal(SIGHUP, reload_config);  // Recargar en SIGHUP

// Enviar SIGHUP al proceso para recargar config
// Desde shell: kill -HUP <pid>
```

### Timeout Usando SIGALRM

```hemlock
let timed_out = false;

fn handle_alarm(sig) {
    print("Timeout!");
    timed_out = true;
}

signal(SIGALRM, handle_alarm);

// Establecer alarma (aun no implementado en Hemlock, solo ejemplo)
// alarm(5);  // timeout de 5 segundos

while (!timed_out) {
    // Hacer trabajo con timeout
}
```

### Maquina de Estados Basada en Senales

```hemlock
let state = 0;

fn next_state(sig) {
    state = (state + 1) % 3;
    print("State: " + typeof(state));
}

fn prev_state(sig) {
    state = (state - 1 + 3) % 3;
    print("State: " + typeof(state));
}

signal(SIGUSR1, next_state);  // Avanzar estado
signal(SIGUSR2, prev_state);  // Retroceder

// Controlar maquina de estados:
// kill -USR1 <pid>  # Siguiente estado
// kill -USR2 <pid>  # Estado anterior
```

## Comportamiento del Manejador de Senales

### Notas Importantes

**Ejecucion del Manejador:**
- Los manejadores se llaman **sincronicamente** cuando se recibe la senal
- Los manejadores se ejecutan en el contexto del proceso actual
- Los manejadores de senal comparten el entorno de clausura de la funcion donde fueron definidos
- Los manejadores pueden acceder y modificar variables del ambito exterior (como globales o variables capturadas)

**Mejores Practicas:**
- Mantener los manejadores simples y rapidos - evitar operaciones de larga duracion
- Establecer flags en lugar de realizar logica compleja
- Evitar llamar funciones que puedan tomar bloqueos
- Estar consciente de que los manejadores pueden interrumpir cualquier operacion

### Que Senales Pueden Capturarse

**Pueden capturarse y manejarse:**
- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT
- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP
- SIGPIPE, SIGTTIN, SIGTTOU
- SIGABRT (pero el programa abortara despues de que el manejador retorne)

**No pueden capturarse:**
- `SIGKILL` (9) - Siempre termina el proceso
- `SIGSTOP` (19) - Siempre detiene el proceso

**Dependiente del sistema:**
- Algunas senales tienen comportamientos por defecto que pueden diferir por sistema
- Verificar la documentacion de senales de tu plataforma para detalles

### Limitaciones del Manejador

```hemlock
fn complex_handler(sig) {
    // Evitar esto en manejadores de senal:

    // âŒ Operaciones de larga duracion
    // process_large_file();

    // âŒ E/S bloqueante
    // let f = open("log.txt", "a");
    // f.write("Signal received\n");

    // âŒ Cambios de estado complejos
    // rebuild_entire_data_structure();

    // âœ… Establecer flag simple es seguro
    let should_stop = true;

    // âœ… Actualizaciones simples de contador usualmente son seguras
    let signal_count = signal_count + 1;
}
```

## Consideraciones de Seguridad

El manejo de senales es **inherentemente inseguro** en la filosofia de Hemlock.

### Condiciones de Carrera

Los manejadores pueden llamarse en cualquier momento, interrumpiendo la ejecucion normal:

```hemlock
let counter = 0;

fn increment(sig) {
    counter = counter + 1;  // Condicion de carrera si se llama durante actualizacion de counter
}

signal(SIGUSR1, increment);

// El codigo principal tambien modifica counter
counter = counter + 1;  // Podria ser interrumpido por manejador de senal
```

**Problema:** Si la senal llega mientras el codigo principal esta actualizando `counter`, el resultado es impredecible.

### Seguridad Async-Signal

Hemlock **no** garantiza seguridad async-signal:
- Los manejadores pueden llamar cualquier codigo de Hemlock (a diferencia de las funciones async-signal-safe restringidas de C)
- Esto proporciona flexibilidad pero requiere precaucion del usuario
- Las condiciones de carrera son posibles si el manejador modifica estado compartido

### Mejores Practicas para Manejo Seguro de Senales

**1. Usar Flags Atomicos**

Asignaciones booleanas simples son generalmente seguras:

```hemlock
let should_exit = false;

fn handler(sig) {
    should_exit = true;  // Asignacion simple es segura
}

signal(SIGINT, handler);

while (!should_exit) {
    // trabajo...
}
```

**2. Minimizar Estado Compartido**

```hemlock
let interrupt_count = 0;

fn handler(sig) {
    // Solo modificar esta variable
    interrupt_count = interrupt_count + 1;
}
```

**3. Diferir Operaciones Complejas**

```hemlock
let pending_reload = false;

fn signal_reload(sig) {
    pending_reload = true;  // Solo establecer flag
}

signal(SIGHUP, signal_reload);

// En bucle principal:
while (true) {
    if (pending_reload) {
        reload_config();  // Hacer trabajo complejo aqui
        pending_reload = false;
    }

    // Trabajo normal...
}
```

**4. Evitar Problemas de Reentrada**

```hemlock
let in_critical_section = false;
let data = [];

fn careful_handler(sig) {
    if (in_critical_section) {
        // No modificar data mientras el codigo principal lo esta usando
        return;
    }
    // Seguro proceder
}
```

## Casos de Uso Comunes

### 1. Apagado Gracioso de Servidor

```hemlock
let running = true;

fn shutdown(sig) {
    print("Shutdown signal received");
    running = false;
}

signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Bucle principal del servidor
while (running) {
    handle_client_request();
}

cleanup_resources();
print("Server stopped");
```

### 2. Recarga de Configuracion (Sin Reinicio)

```hemlock
let config = load_config("app.conf");
let reload_needed = false;

fn trigger_reload(sig) {
    reload_needed = true;
}

signal(SIGHUP, trigger_reload);

while (true) {
    if (reload_needed) {
        print("Reloading configuration...");
        config = load_config("app.conf");
        reload_needed = false;
    }

    // Usar config...
}
```

### 3. Rotacion de Logs

```hemlock
let log_file = open("app.log", "a");
let rotate_needed = false;

fn trigger_rotate(sig) {
    rotate_needed = true;
}

signal(SIGUSR1, trigger_rotate);

while (true) {
    if (rotate_needed) {
        log_file.close();
        // Renombrar log viejo, abrir nuevo
        exec("mv app.log app.log.old");
        log_file = open("app.log", "a");
        rotate_needed = false;
    }

    // Logging normal...
    log_file.write("Log entry\n");
}
```

### 4. Reporte de Estado

```hemlock
let requests_handled = 0;

fn report_status(sig) {
    print("Status: " + typeof(requests_handled) + " requests handled");
}

signal(SIGUSR1, report_status);

while (true) {
    handle_request();
    requests_handled = requests_handled + 1;
}

// Desde shell: kill -USR1 <pid>
```

### 5. Alternar Modo Debug

```hemlock
let debug_mode = false;

fn toggle_debug(sig) {
    debug_mode = !debug_mode;
    if (debug_mode) {
        print("Debug mode: ON");
    } else {
        print("Debug mode: OFF");
    }
}

signal(SIGUSR2, toggle_debug);

// Desde shell: kill -USR2 <pid> para alternar
```

## Ejemplos Completos

### Ejemplo 1: Manejador de Interrupcion con Limpieza

```hemlock
let running = true;
let signal_count = 0;

fn handle_signal(signum) {
    signal_count = signal_count + 1;

    if (signum == SIGINT) {
        print("Interrupt detected (Ctrl+C)");
        running = false;
    }

    if (signum == SIGUSR1) {
        print("User signal 1 received");
    }
}

// Registrar manejadores
signal(SIGINT, handle_signal);
signal(SIGUSR1, handle_signal);

// Simular algo de trabajo
let i = 0;
while (running && i < 100) {
    print("Working... " + typeof(i));

    // Disparar SIGUSR1 cada 10 iteraciones
    if (i == 10 || i == 20) {
        raise(SIGUSR1);
    }

    i = i + 1;
}

print("Total signals received: " + typeof(signal_count));
```

### Ejemplo 2: Maquina de Estados Multi-Senal

```hemlock
let state = "idle";
let request_count = 0;

fn start_processing(sig) {
    state = "processing";
    print("State: " + state);
}

fn stop_processing(sig) {
    state = "idle";
    print("State: " + state);
}

fn report_stats(sig) {
    print("State: " + state);
    print("Requests: " + typeof(request_count));
}

signal(SIGUSR1, start_processing);
signal(SIGUSR2, stop_processing);
signal(SIGHUP, report_stats);

while (true) {
    if (state == "processing") {
        // Hacer trabajo
        request_count = request_count + 1;
    }

    // Verificar cada iteracion...
}
```

### Ejemplo 3: Controlador de Pool de Workers

```hemlock
let worker_count = 4;
let should_exit = false;

fn increase_workers(sig) {
    worker_count = worker_count + 1;
    print("Workers: " + typeof(worker_count));
}

fn decrease_workers(sig) {
    if (worker_count > 1) {
        worker_count = worker_count - 1;
    }
    print("Workers: " + typeof(worker_count));
}

fn shutdown(sig) {
    print("Shutting down...");
    should_exit = true;
}

signal(SIGUSR1, increase_workers);
signal(SIGUSR2, decrease_workers);
signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// El bucle principal ajusta pool de workers basado en worker_count
while (!should_exit) {
    // Gestionar workers basado en worker_count
    // ...
}
```

### Ejemplo 4: Patron de Timeout

```hemlock
let operation_complete = false;
let timed_out = false;

fn timeout_handler(sig) {
    timed_out = true;
}

signal(SIGALRM, timeout_handler);

// Iniciar operacion larga
async fn long_operation() {
    // ... trabajo
    operation_complete = true;
}

let task = spawn(long_operation);

// Esperar con timeout (verificacion manual)
let elapsed = 0;
while (!operation_complete && elapsed < 1000) {
    // Dormir o verificar
    elapsed = elapsed + 1;
}

if (!operation_complete) {
    print("Operation timed out");
    detach(task);  // Abandonar espera
} else {
    join(task);
    print("Operation completed");
}
```

## Depurando Manejadores de Senal

### Agregar Prints de Diagnostico

```hemlock
fn debug_handler(sig) {
    print("Handler called for signal: " + typeof(sig));
    print("Stack: (not yet available)");

    // Tu logica de manejador...
}

signal(SIGINT, debug_handler);
```

### Contar Llamadas de Senal

```hemlock
let handler_calls = 0;

fn counting_handler(sig) {
    handler_calls = handler_calls + 1;
    print("Handler call #" + typeof(handler_calls));

    // Tu logica de manejador...
}
```

### Probar con raise()

```hemlock
fn test_handler(sig) {
    print("Test signal received: " + typeof(sig));
}

signal(SIGUSR1, test_handler);

// Probar enviando manualmente
raise(SIGUSR1);
print("Handler should have been called");
```

## Resumen

El manejo de senales de Hemlock proporciona:

- âœ… Manejo de senales POSIX para control de procesos de bajo nivel
- âœ… 15 constantes de senal estandar
- âœ… API simple de signal() y raise()
- âœ… Funciones manejadoras flexibles con soporte de clausura
- âœ… Multiples senales pueden compartir manejadores

Recuerda:
- El manejo de senales es inherentemente inseguro - usar con precaucion
- Mantener los manejadores simples y rapidos
- Usar flags para cambios de estado, no operaciones complejas
- Los manejadores pueden interrumpir la ejecucion en cualquier momento
- No se pueden capturar SIGKILL o SIGSTOP
- Probar manejadores exhaustivamente con raise()

Patrones comunes:
- Apagado gracioso (SIGINT, SIGTERM)
- Recarga de configuracion (SIGHUP)
- Rotacion de logs (SIGUSR1)
- Reporte de estado (SIGUSR1/SIGUSR2)
- Alternar modo debug (SIGUSR2)



################################################################################
# REFERENCIA DE API
################################################################################

--------------------------------------------------------------------------------
## API de Archivos
--------------------------------------------------------------------------------

# Referencia de la API de Archivos

Referencia completa para el sistema de E/S de archivos de Hemlock.

---

## Descripcion General

Hemlock proporciona una **API de objetos File** para operaciones de archivos con manejo adecuado de errores y gestion de recursos. Los archivos deben abrirse y cerrarse manualmente.

**Caracteristicas Principales:**
- Objeto File con metodos
- Lectura/escritura de datos de texto y binarios
- Busqueda y posicionamiento
- Mensajes de error apropiados
- Gestion manual de recursos (sin RAII)

---

## Tipo File

**Tipo:** `file`

**Descripcion:** Manejador de archivo para operaciones de E/S

**Propiedades (Solo Lectura):**
- `.path` - Ruta del archivo (string)
- `.mode` - Modo de apertura (string)
- `.closed` - Si el archivo esta cerrado (bool)

---

## Abrir Archivos

### open

Abre un archivo para lectura, escritura, o ambos.

**Firma:**
```hemlock
open(path: string, mode?: string): file
```

**Parametros:**
- `path` - Ruta del archivo (relativa o absoluta)
- `mode` (opcional) - Modo de apertura (predeterminado: `"r"`)

**Retorna:** Objeto File

**Modos:**
- `"r"` - Lectura (predeterminado)
- `"w"` - Escritura (trunca archivo existente)
- `"a"` - Anexar
- `"r+"` - Lectura y escritura
- `"w+"` - Lectura y escritura (trunca)
- `"a+"` - Lectura y anexar

**Ejemplos:**
```hemlock
// Modo lectura (predeterminado)
let f = open("data.txt");
let f_read = open("data.txt", "r");

// Modo escritura (trunca)
let f_write = open("output.txt", "w");

// Modo anexar
let f_append = open("log.txt", "a");

// Modo lectura/escritura
let f_rw = open("data.bin", "r+");

// Lectura/escritura (trunca)
let f_rw_trunc = open("output.bin", "w+");

// Lectura/anexar
let f_ra = open("log.txt", "a+");
```

**Manejo de Errores:**
```hemlock
try {
    let f = open("missing.txt", "r");
} catch (e) {
    print("Error al abrir:", e);
    // Error: Failed to open 'missing.txt': No such file or directory
}
```

**Importante:** Los archivos deben cerrarse manualmente con `f.close()` para evitar fugas de descriptores de archivo.

---

## Metodos de File

### Lectura

#### read

Lee texto desde el archivo.

**Firma:**
```hemlock
file.read(size?: i32): string
```

**Parametros:**
- `size` (opcional) - Numero de bytes a leer (si se omite, lee hasta EOF)

**Retorna:** String con el contenido del archivo

**Ejemplos:**
```hemlock
let f = open("data.txt", "r");

// Leer archivo completo
let all = f.read();
print(all);

// Leer numero especifico de bytes
let chunk = f.read(1024);

f.close();
```

**Comportamiento:**
- Lee desde la posicion actual del archivo
- Retorna string vacio en EOF
- Avanza la posicion del archivo

**Errores:**
- Leer desde archivo cerrado
- Leer desde archivo de solo escritura

---

#### read_bytes

Lee datos binarios desde el archivo.

**Firma:**
```hemlock
file.read_bytes(size: i32): buffer
```

**Parametros:**
- `size` - Numero de bytes a leer

**Retorna:** Buffer con datos binarios

**Ejemplos:**
```hemlock
let f = open("data.bin", "r");

// Leer 256 bytes
let binary = f.read_bytes(256);
print(binary.length);       // 256

// Procesar datos binarios
let i = 0;
while (i < binary.length) {
    print(binary[i]);
    i = i + 1;
}

f.close();
```

**Comportamiento:**
- Lee el numero exacto de bytes
- Retorna buffer (no string)
- Avanza la posicion del archivo

---

### Escritura

#### write

Escribe texto al archivo.

**Firma:**
```hemlock
file.write(data: string): i32
```

**Parametros:**
- `data` - String a escribir

**Retorna:** Numero de bytes escritos (i32)

**Ejemplos:**
```hemlock
let f = open("output.txt", "w");

// Escribir texto
let written = f.write("Hello, World!\n");
print("Escribio", written, "bytes");

// Multiples escrituras
f.write("Linea 1\n");
f.write("Linea 2\n");
f.write("Linea 3\n");

f.close();
```

**Comportamiento:**
- Escribe en la posicion actual del archivo
- Retorna el numero de bytes escritos
- Avanza la posicion del archivo

**Errores:**
- Escribir en archivo cerrado
- Escribir en archivo de solo lectura

---

#### write_bytes

Escribe datos binarios al archivo.

**Firma:**
```hemlock
file.write_bytes(data: buffer): i32
```

**Parametros:**
- `data` - Buffer a escribir

**Retorna:** Numero de bytes escritos (i32)

**Ejemplos:**
```hemlock
let f = open("output.bin", "w");

// Crear buffer
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Escribir buffer
let written = f.write_bytes(buf);
print("Escribio", written, "bytes");

f.close();
```

**Comportamiento:**
- Escribe el contenido del buffer al archivo
- Retorna el numero de bytes escritos
- Avanza la posicion del archivo

---

### Posicionamiento

#### seek

Mueve la posicion del archivo a un desplazamiento especifico de bytes.

**Firma:**
```hemlock
file.seek(position: i32): i32
```

**Parametros:**
- `position` - Desplazamiento en bytes desde el inicio del archivo

**Retorna:** Nueva posicion del archivo (i32)

**Ejemplos:**
```hemlock
let f = open("data.txt", "r");

// Saltar al byte 100
f.seek(100);

// Leer desde esa posicion
let chunk = f.read(50);

// Reiniciar al inicio
f.seek(0);

// Leer desde el inicio
let all = f.read();

f.close();
```

**Comportamiento:**
- Establece la posicion del archivo al desplazamiento absoluto
- Retorna la nueva posicion
- Posicionarse mas alla de EOF esta permitido (crea hueco en el archivo al escribir)

---

#### tell

Obtiene la posicion actual del archivo.

**Firma:**
```hemlock
file.tell(): i32
```

**Retorna:** Desplazamiento actual en bytes desde el inicio del archivo (i32)

**Ejemplos:**
```hemlock
let f = open("data.txt", "r");

print(f.tell());        // 0 (al inicio)

f.read(100);
print(f.tell());        // 100 (despues de leer)

f.seek(50);
print(f.tell());        // 50 (despues de posicionarse)

f.close();
```

---

### Cierre

#### close

Cierra el archivo (idempotente).

**Firma:**
```hemlock
file.close(): null
```

**Retorna:** `null`

**Ejemplos:**
```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();

// Seguro llamar multiples veces
f.close();  // Sin error
f.close();  // Sin error
```

**Comportamiento:**
- Cierra el manejador del archivo
- Vacia cualquier escritura pendiente
- Idempotente (seguro llamar multiples veces)
- Establece la propiedad `.closed` a `true`

**Importante:** Siempre cierre los archivos cuando termine para evitar fugas de descriptores de archivo.

---

## Propiedades de File

### .path

Obtiene la ruta del archivo.

**Tipo:** `string`

**Acceso:** Solo lectura

**Ejemplos:**
```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);          // "/path/to/file.txt"
f.close();
```

---

### .mode

Obtiene el modo de apertura.

**Tipo:** `string`

**Acceso:** Solo lectura

**Ejemplos:**
```hemlock
let f = open("data.txt", "r");
print(f.mode);          // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);         // "w"
f2.close();
```

---

### .closed

Verifica si el archivo esta cerrado.

**Tipo:** `bool`

**Acceso:** Solo lectura

**Ejemplos:**
```hemlock
let f = open("data.txt", "r");
print(f.closed);        // false

f.close();
print(f.closed);        // true
```

---

## Manejo de Errores

Todas las operaciones de archivo incluyen mensajes de error apropiados con contexto:

### Archivo No Encontrado
```hemlock
let f = open("missing.txt", "r");
// Error: Failed to open 'missing.txt': No such file or directory
```

### Leer Desde Archivo Cerrado
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Error: Cannot read from closed file 'data.txt'
```

### Escribir en Archivo de Solo Lectura
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Error: Cannot write to file 'readonly.txt' opened in read-only mode
```

### Usando try/catch
```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    print(content);
} catch (e) {
    print("Error de archivo:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Patrones de Gestion de Recursos

### Patron Basico

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Con Manejo de Errores

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Siempre cerrar, incluso en error
}
```

### Patron Seguro

```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    // ... procesar contenido ...
} catch (e) {
    print("Error:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Ejemplos de Uso

### Leer Archivo Completo

```hemlock
fn read_file(filename: string): string {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content;
}

let text = read_file("data.txt");
print(text);
```

### Escribir Archivo de Texto

```hemlock
fn write_file(filename: string, content: string) {
    let f = open(filename, "w");
    f.write(content);
    f.close();
}

write_file("output.txt", "Hello, World!\n");
```

### Anexar a Archivo

```hemlock
fn append_file(filename: string, line: string) {
    let f = open(filename, "a");
    f.write(line + "\n");
    f.close();
}

append_file("log.txt", "Entrada de log 1");
append_file("log.txt", "Entrada de log 2");
```

### Leer Archivo Binario

```hemlock
fn read_binary(filename: string, size: i32): buffer {
    let f = open(filename, "r");
    let data = f.read_bytes(size);
    f.close();
    return data;
}

let binary = read_binary("data.bin", 256);
print("Leyo", binary.length, "bytes");
```

### Escribir Archivo Binario

```hemlock
fn write_binary(filename: string, data: buffer) {
    let f = open(filename, "w");
    f.write_bytes(data);
    f.close();
}

let buf = buffer(10);
buf[0] = 65;
write_binary("output.bin", buf);
```

### Leer Archivo Linea por Linea

```hemlock
fn read_lines(filename: string): array {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content.split("\n");
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Linea", i, ":", lines[i]);
    i = i + 1;
}
```

### Copiar Archivo

```hemlock
fn copy_file(src: string, dest: string) {
    let f_in = open(src, "r");
    let f_out = open(dest, "w");

    let content = f_in.read();
    f_out.write(content);

    f_in.close();
    f_out.close();
}

copy_file("input.txt", "output.txt");
```

### Leer Archivo en Fragmentos

```hemlock
fn process_chunks(filename: string) {
    let f = open(filename, "r");

    while (true) {
        let chunk = f.read(1024);  // Leer 1KB a la vez
        if (chunk.length == 0) {
            break;  // EOF
        }

        // Procesar fragmento
        print("Procesando", chunk.length, "bytes");
    }

    f.close();
}

process_chunks("large_file.txt");
```

---

## Resumen Completo de Metodos

| Metodo        | Firma                    | Retorna   | Descripcion                  |
|---------------|--------------------------|-----------|------------------------------|
| `read`        | `(size?: i32)`           | `string`  | Leer texto                   |
| `read_bytes`  | `(size: i32)`            | `buffer`  | Leer datos binarios          |
| `write`       | `(data: string)`         | `i32`     | Escribir texto               |
| `write_bytes` | `(data: buffer)`         | `i32`     | Escribir datos binarios      |
| `seek`        | `(position: i32)`        | `i32`     | Establecer posicion del archivo |
| `tell`        | `()`                     | `i32`     | Obtener posicion del archivo |
| `close`       | `()`                     | `null`    | Cerrar archivo (idempotente) |

---

## Resumen Completo de Propiedades

| Propiedad | Tipo     | Acceso       | Descripcion              |
|-----------|----------|--------------|--------------------------|
| `.path`   | `string` | Solo lectura | Ruta del archivo         |
| `.mode`   | `string` | Solo lectura | Modo de apertura         |
| `.closed` | `bool`   | Solo lectura | Si el archivo esta cerrado |

---

## Migracion desde la API Antigua

**API Antigua (Eliminada):**
- `read_file(path)` - Use `open(path, "r").read()`
- `write_file(path, data)` - Use `open(path, "w").write(data)`
- `append_file(path, data)` - Use `open(path, "a").write(data)`
- `file_exists(path)` - Sin reemplazo aun

**Ejemplo de Migracion:**
```hemlock
// Antiguo (v0.0)
let content = read_file("data.txt");
write_file("output.txt", content);

// Nuevo (v0.1)
let f = open("data.txt", "r");
let content = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write(content);
f2.close();
```

---

## Ver Tambien

- [Funciones Integradas](#reference-builtins) - Funcion `open()`
- [API de Memoria](#reference-memory-api) - Tipo Buffer
- [API de Strings](#reference-string-api) - Metodos de string para procesamiento de texto


--------------------------------------------------------------------------------
## API de Arreglos
--------------------------------------------------------------------------------

# Referencia de la API de Arrays

Referencia completa para el tipo array de Hemlock y sus 18 metodos.

---

## Descripcion General

Los arrays en Hemlock son secuencias **dinamicas, asignadas en el heap** que pueden contener tipos mixtos. Proporcionan metodos completos para la manipulacion y procesamiento de datos.

**Caracteristicas Principales:**
- Tamano dinamico (crecimiento automatico)
- Indexacion desde cero
- Tipos mixtos permitidos
- 18 metodos integrados
- Asignados en el heap con seguimiento de capacidad

---

## Tipo Array

**Tipo:** `array`

**Propiedades:**
- `.length` - Numero de elementos (i32)

**Sintaxis Literal:** Corchetes `[elem1, elem2, ...]`

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// Tipos mixtos
let mixed = [1, "hello", true, null];
print(mixed.length);   // 4

// Array vacio
let empty = [];
print(empty.length);   // 0
```

---

## Indexacion

Los arrays soportan indexacion basada en cero usando `[]`:

**Acceso de Lectura:**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**Acceso de Escritura:**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**Nota:** La indexacion directa no tiene verificacion de limites. Use metodos para mayor seguridad.

---

## Propiedades de Array

### .length

Obtiene el numero de elementos en el array.

**Tipo:** `i32`

**Ejemplos:**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let empty = [];
print(empty.length);   // 0

// La longitud cambia dinamicamente
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## Metodos de Array

### Operaciones de Pila

#### push

Agrega un elemento al final del array.

**Firma:**
```hemlock
array.push(value: any): null
```

**Parametros:**
- `value` - Elemento a agregar

**Retorna:** `null`

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("hello");     // [1, 2, 3, 4, 5, "hello"]
```

---

#### pop

Elimina y retorna el ultimo elemento.

**Firma:**
```hemlock
array.pop(): any
```

**Retorna:** Ultimo elemento (eliminado del array)

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3];
let last = arr.pop();  // 3
print(arr);            // [1, 2]

let last2 = arr.pop(); // 2
print(arr);            // [1]
```

**Error:** Error en tiempo de ejecucion si el array esta vacio.

---

### Operaciones de Cola

#### shift

Elimina y retorna el primer elemento.

**Firma:**
```hemlock
array.shift(): any
```

**Retorna:** Primer elemento (eliminado del array)

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();  // 1
print(arr);               // [2, 3]

let first2 = arr.shift(); // 2
print(arr);               // [3]
```

**Error:** Error en tiempo de ejecucion si el array esta vacio.

---

#### unshift

Agrega un elemento al inicio del array.

**Firma:**
```hemlock
array.unshift(value: any): null
```

**Parametros:**
- `value` - Elemento a agregar

**Retorna:** `null`

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### Insercion y Eliminacion

#### insert

Inserta un elemento en un indice especifico.

**Firma:**
```hemlock
array.insert(index: i32, value: any): null
```

**Parametros:**
- `index` - Posicion donde insertar (basada en 0)
- `value` - Elemento a insertar

**Retorna:** `null`

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// Insertar al final
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**Comportamiento:** Desplaza los elementos en y despues del indice hacia la derecha.

---

#### remove

Elimina y retorna el elemento en el indice.

**Firma:**
```hemlock
array.remove(index: i32): any
```

**Parametros:**
- `index` - Posicion de donde eliminar (basada en 0)

**Retorna:** Elemento eliminado

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let removed2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**Comportamiento:** Desplaza los elementos despues del indice hacia la izquierda.

**Error:** Error en tiempo de ejecucion si el indice esta fuera de limites.

---

### Busqueda y Encontrar

#### find

Encuentra la primera ocurrencia de un valor.

**Firma:**
```hemlock
array.find(value: any): i32
```

**Parametros:**
- `value` - Valor a buscar

**Retorna:** Indice de la primera ocurrencia, o `-1` si no se encuentra

**Ejemplos:**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1 (no encontrado)

// Encontrar el primer duplicado
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1 (primera ocurrencia)
```

**Comparacion:** Usa igualdad de valor para primitivos y strings.

---

#### contains

Verifica si el array contiene un valor.

**Firma:**
```hemlock
array.contains(value: any): bool
```

**Parametros:**
- `value` - Valor a buscar

**Retorna:** `true` si se encuentra, `false` en caso contrario

**Ejemplos:**
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false

// Funciona con strings
let words = ["hello", "world"];
let has3 = words.contains("hello");  // true
```

---

### Segmentacion y Extraccion

#### slice

Extrae un subarray por rango (fin exclusivo).

**Firma:**
```hemlock
array.slice(start: i32, end: i32): array
```

**Parametros:**
- `start` - Indice inicial (basado en 0, inclusivo)
- `end` - Indice final (exclusivo)

**Retorna:** Nuevo array con elementos desde [start, end)

**Muta:** No (retorna nuevo array)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]
let first_three = arr.slice(0, 3);  // [1, 2, 3]
let last_two = arr.slice(3, 5);     // [4, 5]

// Segmento vacio
let empty = arr.slice(2, 2); // []
```

---

#### first

Obtiene el primer elemento sin eliminarlo.

**Firma:**
```hemlock
array.first(): any
```

**Retorna:** Primer elemento

**Muta:** No

**Ejemplos:**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3] (sin cambios)
```

**Error:** Error en tiempo de ejecucion si el array esta vacio.

---

#### last

Obtiene el ultimo elemento sin eliminarlo.

**Firma:**
```hemlock
array.last(): any
```

**Retorna:** Ultimo elemento

**Muta:** No

**Ejemplos:**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3] (sin cambios)
```

**Error:** Error en tiempo de ejecucion si el array esta vacio.

---

### Manipulacion de Arrays

#### reverse

Invierte el array en su lugar.

**Firma:**
```hemlock
array.reverse(): null
```

**Retorna:** `null`

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let words = ["hello", "world"];
words.reverse();             // ["world", "hello"]
```

---

#### clear

Elimina todos los elementos del array.

**Firma:**
```hemlock
array.clear(): null
```

**Retorna:** `null`

**Muta:** Si (modifica el array en su lugar)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### Combinacion de Arrays

#### concat

Concatena con otro array.

**Firma:**
```hemlock
array.concat(other: array): array
```

**Parametros:**
- `other` - Array a concatenar

**Retorna:** Nuevo array con elementos de ambos arrays

**Muta:** No (retorna nuevo array)

**Ejemplos:**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                    // [1, 2, 3] (sin cambios)
print(b);                    // [4, 5, 6] (sin cambios)

// Encadenar concatenaciones
let c = [7, 8];
let all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### Operaciones Funcionales

#### map

Transforma cada elemento usando una funcion de callback.

**Firma:**
```hemlock
array.map(callback: fn): array
```

**Parametros:**
- `callback` - Funcion que toma un elemento y retorna el valor transformado

**Retorna:** Nuevo array con elementos transformados

**Muta:** No (retorna nuevo array)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let doubled = arr.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

let names = ["alice", "bob"];
let upper = names.map(fn(s) { return s.to_upper(); });
print(upper);  // ["ALICE", "BOB"]
```

---

#### filter

Selecciona elementos que coinciden con un predicado.

**Firma:**
```hemlock
array.filter(predicate: fn): array
```

**Parametros:**
- `predicate` - Funcion que toma un elemento y retorna bool

**Retorna:** Nuevo array con elementos donde el predicado retorno true

**Muta:** No (retorna nuevo array)

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let evens = arr.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4, 6]

let words = ["hello", "hi", "hey", "goodbye"];
let short = words.filter(fn(s) { return s.length < 4; });
print(short);  // ["hi", "hey"]
```

---

#### reduce

Reduce el array a un solo valor usando un acumulador.

**Firma:**
```hemlock
array.reduce(callback: fn, initial: any): any
```

**Parametros:**
- `callback` - Funcion que toma (acumulador, elemento) y retorna nuevo acumulador
- `initial` - Valor inicial para el acumulador

**Retorna:** Valor acumulado final

**Muta:** No

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

let product = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(product);  // 120

// Encontrar el valor maximo
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### Conversion a String

#### join

Une elementos en un string con un delimitador.

**Firma:**
```hemlock
array.join(delimiter: string): string
```

**Parametros:**
- `delimiter` - String a colocar entre elementos

**Retorna:** String con todos los elementos unidos

**Ejemplos:**
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Funciona con tipos mixtos
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"

// Delimitador vacio
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**Comportamiento:** Convierte automaticamente todos los elementos a strings.

---

## Encadenamiento de Metodos

Los metodos de array pueden encadenarse para operaciones concisas:

**Ejemplos:**
```hemlock
// Encadenar slice y join
let result = ["apple", "banana", "cherry", "date"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

// Encadenar concat y slice
let combined = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// Encadenamiento complejo
let words = ["hello", "world", "foo", "bar"];
let result2 = words
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "hello-world-foo-baz"
```

---

## Resumen Completo de Metodos

### Metodos que Mutan

Metodos que modifican el array en su lugar:

| Metodo     | Firma                      | Retorna   | Descripcion                    |
|------------|----------------------------|-----------|--------------------------------|
| `push`     | `(value: any)`             | `null`    | Agregar al final               |
| `pop`      | `()`                       | `any`     | Eliminar del final             |
| `shift`    | `()`                       | `any`     | Eliminar del inicio            |
| `unshift`  | `(value: any)`             | `null`    | Agregar al inicio              |
| `insert`   | `(index: i32, value: any)` | `null`    | Insertar en indice             |
| `remove`   | `(index: i32)`             | `any`     | Eliminar en indice             |
| `reverse`  | `()`                       | `null`    | Invertir en su lugar           |
| `clear`    | `()`                       | `null`    | Eliminar todos los elementos   |

### Metodos que No Mutan

Metodos que retornan nuevos valores sin modificar el original:

| Metodo     | Firma                      | Retorna   | Descripcion                    |
|------------|----------------------------|-----------|--------------------------------|
| `find`     | `(value: any)`             | `i32`     | Encontrar primera ocurrencia   |
| `contains` | `(value: any)`             | `bool`    | Verificar si contiene valor    |
| `slice`    | `(start: i32, end: i32)`   | `array`   | Extraer subarray               |
| `first`    | `()`                       | `any`     | Obtener primer elemento        |
| `last`     | `()`                       | `any`     | Obtener ultimo elemento        |
| `concat`   | `(other: array)`           | `array`   | Concatenar arrays              |
| `join`     | `(delimiter: string)`      | `string`  | Unir elementos en string       |
| `map`      | `(callback: fn)`           | `array`   | Transformar cada elemento      |
| `filter`   | `(predicate: fn)`          | `array`   | Seleccionar elementos que coincidan |
| `reduce`   | `(callback: fn, initial: any)` | `any` | Reducir a un solo valor        |

---

## Patrones de Uso

### Uso como Pila

```hemlock
let stack = [];

// Push de elementos
stack.push(1);
stack.push(2);
stack.push(3);

// Pop de elementos
while (stack.length > 0) {
    let item = stack.pop();
    print(item);  // 3, 2, 1
}
```

### Uso como Cola

```hemlock
let queue = [];

// Encolar
queue.push(1);
queue.push(2);
queue.push(3);

// Desencolar
while (queue.length > 0) {
    let item = queue.shift();
    print(item);  // 1, 2, 3
}
```

### Transformacion de Arrays

```hemlock
// Filtrar (manual)
let numbers = [1, 2, 3, 4, 5, 6];
let evens = [];
let i = 0;
while (i < numbers.length) {
    if (numbers[i] % 2 == 0) {
        evens.push(numbers[i]);
    }
    i = i + 1;
}

// Mapear (manual)
let numbers2 = [1, 2, 3, 4, 5];
let doubled = [];
let j = 0;
while (j < numbers2.length) {
    doubled.push(numbers2[j] * 2);
    j = j + 1;
}
```

### Construir Arrays

```hemlock
let arr = [];

// Construir array con bucle
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## Detalles de Implementacion

**Gestion de Capacidad:**
- Los arrays crecen automaticamente cuando es necesario
- La capacidad se duplica cuando se excede
- Sin control manual de capacidad

**Comparacion de Valores:**
- `find()` y `contains()` usan igualdad de valor
- Funciona correctamente para primitivos y strings
- Objetos/arrays se comparan por referencia

**Memoria:**
- Asignados en el heap
- Sin liberacion automatica (gestion manual de memoria)
- Sin verificacion de limites en acceso directo por indice

---

## Ver Tambien

- [Sistema de Tipos](#reference-type-system) - Detalles del tipo array
- [API de Strings](#reference-string-api) - Resultados de join() en strings
- [Operadores](#reference-operators) - Operador de indexacion de arrays


--------------------------------------------------------------------------------
## API de Cadenas
--------------------------------------------------------------------------------

# Referencia de la API de Strings

Referencia completa para el tipo string de Hemlock y sus 19 metodos.

---

## Descripcion General

Los strings en Hemlock son secuencias **codificadas en UTF-8, mutables, asignadas en el heap** con soporte completo de Unicode. Todas las operaciones trabajan con **puntos de codigo** (caracteres), no bytes.

**Caracteristicas Principales:**
- Codificacion UTF-8 (U+0000 a U+10FFFF)
- Mutable (puede modificar caracteres en su lugar)
- Indexacion basada en puntos de codigo
- 19 metodos integrados
- Concatenacion automatica con el operador `+`

---

## Tipo String

**Tipo:** `string`

**Propiedades:**
- `.length` - Numero de puntos de codigo (caracteres)
- `.byte_length` - Numero de bytes UTF-8

**Sintaxis Literal:** Comillas dobles `"texto"`

**Ejemplos:**
```hemlock
let s = "hello";
print(s.length);        // 5 (puntos de codigo)
print(s.byte_length);   // 5 (bytes)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (un punto de codigo)
print(emoji.byte_length);   // 4 (cuatro bytes UTF-8)
```

---

## Indexacion

Los strings soportan indexacion basada en puntos de codigo usando `[]`:

**Acceso de Lectura:**
```hemlock
let s = "hello";
let ch = s[0];          // Retorna rune 'h'
```

**Acceso de Escritura:**
```hemlock
let s = "hello";
s[0] = 'H';             // Mutar con rune (ahora "Hello")
```

**Ejemplo UTF-8:**
```hemlock
let text = "HiðŸš€!";
print(text[0]);         // 'H'
print(text[1]);         // 'i'
print(text[2]);         // 'ðŸš€' (un punto de codigo)
print(text[3]);         // '!'
```

---

## Concatenacion

Use el operador `+` para concatenar strings y runes:

**String + String:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"
```

**String + Rune:**
```hemlock
let greeting = "Hello" + '!';      // "Hello!"
let decorated = "Text" + 'âœ“';      // "Textâœ“"
```

**Rune + String:**
```hemlock
let prefix = '>' + " Message";     // "> Message"
let bullet = 'â€¢' + " Item";        // "â€¢ Item"
```

**Concatenaciones Multiples:**
```hemlock
let msg = "Hi " + 'ðŸ‘‹' + " World " + 'ðŸŒ';  // "Hi ðŸ‘‹ World ðŸŒ"
```

---

## Propiedades de String

### .length

Obtiene el numero de puntos de codigo Unicode (caracteres).

**Tipo:** `i32`

**Ejemplos:**
```hemlock
let s = "hello";
print(s.length);        // 5

let emoji = "ðŸš€";
print(emoji.length);    // 1 (un punto de codigo)

let text = "Hello ðŸŒ!";
print(text.length);     // 8 (7 ASCII + 1 emoji)
```

---

### .byte_length

Obtiene el numero de bytes UTF-8.

**Tipo:** `i32`

**Ejemplos:**
```hemlock
let s = "hello";
print(s.byte_length);   // 5 (1 byte por caracter ASCII)

let emoji = "ðŸš€";
print(emoji.byte_length); // 4 (emoji es 4 bytes UTF-8)

let text = "Hello ðŸŒ!";
print(text.byte_length);  // 11 (7 ASCII + 4 para emoji)
```

---

## Metodos de String

### Subcadenas y Segmentacion

#### substr

Extrae subcadena por posicion y longitud.

**Firma:**
```hemlock
string.substr(start: i32, length: i32): string
```

**Parametros:**
- `start` - Indice inicial del punto de codigo (basado en 0)
- `length` - Numero de puntos de codigo a extraer

**Retorna:** Nuevo string

**Ejemplos:**
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world"
let first = s.substr(0, 5);     // "hello"

// Ejemplo UTF-8
let text = "HiðŸš€!";
let emoji = text.substr(2, 1);  // "ðŸš€"
```

---

#### slice

Extrae subcadena por rango (fin exclusivo).

**Firma:**
```hemlock
string.slice(start: i32, end: i32): string
```

**Parametros:**
- `start` - Indice inicial del punto de codigo (basado en 0)
- `end` - Indice final del punto de codigo (exclusivo)

**Retorna:** Nuevo string

**Ejemplos:**
```hemlock
let s = "hello world";
let sub = s.slice(0, 5);        // "hello"
let world = s.slice(6, 11);     // "world"

// Ejemplo UTF-8
let text = "HiðŸš€!";
let first_three = text.slice(0, 3);  // "HiðŸš€"
```

---

### Busqueda y Encontrar

#### find

Encuentra la primera ocurrencia de una subcadena.

**Firma:**
```hemlock
string.find(needle: string): i32
```

**Parametros:**
- `needle` - Subcadena a buscar

**Retorna:** Indice del punto de codigo de la primera ocurrencia, o `-1` si no se encuentra

**Ejemplos:**
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6
let pos2 = s.find("foo");       // -1 (no encontrado)
let pos3 = s.find("l");         // 2 (primera 'l')
```

---

#### contains

Verifica si el string contiene una subcadena.

**Firma:**
```hemlock
string.contains(needle: string): bool
```

**Parametros:**
- `needle` - Subcadena a buscar

**Retorna:** `true` si se encuentra, `false` en caso contrario

**Ejemplos:**
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

---

### Dividir y Unir

#### split

Divide el string en un array por delimitador.

**Firma:**
```hemlock
string.split(delimiter: string): array
```

**Parametros:**
- `delimiter` - String por el cual dividir

**Retorna:** Array de strings

**Ejemplos:**
```hemlock
let csv = "a,b,c";
let parts = csv.split(",");     // ["a", "b", "c"]

let path = "/usr/local/bin";
let dirs = path.split("/");     // ["", "usr", "local", "bin"]

let text = "hello world foo";
let words = text.split(" ");    // ["hello", "world", "foo"]
```

---

#### trim

Elimina espacios en blanco al inicio y al final.

**Firma:**
```hemlock
string.trim(): string
```

**Retorna:** Nuevo string con espacios en blanco eliminados

**Ejemplos:**
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let text = "\n\t  world  \n";
let clean2 = text.trim();       // "world"
```

---

### Conversion de Mayusculas/Minusculas

#### to_upper

Convierte el string a mayusculas.

**Firma:**
```hemlock
string.to_upper(): string
```

**Retorna:** Nuevo string en mayusculas

**Ejemplos:**
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

let mixed = "HeLLo";
let upper2 = mixed.to_upper();  // "HELLO"
```

---

#### to_lower

Convierte el string a minusculas.

**Firma:**
```hemlock
string.to_lower(): string
```

**Retorna:** Nuevo string en minusculas

**Ejemplos:**
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"

let mixed = "HeLLo";
let lower2 = mixed.to_lower();  // "hello"
```

---

### Prefijo y Sufijo

#### starts_with

Verifica si el string comienza con un prefijo.

**Firma:**
```hemlock
string.starts_with(prefix: string): bool
```

**Parametros:**
- `prefix` - Prefijo a verificar

**Retorna:** `true` si el string comienza con el prefijo, `false` en caso contrario

**Ejemplos:**
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

---

#### ends_with

Verifica si el string termina con un sufijo.

**Firma:**
```hemlock
string.ends_with(suffix: string): bool
```

**Parametros:**
- `suffix` - Sufijo a verificar

**Retorna:** `true` si el string termina con el sufijo, `false` en caso contrario

**Ejemplos:**
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

---

### Reemplazo

#### replace

Reemplaza la primera ocurrencia de una subcadena.

**Firma:**
```hemlock
string.replace(old: string, new: string): string
```

**Parametros:**
- `old` - Subcadena a reemplazar
- `new` - String de reemplazo

**Retorna:** Nuevo string con la primera ocurrencia reemplazada

**Ejemplos:**
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");  // "hello there"

let text = "foo foo foo";
let text2 = text.replace("foo", "bar"); // "bar foo foo" (solo la primera)
```

---

#### replace_all

Reemplaza todas las ocurrencias de una subcadena.

**Firma:**
```hemlock
string.replace_all(old: string, new: string): string
```

**Parametros:**
- `old` - Subcadena a reemplazar
- `new` - String de reemplazo

**Retorna:** Nuevo string con todas las ocurrencias reemplazadas

**Ejemplos:**
```hemlock
let text = "foo foo foo";
let text2 = text.replace_all("foo", "bar"); // "bar bar bar"

let s = "hello world hello";
let s2 = s.replace_all("hello", "hi");      // "hi world hi"
```

---

### Repeticion

#### repeat

Repite el string n veces.

**Firma:**
```hemlock
string.repeat(count: i32): string
```

**Parametros:**
- `count` - Numero de repeticiones

**Retorna:** Nuevo string repetido count veces

**Ejemplos:**
```hemlock
let s = "ha";
let repeated = s.repeat(3);     // "hahaha"

let line = "-";
let separator = line.repeat(40); // "----------------------------------------"
```

---

### Acceso a Caracteres

#### char_at

Obtiene el punto de codigo Unicode en el indice.

**Firma:**
```hemlock
string.char_at(index: i32): rune
```

**Parametros:**
- `index` - Indice del punto de codigo (basado en 0)

**Retorna:** Rune (punto de codigo Unicode)

**Ejemplos:**
```hemlock
let s = "hello";
let ch = s.char_at(0);          // 'h'
let ch2 = s.char_at(1);         // 'e'

// Ejemplo UTF-8
let emoji = "ðŸš€";
let ch3 = emoji.char_at(0);     // U+1F680 (cohete)
```

---

#### chars

Convierte el string a un array de runes.

**Firma:**
```hemlock
string.chars(): array
```

**Retorna:** Array de runes (puntos de codigo)

**Ejemplos:**
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']

// Ejemplo UTF-8
let text = "HiðŸš€!";
let chars2 = text.chars();      // ['H', 'i', 'ðŸš€', '!']
```

---

### Acceso a Bytes

#### byte_at

Obtiene el valor del byte en el indice.

**Firma:**
```hemlock
string.byte_at(index: i32): u8
```

**Parametros:**
- `index` - Indice del byte (basado en 0, NO indice de punto de codigo)

**Retorna:** Valor del byte (u8)

**Ejemplos:**
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (ASCII 'h')
let byte2 = s.byte_at(1);       // 101 (ASCII 'e')

// Ejemplo UTF-8
let emoji = "ðŸš€";
let byte3 = emoji.byte_at(0);   // 240 (primer byte UTF-8)
```

---

#### bytes

Convierte el string a un array de bytes.

**Firma:**
```hemlock
string.bytes(): array
```

**Retorna:** Array de bytes u8

**Ejemplos:**
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111]

// Ejemplo UTF-8
let emoji = "ðŸš€";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)
```

---

#### to_bytes

Convierte el string a buffer.

**Firma:**
```hemlock
string.to_bytes(): buffer
```

**Retorna:** Buffer conteniendo bytes UTF-8

**Ejemplos:**
```hemlock
let s = "hello";
let buf = s.to_bytes();
print(buf.length);              // 5

// Ejemplo UTF-8
let emoji = "ðŸš€";
let buf2 = emoji.to_bytes();
print(buf2.length);             // 4
```

**Nota:** Este es un metodo heredado. Prefiera `.bytes()` para la mayoria de los casos de uso.

---

### Deserializacion JSON

#### deserialize

Analiza un string JSON a un valor.

**Firma:**
```hemlock
string.deserialize(): any
```

**Retorna:** Valor analizado (objeto, array, numero, string, bool, o null)

**Ejemplos:**
```hemlock
let json = '{"x":10,"y":20}';
let obj = json.deserialize();
print(obj.x);                   // 10
print(obj.y);                   // 20

let arr_json = '[1,2,3]';
let arr = arr_json.deserialize();
print(arr[0]);                  // 1

let num_json = '42';
let num = num_json.deserialize();
print(num);                     // 42
```

**Tipos Soportados:**
- Objetos: `{"key": value}`
- Arrays: `[1, 2, 3]`
- Numeros: `42`, `3.14`
- Strings: `"text"`
- Booleanos: `true`, `false`
- Null: `null`

**Ver Tambien:** Metodo `.serialize()` de objetos

---

## Encadenamiento de Metodos

Los metodos de string pueden encadenarse para operaciones concisas:

**Ejemplos:**
```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ");                  // "foo | bar | baz"

let cleaned = "  HELLO  "
    .trim()
    .to_lower();                   // "hello"
```

---

## Resumen Completo de Metodos

| Metodo         | Firma                                        | Retorna   | Descripcion                           |
|----------------|----------------------------------------------|-----------|---------------------------------------|
| `substr`       | `(start: i32, length: i32)`                  | `string`  | Extraer subcadena por posicion/longitud |
| `slice`        | `(start: i32, end: i32)`                     | `string`  | Extraer subcadena por rango           |
| `find`         | `(needle: string)`                           | `i32`     | Encontrar primera ocurrencia (-1 si no se encuentra) |
| `contains`     | `(needle: string)`                           | `bool`    | Verificar si contiene subcadena       |
| `split`        | `(delimiter: string)`                        | `array`   | Dividir en array                      |
| `trim`         | `()`                                         | `string`  | Eliminar espacios en blanco           |
| `to_upper`     | `()`                                         | `string`  | Convertir a mayusculas                |
| `to_lower`     | `()`                                         | `string`  | Convertir a minusculas                |
| `starts_with`  | `(prefix: string)`                           | `bool`    | Verificar si comienza con prefijo     |
| `ends_with`    | `(suffix: string)`                           | `bool`    | Verificar si termina con sufijo       |
| `replace`      | `(old: string, new: string)`                 | `string`  | Reemplazar primera ocurrencia         |
| `replace_all`  | `(old: string, new: string)`                 | `string`  | Reemplazar todas las ocurrencias      |
| `repeat`       | `(count: i32)`                               | `string`  | Repetir string n veces                |
| `char_at`      | `(index: i32)`                               | `rune`    | Obtener punto de codigo en indice     |
| `byte_at`      | `(index: i32)`                               | `u8`      | Obtener byte en indice                |
| `chars`        | `()`                                         | `array`   | Convertir a array de runes            |
| `bytes`        | `()`                                         | `array`   | Convertir a array de bytes            |
| `to_bytes`     | `()`                                         | `buffer`  | Convertir a buffer (heredado)         |
| `deserialize`  | `()`                                         | `any`     | Analizar string JSON                  |

---

## Ver Tambien

- [Sistema de Tipos](#reference-type-system) - Detalles del tipo string
- [API de Arrays](#reference-array-api) - Metodos de array para resultados de split()
- [Operadores](#reference-operators) - Operador de concatenacion de strings


--------------------------------------------------------------------------------
## API de Concurrencia
--------------------------------------------------------------------------------

# Referencia de la API de Concurrencia

Referencia completa para el sistema async/concurrencia de Hemlock.

---

## Descripcion General

Hemlock proporciona **concurrencia estructurada** con verdadero paralelismo multi-hilo usando hilos POSIX (pthreads). Cada tarea generada se ejecuta en un hilo separado del sistema operativo, permitiendo ejecucion paralela real a traves de multiples nucleos de CPU.

**Caracteristicas Principales:**
- Verdadero paralelismo multi-hilo (no hilos verdes)
- Sintaxis de funciones async
- Generacion y union de tareas
- Canales seguros para hilos
- Propagacion de excepciones

**Modelo de Hilos:**
- Hilos reales del SO (POSIX pthreads)
- Verdadero paralelismo (multiples nucleos de CPU)
- Planificacion del kernel (multitarea preemptiva)
- Sincronizacion segura para hilos (mutexes, variables de condicion)

---

## Funciones Async

### Declaracion de Funcion Async

Las funciones pueden declararse como `async` para indicar que estan disenadas para ejecucion concurrente.

**Sintaxis:**
```hemlock
async fn nombre_funcion(params): tipo_retorno {
    // cuerpo de funcion
}
```

**Ejemplos:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

async fn process_data(data: string) {
    print("Procesando:", data);
    return null;
}
```

**Comportamiento:**
- `async fn` declara una funcion asincrona
- Puede llamarse sincronicamente (se ejecuta en el hilo actual)
- Puede generarse como tarea concurrente (se ejecuta en nuevo hilo)
- Cuando se genera, se ejecuta en su propio hilo del SO

**Nota:** La palabra clave `await` esta reservada para uso futuro pero no esta implementada actualmente.

---

## Gestion de Tareas

### spawn

Crea e inicia una nueva tarea concurrente.

**Firma:**
```hemlock
spawn(async_fn: function, ...args): task
```

**Parametros:**
- `async_fn` - Funcion async a ejecutar
- `...args` - Argumentos a pasar a la funcion

**Retorna:** Manejador de tarea

**Ejemplos:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Generar una sola tarea
let t = spawn(compute, 1000);
let result = join(t);
print(result);

// Generar multiples tareas (se ejecutan en paralelo!)
let t1 = spawn(compute, 100);
let t2 = spawn(compute, 200);
let t3 = spawn(compute, 300);

// Las tres se estan ejecutando simultaneamente
let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

**Comportamiento:**
- Crea nuevo hilo del SO via `pthread_create()`
- Comienza a ejecutar la funcion inmediatamente
- Retorna manejador de tarea para union posterior
- Las tareas se ejecutan en paralelo en nucleos de CPU separados

---

### join

Espera la finalizacion de la tarea y recupera el resultado.

**Firma:**
```hemlock
join(task: task): any
```

**Parametros:**
- `task` - Manejador de tarea de `spawn()`

**Retorna:** Valor de retorno de la tarea

**Ejemplos:**
```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

let t = spawn(factorial, 10);
let result = join(t);  // Bloquea hasta que la tarea complete
print(result);         // 3628800
```

**Comportamiento:**
- Bloquea el hilo actual hasta que la tarea complete
- Retorna el valor de retorno de la tarea
- Propaga excepciones lanzadas por la tarea
- Limpia recursos de la tarea despues de retornar

**Manejo de Errores:**
```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Tarea fallo!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Capturado:", e);  // "Capturado: Tarea fallo!"
}
```

---

### detach

Desvincula la tarea (ejecucion de disparar y olvidar).

**Firma:**
```hemlock
detach(task: task): null
```

**Parametros:**
- `task` - Manejador de tarea de `spawn()`

**Retorna:** `null`

**Ejemplos:**
```hemlock
async fn background_work() {
    print("Trabajando en segundo plano...");
    return null;
}

let t = spawn(background_work);
detach(t);  // La tarea continua ejecutandose independientemente

// No se puede unir tarea desvinculada
// join(t);  // ERROR
```

**Comportamiento:**
- La tarea continua ejecutandose independientemente
- No se puede hacer `join()` a tarea desvinculada
- La tarea y el hilo se limpian automaticamente cuando la tarea completa

**Casos de Uso:**
- Tareas de segundo plano de disparar y olvidar
- Tareas de logging/monitoreo
- Tareas que no necesitan retornar valores

---

## Canales

Los canales proporcionan comunicacion segura entre hilos para tareas.

### channel

Crea un canal con buffer.

**Firma:**
```hemlock
channel(capacity: i32): channel
```

**Parametros:**
- `capacity` - Tamano del buffer (numero de valores)

**Retorna:** Objeto Canal

**Ejemplos:**
```hemlock
let ch = channel(10);  // Canal con buffer de capacidad 10
let ch2 = channel(1);  // Buffer minimo (sincrono)
let ch3 = channel(100); // Buffer grande
```

**Comportamiento:**
- Crea canal seguro para hilos
- Usa mutexes pthread para sincronizacion
- La capacidad es fija al momento de creacion

---

### Metodos de Canal

#### send

Envia valor al canal (bloquea si esta lleno).

**Firma:**
```hemlock
channel.send(value: any): null
```

**Parametros:**
- `value` - Valor a enviar (cualquier tipo)

**Retorna:** `null`

**Ejemplos:**
```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let t = spawn(producer, ch, 5);
```

**Comportamiento:**
- Envia valor al canal
- Bloquea si el canal esta lleno
- Seguro para hilos (usa mutex)
- Retorna despues de que el valor se envia

---

#### recv

Recibe valor del canal (bloquea si esta vacio).

**Firma:**
```hemlock
channel.recv(): any
```

**Retorna:** Valor del canal, o `null` si el canal esta cerrado y vacio

**Ejemplos:**
```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let t = spawn(consumer, ch, 5);
```

**Comportamiento:**
- Recibe valor del canal
- Bloquea si el canal esta vacio
- Retorna `null` si el canal esta cerrado y vacio
- Seguro para hilos (usa mutex)

---

#### close

Cierra el canal (no se permiten mas envios).

**Firma:**
```hemlock
channel.close(): null
```

**Retorna:** `null`

**Ejemplos:**
```hemlock
async fn producer(ch) {
    ch.send(1);
    ch.send(2);
    ch.send(3);
    ch.close();  // Senalar que no hay mas valores
    return null;
}

async fn consumer(ch) {
    while (true) {
        let val = ch.recv();
        if (val == null) {
            break;  // Canal cerrado
        }
        print(val);
    }
    return null;
}
```

**Comportamiento:**
- Cierra el canal
- No se permiten mas envios
- `recv()` retorna `null` cuando el canal esta vacio
- Seguro para hilos

---

## Ejemplo Completo de Concurrencia

### Patron Productor-Consumidor

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        print("Produciendo:", i);
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        print("Consumiendo:", val);
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Crear canal
let ch = channel(10);

// Generar productor y consumidor
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Esperar finalizacion
join(p);
let total = join(c);
print("Total:", total);  // 0+10+20+30+40 = 100
```

---

## Computacion Paralela

### Ejemplo de Multiples Tareas

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Generar multiples tareas (se ejecutan en paralelo!)
let t1 = spawn(factorial, 5);   // Hilo 1
let t2 = spawn(factorial, 6);   // Hilo 2
let t3 = spawn(factorial, 7);   // Hilo 3
let t4 = spawn(factorial, 8);   // Hilo 4

// Las cuatro estan computando simultaneamente!

// Esperar resultados
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
let f8 = join(t4);  // 40320

print(f5, f6, f7, f8);
```

---

## Ciclo de Vida de Tareas

### Transiciones de Estado

1. **Creada** - Tarea generada pero aun no ejecutando
2. **Ejecutando** - Tarea ejecutandose en hilo del SO
3. **Completada** - Tarea terminada (resultado disponible)
4. **Unida** - Resultado recuperado, recursos limpiados
5. **Desvinculada** - Tarea continua independientemente

### Ejemplo de Ciclo de Vida

```hemlock
async fn work(n: i32): i32 {
    return n * 2;
}

// 1. Crear tarea
let t = spawn(work, 21);  // Estado: Ejecutando

// La tarea se ejecuta en hilo separado...

// 2. Unir tarea
let result = join(t);     // Estado: Completada -> Unida
print(result);            // 42

// Recursos de tarea limpiados despues de union
```

### Ciclo de Vida Desvinculado

```hemlock
async fn background() {
    print("Tarea de segundo plano ejecutandose");
    return null;
}

// 1. Crear tarea
let t = spawn(background);  // Estado: Ejecutando

// 2. Desvincular tarea
detach(t);                  // Estado: Desvinculada

// La tarea continua ejecutandose independientemente
// Recursos limpiados por el SO cuando termina
```

---

## Manejo de Errores

### Propagacion de Excepciones

Las excepciones lanzadas en tareas se propagan cuando se unen:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Tarea fallo!";
    }
    return 42;
}

// Tarea que tiene exito
let t1 = spawn(risky_operation, 0);
let result1 = join(t1);  // 42

// Tarea que falla
let t2 = spawn(risky_operation, 1);
try {
    let result2 = join(t2);
} catch (e) {
    print("Capturado:", e);  // "Capturado: Tarea fallo!"
}
```

### Manejando Multiples Tareas

```hemlock
async fn work(id: i32, should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Tarea " + typeof(id) + " fallo";
    }
    return id * 10;
}

let t1 = spawn(work, 1, 0);
let t2 = spawn(work, 2, 1);  // Fallara
let t3 = spawn(work, 3, 0);

// Unir con manejo de errores
try {
    let r1 = join(t1);  // OK
    print("Tarea 1:", r1);

    let r2 = join(t2);  // Lanza
    print("Tarea 2:", r2);  // Nunca se alcanza
} catch (e) {
    print("Error:", e);  // "Error: Tarea 2 fallo"
}

// Aun se puede unir la tarea restante
let r3 = join(t3);
print("Tarea 3:", r3);
```

---

## Caracteristicas de Rendimiento

### Verdadero Paralelismo

```hemlock
async fn cpu_intensive(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Ejecucion secuencial
let start = get_time();
let r1 = cpu_intensive(10000000);
let r2 = cpu_intensive(10000000);
let sequential_time = get_time() - start;

// Ejecucion paralela
let start2 = get_time();
let t1 = spawn(cpu_intensive, 10000000);
let t2 = spawn(cpu_intensive, 10000000);
join(t1);
join(t2);
let parallel_time = get_time() - start2;

// parallel_time deberia ser ~50% de sequential_time en sistemas multi-nucleo
```

**Caracteristicas Comprobadas:**
- N tareas pueden utilizar N nucleos de CPU simultaneamente
- Pruebas de estres muestran 8-9x tiempo de CPU vs tiempo real (prueba de paralelismo)
- Sobrecarga de hilo: ~8KB de pila + sobrecarga de pthread por tarea
- Operaciones bloqueantes en una tarea no bloquean otras

---

## Detalles de Implementacion

### Modelo de Hilos

- **Hilos 1:1** - Cada tarea = 1 hilo del SO (`pthread`)
- **Planificacion del kernel** - El kernel del SO distribuye hilos entre nucleos
- **Multitarea preemptiva** - El SO puede interrumpir y cambiar hilos
- **Sin GIL** - Sin Bloqueo Global del Interprete (a diferencia de Python)

### Sincronizacion

- **Mutexes** - Los canales usan `pthread_mutex_t`
- **Variables de condicion** - send/recv bloqueantes usan `pthread_cond_t`
- **Operaciones sin bloqueo** - Las transiciones de estado de tarea son atomicas

### Memoria y Limpieza

- **Tareas unidas** - Limpiadas automaticamente despues de `join()`
- **Tareas desvinculadas** - Limpiadas automaticamente cuando la tarea completa
- **Canales** - Con conteo de referencias, liberados cuando ya no se usan

---

## Limitaciones

- Sin `select()` para multiplexar multiples canales
- Sin planificador de robo de trabajo (1 hilo por tarea)
- Sin integracion de E/S async (operaciones de archivo/red bloquean)
- Capacidad del canal fija al momento de creacion

---

## Resumen Completo de la API

### Funciones

| Funcion   | Firma                             | Retorna   | Descripcion                    |
|-----------|-----------------------------------|-----------|--------------------------------|
| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Crear e iniciar tarea concurrente |
| `join`    | `(task: task)`                    | `any`     | Esperar tarea, obtener resultado |
| `detach`  | `(task: task)`                    | `null`    | Desvincular tarea (disparar y olvidar) |
| `channel` | `(capacity: i32)`                 | `channel` | Crear canal seguro para hilos  |

### Metodos de Canal

| Metodo  | Firma           | Retorna | Descripcion                      |
|---------|-----------------|---------|----------------------------------|
| `send`  | `(value: any)`  | `null`  | Enviar valor (bloquea si lleno)  |
| `recv`  | `()`            | `any`   | Recibir valor (bloquea si vacio) |
| `close` | `()`            | `null`  | Cerrar canal                     |

### Tipos

| Tipo      | Descripcion                          |
|-----------|--------------------------------------|
| `task`    | Manejador para tarea concurrente     |
| `channel` | Canal de comunicacion seguro para hilos |

---

## Mejores Practicas

### Hacer

- Use canales para comunicacion entre tareas
- Maneje excepciones de tareas unidas
- Cierre canales cuando termine de enviar
- Use `join()` para obtener resultados y limpiar
- Genere solo funciones async

### No Hacer

- No comparta estado mutable sin sincronizacion
- No una la misma tarea dos veces
- No envie en canales cerrados
- No genere funciones no-async
- No olvide unir tareas (a menos que esten desvinculadas)

---

## Ver Tambien

- [Funciones Integradas](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`
- [Sistema de Tipos](#reference-type-system) - Tipos de tarea y canal


--------------------------------------------------------------------------------
## API de Memoria
--------------------------------------------------------------------------------

# Referencia de la API de Memoria

Referencia completa para las funciones de gestion de memoria y tipos de puntero de Hemlock.

---

## Descripcion General

Hemlock proporciona **gestion manual de memoria** con asignacion y liberacion explicitas. La memoria se gestiona a traves de dos tipos de puntero: punteros crudos (`ptr`) y buffers seguros (`buffer`).

**Principios Clave:**
- Asignacion y liberacion explicitas
- Sin recoleccion de basura
- El usuario es responsable de llamar a `free()`
- Conteo de referencias interno para seguridad de alcance/reasignacion (ver abajo)

### Conteo de Referencias Interno

El runtime usa conteo de referencias internamente para gestionar los tiempos de vida de objetos a traves de alcances. Para la mayoria de variables locales, la limpieza es automatica.

**Automatico (sin necesidad de `free()`):**
- Variables locales de tipos con conteo de referencias (buffer, array, object, string) se liberan cuando el alcance termina
- Los valores antiguos se liberan cuando las variables se reasignan
- Los elementos de contenedores se liberan cuando los contenedores se liberan

**Se requiere `free()` manual:**
- Punteros crudos de `alloc()` - siempre
- Limpieza temprana antes de que termine el alcance
- Datos de larga duracion/globales

Vea la [Guia de Gestion de Memoria](../language-guide/memory.md#internal-reference-counting) para detalles.

---

## Tipos de Puntero

### ptr (Puntero Crudo)

**Tipo:** `ptr`

**Descripcion:** Direccion de memoria cruda sin verificacion de limites ni seguimiento.

**Tamano:** 8 bytes

**Casos de Uso:**
- Operaciones de memoria de bajo nivel
- FFI (Interfaz de Funciones Foraneas)
- Maximo rendimiento (sin sobrecarga)

**Seguridad:** Inseguro - sin verificacion de limites, el usuario debe rastrear el tiempo de vida

**Ejemplos:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer (Buffer Seguro)

**Tipo:** `buffer`

**Descripcion:** Envoltorio de puntero seguro con verificacion de limites.

**Estructura:** Puntero + longitud + capacidad + ref_count

**Propiedades:**
- `.length` - Tamano del buffer (i32)
- `.capacity` - Capacidad asignada (i32)

**Casos de Uso:**
- La mayoria de las asignaciones de memoria
- Cuando la seguridad es importante
- Arrays dinamicos

**Seguridad:** Verificacion de limites en acceso por indice

**Conteo de Referencias:** Los buffers tienen conteo de referencias interno. Se liberan automaticamente cuando el alcance termina o la variable se reasigna. Use `free()` para limpieza temprana o datos de larga duracion.

**Ejemplos:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Verificacion de limites
print(b.length);        // 64
free(b);
```

---

## Funciones de Asignacion de Memoria

### alloc

Asigna memoria cruda.

**Firma:**
```hemlock
alloc(size: i32): ptr
```

**Parametros:**
- `size` - Numero de bytes a asignar

**Retorna:** Puntero a la memoria asignada (`ptr`)

**Ejemplos:**
```hemlock
let p = alloc(1024);        // Asignar 1KB
memset(p, 0, 1024);         // Inicializar a cero
free(p);                    // Liberar cuando termine

// Asignar para estructura
let struct_size = 16;
let p2 = alloc(struct_size);
```

**Comportamiento:**
- Retorna memoria sin inicializar
- La memoria debe liberarse manualmente
- Retorna `null` en fallo de asignacion (el llamador debe verificar)

**Ver Tambien:** `buffer()` para alternativa mas segura

---

### buffer

Asigna buffer seguro con verificacion de limites.

**Firma:**
```hemlock
buffer(size: i32): buffer
```

**Parametros:**
- `size` - Tamano del buffer en bytes

**Retorna:** Objeto Buffer

**Ejemplos:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// Acceso con verificacion de limites
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // ERROR: fuera de limites

free(buf);
```

**Propiedades:**
- `.length` - Tamano actual (i32)
- `.capacity` - Capacidad asignada (i32)

**Comportamiento:**
- Inicializa la memoria a cero
- Proporciona verificacion de limites en acceso por indice
- Retorna `null` en fallo de asignacion (el llamador debe verificar)
- Debe liberarse manualmente

---

### free

Libera memoria asignada.

**Firma:**
```hemlock
free(ptr: ptr | buffer): null
```

**Parametros:**
- `ptr` - Puntero o buffer a liberar

**Retorna:** `null`

**Ejemplos:**
```hemlock
// Liberar puntero crudo
let p = alloc(1024);
free(p);

// Liberar buffer
let buf = buffer(256);
free(buf);
```

**Comportamiento:**
- Libera memoria asignada por `alloc()` o `buffer()`
- Doble liberacion causa crash (responsabilidad del usuario evitarlo)
- Liberar punteros invalidos causa comportamiento indefinido

**Importante:** Tu asignas, tu liberas. Sin limpieza automatica.

---

### realloc

Redimensiona memoria asignada.

**Firma:**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**Parametros:**
- `ptr` - Puntero a redimensionar
- `new_size` - Nuevo tamano en bytes

**Retorna:** Puntero a la memoria redimensionada (puede ser direccion diferente)

**Ejemplos:**
```hemlock
let p = alloc(100);
// ... usar memoria ...

// Necesita mas espacio
p = realloc(p, 200);        // Ahora 200 bytes
// ... usar memoria expandida ...

free(p);
```

**Comportamiento:**
- Puede mover la memoria a nueva ubicacion
- Preserva datos existentes (hasta el minimo del tamano antiguo/nuevo)
- El puntero antiguo es invalido despues de realloc exitoso (use el puntero retornado)
- Si new_size es menor, los datos se truncan
- Retorna `null` en fallo de asignacion (el puntero original permanece valido)

**Importante:** Siempre verifique si es `null` y actualice su variable de puntero con el resultado.

---

## Operaciones de Memoria

### memset

Llena memoria con valor de byte.

**Firma:**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**Parametros:**
- `ptr` - Puntero a memoria
- `byte` - Valor de byte a llenar (0-255)
- `size` - Numero de bytes a llenar

**Retorna:** `null`

**Ejemplos:**
```hemlock
let p = alloc(100);

// Poner memoria a cero
memset(p, 0, 100);

// Llenar con valor especifico
memset(p, 0xFF, 100);

// Inicializar buffer
let buf = alloc(256);
memset(buf, 65, 256);       // Llenar con 'A'

free(p);
free(buf);
```

**Comportamiento:**
- Escribe el valor de byte a cada byte en el rango
- El valor de byte se trunca a 8 bits (0-255)
- Sin verificacion de limites (inseguro)

---

### memcpy

Copia memoria desde origen a destino.

**Firma:**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**Parametros:**
- `dest` - Puntero destino
- `src` - Puntero origen
- `size` - Numero de bytes a copiar

**Retorna:** `null`

**Ejemplos:**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// Inicializar origen
memset(src, 65, 100);

// Copiar a destino
memcpy(dest, src, 100);

// dest ahora contiene los mismos datos que src

free(src);
free(dest);
```

**Comportamiento:**
- Copia byte por byte desde src a dest
- Sin verificacion de limites (inseguro)
- Regiones superpuestas tienen comportamiento indefinido (use con cuidado)

---

## Operaciones de Memoria Tipadas

### sizeof

Obtiene el tamano de un tipo en bytes.

**Firma:**
```hemlock
sizeof(type): i32
```

**Parametros:**
- `type` - Identificador de tipo (ej., `i32`, `f64`, `ptr`)

**Retorna:** Tamano en bytes (i32)

**Tamanos de Tipos:**

| Tipo | Tamano (bytes) |
|------|----------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**Ejemplos:**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// Calcular tamano de asignacion de array
let count = 100;
let total = sizeof(i32) * count; // 400 bytes
```

**Comportamiento:**
- Retorna 0 para tipos desconocidos
- Acepta tanto identificadores de tipo como strings de tipo

---

### talloc

Asigna array de valores tipados.

**Firma:**
```hemlock
talloc(type, count: i32): ptr
```

**Parametros:**
- `type` - Tipo a asignar (ej., `i32`, `f64`, `ptr`)
- `count` - Numero de elementos (debe ser positivo)

**Retorna:** Puntero al array asignado, o `null` en fallo de asignacion

**Ejemplos:**
```hemlock
let arr = talloc(i32, 100);      // Array de 100 i32s (400 bytes)
let floats = talloc(f64, 50);    // Array de 50 f64s (400 bytes)
let bytes = talloc(u8, 1024);    // Array de 1024 bytes

// Siempre verificar fallo de asignacion
if (arr == null) {
    panic("fallo de asignacion");
}

// Usar la memoria asignada
// ...

free(arr);
free(floats);
free(bytes);
```

**Comportamiento:**
- Asigna `sizeof(type) * count` bytes
- Retorna memoria sin inicializar
- La memoria debe liberarse manualmente con `free()`
- Retorna `null` en fallo de asignacion (el llamador debe verificar)
- Entra en panico si count no es positivo

---

## Propiedades de Buffer

### .length

Obtiene el tamano del buffer.

**Tipo:** `i32`

**Acceso:** Solo lectura

**Ejemplos:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

Obtiene la capacidad del buffer.

**Tipo:** `i32`

**Acceso:** Solo lectura

**Ejemplos:**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**Nota:** Actualmente, `.length` y `.capacity` son iguales para buffers creados con `buffer()`.

---

## Patrones de Uso

### Patron de Asignacion Basico

```hemlock
// Asignar
let p = alloc(1024);
if (p == null) {
    panic("fallo de asignacion");
}

// Usar
memset(p, 0, 1024);

// Liberar
free(p);
```

### Patron de Buffer Seguro

```hemlock
// Asignar buffer
let buf = buffer(256);
if (buf == null) {
    panic("fallo de asignacion de buffer");
}

// Usar con verificacion de limites
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// Liberar
free(buf);
```

### Patron de Crecimiento Dinamico

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("fallo de asignacion");
}

// ... usar memoria ...

// Necesita mas espacio - verificar fallo
let new_p = realloc(p, 200);
if (new_p == null) {
    // El puntero original sigue valido, limpiar
    free(p);
    panic("fallo de realloc");
}
p = new_p;
size = 200;

// ... usar memoria expandida ...

free(p);
```

### Patron de Copia de Memoria

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// Crear copia
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## Consideraciones de Seguridad

**La gestion de memoria de Hemlock es INSEGURA por diseno:**

### Errores Comunes

**1. Fugas de Memoria**
```hemlock
// MAL: Fuga de memoria
fn create_buffer() {
    let p = alloc(1024);
    return null;  // Memoria perdida!
}

// BIEN: Limpieza apropiada
fn create_buffer() {
    let p = alloc(1024);
    // ... usar memoria ...
    free(p);
    return null;
}
```

**2. Uso Despues de Liberar**
```hemlock
// MAL: Uso despues de liberar
let p = alloc(100);
free(p);
memset(p, 0, 100);  // CRASH: usando memoria liberada

// BIEN: No usar despues de liberar
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// No tocar p2 despues de esto
```

**3. Doble Liberacion**
```hemlock
// MAL: Doble liberacion
let p = alloc(100);
free(p);
free(p);  // CRASH: doble liberacion

// BIEN: Liberar una vez
let p2 = alloc(100);
free(p2);
```

**4. Desbordamiento de Buffer (ptr)**
```hemlock
// MAL: Desbordamiento de buffer con ptr
let p = alloc(10);
memset(p, 65, 100);  // CRASH: escribiendo mas alla de la asignacion

// BIEN: Usar buffer para verificacion de limites
let buf = buffer(10);
// buf[100] = 65;  // ERROR: verificacion de limites falla
```

**5. Punteros Colgantes**
```hemlock
// MAL: Puntero colgante
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // CRASH: p2 esta colgando

// BIEN: Rastrear propiedad cuidadosamente
let p = alloc(100);
// ... usar p ...
free(p);
// No mantener otras referencias a p
```

**6. Fallo de Asignacion sin Verificar**
```hemlock
// MAL: No verificar null
let p = alloc(1000000000);  // Puede fallar con poca memoria
memset(p, 0, 1000000000);   // CRASH: p es null

// BIEN: Siempre verificar resultado de asignacion
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("sin memoria");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## Cuando Usar Que

### Use `buffer()` cuando:
- Necesite verificacion de limites
- Trabaje con datos dinamicos
- La seguridad sea importante
- Este aprendiendo Hemlock

### Use `alloc()` cuando:
- Necesite maximo rendimiento
- Interfaz FFI/con C
- Conozca el layout exacto de memoria
- Sea un experto

### Use `realloc()` cuando:
- Crezca/reduzca asignaciones
- Arrays dinamicos
- Necesite preservar datos

---

## Resumen Completo de Funciones

| Funcion   | Firma                              | Retorna  | Descripcion                |
|-----------|----------------------------------------|----------|----------------------------|
| `alloc`   | `(size: i32)`                          | `ptr`    | Asignar memoria cruda      |
| `buffer`  | `(size: i32)`                          | `buffer` | Asignar buffer seguro      |
| `free`    | `(ptr: ptr \| buffer)`                 | `null`   | Liberar memoria            |
| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | Redimensionar asignacion   |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | Llenar memoria             |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | Copiar memoria             |
| `sizeof`  | `(type)`                               | `i32`    | Obtener tamano de tipo en bytes |
| `talloc`  | `(type, count: i32)`                   | `ptr`    | Asignar array tipado       |

---

## Ver Tambien

- [Sistema de Tipos](#reference-type-system) - Tipos de puntero y buffer
- [Funciones Integradas](#reference-builtins) - Todas las funciones integradas
- [API de Strings](#reference-string-api) - Metodo `.to_bytes()` de string


--------------------------------------------------------------------------------
## Funciones Integradas
--------------------------------------------------------------------------------

# Referencia de Funciones Integradas

Referencia completa para todas las funciones integradas y constantes en Hemlock.

---

## Descripcion General

Hemlock proporciona un conjunto de funciones integradas para E/S, introspeccion de tipos, gestion de memoria, concurrencia e interaccion con el sistema. Todas las funciones integradas estan disponibles globalmente sin importaciones.

---

## Funciones de E/S

### print

Imprime valores a stdout con nueva linea.

**Firma:**
```hemlock
print(...values): null
```

**Parametros:**
- `...values` - Cualquier numero de valores a imprimir

**Retorna:** `null`

**Ejemplos:**
```hemlock
print("Hello, World!");
print(42);
print(3.14);
print(true);
print([1, 2, 3]);
print({ x: 10, y: 20 });

// Multiples valores
print("x =", 10, "y =", 20);
```

**Comportamiento:**
- Convierte todos los valores a strings
- Separa multiples valores con espacios
- Agrega nueva linea al final
- Vacia stdout

---

### read_line

Lee una linea de texto desde stdin (entrada del usuario).

**Firma:**
```hemlock
read_line(): string | null
```

**Parametros:** Ninguno

**Retorna:**
- `string` - La linea leida desde stdin (nueva linea eliminada)
- `null` - En EOF (fin de archivo/entrada)

**Ejemplos:**
```hemlock
// Prompt simple
print("Cual es tu nombre?");
let name = read_line();
print("Hola, " + name + "!");

// Leer numeros (requiere analisis manual)
print("Ingresa un numero:");
let input = read_line();
let num = parse_int(input);  // Ver abajo para parse_int
print("Doble:", num * 2);

// Manejar EOF
let line = read_line();
if (line == null) {
    print("Fin de entrada");
}

// Leer multiples lineas
print("Ingresa lineas (Ctrl+D para parar):");
while (true) {
    let line = read_line();
    if (line == null) {
        break;
    }
    print("Dijiste:", line);
}
```

**Comportamiento:**
- Bloquea hasta que el usuario presiona Enter
- Elimina nueva linea (`\n`) y retorno de carro (`\r`) finales
- Retorna `null` en EOF (Ctrl+D en Unix, Ctrl+Z en Windows)
- Lee solo desde stdin (no desde archivos)

**Analizando Entrada del Usuario:**

Como `read_line()` siempre retorna un string, necesita analizar entrada numerica manualmente:

```hemlock
// Analizador simple de enteros
fn parse_int(s: string): i32 {
    let result: i32 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// Uso
print("Ingresa tu edad:");
let age = parse_int(read_line());
print("En 10 anos tendras", age + 10);
```

**Ver Tambien:** [API de Archivos](#reference-file-api) para leer desde archivos

---

### eprint

Imprime un valor a stderr con nueva linea.

**Firma:**
```hemlock
eprint(value: any): null
```

**Parametros:**
- `value` - Valor unico a imprimir a stderr

**Retorna:** `null`

**Ejemplos:**
```hemlock
eprint("Error: archivo no encontrado");
eprint(404);
eprint("Advertencia: " + message);

// Patron tipico de manejo de errores
fn load_config(path: string) {
    if (!exists(path)) {
        eprint("Error: archivo de configuracion no encontrado: " + path);
        return null;
    }
    // ...
}
```

**Comportamiento:**
- Imprime a stderr (flujo de error estandar)
- Agrega nueva linea al final
- Solo acepta un argumento (a diferencia de `print`)
- Util para mensajes de error que no deben mezclarse con salida normal

**Diferencia con print:**
- `print()` -> stdout (salida normal, puede redirigirse con `>`)
- `eprint()` -> stderr (salida de error, puede redirigirse con `2>`)

```bash
# Ejemplo de shell: separar stdout y stderr
./hemlock script.hml > output.txt 2> errors.txt
```

---

## Introspeccion de Tipos

### typeof

Obtiene el nombre del tipo de un valor.

**Firma:**
```hemlock
typeof(value: any): string
```

**Parametros:**
- `value` - Cualquier valor

**Retorna:** Nombre del tipo como string

**Ejemplos:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof(null));            // "null"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

// Objetos tipados
define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"

// Otros tipos
print(typeof(alloc(10)));       // "ptr"
print(typeof(buffer(10)));      // "buffer"
print(typeof(open("file.txt"))); // "file"
```

**Nombres de Tipos:**
- Primitivos: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Compuestos: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Especiales: `"file"`, `"task"`, `"channel"`
- Personalizados: Nombres de tipos definidos por el usuario desde `define`

**Ver Tambien:** [Sistema de Tipos](#reference-type-system)

---

## Ejecucion de Comandos

### exec

Ejecuta comando de shell y captura salida.

**Firma:**
```hemlock
exec(command: string): object
```

**Parametros:**
- `command` - Comando de shell a ejecutar

**Retorna:** Objeto con campos:
- `output` (string) - stdout del comando
- `exit_code` (i32) - Codigo de estado de salida (0 = exito)

**Ejemplos:**
```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0

// Verificar estado de salida
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Encontrado:", r.output);
} else {
    print("Patron no encontrado");
}

// Procesar salida multi-linea
let r2 = exec("ls -la");
let lines = r2.output.split("\n");
```

**Comportamiento:**
- Ejecuta comando via `/bin/sh`
- Captura solo stdout (stderr va a terminal)
- Bloquea hasta que el comando complete
- Retorna string vacio si no hay salida

**Manejo de Errores:**
```hemlock
try {
    let r = exec("nonexistent_command");
} catch (e) {
    print("Fallo al ejecutar:", e);
}
```

**Advertencia de Seguridad:** Vulnerable a inyeccion de shell. Siempre valide/sanee entrada del usuario.

**Limitaciones:**
- Sin captura de stderr
- Sin streaming
- Sin timeout
- Sin manejo de senales

---

### exec_argv

Ejecuta un comando con array de argumentos explicito (sin interpretacion de shell).

**Firma:**
```hemlock
exec_argv(argv: array): object
```

**Parametros:**
- `argv` - Array de strings: `[comando, arg1, arg2, ...]`

**Retorna:** Objeto con campos:
- `output` (string) - stdout del comando
- `exit_code` (i32) - Codigo de estado de salida (0 = exito)

**Ejemplos:**
```hemlock
// Comando simple
let result = exec_argv(["ls", "-la"]);
print(result.output);

// Comando con argumentos que contienen espacios (seguro!)
let r = exec_argv(["grep", "hello world", "file.txt"]);

// Ejecutar script con argumentos
let r2 = exec_argv(["python", "script.py", "--input", "data.json"]);
print(r2.exit_code);
```

**Diferencia con exec:**
```hemlock
// exec() usa shell - INSEGURO con entrada de usuario
exec("ls " + user_input);  // Riesgo de inyeccion de shell!

// exec_argv() evita shell - SEGURO
exec_argv(["ls", user_input]);  // Sin inyeccion posible
```

**Cuando usar:**
- Cuando los argumentos contienen espacios, comillas o caracteres especiales
- Al procesar entrada de usuario (seguridad)
- Cuando necesita analisis predecible de argumentos

**Ver Tambien:** `exec()` para comandos de shell simples

---

## Manejo de Errores

### throw

Lanza una excepcion.

**Firma:**
```hemlock
throw expression
```

**Parametros:**
- `expression` - Valor a lanzar (cualquier tipo)

**Retorna:** Nunca retorna (transfiere control)

**Ejemplos:**
```hemlock
throw "mensaje de error";
throw 404;
throw { code: 500, message: "Error interno" };
throw null;
```

**Ver Tambien:** Sentencias try/catch/finally

---

### panic

Termina inmediatamente el programa con mensaje de error (irrecuperable).

**Firma:**
```hemlock
panic(message?: any): never
```

**Parametros:**
- `message` (opcional) - Mensaje de error a imprimir

**Retorna:** Nunca retorna (el programa sale)

**Ejemplos:**
```hemlock
panic();                          // Por defecto: "panic!"
panic("codigo inalcanzable alcanzado");
panic(42);

// Caso de uso comun
fn process_state(state: i32): string {
    if (state == 1) { return "listo"; }
    if (state == 2) { return "ejecutando"; }
    panic("estado invalido: " + typeof(state));
}
```

**Comportamiento:**
- Imprime error a stderr: `panic: <mensaje>`
- Sale con codigo 1
- **NO se puede capturar** con try/catch
- Use para bugs y errores irrecuperables

**Panic vs Throw:**
- `panic()` - Error irrecuperable, sale inmediatamente
- `throw` - Error recuperable, puede capturarse

---

### assert

Afirma que una condicion es verdadera, o termina con un mensaje de error.

**Firma:**
```hemlock
assert(condition: any, message?: string): null
```

**Parametros:**
- `condition` - Valor a verificar por veracidad
- `message` (opcional) - Mensaje de error personalizado si la afirmacion falla

**Retorna:** `null` (si la afirmacion pasa)

**Ejemplos:**
```hemlock
// Afirmaciones basicas
assert(x > 0);
assert(name != null);
assert(arr.length > 0, "El array no debe estar vacio");

// Con mensajes personalizados
fn divide(a: i32, b: i32): f64 {
    assert(b != 0, "Division por cero");
    return a / b;
}

// Validar argumentos de funcion
fn process_data(data: array) {
    assert(data != null, "data no puede ser null");
    assert(data.length > 0, "data no puede estar vacio");
    // ...
}
```

**Comportamiento:**
- Si la condicion es verdadera: retorna `null`, la ejecucion continua
- Si la condicion es falsa: imprime error y sale con codigo 1
- Valores falsos: `false`, `0`, `0.0`, `null`, `""` (string vacio)
- Valores verdaderos: todo lo demas

**Salida en fallo:**
```
Assertion failed: El array no debe estar vacio
```

**Cuando usar:**
- Validar precondiciones de funciones
- Verificar invariantes durante desarrollo
- Capturar errores del programador temprano

**assert vs panic:**
- `assert(cond, msg)` - Verifica una condicion, falla si es falsa
- `panic(msg)` - Siempre falla incondicionalmente

---

## Manejo de Senales

### signal

Registra o reinicia manejador de senal.

**Firma:**
```hemlock
signal(signum: i32, handler: function | null): function | null
```

**Parametros:**
- `signum` - Numero de senal (use constantes como `SIGINT`)
- `handler` - Funcion a llamar cuando se recibe senal, o `null` para reiniciar a predeterminado

**Retorna:** Funcion manejadora anterior, o `null`

**Ejemplos:**
```hemlock
fn handle_interrupt(sig) {
    print("SIGINT capturado!");
}

signal(SIGINT, handle_interrupt);

// Reiniciar a predeterminado
signal(SIGINT, null);
```

**Firma del Manejador:**
```hemlock
fn handler(signum: i32) {
    // signum contiene el numero de senal
}
```

**Ver Tambien:**
- [Constantes de senal](#constantes-de-senal)
- `raise()`

---

### raise

Envia senal al proceso actual.

**Firma:**
```hemlock
raise(signum: i32): null
```

**Parametros:**
- `signum` - Numero de senal a lanzar

**Retorna:** `null`

**Ejemplos:**
```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

raise(SIGUSR1);
raise(SIGUSR1);
print(count);  // 2
```

---

## Variables Globales

### args

Array de argumentos de linea de comandos.

**Tipo:** `array` de strings

**Estructura:**
- `args[0]` - Nombre del archivo de script
- `args[1..n]` - Argumentos de linea de comandos

**Ejemplos:**
```bash
# Comando: ./hemlock script.hml hello world
```

```hemlock
print(args[0]);        // "script.hml"
print(args.length);    // 3
print(args[1]);        // "hello"
print(args[2]);        // "world"

// Iterar argumentos
let i = 1;
while (i < args.length) {
    print("Argumento", i, ":", args[i]);
    i = i + 1;
}
```

**Comportamiento en REPL:** En el REPL, `args.length` es 0 (array vacio)

---

## Constantes de Senal

Constantes de senal POSIX estandar (valores i32):

### Interrupcion y Terminacion

| Constante  | Valor | Descripcion                            |
|------------|-------|----------------------------------------|
| `SIGINT`   | 2     | Interrupcion desde teclado (Ctrl+C)    |
| `SIGTERM`  | 15    | Solicitud de terminacion               |
| `SIGQUIT`  | 3     | Salir desde teclado (Ctrl+\)           |
| `SIGHUP`   | 1     | Colgado detectado en terminal controladora |
| `SIGABRT`  | 6     | Senal de abortar                       |

### Definidas por Usuario

| Constante  | Valor | Descripcion                |
|------------|-------|----------------------------|
| `SIGUSR1`  | 10    | Senal definida por usuario 1 |
| `SIGUSR2`  | 12    | Senal definida por usuario 2 |

### Control de Proceso

| Constante  | Valor | Descripcion                     |
|------------|-------|---------------------------------|
| `SIGALRM`  | 14    | Temporizador de alarma          |
| `SIGCHLD`  | 17    | Cambio de estado de proceso hijo |
| `SIGCONT`  | 18    | Continuar si esta detenido      |
| `SIGSTOP`  | 19    | Detener proceso (no se puede capturar) |
| `SIGTSTP`  | 20    | Parada de terminal (Ctrl+Z)     |

### E/S

| Constante  | Valor | Descripcion                        |
|------------|-------|------------------------------------|
| `SIGPIPE`  | 13    | Tuberia rota                       |
| `SIGTTIN`  | 21    | Lectura de terminal en segundo plano |
| `SIGTTOU`  | 22    | Escritura de terminal en segundo plano |

**Ejemplos:**
```hemlock
fn handle_signal(sig) {
    if (sig == SIGINT) {
        print("Interrupcion detectada");
    }
    if (sig == SIGTERM) {
        print("Terminacion solicitada");
    }
}

signal(SIGINT, handle_signal);
signal(SIGTERM, handle_signal);
```

**Nota:** `SIGKILL` (9) y `SIGSTOP` (19) no pueden capturarse ni ignorarse.

---

## Funciones Matematicas/Aritmeticas

### div

Division entera que retorna un flotante.

**Firma:**
```hemlock
div(a: number, b: number): f64
```

**Parametros:**
- `a` - Dividendo
- `b` - Divisor

**Retorna:** Piso de `a / b` como flotante (f64)

**Ejemplos:**
```hemlock
let result = div(7, 2);    // 3.0 (no 3.5)
let result2 = div(10, 3);  // 3.0
let result3 = div(-7, 2);  // -4.0 (piso redondea hacia infinito negativo)
```

**Nota:** En Hemlock, el operador `/` siempre retorna un flotante. Use `div()` para division entera cuando necesite la parte entera como flotante, o `divi()` cuando necesite un resultado entero.

---

### divi

Division entera que retorna un entero.

**Firma:**
```hemlock
divi(a: number, b: number): i64
```

**Parametros:**
- `a` - Dividendo
- `b` - Divisor

**Retorna:** Piso de `a / b` como entero (i64)

**Ejemplos:**
```hemlock
let result = divi(7, 2);    // 3
let result2 = divi(10, 3);  // 3
let result3 = divi(-7, 2);  // -4 (piso redondea hacia infinito negativo)
```

**Comparacion:**
```hemlock
print(7 / 2);      // 3.5 (division regular, siempre flotante)
print(div(7, 2));  // 3.0 (division entera, resultado flotante)
print(divi(7, 2)); // 3   (division entera, resultado entero)
```

---

## Funciones de Gestion de Memoria

Vea la [API de Memoria](#reference-memory-api) para referencia completa:
- `alloc(size)` - Asignar memoria cruda
- `free(ptr)` - Liberar memoria
- `buffer(size)` - Asignar buffer seguro
- `memset(ptr, byte, size)` - Llenar memoria
- `memcpy(dest, src, size)` - Copiar memoria
- `realloc(ptr, new_size)` - Redimensionar asignacion

### sizeof

Obtiene el tamano de un tipo en bytes.

**Firma:**
```hemlock
sizeof(type): i32
```

**Parametros:**
- `type` - Una constante de tipo (`i32`, `f64`, `ptr`, etc.) o string de nombre de tipo

**Retorna:** Tamano en bytes como `i32`

**Ejemplos:**
```hemlock
print(sizeof(i8));       // 1
print(sizeof(i16));      // 2
print(sizeof(i32));      // 4
print(sizeof(i64));      // 8
print(sizeof(f32));      // 4
print(sizeof(f64));      // 8
print(sizeof(ptr));      // 8
print(sizeof(rune));     // 4

// Usando alias de tipo
print(sizeof(byte));     // 1 (igual que u8)
print(sizeof(integer));  // 4 (igual que i32)
print(sizeof(number));   // 8 (igual que f64)

// Forma string tambien funciona
print(sizeof("i32"));    // 4
```

**Tipos Soportados:**
| Tipo | Tamano | Alias |
|------|--------|-------|
| `i8` | 1 | - |
| `i16` | 2 | - |
| `i32` | 4 | `integer` |
| `i64` | 8 | - |
| `u8` | 1 | `byte` |
| `u16` | 2 | - |
| `u32` | 4 | - |
| `u64` | 8 | - |
| `f32` | 4 | - |
| `f64` | 8 | `number` |
| `ptr` | 8 | - |
| `rune` | 4 | - |
| `bool` | 1 | - |

**Ver Tambien:** `talloc()` para asignacion tipada

---

### talloc

Asigna memoria para un array tipado (asignacion consciente del tipo).

**Firma:**
```hemlock
talloc(type, count: i32): ptr
```

**Parametros:**
- `type` - Una constante de tipo (`i32`, `f64`, `ptr`, etc.)
- `count` - Numero de elementos a asignar

**Retorna:** `ptr` a memoria asignada, o `null` en fallo

**Ejemplos:**
```hemlock
// Asignar array de 10 i32s (40 bytes)
let int_arr = talloc(i32, 10);
ptr_write_i32(int_arr, 42);
ptr_write_i32(ptr_offset(int_arr, 1, 4), 100);

// Asignar array de 5 f64s (40 bytes)
let float_arr = talloc(f64, 5);

// Asignar array de 100 bytes
let byte_arr = talloc(u8, 100);

// No olvide liberar!
free(int_arr);
free(float_arr);
free(byte_arr);
```

**Comparacion con alloc:**
```hemlock
// Estos son equivalentes:
let p1 = talloc(i32, 10);      // Consciente del tipo: 10 i32s
let p2 = alloc(sizeof(i32) * 10);  // Calculo manual

// talloc es mas claro y menos propenso a errores
```

**Manejo de Errores:**
- Retorna `null` si la asignacion falla
- Sale con error si count no es positivo
- Verifica desbordamiento de tamano (count * tamano_elemento)

**Ver Tambien:** `alloc()`, `sizeof()`, `free()`

---

## Ayudantes de Puntero FFI

Estas funciones ayudan a leer y escribir valores tipados en memoria cruda, utiles para FFI y manipulacion de memoria de bajo nivel.

### ptr_null

Crea un puntero nulo.

**Firma:**
```hemlock
ptr_null(): ptr
```

**Retorna:** Un puntero nulo

**Ejemplo:**
```hemlock
let p = ptr_null();
if (p == null) {
    print("El puntero es nulo");
}
```

---

### ptr_offset

Calcula desplazamiento de puntero (aritmetica de punteros).

**Firma:**
```hemlock
ptr_offset(ptr: ptr, index: i32, element_size: i32): ptr
```

**Parametros:**
- `ptr` - Puntero base
- `index` - Indice del elemento
- `element_size` - Tamano de cada elemento en bytes

**Retorna:** Puntero al elemento en el indice dado

**Ejemplo:**
```hemlock
let arr = talloc(i32, 10);
ptr_write_i32(arr, 100);                      // arr[0] = 100
ptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200
ptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300

print(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200
free(arr);
```

---

### Funciones de Lectura de Puntero

Lee valores tipados desde memoria.

| Funcion | Firma | Retorna | Descripcion |
|---------|-------|---------|-------------|
| `ptr_read_i8` | `(ptr)` | `i8` | Lee entero con signo de 8 bits |
| `ptr_read_i16` | `(ptr)` | `i16` | Lee entero con signo de 16 bits |
| `ptr_read_i32` | `(ptr)` | `i32` | Lee entero con signo de 32 bits |
| `ptr_read_i64` | `(ptr)` | `i64` | Lee entero con signo de 64 bits |
| `ptr_read_u8` | `(ptr)` | `u8` | Lee entero sin signo de 8 bits |
| `ptr_read_u16` | `(ptr)` | `u16` | Lee entero sin signo de 16 bits |
| `ptr_read_u32` | `(ptr)` | `u32` | Lee entero sin signo de 32 bits |
| `ptr_read_u64` | `(ptr)` | `u64` | Lee entero sin signo de 64 bits |
| `ptr_read_f32` | `(ptr)` | `f32` | Lee flotante de 32 bits |
| `ptr_read_f64` | `(ptr)` | `f64` | Lee flotante de 64 bits |
| `ptr_read_ptr` | `(ptr)` | `ptr` | Lee valor de puntero |

**Ejemplo:**
```hemlock
let p = alloc(8);
ptr_write_f64(p, 3.14159);
let value = ptr_read_f64(p);
print(value);  // 3.14159
free(p);
```

---

### Funciones de Escritura de Puntero

Escribe valores tipados a memoria.

| Funcion | Firma | Retorna | Descripcion |
|---------|-------|---------|-------------|
| `ptr_write_i8` | `(ptr, value)` | `null` | Escribe entero con signo de 8 bits |
| `ptr_write_i16` | `(ptr, value)` | `null` | Escribe entero con signo de 16 bits |
| `ptr_write_i32` | `(ptr, value)` | `null` | Escribe entero con signo de 32 bits |
| `ptr_write_i64` | `(ptr, value)` | `null` | Escribe entero con signo de 64 bits |
| `ptr_write_u8` | `(ptr, value)` | `null` | Escribe entero sin signo de 8 bits |
| `ptr_write_u16` | `(ptr, value)` | `null` | Escribe entero sin signo de 16 bits |
| `ptr_write_u32` | `(ptr, value)` | `null` | Escribe entero sin signo de 32 bits |
| `ptr_write_u64` | `(ptr, value)` | `null` | Escribe entero sin signo de 64 bits |
| `ptr_write_f32` | `(ptr, value)` | `null` | Escribe flotante de 32 bits |
| `ptr_write_f64` | `(ptr, value)` | `null` | Escribe flotante de 64 bits |
| `ptr_write_ptr` | `(ptr, value)` | `null` | Escribe valor de puntero |

**Ejemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);
print(ptr_read_i32(p));  // 42
free(p);
```

---

### Conversion Buffer/Puntero

#### buffer_ptr

Obtiene puntero crudo desde un buffer.

**Firma:**
```hemlock
buffer_ptr(buf: buffer): ptr
```

**Ejemplo:**
```hemlock
let buf = buffer(64);
let p = buffer_ptr(buf);
// Ahora p apunta a la misma memoria que buf
```

#### ptr_to_buffer

Crea un envoltorio de buffer alrededor de un puntero crudo.

**Firma:**
```hemlock
ptr_to_buffer(ptr: ptr, size: i32): buffer
```

**Ejemplo:**
```hemlock
let p = alloc(64);
let buf = ptr_to_buffer(p, 64);
buf[0] = 65;  // Ahora tiene verificacion de limites
// Nota: liberar buf liberara la memoria subyacente
```

---

## Funciones de E/S de Archivos

Vea la [API de Archivos](#reference-file-api) para referencia completa:
- `open(path, mode?)` - Abrir archivo

---

## Funciones de Concurrencia

Vea la [API de Concurrencia](#reference-concurrency-api) para referencia completa:
- `spawn(fn, args...)` - Generar tarea
- `join(task)` - Esperar tarea
- `detach(task)` - Desvincular tarea
- `channel(capacity)` - Crear canal

### apply

Llama una funcion dinamicamente con un array de argumentos.

**Firma:**
```hemlock
apply(fn: function, args: array): any
```

**Parametros:**
- `fn` - La funcion a llamar
- `args` - Array de argumentos a pasar a la funcion

**Retorna:** El valor de retorno de la funcion llamada

**Ejemplos:**
```hemlock
fn add(a, b) {
    return a + b;
}

// Llamar con array de argumentos
let result = apply(add, [2, 3]);
print(result);  // 5

// Despacho dinamico
let operations = {
    add: fn(a, b) { return a + b; },
    mul: fn(a, b) { return a * b; },
    sub: fn(a, b) { return a - b; }
};

fn calculate(op: string, args: array) {
    return apply(operations[op], args);
}

print(calculate("add", [10, 5]));  // 15
print(calculate("mul", [10, 5]));  // 50
print(calculate("sub", [10, 5]));  // 5

// Argumentos variables
fn sum(...nums) {
    let total = 0;
    for (n in nums) {
        total = total + n;
    }
    return total;
}

let numbers = [1, 2, 3, 4, 5];
print(apply(sum, numbers));  // 15
```

**Casos de Uso:**
- Despacho dinamico de funciones basado en valores en tiempo de ejecucion
- Llamar funciones con listas de argumentos variables
- Implementar utilidades de orden superior (map, filter, etc.)
- Sistemas de plugins/extensiones

---

### select

Espera datos de multiples canales, retornando cuando alguno tenga datos.

**Firma:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parametros:**
- `channels` - Array de valores de canal
- `timeout_ms` (opcional) - Timeout en milisegundos (-1 u omitir para infinito)

**Retorna:**
- `{ channel, value }` - Objeto con el canal que tenia datos y el valor recibido
- `null` - En timeout

**Ejemplos:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Tareas productoras
spawn(fn() {
    sleep(100);
    ch1.send("desde canal 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("desde canal 2");
});

// Esperar primer mensaje
let result = select([ch1, ch2]);
print(result.value);  // "desde canal 2" (llego primero)

// Con timeout
let result2 = select([ch1, ch2], 1000);  // Esperar hasta 1 segundo
if (result2 == null) {
    print("Timeout - no se recibieron datos");
} else {
    print("Recibido:", result2.value);
}

// Bucle select continuo
while (true) {
    let msg = select([ch1, ch2], 5000);
    if (msg == null) {
        print("Sin actividad por 5 segundos");
        break;
    }
    print("Mensaje recibido:", msg.value);
}
```

**Comportamiento:**
- Bloquea hasta que un canal tenga datos o expire el timeout
- Retorna inmediatamente si un canal ya tiene datos
- Si el canal esta cerrado y vacio, retorna `{ channel, value: null }`
- Sondea canales en orden (el primer canal listo gana)

**Casos de Uso:**
- Multiplexar multiples productores
- Implementar timeouts en operaciones de canal
- Construir bucles de eventos con multiples fuentes

---

## Tabla Resumen

### Funciones

| Funcion    | Categoria       | Retorna      | Descripcion                     |
|------------|-----------------|--------------|----------------------------------|
| `print`    | E/S             | `null`       | Imprimir a stdout               |
| `read_line`| E/S             | `string?`    | Leer linea desde stdin          |
| `eprint`   | E/S             | `null`       | Imprimir a stderr               |
| `typeof`   | Tipo            | `string`     | Obtener nombre de tipo          |
| `exec`     | Comando         | `object`     | Ejecutar comando de shell       |
| `exec_argv`| Comando         | `object`     | Ejecutar con array de argumentos |
| `assert`   | Error           | `null`       | Afirmar condicion o salir       |
| `panic`    | Error           | `never`      | Error irrecuperable (sale)      |
| `signal`   | Senal           | `function?`  | Registrar manejador de senal    |
| `raise`    | Senal           | `null`       | Enviar senal al proceso         |
| `alloc`    | Memoria         | `ptr`        | Asignar memoria cruda           |
| `talloc`   | Memoria         | `ptr`        | Asignacion tipada               |
| `sizeof`   | Memoria         | `i32`        | Obtener tamano de tipo en bytes |
| `free`     | Memoria         | `null`       | Liberar memoria                 |
| `buffer`   | Memoria         | `buffer`     | Asignar buffer seguro           |
| `memset`   | Memoria         | `null`       | Llenar memoria                  |
| `memcpy`   | Memoria         | `null`       | Copiar memoria                  |
| `realloc`  | Memoria         | `ptr`        | Redimensionar asignacion        |
| `open`     | E/S Archivo     | `file`       | Abrir archivo                   |
| `spawn`    | Concurrencia    | `task`       | Generar tarea concurrente       |
| `join`     | Concurrencia    | `any`        | Esperar resultado de tarea      |
| `detach`   | Concurrencia    | `null`       | Desvincular tarea               |
| `channel`  | Concurrencia    | `channel`    | Crear canal de comunicacion     |
| `select`   | Concurrencia    | `object?`    | Esperar en multiples canales    |
| `apply`    | Funciones       | `any`        | Llamar funcion con array de args |

### Variables Globales

| Variable   | Tipo     | Descripcion                       |
|------------|----------|-----------------------------------|
| `args`     | `array`  | Argumentos de linea de comandos   |

### Constantes

| Constante  | Tipo  | Categoria | Valor | Descripcion               |
|------------|-------|----------|-------|---------------------------|
| `SIGINT`   | `i32` | Senal    | 2     | Interrupcion de teclado   |
| `SIGTERM`  | `i32` | Senal    | 15    | Solicitud de terminacion  |
| `SIGQUIT`  | `i32` | Senal    | 3     | Salir de teclado          |
| `SIGHUP`   | `i32` | Senal    | 1     | Colgado                   |
| `SIGABRT`  | `i32` | Senal    | 6     | Abortar                   |
| `SIGUSR1`  | `i32` | Senal    | 10    | Definida por usuario 1    |
| `SIGUSR2`  | `i32` | Senal    | 12    | Definida por usuario 2    |
| `SIGALRM`  | `i32` | Senal    | 14    | Temporizador de alarma    |
| `SIGCHLD`  | `i32` | Senal    | 17    | Cambio de estado de hijo  |
| `SIGCONT`  | `i32` | Senal    | 18    | Continuar                 |
| `SIGSTOP`  | `i32` | Senal    | 19    | Parar (no capturable)     |
| `SIGTSTP`  | `i32` | Senal    | 20    | Parada de terminal        |
| `SIGPIPE`  | `i32` | Senal    | 13    | Tuberia rota              |
| `SIGTTIN`  | `i32` | Senal    | 21    | Lectura terminal segundo plano |
| `SIGTTOU`  | `i32` | Senal    | 22    | Escritura terminal segundo plano |

---

## Ver Tambien

- [Sistema de Tipos](#reference-type-system) - Tipos y conversiones
- [API de Memoria](#reference-memory-api) - Funciones de asignacion de memoria
- [API de Archivos](#reference-file-api) - Funciones de E/S de archivos
- [API de Concurrencia](#reference-concurrency-api) - Funciones async/concurrencia
- [API de Strings](#reference-string-api) - Metodos de string
- [API de Arrays](#reference-array-api) - Metodos de array


--------------------------------------------------------------------------------
## Operadores
--------------------------------------------------------------------------------

# Referencia de Operadores

Referencia completa para todos los operadores en Hemlock, incluyendo precedencia, asociatividad y comportamiento.

---

## Descripcion General

Hemlock proporciona operadores estilo C con reglas de precedencia explicitas. Todos los operadores siguen reglas de tipado estrictas con promocion automatica de tipos donde sea aplicable.

---

## Operadores Aritmeticos

### Aritmeticos Binarios

| Operador | Nombre         | Ejemplo    | Descripcion                  |
|----------|----------------|------------|------------------------------|
| `+`      | Suma           | `a + b`    | Sumar dos valores            |
| `-`      | Resta          | `a - b`    | Restar b de a                |
| `*`      | Multiplicacion | `a * b`    | Multiplicar dos valores      |
| `/`      | Division       | `a / b`    | Dividir a entre b            |

**Promocion de Tipos:**
Los resultados siguen reglas de promocion de tipos (vea [Sistema de Tipos](type-system.md#reglas-de-promocion-de-tipos)).

**Ejemplos:**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// Division flotante
let e = 10.0 / 3.0;    // 3.333... (f64)

// Tipos mixtos
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, promocionado)
```

**Division por Cero:**
- Division entera por cero: Error en tiempo de ejecucion
- Division flotante por cero: Retorna `inf` o `-inf`

---

### Aritmeticos Unarios

| Operador | Nombre   | Ejemplo | Descripcion          |
|----------|----------|---------|----------------------|
| `-`      | Negacion | `-a`    | Negar valor          |
| `+`      | Mas      | `+a`    | Identidad (sin efecto) |

**Ejemplos:**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5 (sin cambio)

let x = -3.14;         // -3.14
```

---

## Operadores de Comparacion

| Operador | Nombre                | Ejemplo    | Retorna |
|----------|-----------------------|------------|---------|
| `==`     | Igual                 | `a == b`   | `bool`  |
| `!=`     | No igual              | `a != b`   | `bool`  |
| `<`      | Menor que             | `a < b`    | `bool`  |
| `>`      | Mayor que             | `a > b`    | `bool`  |
| `<=`     | Menor o igual que     | `a <= b`   | `bool`  |
| `>=`     | Mayor o igual que     | `a >= b`   | `bool`  |

**Promocion de Tipos:**
Los operandos se promocionan antes de la comparacion.

**Ejemplos:**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// Comparacion de strings
print("hello" == "hello");  // true
print("abc" < "def");       // true (lexicografico)

// Tipos mixtos
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true (promocionado a i32)
```

---

## Operadores Logicos

| Operador | Nombre      | Ejemplo      | Descripcion              |
|----------|-------------|--------------|--------------------------|
| `&&`     | AND Logico  | `a && b`     | Verdadero si ambos son verdaderos |
| `||`     | OR Logico   | `a || b`     | Verdadero si alguno es verdadero |
| `!`      | NOT Logico  | `!a`         | Negar booleano           |

**Evaluacion de Cortocircuito:**
- `&&` - Se detiene en el primer valor falso
- `||` - Se detiene en el primer valor verdadero

**Ejemplos:**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// Cortocircuito
if (x != 0 && (10 / x) > 2) {
    print("seguro");
}

if (x == 0 || (10 / x) > 2) {
    print("seguro");
}
```

---

## Operadores de Bits

**Restriccion:** Solo tipos enteros (i8-i64, u8-u64)

### Binarios de Bits

| Operador | Nombre           | Ejemplo    | Descripcion              |
|----------|------------------|------------|--------------------------|
| `&`      | AND de Bits      | `a & b`    | AND cada bit             |
| `|`      | OR de Bits       | `a | b`    | OR cada bit              |
| `^`      | XOR de Bits      | `a ^ b`    | XOR cada bit             |
| `<<`     | Desplazamiento izq | `a << b` | Desplazar izquierda b bits |
| `>>`     | Desplazamiento der | `a >> b` | Desplazar derecha b bits |

**Preservacion de Tipo:**
El tipo del resultado coincide con los tipos de operandos (con promocion de tipos).

**Ejemplos:**
```hemlock
let a = 12;  // 1100 en binario
let b = 10;  // 1010 en binario

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**Ejemplo Sin Signo:**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**Comportamiento de Desplazamiento Derecho:**
- Tipos con signo: Desplazamiento aritmetico (extiende signo)
- Tipos sin signo: Desplazamiento logico (llena con ceros)

---

### Unarios de Bits

| Operador | Nombre        | Ejemplo | Descripcion              |
|----------|---------------|---------|--------------------------|
| `~`      | NOT de Bits   | `~a`    | Invertir todos los bits  |

**Ejemplos:**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13 (complemento a dos)

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## Operadores de String

### Concatenacion

| Operador | Nombre         | Ejemplo    | Descripcion        |
|----------|----------------|------------|--------------------|
| `+`      | Concatenacion  | `a + b`    | Unir strings       |

**Ejemplos:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"

// String + rune
let greeting = "Hello" + '!';      // "Hello!"

// Rune + string
let prefix = '>' + " Message";     // "> Message"
```

---

## Operadores de Asignacion

### Asignacion Basica

| Operador | Nombre     | Ejemplo    | Descripcion              |
|----------|------------|------------|--------------------------|
| `=`      | Asignacion | `a = b`    | Asignar valor a variable |

**Ejemplos:**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### Asignacion Compuesta

#### Asignacion Compuesta Aritmetica

| Operador | Nombre            | Ejemplo    | Equivalente         |
|----------|-------------------|------------|---------------------|
| `+=`     | Asignar suma      | `a += b`   | `a = a + b`        |
| `-=`     | Asignar resta     | `a -= b`   | `a = a - b`        |
| `*=`     | Asignar mult      | `a *= b`   | `a = a * b`        |
| `/=`     | Asignar div       | `a /= b`   | `a = a / b`        |
| `%=`     | Asignar modulo    | `a %= b`   | `a = a % b`        |

**Ejemplos:**
```hemlock
let x = 10;
x += 5;      // x ahora es 15
x -= 3;      // x ahora es 12
x *= 2;      // x ahora es 24
x /= 4;      // x ahora es 6

let count = 0;
count += 1;  // Incrementar por 1
```

#### Asignacion Compuesta de Bits

| Operador | Nombre                 | Ejemplo     | Equivalente          |
|----------|------------------------|-------------|----------------------|
| `&=`     | Asignar AND de bits    | `a &= b`    | `a = a & b`         |
| `\|=`   | Asignar OR de bits     | `a \|= b`   | `a = a \| b`        |
| `^=`     | Asignar XOR de bits    | `a ^= b`    | `a = a ^ b`         |
| `<<=`    | Asignar desp izq       | `a <<= b`   | `a = a << b`        |
| `>>=`    | Asignar desp der       | `a >>= b`   | `a = a >> b`        |

**Ejemplos:**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flags ahora es 0b0011 (enmascarar bits superiores)
flags |= 0b1000;   // flags ahora es 0b1011 (establecer un bit)
flags ^= 0b0001;   // flags ahora es 0b1010 (alternar un bit)

let x = 1;
x <<= 4;           // x ahora es 16 (desplazar izquierda por 4)
x >>= 2;           // x ahora es 4 (desplazar derecha por 2)
```

### Incremento/Decremento

| Operador | Nombre     | Ejemplo | Descripcion              |
|----------|------------|---------|--------------------------|
| `++`     | Incremento | `a++`   | Incrementar por 1 (postfijo) |
| `--`     | Decremento | `a--`   | Decrementar por 1 (postfijo) |

**Ejemplos:**
```hemlock
let i = 0;
i++;         // i ahora es 1
i++;         // i ahora es 2
i--;         // i ahora es 1

// Comun en bucles
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**Nota:** Tanto `++` como `--` son operadores postfijos (el valor se retorna antes del incremento/decremento)

---

## Operadores de Seguridad Null

### Coalescencia Null (`??`)

Retorna el operando izquierdo si no es null, de lo contrario retorna el operando derecho.

| Operador | Nombre            | Ejemplo      | Descripcion                    |
|----------|-------------------|--------------|--------------------------------|
| `??`     | Coalescencia null | `a ?? b`     | Retornar a si no es null, sino b |

**Ejemplos:**
```hemlock
let name = null;
let display = name ?? "Anonimo";  // "Anonimo"

let value = 42;
let result = value ?? 0;            // 42

// Encadenamiento
let a = null;
let b = null;
let c = "encontrado";
let result2 = a ?? b ?? c;          // "encontrado"

// Con llamadas a funcion
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### Encadenamiento Opcional (`?.`)

Accede a propiedades o llama metodos de forma segura en valores potencialmente null.

| Operador | Nombre               | Ejemplo        | Descripcion                      |
|----------|----------------------|----------------|----------------------------------|
| `?.`     | Encadenamiento opcional | `a?.b`      | Retornar a.b si a no es null, sino null |
| `?.[`    | Indice opcional      | `a?.[0]`       | Retornar a[0] si a no es null, sino null |
| `?.(`    | Llamada opcional     | `a?.()`        | Llamar a() si a no es null, sino null |

**Ejemplos:**
```hemlock
let user = null;
let name = user?.name;              // null (sin error)

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null (navegacion segura)

// Con arrays
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// Con llamadas a metodos
let obj = { greet: fn() { return "Hola"; } };
let greeting = obj?.greet?.();      // "Hola"

let empty = null;
let result = empty?.method?.();     // null
```

**Comportamiento:**
- Si el operando izquierdo es null, toda la expresion cortocircuita a null
- Si el operando izquierdo no es null, el acceso procede normalmente
- Puede encadenarse para acceso profundo a propiedades

---

## Operadores de Acceso a Miembros

### Operador Punto

| Operador | Nombre              | Ejemplo      | Descripcion           |
|----------|---------------------|--------------|-----------------------|
| `.`      | Acceso a miembro    | `obj.field`  | Acceder campo de objeto |
| `.`      | Acceso a propiedad  | `arr.length` | Acceder propiedad     |

**Ejemplos:**
```hemlock
// Acceso a campo de objeto
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// Propiedad de array
let arr = [1, 2, 3];
print(arr.length);         // 3

// Propiedad de string
let s = "hello";
print(s.length);           // 5

// Llamada a metodo
let result = s.to_upper(); // "HELLO"
```

---

### Operador de Indice

| Operador | Nombre  | Ejemplo   | Descripcion          |
|----------|---------|-----------|----------------------|
| `[]`     | Indice  | `arr[i]`  | Acceder elemento     |

**Ejemplos:**
```hemlock
// Indexacion de array
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// Indexacion de string (retorna rune)
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// Indexacion de buffer
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## Operador de Llamada a Funcion

| Operador | Nombre           | Ejemplo      | Descripcion        |
|----------|------------------|--------------|--------------------|
| `()`     | Llamada a funcion | `f(a, b)`   | Llamar funcion     |

**Ejemplos:**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// Llamada a metodo
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// Llamada integrada
print("mensaje");
```

---

## Precedencia de Operadores

Los operadores se listan de mayor a menor precedencia:

| Precedencia | Operadores                  | Descripcion                    | Asociatividad |
|-------------|----------------------------|--------------------------------|---------------|
| 1          | `()` `[]` `.` `?.`         | Llamada, indice, acceso miembro, encadenamiento opcional | Izq-a-der |
| 2          | `++` `--`                  | Incremento/decremento postfijo | Izq-a-der |
| 3          | `!` `~` `-` (unario) `+` (unario) | NOT logico, NOT de bits, negacion | Der-a-izq |
| 4          | `*` `/` `%`                | Multiplicacion, division, modulo | Izq-a-der |
| 5          | `+` `-`                    | Suma, resta          | Izq-a-der |
| 6          | `<<` `>>`                  | Desplazamientos de bits        | Izq-a-der |
| 7          | `<` `<=` `>` `>=`          | Relacionales                   | Izq-a-der |
| 8          | `==` `!=`                  | Igualdad                       | Izq-a-der |
| 9          | `&`                        | AND de bits                    | Izq-a-der |
| 10         | `^`                        | XOR de bits                    | Izq-a-der |
| 11         | `|`                        | OR de bits                     | Izq-a-der |
| 12         | `&&`                       | AND logico                     | Izq-a-der |
| 13         | `||`                       | OR logico                      | Izq-a-der |
| 14         | `??`                       | Coalescencia null              | Izq-a-der |
| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | Asignacion | Der-a-izq |

---

## Ejemplos de Precedencia

### Ejemplo 1: Aritmetica y Comparacion
```hemlock
let result = 5 + 3 * 2;
// Evaluado como: 5 + (3 * 2) = 11
// Multiplicacion tiene mayor precedencia que suma

let cmp = 10 > 5 + 3;
// Evaluado como: 10 > (5 + 3) = true
// Suma tiene mayor precedencia que comparacion
```

### Ejemplo 2: Operadores de Bits
```hemlock
let result1 = 12 | 10 & 8;
// Evaluado como: 12 | (10 & 8) = 12 | 8 = 12
// & tiene mayor precedencia que |

let result2 = 8 | 1 << 2;
// Evaluado como: 8 | (1 << 2) = 8 | 4 = 12
// Desplazamiento tiene mayor precedencia que OR de bits

// Use parentesis para claridad
let result3 = (5 & 3) | (2 << 1);
// Evaluado como: 1 | 4 = 5
```

### Ejemplo 3: Operadores Logicos
```hemlock
let result = true || false && false;
// Evaluado como: true || (false && false) = true
// && tiene mayor precedencia que ||

let cmp = 5 < 10 && 10 < 20;
// Evaluado como: (5 < 10) && (10 < 20) = true
// Comparacion tiene mayor precedencia que &&
```

### Ejemplo 4: Usando Parentesis
```hemlock
// Sin parentesis
let a = 2 + 3 * 4;        // 14

// Con parentesis
let b = (2 + 3) * 4;      // 20

// Expresion compleja
let c = (a + b) * (a - b);
```

---

## Comportamiento de Operadores Especifico por Tipo

### Division (Siempre Flotante)

El operador `/` **siempre retorna un flotante** (f64), independientemente de los tipos de operandos:

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

Esto previene el bug comun de truncamiento entero inesperado.

### Division Entera (div / divi)

Para division entera (como division de enteros en otros lenguajes), use las funciones `div()` y `divi()`:

```hemlock
// div(a, b) - division entera retornando flotante
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- piso hacia -infinito

// divi(a, b) - division entera retornando entero
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**Funciones matematicas que retornan enteros:**
Para otras operaciones de redondeo que retornan enteros:

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// Estos pueden usarse directamente como indices de array
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20 (indice 1)
```

### Comparacion de Strings

Los strings se comparan lexicograficamente:

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Comparacion con Null

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### Errores de Tipo

Algunas operaciones no estan permitidas entre tipos incompatibles:

```hemlock
// ERROR: No se pueden usar operadores de bits en flotantes
let x = 3.14 & 2.71;

// ERROR: No se pueden usar operadores de bits en strings
let y = "hello" & "world";

// OK: Promocion de tipo para aritmetica
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32 (promocionado)
```

---

## Ver Tambien

- [Sistema de Tipos](#reference-type-system) - Reglas de promocion y conversion de tipos
- [Funciones Integradas](#reference-builtins) - Operaciones integradas
- [API de Strings](#reference-string-api) - Concatenacion y metodos de strings


--------------------------------------------------------------------------------
## Sistema de Tipos
--------------------------------------------------------------------------------

# Referencia del Sistema de Tipos

Referencia completa para el sistema de tipos de Hemlock, incluyendo todos los tipos primitivos y compuestos.

---

## Descripcion General

Hemlock usa un **sistema de tipos dinamico** con etiquetas de tipo en tiempo de ejecucion y anotaciones de tipo opcionales. Cada valor tiene un tipo en tiempo de ejecucion, y las conversiones de tipo siguen reglas de promocion explicitas.

**Caracteristicas Principales:**
- Verificacion de tipos en tiempo de ejecucion (interprete)
- Verificacion de tipos en tiempo de compilacion (hemlockc - habilitado por defecto)
- Anotaciones de tipo opcionales
- Inferencia de tipos automatica para literales
- Reglas de promocion de tipos explicitas
- Sin conversiones implicitas que pierdan precision

---

## Verificacion de Tipos en Tiempo de Compilacion (hemlockc)

El compilador de Hemlock (`hemlockc`) incluye un verificador de tipos en tiempo de compilacion que valida su codigo antes de generar ejecutables. Esto captura errores de tipo tempranamente sin necesidad de ejecutar el programa.

### Comportamiento por Defecto

La verificacion de tipos esta **habilitada por defecto** en hemlockc:

```bash
# La verificacion de tipos ocurre automaticamente
hemlockc program.hml -o program

# Los errores se reportan antes de la compilacion
hemlockc bad_types.hml
# Salida: 1 type error found
```

### Banderas del Compilador

| Bandera | Descripcion |
|---------|-------------|
| `--check` | Solo verificar tipos, no compilar (salir despues de validacion) |
| `--no-type-check` | Deshabilitar verificacion de tipos (no recomendado) |
| `--strict-types` | Habilitar advertencias de tipos mas estrictas |

**Ejemplos:**

```bash
# Solo validar tipos sin compilar
hemlockc --check program.hml
# Salida: program.hml: no type errors

# Deshabilitar verificacion de tipos (usar con precaucion)
hemlockc --no-type-check dynamic_code.hml -o program

# Habilitar advertencias estrictas para tipos any implicitos
hemlockc --strict-types program.hml -o program
```

### Que Valida el Verificador de Tipos

1. **Anotaciones de tipo** - Asegura que los valores asignados coincidan con los tipos declarados
2. **Llamadas a funciones** - Valida tipos de argumentos contra tipos de parametros
3. **Tipos de retorno** - Verifica que las sentencias return coincidan con el tipo de retorno declarado
4. **Uso de operadores** - Verifica que los operandos sean compatibles
5. **Acceso a propiedades** - Valida tipos de campos de objetos para objetos tipados

### Conversiones Numericas Permisivas

El verificador de tipos permite conversiones de tipos numericos en tiempo de compilacion, con validacion de rango ocurriendo en tiempo de ejecucion:

```hemlock
let x: i8 = 100;      // OK - 100 cabe en i8 (validado en tiempo de ejecucion)
let y: u8 = 255;      // OK - dentro del rango de u8
let z: f64 = 42;      // OK - i32 a f64 es seguro
```

### Soporte de Codigo Dinamico

El codigo sin anotaciones de tipo se trata como dinamico (tipo `any`) y siempre pasa el verificador de tipos:

```hemlock
let x = get_value();  // Dinamico - sin anotacion
process(x);           // OK - valores dinamicos aceptados en cualquier lugar
```

---

## Tipos Primitivos

### Tipos Numericos

#### Enteros con Signo

| Tipo   | Tamano    | Rango                                      | Alias     |
|--------|-----------|-------------------------------------------|-----------|
| `i8`   | 1 byte    | -128 a 127                                | -         |
| `i16`  | 2 bytes   | -32,768 a 32,767                          | -         |
| `i32`  | 4 bytes   | -2,147,483,648 a 2,147,483,647            | `integer` |
| `i64`  | 8 bytes   | -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 | - |

**Ejemplos:**
```hemlock
let a: i8 = 127;
let b: i16 = 32000;
let c: i32 = 1000000;
let d: i64 = 9223372036854775807;

// Alias de tipo
let x: integer = 42;  // Igual que i32
```

#### Enteros sin Signo

| Tipo   | Tamano    | Rango                     | Alias  |
|--------|-----------|---------------------------|--------|
| `u8`   | 1 byte    | 0 a 255                   | `byte` |
| `u16`  | 2 bytes   | 0 a 65,535                | -      |
| `u32`  | 4 bytes   | 0 a 4,294,967,295         | -      |
| `u64`  | 8 bytes   | 0 a 18,446,744,073,709,551,615 | - |

**Ejemplos:**
```hemlock
let a: u8 = 255;
let b: u16 = 65535;
let c: u32 = 4294967295;
let d: u64 = 18446744073709551615;

// Alias de tipo
let byte_val: byte = 65;  // Igual que u8
```

#### Punto Flotante

| Tipo   | Tamano    | Precision      | Alias    |
|--------|-----------|----------------|----------|
| `f32`  | 4 bytes   | ~7 digitos     | -        |
| `f64`  | 8 bytes   | ~15 digitos    | `number` |

**Ejemplos:**
```hemlock
let pi: f32 = 3.14159;
let precise: f64 = 3.14159265359;

// Alias de tipo
let x: number = 2.718;  // Igual que f64
```

---

### Inferencia de Literales Enteros

Los literales enteros se tipan automaticamente basandose en su valor:

**Reglas:**
- Valores en rango i32 (-2,147,483,648 a 2,147,483,647): inferir como `i32`
- Valores fuera del rango i32 pero dentro del rango i64: inferir como `i64`
- Use anotaciones de tipo explicitas para otros tipos (i8, i16, u8, u16, u32, u64)

**Ejemplos:**
```hemlock
let small = 42;                    // i32 (cabe en i32)
let large = 5000000000;            // i64 (> maximo i32)
let max_i64 = 9223372036854775807; // i64 (INT64_MAX)
let explicit: u32 = 100;           // u32 (anotacion de tipo anula)
```

---

### Tipo Booleano

**Tipo:** `bool`

**Valores:** `true`, `false`

**Tamano:** 1 byte (internamente)

**Ejemplos:**
```hemlock
let is_active: bool = true;
let done = false;

if (is_active && !done) {
    print("trabajando");
}
```

---

### Tipos de Caracter

#### Rune

**Tipo:** `rune`

**Descripcion:** Punto de codigo Unicode (U+0000 a U+10FFFF)

**Tamano:** 4 bytes (valor de 32 bits)

**Rango:** 0 a 0x10FFFF (1,114,111)

**Sintaxis Literal:** Comillas simples `'x'`

**Ejemplos:**
```hemlock
// ASCII
let a = 'A';
let digit = '0';

// UTF-8 multi-byte
let rocket = 'ðŸš€';      // U+1F680
let heart = 'â¤';        // U+2764
let chinese = 'ä¸­';     // U+4E2D

// Secuencias de escape
let newline = '\n';
let tab = '\t';
let backslash = '\\';
let quote = '\'';
let null = '\0';

// Escapes Unicode
let emoji = '\u{1F680}';   // Hasta 6 digitos hex
let max = '\u{10FFFF}';    // Punto de codigo maximo
```

**Conversiones de Tipo:**
```hemlock
// Entero a rune
let code: rune = 65;        // 'A'
let r: rune = 128640;       // ðŸš€

// Rune a entero
let value: i32 = 'Z';       // 90

// Rune a string
let s: string = 'H';        // "H"

// u8 a rune
let byte: u8 = 65;
let rune_val: rune = byte;  // 'A'
```

**Ver Tambien:** [API de Strings](#reference-string-api) para concatenacion de string + rune

---

### Tipo String

**Tipo:** `string`

**Descripcion:** Texto codificado en UTF-8, mutable, asignado en heap

**Codificacion:** UTF-8 (U+0000 a U+10FFFF)

**Mutabilidad:** Mutable (a diferencia de la mayoria de lenguajes)

**Propiedades:**
- `.length` - Conteo de puntos de codigo (numero de caracteres)
- `.byte_length` - Conteo de bytes (tamano de codificacion UTF-8)

**Sintaxis Literal:** Comillas dobles `"texto"`

**Ejemplos:**
```hemlock
let s = "hello";
s[0] = 'H';             // Mutar (ahora "Hello")
print(s.length);        // 5 (conteo de puntos de codigo)
print(s.byte_length);   // 5 (bytes UTF-8)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (un punto de codigo)
print(emoji.byte_length);   // 4 (cuatro bytes UTF-8)
```

**Indexacion:**
```hemlock
let s = "hello";
let ch = s[0];          // Retorna rune 'h'
s[0] = 'H';             // Establecer con rune
```

**Ver Tambien:** [API de Strings](#reference-string-api) para referencia completa de metodos

---

### Tipo Null

**Tipo:** `null`

**Descripcion:** El valor null (ausencia de valor)

**Tamano:** 8 bytes (internamente)

**Valor:** `null`

**Ejemplos:**
```hemlock
let x = null;
let y: i32 = null;  // ERROR: discrepancia de tipo

if (x == null) {
    print("x es null");
}
```

---

## Tipos Compuestos

### Tipo Array

**Tipo:** `array`

**Descripcion:** Array dinamico, asignado en heap, de tipos mixtos

**Propiedades:**
- `.length` - Numero de elementos

**Indexacion desde cero:** Si

**Sintaxis Literal:** `[elem1, elem2, ...]`

**Ejemplos:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Tipos mixtos
let mixed = [1, "hello", true, null];
```

**Ver Tambien:** [API de Arrays](#reference-array-api) para referencia completa de metodos

---

### Tipo Objeto

**Tipo:** `object`

**Descripcion:** Objeto estilo JavaScript con campos dinamicos

**Sintaxis Literal:** `{ campo: valor, ... }`

**Ejemplos:**
```hemlock
let person = { name: "Alice", age: 30 };
print(person.name);  // "Alice"

// Agregar campo dinamicamente
person.email = "alice@example.com";
```

**Definiciones de Tipo:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: bool,  // Campo opcional
}

let p: Person = { name: "Bob", age: 25 };
print(typeof(p));  // "Person"
```

---

### Tipos de Puntero

#### Puntero Crudo (ptr)

**Tipo:** `ptr`

**Descripcion:** Direccion de memoria cruda (inseguro)

**Tamano:** 8 bytes

**Verificacion de Limites:** Ninguna

**Ejemplos:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

#### Buffer (buffer)

**Tipo:** `buffer`

**Descripcion:** Envoltorio de puntero seguro con verificacion de limites

**Estructura:** Puntero + longitud + capacidad

**Propiedades:**
- `.length` - Tamano del buffer
- `.capacity` - Capacidad asignada

**Ejemplos:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Verificacion de limites
print(b.length);        // 64
free(b);
```

**Ver Tambien:** [API de Memoria](#reference-memory-api) para funciones de asignacion

---

## Tipos Especiales

### Tipo File

**Tipo:** `file`

**Descripcion:** Manejador de archivo para operaciones de E/S

**Propiedades:**
- `.path` - Ruta del archivo (string)
- `.mode` - Modo de apertura (string)
- `.closed` - Si el archivo esta cerrado (bool)

**Ver Tambien:** [API de Archivos](#reference-file-api)

---

### Tipo Task

**Tipo:** `task`

**Descripcion:** Manejador para tarea concurrente

**Ver Tambien:** [API de Concurrencia](#reference-concurrency-api)

---

### Tipo Channel

**Tipo:** `channel`

**Descripcion:** Canal de comunicacion seguro para hilos

**Ver Tambien:** [API de Concurrencia](#reference-concurrency-api)

---

### Tipo Function

**Tipo:** `function`

**Descripcion:** Valor de funcion de primera clase

**Ejemplos:**
```hemlock
fn add(a, b) {
    return a + b;
}

let multiply = fn(x, y) {
    return x * y;
};

print(typeof(add));      // "function"
print(typeof(multiply)); // "function"
```

---

### Tipo Void

**Tipo:** `void`

**Descripcion:** Ausencia de valor de retorno (uso interno)

---

## Reglas de Promocion de Tipos

Cuando se mezclan tipos en operaciones, Hemlock promociona al tipo "superior":

**Jerarquia de Promocion:**
```
f64 (mayor precision)
 â†‘
f32
 â†‘
u64
 â†‘
i64
 â†‘
u32
 â†‘
i32
 â†‘
u16
 â†‘
i16
 â†‘
u8
 â†‘
i8 (menor)
```

**Reglas:**
1. Flotante siempre gana sobre entero
2. Tamano mayor gana dentro de la misma categoria (int/uint/float)
3. Ambos operandos se promocionan al tipo del resultado
4. **Preservacion de precision:** i64/u64 + f32 promociona a f64 (no f32)

**Ejemplos:**
```hemlock
// Promocion por tamano
u8 + i32    â†’ i32    // Tamano mayor gana
i32 + i64   â†’ i64    // Tamano mayor gana
u32 + u64   â†’ u64    // Tamano mayor gana

// Promocion a flotante
i32 + f32   â†’ f32    // Flotante gana, f32 suficiente para i32
i64 + f32   â†’ f64    // Promociona a f64 para preservar precision de i64
i64 + f64   â†’ f64    // Flotante siempre gana
i8 + f64    â†’ f64    // Flotante + mayor gana
```

**Por que i64 + f32 -> f64?**

f32 tiene solo una mantisa de 24 bits, que no puede representar precisamente enteros mayores que 2^24 (16,777,216). Como i64 puede contener valores hasta 2^63, mezclar i64 con f32 causaria perdida severa de precision. Hemlock promociona a f64 (mantisa de 53 bits) en su lugar.

---

## Verificacion de Rango

Las anotaciones de tipo imponen verificaciones de rango en asignacion:

**Asignaciones Validas:**
```hemlock
let x: u8 = 255;             // OK
let y: i8 = 127;             // OK
let a: i64 = 2147483647;     // OK
let b: u64 = 4294967295;     // OK
```

**Asignaciones Invalidas (Error en Tiempo de Ejecucion):**
```hemlock
let x: u8 = 256;             // ERROR: fuera de rango
let y: i8 = 128;             // ERROR: maximo es 127
let z: u64 = -1;             // ERROR: u64 no puede ser negativo
```

---

## Introspeccion de Tipos

### typeof(value)

Retorna el nombre del tipo como string.

**Firma:**
```hemlock
typeof(value: any): string
```

**Retorna:**
- Tipos primitivos: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Tipos compuestos: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Tipos especiales: `"file"`, `"task"`, `"channel"`
- Objetos tipados: Nombre de tipo personalizado (ej., `"Person"`)

**Ejemplos:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"
```

**Ver Tambien:** [Funciones Integradas](builtins.md#typeof)

---

## Conversiones de Tipo

### Conversiones Implicitas

Hemlock realiza conversiones de tipo implicitas en operaciones aritmeticas siguiendo las reglas de promocion de tipos.

**Ejemplos:**
```hemlock
let a: u8 = 10;
let b: i32 = 20;
let result = a + b;     // result es i32 (promocionado)
```

### Conversiones Explicitas

Use anotaciones de tipo para conversiones explicitas:

**Ejemplos:**
```hemlock
// Entero a flotante
let i: i32 = 42;
let f: f64 = i;         // 42.0

// Flotante a entero (trunca)
let x: f64 = 3.14;
let y: i32 = x;         // 3

// Entero a rune
let code: rune = 65;    // 'A'

// Rune a entero
let value: i32 = 'Z';   // 90

// Rune a string
let s: string = 'H';    // "H"
```

---

## Alias de Tipo

### Alias Integrados

Hemlock proporciona alias de tipo integrados para tipos comunes:

| Alias     | Tipo Real | Uso                      |
|-----------|-----------|--------------------------|
| `integer` | `i32`     | Enteros de proposito general |
| `number`  | `f64`     | Flotantes de proposito general |
| `byte`    | `u8`      | Valores de byte          |

**Ejemplos:**
```hemlock
let count: integer = 100;       // Igual que i32
let price: number = 19.99;      // Igual que f64
let b: byte = 255;              // Igual que u8
```

### Alias de Tipo Personalizados

Defina alias de tipo personalizados usando la palabra clave `type`:

```hemlock
// Alias simples
type Integer = i32;
type Text = string;

// Alias de tipo funcion
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

// Alias de tipo compuesto
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Alias de tipo generico
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
```

**Usando alias personalizados:**
```hemlock
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Nota:** Los alias de tipo son transparentes - `typeof()` retorna el nombre del tipo subyacente.

---

## Tipos de Funcion

Los tipos de funcion especifican la firma de valores de funcion:

### Sintaxis

```hemlock
fn(tipos_parametros): tipo_retorno
```

### Ejemplos

```hemlock
// Tipo de funcion basico
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Parametro de funcion
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Funcion de orden superior retornando funcion
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Tipo de funcion async
fn run_async(handler: async fn(): void) {
    spawn(handler);
}
```

---

## Tipos Compuestos (Interseccion)

Los tipos compuestos usan `&` para requerir multiples restricciones de tipo:

```hemlock
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// El objeto debe satisfacer todos los tipos
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Tres o mas tipos
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

---

## Tabla Resumen

| Tipo       | Tamano   | Mutable | Asignado en Heap | Descripcion                    |
|------------|----------|---------|------------------|--------------------------------|
| `i8`-`i64` | 1-8 bytes| No      | No               | Enteros con signo              |
| `u8`-`u64` | 1-8 bytes| No      | No               | Enteros sin signo              |
| `f32`      | 4 bytes  | No      | No               | Flotante precision simple      |
| `f64`      | 8 bytes  | No      | No               | Flotante precision doble       |
| `bool`     | 1 byte   | No      | No               | Booleano                       |
| `rune`     | 4 bytes  | No      | No               | Punto de codigo Unicode        |
| `string`   | Variable | Si      | Si               | Texto UTF-8                    |
| `array`    | Variable | Si      | Si               | Array dinamico                 |
| `object`   | Variable | Si      | Si               | Objeto dinamico                |
| `ptr`      | 8 bytes  | No      | No               | Puntero crudo                  |
| `buffer`   | Variable | Si      | Si               | Envoltorio de puntero seguro   |
| `file`     | Opaco    | Si      | Si               | Manejador de archivo           |
| `task`     | Opaco    | No      | Si               | Manejador de tarea concurrente |
| `channel`  | Opaco    | Si      | Si               | Canal seguro para hilos        |
| `function` | Opaco    | No      | Si               | Valor de funcion               |
| `null`     | 8 bytes  | No      | No               | Valor null                     |

---

## Ver Tambien

- [Referencia de Operadores](#reference-operators) - Comportamiento de tipos en operaciones
- [Funciones Integradas](#reference-builtins) - Introspeccion y conversion de tipos
- [API de Strings](#reference-string-api) - Metodos de tipo string
- [API de Arrays](#reference-array-api) - Metodos de tipo array
- [API de Memoria](#reference-memory-api) - Operaciones de puntero y buffer



################################################################################
# DISEÃ‘O Y FILOSOFÃA
################################################################################

--------------------------------------------------------------------------------
## FilosofÃ­a
--------------------------------------------------------------------------------

# Filosofia de Diseno del Lenguaje Hemlock

> "Un lenguaje pequeno e inseguro para escribir cosas inseguras de forma segura."

Este documento captura los principios fundamentales de diseno y la filosofia de Hemlock. Lea esto primero antes de realizar cualquier cambio o adicion al lenguaje.

---

## Tabla de Contenidos

- [Identidad Central](#identidad-central)
- [Principios de Diseno](#principios-de-diseno)
- [Filosofia sobre la Seguridad](#filosofia-sobre-la-seguridad)
- [Que NO Agregar](#que-no-agregar)
- [Consideraciones Futuras](#consideraciones-futuras)
- [Reflexiones Finales](#reflexiones-finales)

---

## Identidad Central

Hemlock es un **lenguaje de scripting para sistemas** que adopta la gestion manual de memoria y el control explicito. Esta disenado para programadores que desean:

- El poder de C
- La ergonomia de los lenguajes de scripting modernos
- Concurrencia asincrona estructurada integrada
- Sin comportamientos ocultos ni magia

### Lo que Hemlock NO ES

- **Seguro en memoria** (los punteros colgantes son su responsabilidad)
- **Un reemplazo para Rust, Go o Lua**
- **Un lenguaje que oculta la complejidad**

### Lo que Hemlock SI ES

- **Explicito sobre implicito, siempre**
- **Educativo y experimental**
- **Una "capa de scripting tipo C" para trabajo de sistemas**
- **Honesto sobre las compensaciones**

---

## Principios de Diseno

### 1. Explicito Sobre Implicito

Hemlock favorece la explicitud en todas las construcciones del lenguaje. No debe haber sorpresas, ni magia, ni comportamientos ocultos.

**Malo (implicito):**
```hemlock
let x = 5  // Falta punto y coma - deberia dar error
```

**Bueno (explicito):**
```hemlock
let x = 5;
free(ptr);  // Usted lo asigno, usted lo libera
```

**Aspectos clave:**
- Los puntos y coma son obligatorios (sin insercion automatica de punto y coma)
- Sin recoleccion de basura
- Gestion manual de memoria (alloc/free)
- Las anotaciones de tipo son opcionales pero se verifican en tiempo de ejecucion
- Sin limpieza automatica de recursos (sin RAII), pero `defer` proporciona limpieza explicita

### 2. Dinamico por Defecto, Tipado por Eleccion

Cada valor tiene una etiqueta de tipo en tiempo de ejecucion, pero el sistema esta disenado para ser flexible mientras aun detecta errores.

**Inferencia de tipos:**
- Enteros pequenos (caben en i32): `42` -> `i32`
- Enteros grandes (> rango de i32): `9223372036854775807` -> `i64`
- Flotantes: `3.14` -> `f64`

**Tipado explicito cuando es necesario:**
```hemlock
let x = 42;              // i32 inferido (valor pequeno)
let y: u8 = 255;         // u8 explicito
let z = x + y;           // se promueve a i32
let big = 5000000000;    // i64 inferido (> maximo de i32)
```

**Las reglas de promocion de tipos** siguen una jerarquia clara de menor a mayor, con los flotantes siempre ganando sobre los enteros.

### 3. Lo Inseguro es una Caracteristica, No un Defecto

Hemlock no intenta prevenir todos los errores. En cambio, le proporciona las herramientas para ser seguro mientras le permite optar por comportamientos inseguros cuando es necesario.

**Ejemplos de inseguridad intencional:**
- La aritmetica de punteros puede desbordarse (responsabilidad del usuario)
- Sin verificacion de limites en `ptr` crudo (use `buffer` si desea seguridad)
- Se permiten bloqueos por doble liberacion (gestion manual de memoria)
- El sistema de tipos previene accidentes pero permite riesgos cuando es necesario

```hemlock
let p = alloc(10);
let q = p + 100;  // Muy lejos de la asignacion - permitido pero peligroso
```

**La filosofia:** El sistema de tipos debe prevenir *accidentes* pero permitir operaciones inseguras *intencionales*.

### 4. Concurrencia Estructurada de Primera Clase

La concurrencia no es una ocurrencia tardia en Hemlock. Esta integrada en el lenguaje desde la base.

**Caracteristicas clave:**
- `async`/`await` integrados en el lenguaje
- Canales para comunicacion
- `spawn`/`join`/`detach` para gestion de tareas
- Sin hilos crudos, sin bloqueos - solo estructurado
- Verdadero paralelismo multi-hilo usando hilos POSIX

**No es un bucle de eventos ni hilos verdes** - Hemlock usa hilos reales del sistema operativo para verdadero paralelismo a traves de multiples nucleos de CPU.

### 5. Sintaxis Similar a C, Poca Ceremonia

Hemlock debe resultar familiar a los programadores de sistemas mientras reduce el codigo repetitivo.

**Decisiones de diseno:**
- Bloques `{}` siempre, sin llaves opcionales
- Los operadores coinciden con C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- Sintaxis de tipos coincide con Rust/TypeScript: `let x: type = value;`
- Las funciones son valores de primera clase
- Palabras clave y formas especiales minimas

---

## Filosofia sobre la Seguridad

**La postura de Hemlock sobre la seguridad:**

> "Le damos las herramientas para ser seguro (`buffer`, anotaciones de tipo, verificacion de limites) pero no le obligamos a usarlas (`ptr`, memoria manual, operaciones inseguras).
>
> El valor predeterminado debe guiar hacia la seguridad, pero la escotilla de escape siempre debe estar disponible."

### Herramientas de Seguridad Proporcionadas

**1. Tipo buffer seguro:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // con verificacion de limites
print(b.length);        // 64
free(b);                // aun manual
```

**2. Punteros crudos inseguros:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Debe recordar liberar
```

**3. Anotaciones de tipo:**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // ERROR: fuera de rango
```

**4. Verificacion de tipos en tiempo de ejecucion:**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // Seguro de usar como entero
}
```

### Principios Guia

1. **Usar patrones seguros por defecto en la documentacion** - Mostrar `buffer` antes de `ptr`, fomentar anotaciones de tipo
2. **Hacer obvias las operaciones inseguras** - La aritmetica de punteros crudos debe parecer intencional
3. **Proporcionar escotillas de escape** - No prevenir que usuarios experimentados hagan trabajo de bajo nivel
4. **Ser honesto sobre las compensaciones** - Documentar que puede salir mal

### Ejemplos de Seguridad vs. Inseguridad

| Patron Seguro | Patron Inseguro | Cuando Usar Inseguro |
|---------------|-----------------|---------------------|
| Tipo `buffer` | Tipo `ptr` | FFI, codigo critico para rendimiento |
| Anotaciones de tipo | Sin anotaciones | Interfaces externas, validacion |
| Acceso con verificacion de limites | Aritmetica de punteros | Operaciones de memoria de bajo nivel |
| Manejo de excepciones | Retornar null/codigos de error | Cuando las excepciones son muy pesadas |

---

## Que NO Agregar

Entender que **no** agregar es tan importante como saber que agregar.

### No Agregar Comportamiento Implicito

**Malos ejemplos:**

```hemlock
// MALO: Insercion automatica de punto y coma
let x = 5
let y = 10

// MALO: Conversiones de tipo implicitas que pierden precision
let x: i32 = 3.14  // Â¿Deberia truncar o dar error?
```

**Por que:** El comportamiento implicito crea sorpresas y hace que el codigo sea mas dificil de razonar.

### No Ocultar la Complejidad

**Malos ejemplos:**

```hemlock
// MALO: Optimizacion magica detras de escena
let arr = [1, 2, 3]  // Â¿Esta en la pila o en el heap? Â¡El usuario debe saberlo! (Heap, con conteo de referencias)

// MALO: Puntero crudo auto-liberado
let p = alloc(100)  // Â¿Se auto-libera? Â¡NO! Los ptrs crudos siempre necesitan free()
```

**Nota sobre conteo de referencias:** Hemlock usa conteo de referencias interno para strings, arrays, objetos y buffers - estos SI se auto-liberan cuando el ambito termina. Esto es explicito y predecible (limpieza determinista cuando la referencia llega a 0, sin pausas de GC). Los punteros crudos (`ptr` de `alloc()`) NO tienen conteo de referencias y siempre requieren `free()` manual.

**Por que:** La complejidad oculta hace imposible predecir el rendimiento y depurar problemas.

### No Romper la Semantica Existente

**Nunca cambiar estas decisiones fundamentales:**
- Los puntos y coma son obligatorios - no hacerlos opcionales
- Gestion manual de memoria - no agregar GC
- Strings mutables - no hacerlos inmutables
- Verificacion de tipos en tiempo de ejecucion - no eliminarla

**Por que:** La consistencia y estabilidad son mas importantes que las caracteristicas de moda.

### No Agregar Caracteristicas "Convenientes" que Reducen la Explicitud

**Ejemplos de caracteristicas a evitar:**
- Sobrecarga de operadores (quizas para tipos de usuario, pero con cuidado)
- Coercion de tipos implicita que pierde informacion
- Limpieza automatica de recursos (RAII)
- Encadenamiento de metodos que oculta complejidad
- DSLs y sintaxis magica

**Excepcion:** Las caracteristicas de conveniencia estan bien si son **azucar explicito** sobre operaciones simples:
- `else if` esta bien (son solo sentencias if anidadas)
- La interpolacion de strings podria estar bien si es claramente azucar sintactico
- La sintaxis de metodos para objetos esta bien (es explicito lo que hace)

---

## Consideraciones Futuras

### Quizas Agregar (En Discusion)

Estas caracteristicas se alinean con la filosofia de Hemlock pero necesitan diseno cuidadoso:

**1. Coincidencia de patrones**
```hemlock
match (value) {
    case i32: print("entero");
    case string: print("texto");
    case _: print("otro");
}
```
- Verificacion de tipos explicita
- Sin costos ocultos
- Posible verificacion de exhaustividad en tiempo de compilacion

**2. Tipos de error (`Result<T, E>`)**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("division por cero");
    }
    return Ok(a / b);
}
```
- Manejo de errores explicito
- Obliga a los usuarios a pensar en los errores
- Alternativa a las excepciones

**3. Tipos de array/slice**
- Ya tenemos arrays dinamicos
- Podriamos agregar arrays de tamano fijo para asignacion en pila
- Necesitaria ser explicito sobre pila vs. heap

**4. Herramientas mejoradas de seguridad de memoria**
- Bandera opcional de verificacion de limites
- Deteccion de fugas de memoria en compilaciones de depuracion
- Integracion con sanitizadores

### Probablemente Nunca Agregar

Estas caracteristicas violan los principios fundamentales:

**1. Recoleccion de basura**
- Oculta la complejidad de gestion de memoria
- Rendimiento impredecible
- Contra el principio de control explicito

**2. Gestion automatica de memoria**
- Mismas razones que GC
- El conteo de referencias podria estar bien si es explicito

**3. Conversiones de tipo implicitas que pierden datos**
- Va contra "explicito sobre implicito"
- Fuente de errores sutiles

**4. Macros (complejas)**
- Demasiado poder, demasiada complejidad
- Un sistema de macros simple podria estar bien
- Preferir generacion de codigo o funciones

**5. POO basada en clases con herencia**
- Demasiado comportamiento implicito
- El duck typing y los objetos son suficientes
- Composicion sobre herencia

**6. Sistema de modulos con resolucion compleja**
- Mantener las importaciones simples y explicitas
- Sin rutas de busqueda magicas
- Sin resolucion de versiones (usar el gestor de paquetes del SO)

---

## Reflexiones Finales

### Confianza y Responsabilidad

Hemlock trata sobre **confianza y responsabilidad**. Confiamos en que el programador:

- Gestione la memoria correctamente
- Use los tipos apropiadamente
- Maneje los errores adecuadamente
- Entienda las compensaciones

A cambio, Hemlock proporciona:

- Sin costos ocultos
- Sin comportamiento sorpresa
- Control total cuando es necesario
- Herramientas de seguridad cuando se desean

### La Pregunta Guia

**Al considerar una nueva caracteristica, pregunte:**

> "Â¿Esto le da al programador mas control explicito, o oculta algo?"

- Si **agrega control explicito** -> probablemente encaja en Hemlock
- Si **oculta complejidad** -> probablemente no pertenece
- Si es **azucar opcional** que esta claramente documentado -> podria estar bien

### Ejemplos de Buenas Adiciones

Sentencias switch - Flujo de control explicito, sin magia, semantica clara

Async/await con pthreads - Concurrencia explicita, verdadero paralelismo, el usuario controla el spawn

Tipo buffer junto con ptr - Da eleccion entre seguro e inseguro

Anotaciones de tipo opcionales - Ayuda a detectar errores sin forzar rigidez

Try/catch/finally - Manejo de errores explicito con flujo de control claro

### Ejemplos de Malas Adiciones

Insercion automatica de punto y coma - Oculta errores de sintaxis, hace el codigo ambiguo

RAII/destructores - La limpieza automatica oculta cuando se liberan los recursos

Coalescencia null implicita - Oculta verificaciones de null, hace el codigo mas dificil de razonar

Strings auto-crecientes - Oculta asignacion de memoria, rendimiento impredecible

---

## Conclusion

Hemlock no intenta ser el lenguaje mas seguro, el lenguaje mas rapido, o el lenguaje con mas caracteristicas.

**Hemlock intenta ser el lenguaje mas *honesto*.**

Le dice exactamente lo que esta haciendo, le da control cuando lo necesita, y no oculta los bordes afilados. Es un lenguaje para personas que quieren entender su codigo a bajo nivel mientras aun disfrutan de ergonomia moderna.

Si no esta seguro de si una caracteristica pertenece a Hemlock, recuerde:

> **Explicito sobre implicito, siempre.**
> **Lo inseguro es una caracteristica, no un defecto.**
> **El usuario es responsable, y eso esta bien.**


--------------------------------------------------------------------------------
## ImplementaciÃ³n
--------------------------------------------------------------------------------

# Detalles de Implementacion de Hemlock

Este documento describe la implementacion tecnica del lenguaje Hemlock, incluyendo la estructura del proyecto, el pipeline de compilacion, la arquitectura del runtime y las decisiones de diseno.

---

## Tabla de Contenidos

- [Estructura del Proyecto](#estructura-del-proyecto)
- [Pipeline de Compilacion](#pipeline-de-compilacion)
- [Diseno Modular del Interprete](#diseno-modular-del-interprete)
- [Arquitectura del Runtime](#arquitectura-del-runtime)
- [Representacion de Valores](#representacion-de-valores)
- [Implementacion del Sistema de Tipos](#implementacion-del-sistema-de-tipos)
- [Gestion de Memoria](#gestion-de-memoria)
- [Modelo de Concurrencia](#modelo-de-concurrencia)
- [Planes Futuros](#planes-futuros)

---

## Estructura del Proyecto

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/              # Compartido: lexer, parser, AST
â”‚   â”‚   â”œâ”€â”€ lexer.c            # Tokenizacion
â”‚   â”‚   â”œâ”€â”€ parser/            # Parser de descenso recursivo
â”‚   â”‚   â”œâ”€â”€ ast.c              # Gestion de nodos AST
â”‚   â”‚   â””â”€â”€ module.c           # Resolucion de modulos
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/       # hemlock: interprete de recorrido de arbol
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c         # Punto de entrada CLI
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime.c      # Evaluacion de expresiones/sentencias
â”‚   â”‚   â”‚   â”œâ”€â”€ builtins.c     # Funciones integradas
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ compiler/          # hemlockc: generador de codigo C
â”‚   â”‚       â”œâ”€â”€ main.c         # CLI, orquestacion
â”‚   â”‚       â”œâ”€â”€ type_check.c   # Verificacion de tipos en compilacion
â”‚   â”‚       â”œâ”€â”€ codegen.c      # Contexto de generacion de codigo
â”‚   â”‚       â”œâ”€â”€ codegen_expr.c # Codegen de expresiones
â”‚   â”‚       â”œâ”€â”€ codegen_stmt.c # Codegen de sentencias
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/               # Protocolo de Servidor de Lenguaje
â”‚   â”‚   â””â”€â”€ bundler/           # Herramientas de empaquetado
â”œâ”€â”€ runtime/                   # libhemlock_runtime.a (para programas compilados)
â”œâ”€â”€ stdlib/                    # Biblioteca estandar (39 modulos)
â”‚   â””â”€â”€ docs/                  # Documentacion de modulos
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ parity/                # Pruebas que deben pasar ambos backends
â”‚   â”œâ”€â”€ interpreter/           # Pruebas especificas del interprete
â”‚   â””â”€â”€ compiler/              # Pruebas especificas del compilador
â”œâ”€â”€ examples/                  # Programas de ejemplo
â””â”€â”€ docs/                      # Documentacion
```

### Organizacion de Directorios

**`include/`** - Headers de API publica que definen la interfaz entre componentes:
- Separacion limpia entre lexer, parser, AST e interprete
- Declaraciones adelantadas para minimizar dependencias
- API publica para incrustar Hemlock en otros programas

**`src/`** - Archivos de implementacion:
- Los archivos de nivel superior manejan lexing, parsing, gestion de AST
- `main.c` proporciona CLI y REPL
- El interprete esta modularizado en subsistemas separados

**`src/interpreter/`** - Implementacion modular del interprete:
- Cada modulo tiene una responsabilidad unica y clara
- API interna definida en `internal.h` para comunicacion entre modulos
- Los modulos pueden compilarse independientemente para compilaciones mas rapidas

**`tests/`** - Suite de pruebas completa:
- Organizada por area de caracteristica
- Cada directorio contiene casos de prueba enfocados
- `run_tests.sh` orquesta la ejecucion de pruebas

---

## Pipeline de Compilacion

Hemlock usa un pipeline de compilacion tradicional con fases distintas:

### Fase 1: Analisis Lexico (Lexer)

**Entrada:** Texto de codigo fuente
**Salida:** Flujo de tokens
**Implementacion:** `src/lexer.c`

```
Fuente: "let x = 42;"
   â†“
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**Caracteristicas clave:**
- Reconoce palabras clave, identificadores, literales, operadores, puntuacion
- Maneja literales de string UTF-8 y literales de runa
- Reporta numeros de linea para mensajes de error
- Pasada unica, sin retroceso

### Fase 2: Analisis Sintactico (Parser)

**Entrada:** Flujo de tokens
**Salida:** Arbol de Sintaxis Abstracta (AST)
**Implementacion:** `src/parser.c`

```
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   â†“
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**Caracteristicas clave:**
- Parser de descenso recursivo
- Construye representacion en arbol de la estructura del programa
- Maneja precedencia de operadores
- Valida sintaxis (llaves, puntos y coma, etc.)
- Sin analisis semantico aun (se hace en tiempo de ejecucion)

**Precedencia de Operadores (menor a mayor):**
1. Asignacion: `=`
2. OR logico: `||`
3. AND logico: `&&`
4. OR a nivel de bits: `|`
5. XOR a nivel de bits: `^`
6. AND a nivel de bits: `&`
7. Igualdad: `==`, `!=`
8. Comparacion: `<`, `>`, `<=`, `>=`
9. Desplazamientos de bits: `<<`, `>>`
10. Suma/Resta: `+`, `-`
11. Multiplicacion/Division/Modulo: `*`, `/`, `%`
12. Unarios: `!`, `-`, `~`
13. Llamada/Indice/Miembro: `()`, `[]`, `.`

### Fase 3a: Interpretacion (Recorrido de Arbol)

**Entrada:** AST
**Salida:** Ejecucion del programa
**Implementacion:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   â†“
Ejecucion: Evalua nodos AST recursivamente
   â†“
Resultado: Variable x creada con valor 42
```

**Caracteristicas clave:**
- Recorrido directo del AST (interprete de recorrido de arbol)
- Verificacion dinamica de tipos en tiempo de ejecucion
- Almacenamiento de variables basado en entorno

### Fase 3b: Compilacion (hemlockc)

**Entrada:** AST
**Salida:** Ejecutable nativo via generacion de codigo C
**Implementacion:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   â†“
Verificacion de Tipos: Validar tipos en tiempo de compilacion
   â†“
Codegen C: Generar codigo C equivalente
   â†“
GCC: Compilar C a binario nativo
   â†“
Resultado: Ejecutable independiente
```

**Caracteristicas clave:**
- Verificacion de tipos en tiempo de compilacion (habilitada por defecto)
- Generacion de codigo C para portabilidad
- Enlaza contra `libhemlock_runtime.a`
- Ejecucion significativamente mas rapida que el interprete

---

## Backend del Compilador (hemlockc)

El compilador de Hemlock genera codigo C desde el AST, que luego se compila a un ejecutable nativo usando GCC.

### Arquitectura del Compilador

```
src/backends/compiler/
â”œâ”€â”€ main.c              # CLI, parseo de argumentos, orquestacion
â”œâ”€â”€ codegen.c           # Contexto central de generacion de codigo
â”œâ”€â”€ codegen_expr.c      # Generacion de codigo de expresiones
â”œâ”€â”€ codegen_stmt.c      # Generacion de codigo de sentencias
â”œâ”€â”€ codegen_call.c      # Generacion de llamadas a funciones
â”œâ”€â”€ codegen_closure.c   # Implementacion de closures
â”œâ”€â”€ codegen_program.c   # Generacion de programa de nivel superior
â”œâ”€â”€ codegen_module.c    # Manejo de modulos/importaciones
â”œâ”€â”€ type_check.c        # Verificacion de tipos en compilacion
â””â”€â”€ type_check.h        # API del verificador de tipos
```

### Verificacion de Tipos

El compilador incluye un sistema unificado de verificacion de tipos que:

1. **Valida tipos en tiempo de compilacion** - Detecta errores de tipo antes de la ejecucion
2. **Soporta codigo dinamico** - Codigo sin tipos tratado como `any` (siempre valido)
3. **Proporciona pistas de optimizacion** - Identifica variables que pueden desempaquetarse

**Banderas de Verificacion de Tipos:**

| Bandera | Descripcion |
|---------|-------------|
| (defecto) | Verificacion de tipos habilitada |
| `--check` | Solo verificar tipos, no compilar |
| `--no-type-check` | Deshabilitar verificacion de tipos |
| `--strict-types` | Advertir sobre tipos `any` implicitos |

**Implementacion del Verificador de Tipos:**

```c
// type_check.h - Estructuras clave
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // Pistas de optimizacion
    // ... entorno de tipos, definiciones, etc.
} TypeCheckContext;

// Punto de entrada principal
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### Generacion de Codigo

La fase de codegen traduce nodos AST a codigo C:

**Mapeo de Expresiones:**
```
Hemlock                 â†’  C Generado
----------------------------------------
let x = 42;            â†’  HmlValue x = hml_val_i32(42);
x + y                  â†’  hml_add(x, y)
arr[i]                 â†’  hml_array_get(arr, i)
obj.field              â†’  hml_object_get_field(obj, "field")
fn(a, b) { ... }       â†’  Closure con captura de entorno
```

**Integracion con Runtime:**

El codigo C generado enlaza contra `libhemlock_runtime.a` que proporciona:
- Tipo union etiquetada `HmlValue`
- Gestion de memoria (conteo de referencias)
- Funciones integradas (print, typeof, etc.)
- Primitivas de concurrencia (tareas, canales)
- Soporte FFI

### Optimizacion de Desempaquetado

El verificador de tipos identifica variables que pueden usar tipos C nativos en lugar de `HmlValue` empaquetados:

**Patrones Desempaquetables:**
- Contadores de bucle con tipo entero conocido
- Variables acumuladoras en bucles
- Variables con anotaciones de tipo explicitas (i32, i64, f64, bool)

```hemlock
// El contador de bucle 'i' puede desempaquetarse a int32_t nativo
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## Diseno Modular del Interprete

El interprete esta dividido en modulos enfocados para mantenibilidad y escalabilidad.

### Responsabilidades de los Modulos

#### 1. Entorno (`environment.c`) - 121 lineas

**Proposito:** Alcance de variables y resolucion de nombres

**Funciones clave:**
- `env_create()` - Crear nuevo entorno con padre opcional
- `env_define()` - Definir nueva variable en alcance actual
- `env_get()` - Buscar variable en alcances actual o padres
- `env_set()` - Actualizar valor de variable existente
- `env_free()` - Liberar entorno y todas las variables

**Diseno:**
- Alcances enlazados (cada entorno tiene puntero al padre)
- HashMap para busqueda rapida de variables
- Soporta alcance lexico para closures

#### 2. Valores (`values.c`) - 394 lineas

**Proposito:** Constructores de valores y gestion de estructuras de datos

**Funciones clave:**
- `value_create_*()` - Constructores para cada tipo de valor
- `value_copy()` - Logica de copia profunda/superficial
- `value_free()` - Limpieza y desasignacion de memoria
- `value_to_string()` - Representacion en string para impresion

**Estructuras de datos:**
- Objetos (arrays de campos dinamicos)
- Arrays (redimensionamiento dinamico)
- Buffers (ptr + longitud + capacidad)
- Closures (funcion + entorno capturado)
- Tareas y Canales (primitivas de concurrencia)

#### 3. Tipos (`types.c`) - 440 lineas

**Proposito:** Sistema de tipos, conversiones y duck typing

**Funciones clave:**
- `type_check()` - Validacion de tipos en tiempo de ejecucion
- `type_convert()` - Conversiones/promociones de tipo implicitas
- `duck_type_check()` - Verificacion de tipos estructural para objetos
- `type_name()` - Obtener nombre de tipo imprimible

**Caracteristicas:**
- Jerarquia de promocion de tipos (i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64, con i64/u64 + f32 â†’ f64)
- Verificacion de rango para tipos numericos
- Duck typing para definiciones de tipos de objetos
- Valores por defecto de campos opcionales

#### 4. Funciones Integradas (`builtins.c`) - 955 lineas

**Proposito:** Funciones integradas y registro global

**Funciones clave:**
- `register_builtins()` - Registrar todas las funciones y constantes integradas
- Implementaciones de funciones integradas (print, typeof, alloc, free, etc.)
- Funciones de manejo de senales
- Ejecucion de comandos (exec)

**Categorias de funciones integradas:**
- E/S: print, open, read_file, write_file
- Memoria: alloc, free, memset, memcpy, realloc
- Tipos: typeof, assert
- Concurrencia: spawn, join, detach, channel
- Sistema: exec, signal, raise, panic
- FFI: dlopen, dlsym, dlcall, dlclose

#### 5. E/S (`io.c`) - 449 lineas

**Proposito:** E/S de archivos y serializacion JSON

**Funciones clave:**
- Metodos de objeto archivo (read, write, seek, tell, close)
- Serializacion/deserializacion JSON
- Deteccion de referencias circulares

**Caracteristicas:**
- Objeto archivo con propiedades (path, mode, closed)
- E/S de texto consciente de UTF-8
- Soporte de E/S binaria
- Ida y vuelta JSON para objetos y arrays

#### 6. FFI (`ffi.c`) - Interfaz de Funciones Foraneas

**Proposito:** Llamar funciones C desde bibliotecas compartidas

**Funciones clave:**
- `dlopen()` - Cargar biblioteca compartida
- `dlsym()` - Obtener puntero de funcion por nombre
- `dlcall()` - Llamar funcion C con conversion de tipos
- `dlclose()` - Descargar biblioteca

**Caracteristicas:**
- Integracion con libffi para llamadas dinamicas a funciones
- Conversion automatica de tipos (Hemlock â†” tipos C)
- Soporte para todos los tipos primitivos
- Soporte de punteros y buffers

#### 7. Runtime (`runtime.c`) - 865 lineas

**Proposito:** Evaluacion de expresiones y ejecucion de sentencias

**Funciones clave:**
- `eval_expr()` - Evaluar expresiones (recursivo)
- `eval_stmt()` - Ejecutar sentencias
- Manejo de flujo de control (if, while, for, switch, etc.)
- Manejo de excepciones (try/catch/finally/throw)

**Caracteristicas:**
- Evaluacion recursiva de expresiones
- Evaluacion booleana de cortocircuito
- Deteccion de llamadas a metodos y vinculacion de `self`
- Propagacion de excepciones
- Manejo de break/continue/return

### Beneficios del Diseno Modular

**1. Separacion de Responsabilidades**
- Cada modulo tiene una responsabilidad clara
- Facil encontrar donde se implementan las caracteristicas
- Reduce la carga cognitiva al hacer cambios

**2. Compilaciones Incrementales mas Rapidas**
- Solo los modulos modificados necesitan recompilacion
- Compilacion paralela posible
- Tiempos de iteracion mas cortos durante el desarrollo

**3. Pruebas y Depuracion mas Faciles**
- Los modulos pueden probarse en aislamiento
- Los errores se localizan en subsistemas especificos
- Implementaciones mock posibles para pruebas

**4. Escalabilidad**
- Nuevas caracteristicas pueden agregarse a modulos apropiados
- Los modulos pueden refactorizarse independientemente
- El tamano del codigo por archivo se mantiene manejable

**5. Organizacion del Codigo**
- Agrupacion logica de funcionalidad relacionada
- Grafo de dependencias claro
- Incorporacion mas facil para nuevos contribuidores

---

## Arquitectura del Runtime

### Representacion de Valores

Todos los valores en Hemlock se representan por la estructura `Value` usando una union etiquetada:

```c
typedef struct Value {
    ValueType type;  // Etiqueta de tipo en tiempo de ejecucion
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**Decisiones de diseno:**
- **Union etiquetada** para seguridad de tipos manteniendo flexibilidad
- **Etiquetas de tipo en tiempo de ejecucion** habilitan tipado dinamico con verificacion de tipos
- **Almacenamiento directo de valores** para primitivos (sin empaquetado)
- **Almacenamiento de punteros** para tipos asignados en heap (strings, objetos, arrays)

### Ejemplos de Disposicion en Memoria

**Entero (i32):**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- Tamano total: ~16 bytes (etiqueta de 8 bytes + union de 8 bytes)
- Asignado en pila
- No necesita asignacion en heap

**String:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // Puntero al heap
}

Heap: "hello\0" (6 bytes, terminado en null UTF-8)
```
- El valor es 16 bytes en la pila
- Los datos del string estan asignados en heap
- Debe liberarse manualmente

**Objeto:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // Puntero al heap
}

Heap: Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- Estructura del objeto en heap
- Campos almacenados en array dinamico
- Valores de campos son estructuras Value incrustadas

### Implementacion de Entorno

Las variables se almacenan en cadenas de entorno:

```c
typedef struct Environment {
    HashMap *bindings;           // nombre â†’ Value
    struct Environment *parent;  // Alcance padre lexico
} Environment;
```

**Ejemplo de cadena de alcances:**
```
Alcance Global: { print: <builtin>, args: <array> }
    â†‘
Alcance de Funcion: { x: 10, y: 20 }
    â†‘
Alcance de Bloque: { i: 0 }
```

**Algoritmo de busqueda:**
1. Verificar el hashmap del entorno actual
2. Si no se encuentra, verificar el entorno padre
3. Repetir hasta encontrar o alcanzar el alcance global
4. Error si no se encuentra en ningun alcance

---

## Implementacion del Sistema de Tipos

### Estrategia de Verificacion de Tipos

Hemlock usa **verificacion de tipos en tiempo de ejecucion** con **anotaciones de tipo opcionales**:

```hemlock
let x = 42;           // Sin verificacion de tipo, infiere i32
let y: u8 = 255;      // Verificacion en tiempo de ejecucion: valor debe caber en u8
let z: i32 = x + y;   // Verificacion en tiempo de ejecucion + promocion de tipos
```

**Flujo de implementacion:**
1. **Inferencia de literales** - Lexer/parser determinan tipo inicial del literal
2. **Verificacion de anotacion de tipo** - Si hay anotacion presente, validar en asignacion
3. **Promocion** - Operaciones binarias promueven a tipo comun
4. **Conversion** - Conversiones explicitas ocurren bajo demanda

### Implementacion de Promocion de Tipos

La promocion de tipos sigue una jerarquia fija con preservacion de precision:

```c
// Logica de promocion simplificada
ValueType promote_types(ValueType a, ValueType b) {
    // f64 siempre gana
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32 con i64/u64 promueve a f64 (preservacion de precision)
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // Tipos enteros mas grandes ganan
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**Rangos de tipos:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### Implementacion de Duck Typing

La verificacion de tipos de objetos usa comparacion estructural:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // Verificar todos los campos requeridos
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // Campo faltante
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // Tipo incorrecto
        }
    }

    return true;  // Todos los campos requeridos presentes y tipo correcto
}
```

**El duck typing permite:**
- Campos extra en objetos (ignorados)
- Tipado subestructural (objeto puede tener mas de lo requerido)
- Asignacion de nombre de tipo despues de validacion

---

## Gestion de Memoria

### Estrategia de Asignacion

Hemlock usa **gestion manual de memoria** con dos primitivas de asignacion:

**1. Punteros crudos (`ptr`):**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Sin memoria\n");
        exit(1);
    }
    return ptr;
}
```
- malloc/free directo
- Sin seguimiento
- Responsabilidad del usuario liberar

**2. Buffers (`buffer`):**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- Rastrea tamano y capacidad
- Verificacion de limites en acceso
- Aun requiere free manual

### Tipos Asignados en Heap

**Strings:**
- Array de bytes UTF-8 en heap
- Terminado en null para interoperabilidad con C
- Mutable (puede modificar en lugar)
- Con conteo de referencias (auto-liberado cuando el alcance termina)

**Objetos:**
- Array de campos dinamico
- Nombres y valores de campos en heap
- Con conteo de referencias (auto-liberado cuando el alcance termina)
- Referencias circulares posibles (manejadas con seguimiento de conjunto visitado)

**Arrays:**
- Crecimiento dinamico con duplicacion de capacidad
- Elementos son estructuras Value incrustadas
- Reasignacion automatica al crecer
- Con conteo de referencias (auto-liberado cuando el alcance termina)

**Closures:**
- Captura entorno por referencia
- Entorno asignado en heap
- Entornos de closure se liberan apropiadamente cuando ya no se referencian

---

## Modelo de Concurrencia

### Arquitectura de Hilos

Hemlock usa **hilos 1:1** con hilos POSIX (pthreads):

```
Tarea de Usuario       Hilo del SO         Nucleo de CPU
----------------       -----------         -------------
spawn(f1) ------>  pthread_create --> Nucleo 0
spawn(f2) ------>  pthread_create --> Nucleo 1
spawn(f3) ------>  pthread_create --> Nucleo 2
```

**Caracteristicas clave:**
- Cada `spawn()` crea un nuevo pthread
- El kernel programa hilos a traves de nucleos
- Ejecucion paralela verdadera (sin GIL)
- Multitarea preventiva

### Implementacion de Tareas

```c
typedef struct Task {
    pthread_t thread;        // Handle de hilo del SO
    Value result;            // Valor de retorno
    char *error;             // Mensaje de excepcion (si se lanzo)
    pthread_mutex_t lock;    // Protege el estado
    TaskState state;         // RUNNING, FINISHED, ERROR
} Task;
```

**Ciclo de vida de tareas:**
1. `spawn(func, args)` â†’ Crear Task, iniciar pthread
2. El hilo ejecuta la funcion con argumentos
3. Al retornar: Almacenar resultado, establecer estado a FINISHED
4. En excepcion: Almacenar mensaje de error, establecer estado a ERROR
5. `join(task)` â†’ Esperar al hilo, retornar resultado o lanzar excepcion

### Implementacion de Canales

```c
typedef struct Channel {
    void **buffer;           // Buffer circular de Value*
    size_t capacity;         // Maximo de elementos en buffer
    size_t count;            // Elementos actuales en buffer
    size_t read_index;       // Siguiente posicion de lectura
    size_t write_index;      // Siguiente posicion de escritura
    bool closed;             // Bandera de canal cerrado
    pthread_mutex_t lock;    // Protege el buffer
    pthread_cond_t not_full; // Senal cuando hay espacio disponible
    pthread_cond_t not_empty;// Senal cuando hay datos disponibles
} Channel;
```

**Operacion de envio:**
1. Bloquear mutex
2. Esperar si buffer lleno (cond_wait en not_full)
3. Escribir valor en buffer[write_index]
4. Incrementar write_index (circular)
5. Senalar not_empty
6. Desbloquear mutex

**Operacion de recepcion:**
1. Bloquear mutex
2. Esperar si buffer vacio (cond_wait en not_empty)
3. Leer valor de buffer[read_index]
4. Incrementar read_index (circular)
5. Senalar not_full
6. Desbloquear mutex

**Garantias de sincronizacion:**
- Envio/recepcion seguro entre hilos (protegido por mutex)
- Semantica bloqueante (productor espera si esta lleno, consumidor espera si esta vacio)
- Entrega ordenada (FIFO dentro de un canal)

---

## Planes Futuros

### Completado: Backend del Compilador

El backend del compilador (`hemlockc`) ha sido implementado con:
- Generacion de codigo C desde AST
- Verificacion de tipos en tiempo de compilacion (habilitada por defecto)
- Biblioteca de runtime (`libhemlock_runtime.a`)
- Paridad completa con el interprete (98% de tasa de aprobacion de pruebas)
- Marco de optimizacion de desempaquetado

### Enfoque Actual: Mejoras del Sistema de Tipos

**Mejoras recientes:**
- Sistemas unificados de verificacion de tipos e inferencia de tipos
- Verificacion de tipos en tiempo de compilacion habilitada por defecto
- Bandera `--check` para validacion solo de tipos
- Contexto de tipos pasado a codegen para pistas de optimizacion

### Mejoras Futuras

**Adiciones potenciales:**
- Genericos/plantillas
- Coincidencia de patrones
- Integracion LSP para soporte de IDE consciente de tipos
- Optimizaciones de desempaquetado mas agresivas
- Analisis de escape para asignacion en pila

### Optimizaciones a Largo Plazo

**Mejoras posibles:**
- Cache en linea para llamadas a metodos
- Compilacion JIT para caminos de codigo calientes
- Programador de robo de trabajo para mejor concurrencia
- Optimizacion guiada por perfil

---

## Directrices de Implementacion

### Agregar Nuevas Caracteristicas

Al implementar nuevas caracteristicas, siga estas directrices:

**1. Elegir el modulo correcto:**
- Nuevos tipos de valor â†’ `values.c`
- Conversiones de tipo â†’ `types.c`
- Funciones integradas â†’ `builtins.c`
- Operaciones de E/S â†’ `io.c`
- Flujo de control â†’ `runtime.c`

**2. Actualizar todas las capas:**
- Agregar tipos de nodo AST si es necesario (`ast.h`, `ast.c`)
- Agregar tokens de lexer si es necesario (`lexer.c`)
- Agregar reglas de parser (`parser.c`)
- Implementar comportamiento en runtime (`runtime.c` o modulo apropiado)
- Agregar pruebas (`tests/`)

**3. Mantener consistencia:**
- Seguir el estilo de codigo existente
- Usar convenciones de nomenclatura consistentes
- Documentar API publica en headers
- Mantener mensajes de error claros y consistentes

**4. Probar exhaustivamente:**
- Agregar casos de prueba antes de implementar
- Probar caminos de exito y error
- Probar casos limite
- Verificar que no haya fugas de memoria (valgrind)

### Consideraciones de Rendimiento

**Cuellos de botella actuales:**
- Busquedas en HashMap para acceso a variables
- Llamadas a funciones recursivas (sin TCO)
- Concatenacion de strings (asigna nuevo string cada vez)
- Sobrecarga de verificacion de tipos en cada operacion

**Oportunidades de optimizacion:**
- Cachear ubicaciones de variables (cache en linea)
- Optimizacion de llamada de cola
- Constructor de strings para concatenacion
- Inferencia de tipos para omitir verificaciones en tiempo de ejecucion

### Consejos de Depuracion

**Herramientas utiles:**
- `valgrind` - Deteccion de fugas de memoria
- `gdb` - Depurar crashes
- Bandera `-g` - Simbolos de depuracion
- Depuracion con `printf` - Simple pero efectivo

**Problemas comunes:**
- Segfault â†’ Desreferencia de puntero nulo (verificar valores de retorno)
- Fuga de memoria â†’ Llamada a free() faltante (verificar caminos de value_free)
- Error de tipo â†’ Verificar logica de type_convert() y type_check()
- Crash en hilos â†’ Condicion de carrera (verificar uso de mutex)

---

## Conclusion

La implementacion de Hemlock prioriza:
- **Modularidad** - Separacion limpia de responsabilidades
- **Simplicidad** - Implementacion directa
- **Explicitud** - Sin magia oculta
- **Mantenibilidad** - Facil de entender y modificar

El actual interprete de recorrido de arbol es intencionalmente simple para facilitar el desarrollo rapido de caracteristicas y la experimentacion. El futuro backend del compilador mejorara el rendimiento manteniendo la misma semantica.


--------------------------------------------------------------------------------
## Sintaxis de Firmas
--------------------------------------------------------------------------------

# Diseno de Sintaxis de Firmas

> Extendiendo el sistema de tipos de Hemlock con tipos de funcion, modificadores nullables, alias de tipos, parametros const y firmas de metodos.

**Estado:** Implementado (v1.7.0)
**Version:** 1.0
**Autor:** Claude

---

## Vision General

Este documento propone cinco extensiones interconectadas del sistema de tipos que se construyen sobre la infraestructura existente de Hemlock:

1. **Anotaciones de Tipos de Funcion** - Tipos de funcion de primera clase
2. **Modificadores de Tipo Nullable** - Manejo explicito de null (extiende la bandera `nullable` existente)
3. **Alias de Tipos** - Abreviaciones de tipos con nombre
4. **Parametros Const** - Contratos de inmutabilidad
5. **Firmas de Metodos en Define** - Comportamiento similar a interfaces

Estas caracteristicas comparten la filosofia: **explicito sobre implicito, opcional pero aplicado cuando se usa**.

---

## 1. Anotaciones de Tipos de Funcion

### Motivacion

Actualmente, no hay forma de expresar la firma de una funcion como un tipo:

```hemlock
// Actual: callback no tiene informacion de tipo
fn map(arr: array, callback) { ... }

// Propuesto: tipo de funcion explicito
fn map(arr: array, callback: fn(any, i32): any): array { ... }
```

### Sintaxis

```hemlock
// Tipo de funcion basico
fn(i32, i32): i32

// Con nombres de parametros (solo documentacion, no se aplica)
fn(a: i32, b: i32): i32

// Sin valor de retorno (void)
fn(string): void
fn(string)              // Abreviatura: omitir `: void`

// Retorno nullable
fn(i32): string?

// Parametros opcionales
fn(name: string, age?: i32): void

// Parametros rest
fn(...args: array): i32

// Sin parametros
fn(): bool

// Orden superior: funcion que retorna funcion
fn(i32): fn(i32): i32

// Tipo de funcion async
async fn(i32): i32
```

### Ejemplos de Uso

```hemlock
// Variable con tipo de funcion
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Parametro de funcion
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// El tipo de retorno es una funcion
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Array de funciones
let ops: array<fn(i32, i32): i32> = [add, subtract, multiply];

// Campo de objeto
define EventHandler {
    name: string;
    callback: fn(Event): void;
}
```

### Cambios en el AST

```c
// En enum TypeKind (include/ast.h)
typedef enum {
    // ... tipos existentes ...
    TYPE_FUNCTION,      // NUEVO: Tipo de funcion
} TypeKind;

// En struct Type (include/ast.h)
struct Type {
    TypeKind kind;
    // ... campos existentes ...

    // Para TYPE_FUNCTION:
    struct Type **param_types;      // Tipos de parametros
    char **param_names;             // Nombres de parametros opcionales (docs)
    int *param_optional;            // Cuales parametros son opcionales
    int num_params;
    char *rest_param_name;          // Nombre de parametro rest o NULL
    struct Type *rest_param_type;   // Tipo de parametro rest
    struct Type *return_type;       // Tipo de retorno (NULL = void)
    int is_async;                   // tipo fn async
};
```

### Parsing

Los tipos de funcion comienzan con `fn` (o `async fn`) seguido de lista de parametros:

```
function_type := ["async"] "fn" "(" [param_type_list] ")" [":" type]
param_type_list := param_type ("," param_type)*
param_type := [identifier ":"] ["?"] type | "..." [identifier] [":" type]
```

**Desambiguacion:** Al parsear un tipo y encontrar `fn`:
- Si va seguido de `(`, es un tipo de funcion
- De lo contrario, error de sintaxis (`fn` solo no es un tipo valido)

### Compatibilidad de Tipos

```hemlock
// Se requiere coincidencia exacta para tipos de funcion
let f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK

// Contravarianza de parametros (aceptar tipos mas amplios esta bien)
let g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// Covarianza de retorno (retornar tipos mas estrechos esta bien)
let h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// La aridad debe coincidir
let bad: fn(i32): i32 = fn(a, b) { return a; };       // ERROR: aridad no coincide

// Parametros opcionales compatibles con requeridos
let opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK
```

---

## 2. Modificadores de Tipo Nullable

### Motivacion

El sufijo `?` hace explicita la aceptacion de null en las firmas:

```hemlock
// Actual: no esta claro si null es valido
fn find(arr: array, val: any): i32 { ... }

// Propuesto: retorno nullable explicito
fn find(arr: array, val: any): i32? { ... }
```

### Sintaxis

```hemlock
// Tipos nullables con sufijo ?
string?           // string o null
i32?              // i32 o null
User?             // User o null
array<i32>?       // array o null
fn(i32): i32?     // funcion que retorna i32 o null

// Composicion con tipos de funcion
fn(string?): i32          // Acepta string o null
fn(string): i32?          // Retorna i32 o null
fn(string?): i32?         // Ambos nullables

// En define
define Result {
    value: any?;
    error: string?;
}
```

### Notas de Implementacion

**Ya existe:** La bandera `Type.nullable` ya esta en el AST. Esta caracteristica principalmente necesita:
1. Soporte del parser para sufijo `?` en cualquier tipo (verificar/extender)
2. Composicion adecuada con tipos de funcion
3. Aplicacion en tiempo de ejecucion

### Compatibilidad de Tipos

```hemlock
// No-nullable asignable a nullable
let x: i32? = 42;           // OK
let y: i32? = null;         // OK

// Nullable NO asignable a no-nullable
let z: i32 = x;             // ERROR: x podria ser null

// Coalescencia null para desenvolver
let z: i32 = x ?? 0;        // OK: ?? proporciona valor por defecto

// Encadenamiento opcional retorna nullable
let name: string? = user?.name;
```

---

## 3. Alias de Tipos

### Motivacion

Los tipos complejos se benefician de abreviaciones con nombre:

```hemlock
// Actual: tipos compuestos repetitivos
fn process(entity: HasName & HasId & HasTimestamp) { ... }
fn validate(entity: HasName & HasId & HasTimestamp) { ... }

// Propuesto: alias con nombre
type Entity = HasName & HasId & HasTimestamp;
fn process(entity: Entity) { ... }
fn validate(entity: Entity) { ... }
```

### Sintaxis

```hemlock
// Alias basico
type Integer = i32;
type Text = string;

// Alias de tipo compuesto
type Entity = HasName & HasId;
type Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;

// Alias de tipo de funcion
type Callback = fn(Event): void;
type Predicate = fn(any): bool;
type Reducer = fn(acc: any, val: any): any;
type AsyncTask = async fn(): any;

// Alias nullable
type OptionalString = string?;

// Alias generico (si soportamos alias de tipos genericos)
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Alias de tipo array
type IntArray = array<i32>;
type Matrix = array<array<f64>>;
```

### Alcance y Visibilidad

```hemlock
// Alcance de modulo por defecto
type Callback = fn(Event): void;

// Exportable
export type Handler = fn(Request): Response;

// En otro archivo
import { Handler } from "./handlers.hml";
fn register(h: Handler) { ... }
```

### Cambios en el AST

```c
// Nuevo tipo de sentencia
typedef enum {
    // ... sentencias existentes ...
    STMT_TYPE_ALIAS,    // NUEVO
} StmtKind;

// En union Stmt
struct {
    char *name;                 // Nombre del alias
    char **type_params;         // Parametros genericos: <T, U>
    int num_type_params;
    Type *aliased_type;         // El tipo real
} type_alias;
```

### Parsing

```
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"
```

**Nota:** `type` es una nueva palabra clave. Verificar conflictos con identificadores existentes.

### Resolucion

Los alias de tipos se resuelven en:
- **Tiempo de parsing:** Alias registrado en entorno de tipos
- **Tiempo de verificacion:** Alias expandido al tipo subyacente
- **Tiempo de ejecucion:** Alias es transparente (igual que el tipo subyacente)

```hemlock
type MyInt = i32;
let x: MyInt = 42;
typeof(x);           // "i32" (no "MyInt")
```

---

## 4. Parametros Const

### Motivacion

Senalar la intencion de inmutabilidad en firmas de funcion:

```hemlock
// Actual: no esta claro si el array se modificara
fn print_all(items: array) { ... }

// Propuesto: contrato de inmutabilidad explicito
fn print_all(const items: array) { ... }
```

### Sintaxis

```hemlock
// Parametro const
fn process(const data: buffer) {
    // data[0] = 0;        // ERROR: no puede mutar const
    let x = data[0];       // OK: lectura permitida
    return x;
}

// Multiples parametros const
fn compare(const a: array, const b: array): bool { ... }

// Mezcla de const y mutable
fn update(const source: array, target: array) {
    for (item in source) {
        target.push(item);   // OK: target es mutable
    }
}

// Const con inferencia de tipos
fn log(const msg) {
    print(msg);
}

// Const en tipos de funcion
type Reader = fn(const buffer): i32;
```

### Que Previene Const

```hemlock
fn bad(const arr: array) {
    arr.push(1);         // ERROR: metodo mutante
    arr.pop();           // ERROR: metodo mutante
    arr[0] = 5;          // ERROR: asignacion por indice
    arr.clear();         // ERROR: metodo mutante
}

fn ok(const arr: array) {
    let x = arr[0];      // OK: lectura
    let len = len(arr);  // OK: verificacion de longitud
    let copy = arr.slice(0, 10);  // OK: crea nuevo array
    for (item in arr) {  // OK: iteracion
        print(item);
    }
}
```

### Metodos Mutantes vs No-Mutantes

| Tipo | Mutante (bloqueado por const) | No-Mutante (permitido) |
|------|------------------------------|------------------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |
| string | asignacion por indice (`s[0] = 'x'`) | todos los metodos (retornan nuevos strings) |
| buffer | asignacion por indice, memset, memcpy (hacia) | lectura por indice, slice |
| object | asignacion de campo | lectura de campo |

### Cambios en el AST

```c
// En expresion de funcion (include/ast.h)
struct {
    // ... campos existentes ...
    int *param_is_const;    // NUEVO: 1 si es const, 0 en caso contrario
} function;

// En struct Type para tipos de funcion
struct Type {
    // ... campos existentes ...
    int *param_is_const;    // Para TYPE_FUNCTION
};
```

### Aplicacion

**Interprete:**
- Rastrear estado const en vinculaciones de variables
- Verificar antes de operaciones de mutacion
- Error en tiempo de ejecucion por violacion de const

**Compilador:**
- Emitir variables C calificadas con const donde sea beneficioso
- Analisis estatico para violaciones de const
- Advertencia/error en tiempo de compilacion

---

## 5. Firmas de Metodos en Define

### Motivacion

Permitir que los bloques `define` especifiquen metodos esperados, no solo campos de datos:

```hemlock
// Actual: solo campos de datos
define User {
    name: string;
    age: i32;
}

// Propuesto: firmas de metodos
define Comparable {
    fn compare(other: Self): i32;
}

define Serializable {
    fn serialize(): string;
    fn deserialize(data: string): Self;  // Metodo estatico
}
```

### Sintaxis

```hemlock
// Firma de metodo (sin cuerpo)
define Hashable {
    fn hash(): i32;
}

// Multiples metodos
define Collection {
    fn size(): i32;
    fn is_empty(): bool;
    fn contains(item: any): bool;
}

// Campos y metodos mezclados
define Entity {
    id: i32;
    name: string;
    fn validate(): bool;
    fn serialize(): string;
}

// Usando tipo Self
define Cloneable {
    fn clone(): Self;
}

define Comparable {
    fn compare(other: Self): i32;
    fn equals(other: Self): bool;
}

// Metodos opcionales
define Printable {
    fn to_string(): string;
    fn debug_string?(): string;  // Metodo opcional (puede estar ausente)
}

// Metodos con implementaciones por defecto
define Ordered {
    fn compare(other: Self): i32;  // Requerido

    // Implementaciones por defecto (heredadas si no se sobrescriben)
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
}
```

### El Tipo `Self`

`Self` se refiere al tipo concreto que implementa la interfaz:

```hemlock
define Addable {
    fn add(other: Self): Self;
}

// Cuando se usa:
let a: Addable = {
    value: 10,
    add: fn(other) {
        return { value: self.value + other.value, add: self.add };
    }
};
```

### Tipado Estructural (Duck Typing)

Las firmas de metodos usan el mismo duck typing que los campos:

```hemlock
define Stringifiable {
    fn to_string(): string;
}

// Cualquier objeto con metodo to_string() satisface Stringifiable
let x: Stringifiable = {
    name: "test",
    to_string: fn() { return self.name; }
};

// Tipos compuestos con metodos
define Named { name: string; }
define Printable { fn to_string(): string; }

type NamedPrintable = Named & Printable;

let y: NamedPrintable = {
    name: "Alice",
    to_string: fn() { return "Name: " + self.name; }
};
```

### Cambios en el AST

```c
// Extender define_object en union Stmt
struct {
    char *name;
    char **type_params;
    int num_type_params;

    // Campos (existentes)
    char **field_names;
    Type **field_types;
    int *field_optional;
    Expr **field_defaults;
    int num_fields;

    // Metodos (NUEVO)
    char **method_names;
    Type **method_types;        // TYPE_FUNCTION
    int *method_optional;       // Metodos opcionales (fn name?(): type)
    Expr **method_defaults;     // Implementaciones por defecto (NULL si solo firma)
    int num_methods;
} define_object;
```

### Verificacion de Tipos

Al verificar `value: InterfaceType`:
1. Verificar que todos los campos requeridos existen con tipos compatibles
2. Verificar que todos los metodos requeridos existen con firmas compatibles
3. Campos/metodos opcionales pueden estar ausentes

```hemlock
define Sortable {
    fn compare(other: Self): i32;
}

// Valido: tiene metodo compare
let valid: Sortable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Invalido: falta compare
let invalid: Sortable = { value: 10 };  // ERROR: falta metodo 'compare'

// Invalido: firma incorrecta
let wrong: Sortable = {
    compare: fn() { return 0; }  // ERROR: se esperaba (Self): i32
};
```

---

## Ejemplos de Interaccion

### Combinando Todas las Caracteristicas

```hemlock
// Alias de tipo para tipo de funcion complejo
type EventCallback = fn(event: Event, context: Context?): bool;

// Alias de tipo para interfaz compuesta
type Entity = HasId & HasName & Serializable;

// Define con firmas de metodos
define Repository<T> {
    fn find(id: i32): T?;
    fn save(const entity: T): bool;
    fn delete(id: i32): bool;
    fn find_all(predicate: fn(T): bool): array<T>;
}

// Usando todo junto
fn create_user_repo(): Repository<User> {
    let users: array<User> = [];

    return {
        find: fn(id) {
            for (u in users) {
                if (u.id == id) { return u; }
            }
            return null;
        },
        save: fn(const entity) {
            users.push(entity);
            return true;
        },
        delete: fn(id) {
            // ...
            return true;
        },
        find_all: fn(predicate) {
            return users.filter(predicate);
        }
    };
}
```

### Callbacks con Tipos Explicitos

```hemlock
type ClickHandler = fn(event: MouseEvent): void;
type KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;

define Widget {
    x: i32;
    y: i32;
    on_click: ClickHandler?;
    on_key: KeyHandler?;
}

fn create_button(label: string, handler: ClickHandler): Widget {
    return {
        x: 0, y: 0,
        on_click: handler,
        on_key: null
    };
}
```

### Tipos de Funcion Nullables

```hemlock
// Callback opcional
fn fetch(url: string, on_complete: fn(Response): void?): void {
    let response = http_get(url);
    if (on_complete != null) {
        on_complete(response);
    }
}

// Retorno nullable de tipo de funcion
type Parser = fn(input: string): AST?;

fn try_parse(parsers: array<Parser>, input: string): AST? {
    for (p in parsers) {
        let result = p(input);
        if (result != null) {
            return result;
        }
    }
    return null;
}
```

---

## Hoja de Ruta de Implementacion

### Fase 1: Infraestructura Central
1. Agregar `TYPE_FUNCTION` al enum TypeKind
2. Extender struct Type con campos de tipo de funcion
3. Agregar `CHECKED_FUNCTION` al verificador de tipos del compilador
4. Agregar soporte de tipo `Self` (TYPE_SELF)

### Fase 2: Parsing
1. Implementar `parse_function_type()` en el parser
2. Manejar `fn(...)` en posicion de tipo
3. Agregar palabra clave `type` y parsing de `STMT_TYPE_ALIAS`
4. Agregar parsing de modificador de parametro `const`
5. Extender parsing de define para firmas de metodos

### Fase 3: Verificacion de Tipos
1. Reglas de compatibilidad de tipos de funcion
2. Resolucion y expansion de alias de tipos
3. Verificacion de mutacion de parametros const
4. Validacion de firmas de metodos en tipos define
5. Resolucion de tipo Self

### Fase 4: Runtime
1. Validacion de tipo de funcion en sitios de llamada
2. Deteccion de violacion de const
3. Transparencia de alias de tipos

### Fase 5: Pruebas de Paridad
1. Pruebas de anotacion de tipos de funcion
2. Pruebas de composicion nullable
3. Pruebas de alias de tipos
4. Pruebas de parametros const
5. Pruebas de firmas de metodos

---

## Decisiones de Diseno

### 1. Alias de Tipos Genericos: **SI**

Los alias de tipos soportan parametros genericos:

```hemlock
// Alias de tipos genericos
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
type Mapper<T, U> = fn(T): U;
type AsyncResult<T> = async fn(): T?;

// Uso
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
let result: Result<User, string> = { value: user, error: null };
let transform: Mapper<i32, string> = fn(n) { return n.to_string(); };
```

### 2. Propagacion de Const: **PROFUNDA**

Los parametros const son completamente inmutables - sin mutacion a traves de ninguna ruta:

```hemlock
fn process(const arr: array<object>) {
    arr.push({});        // ERROR: no puede mutar array const
    arr[0] = {};         // ERROR: no puede mutar array const
    arr[0].x = 5;        // ERROR: no puede mutar a traves de const (PROFUNDO)

    let x = arr[0].x;    // OK: leer esta bien
    let copy = arr[0];   // OK: crea una copia
    copy.x = 5;          // OK: copy no es const
}

fn nested(const obj: object) {
    obj.user.name = "x"; // ERROR: const profundo previene mutacion anidada
    obj.items[0] = 1;    // ERROR: const profundo previene mutacion anidada
}
```

**Justificacion:** Const profundo proporciona garantias mas fuertes y es mas util para
asegurar integridad de datos. Si necesita mutar datos anidados, haga una copia primero.

### 3. Self en Alias de Tipos Independientes: **NO**

`Self` solo es valido dentro de bloques `define` donde tiene un significado claro:

```hemlock
// Valido: Self se refiere al tipo definido
define Comparable {
    fn compare(other: Self): i32;
}

// Invalido: Self no tiene significado aqui
type Cloner = fn(Self): Self;  // ERROR: Self fuera de contexto define

// En su lugar, usar genericos:
type Cloner<T> = fn(T): T;
```

### 4. Implementaciones por Defecto de Metodos: **SI (Solo Simples)**

Permitir implementaciones por defecto para metodos simples/utilitarios:

```hemlock
define Comparable {
    // Requerido: debe ser implementado
    fn compare(other: Self): i32;

    // Implementaciones por defecto (metodos de conveniencia simples)
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
}

define Printable {
    fn to_string(): string;

    // Por defecto: delega al metodo requerido
    fn print() {
        print(self.to_string());
    }
    fn println() {
        print(self.to_string() + "\n");
    }
}

// El objeto solo necesita implementar metodos requeridos
let item: Comparable = {
    value: 42,
    compare: fn(other) { return self.value - other.value; }
    // equals, less_than, greater_than se heredan de los valores por defecto
};

item.less_than({ value: 50, compare: item.compare });  // true
```

**Directrices para valores por defecto:**
- Mantenerlos simples (1-3 lineas)
- Deben delegar a metodos requeridos
- Sin logica compleja ni efectos secundarios
- Solo primitivas y composiciones directas

### 5. Varianza: **INFERIDA (Sin Anotaciones Explicitas)**

La varianza se infiere de como se usan los parametros de tipo:

```hemlock
// La varianza es automatica basada en posicion
type Producer<T> = fn(): T;           // T en retorno = covariante
type Consumer<T> = fn(T): void;       // T en parametro = contravariante
type Transformer<T> = fn(T): T;       // T en ambos = invariante

// Ejemplo: Dog <: Animal (Dog es subtipo de Animal)
let dog_producer: Producer<Dog> = fn() { return new_dog(); };
let animal_producer: Producer<Animal> = dog_producer;  // OK: covariante

let animal_consumer: Consumer<Animal> = fn(a) { print(a); };
let dog_consumer: Consumer<Dog> = animal_consumer;     // OK: contravariante
```

**Â¿Por que inferir?**
- Menos codigo repetitivo (`<out T>` / `<in T>` agrega ruido)
- Sigue "explicito sobre implicito" - la posicion ES explicita
- Coincide con como la mayoria de los lenguajes manejan la varianza de tipos de funcion
- Los errores son claros cuando se violan las reglas de varianza

---

## Apendice: Cambios en la Gramatica

```ebnf
(* Tipos *)
type := simple_type | compound_type | function_type
simple_type := base_type ["?"] | identifier ["<" type_args ">"] ["?"]
compound_type := simple_type ("&" simple_type)+
function_type := ["async"] "fn" "(" [param_types] ")" [":" type]

base_type := "i8" | "i16" | "i32" | "i64"
           | "u8" | "u16" | "u32" | "u64"
           | "f32" | "f64" | "bool" | "string" | "rune"
           | "ptr" | "buffer" | "void" | "null"
           | "array" ["<" type ">"]
           | "object"
           | "Self"

param_types := param_type ("," param_type)*
param_type := ["const"] [identifier ":"] ["?"] type
            | "..." [identifier] [":" type]

type_args := type ("," type)*

(* Sentencias *)
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"

define_stmt := "define" identifier ["<" type_params ">"] "{" define_members "}"
define_members := (field_def | method_def)*
field_def := identifier (":" type ["=" expr] | "?:" (type | expr)) ";"?
method_def := "fn" identifier ["?"] "(" [param_types] ")" [":" type] (block | ";")
            (* "?" marca metodo opcional, block proporciona implementacion por defecto *)

(* Parametros *)
param := ["const"] ["ref"] identifier [":" type] ["?:" expr]
       | "..." identifier [":" type]
```



################################################################################
# CONTRIBUIR
################################################################################

--------------------------------------------------------------------------------
## GuÃ­as de ContribuciÃ³n
--------------------------------------------------------------------------------

# Contribuir a Hemlock

Gracias por tu interÃ©s en contribuir a Hemlock. Esta guÃ­a te ayudarÃ¡ a entender cÃ³mo contribuir de manera efectiva mientras mantienes la filosofÃ­a de diseÃ±o del lenguaje y la calidad del cÃ³digo.

---

## Tabla de Contenidos

- [Antes de Comenzar](#antes-de-comenzar)
- [Flujo de Trabajo de ContribuciÃ³n](#flujo-de-trabajo-de-contribuciÃ³n)
- [GuÃ­a de Estilo de CÃ³digo](#guÃ­a-de-estilo-de-cÃ³digo)
- [QuÃ© Contribuir](#quÃ©-contribuir)
- [QuÃ© NO Contribuir](#quÃ©-no-contribuir)
- [Patrones Comunes](#patrones-comunes)
- [Agregar Nuevas Funcionalidades](#agregar-nuevas-funcionalidades)
- [Proceso de RevisiÃ³n de CÃ³digo](#proceso-de-revisiÃ³n-de-cÃ³digo)

---

## Antes de Comenzar

### Lectura Requerida

Antes de contribuir, por favor lee estos documentos en orden:

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Comprende los principios fundamentales de Hemlock
2. **`/home/user/hemlock/docs/design/implementation.md`** - Aprende la estructura del cÃ³digo base
3. **`/home/user/hemlock/docs/contributing/testing.md`** - Comprende los requisitos de pruebas
4. **Este documento** - Aprende las guÃ­as de contribuciÃ³n

### Prerrequisitos

**Conocimiento requerido:**
- ProgramaciÃ³n en C (punteros, gestiÃ³n de memoria, estructuras)
- Fundamentos de compiladores/intÃ©rpretes (anÃ¡lisis lÃ©xico, sintÃ¡ctico, AST)
- Flujo de trabajo con Git y GitHub
- LÃ­nea de comandos Unix/Linux

**Herramientas requeridas:**
- Compilador GCC o Clang
- Sistema de compilaciÃ³n Make
- Control de versiones Git
- Valgrind (para detecciÃ³n de fugas de memoria)
- Editor de texto bÃ¡sico o IDE

### Canales de ComunicaciÃ³n

**DÃ³nde hacer preguntas:**
- GitHub Issues - Reportes de errores y solicitudes de funcionalidades
- GitHub Discussions - Preguntas generales y discusiones de diseÃ±o
- Comentarios en Pull Request - RetroalimentaciÃ³n especÃ­fica de cÃ³digo

---

## Flujo de Trabajo de ContribuciÃ³n

### 1. Encontrar o Crear un Issue

**Antes de escribir cÃ³digo:**
- Verifica si existe un issue para tu contribuciÃ³n
- Si no existe, crea uno describiendo lo que quieres hacer
- Espera retroalimentaciÃ³n de los mantenedores antes de comenzar cambios grandes
- Las correcciones pequeÃ±as de errores pueden omitir este paso

**Las buenas descripciones de issues incluyen:**
- DeclaraciÃ³n del problema (quÃ© estÃ¡ roto o falta)
- SoluciÃ³n propuesta (cÃ³mo planeas solucionarlo)
- Ejemplos (fragmentos de cÃ³digo mostrando el problema)
- JustificaciÃ³n (por quÃ© este cambio se alinea con la filosofÃ­a de Hemlock)

### 2. Fork y Clone

```bash
# Fork the repository on GitHub first, then:
git clone https://github.com/YOUR_USERNAME/hemlock.git
cd hemlock
git checkout -b feature/your-feature-name
```

### 3. Hacer tus Cambios

Sigue estas directrices:
- Escribe las pruebas primero (enfoque TDD)
- Implementa la funcionalidad
- AsegÃºrate de que todas las pruebas pasen
- Verifica fugas de memoria
- Actualiza la documentaciÃ³n

### 4. Probar tus Cambios

```bash
# Run the full test suite
make test

# Run specific test category
./tests/run_tests.sh tests/category/

# Check for memory leaks
valgrind ./hemlock tests/your_test.hml

# Build and test
make clean && make && make test
```

### 5. Hacer Commit de tus Cambios

**Buenos mensajes de commit:**
```
Add bitwise operators for integer types

- Implement &, |, ^, <<, >>, ~ operators
- Add type checking to ensure integer-only operations
- Update operator precedence table
- Add comprehensive tests for all operators

Closes #42
```

**Formato del mensaje de commit:**
- Primera lÃ­nea: Resumen breve (mÃ¡ximo 50 caracteres)
- LÃ­nea en blanco
- ExplicaciÃ³n detallada (ajustar a 72 caracteres)
- Referenciar nÃºmeros de issue

### 6. Enviar un Pull Request

**Antes de enviar:**
- Haz rebase sobre la Ãºltima rama main
- AsegÃºrate de que todas las pruebas pasen
- Ejecuta valgrind para verificar fugas
- Actualiza CLAUDE.md si agregas funcionalidades visibles al usuario

**La descripciÃ³n del pull request debe incluir:**
- QuÃ© problema resuelve
- CÃ³mo lo resuelve
- Cambios incompatibles (si los hay)
- Ejemplos de nueva sintaxis o comportamiento
- Resumen de cobertura de pruebas

---

## GuÃ­a de Estilo de CÃ³digo

### Estilo de CÃ³digo C

**Formato:**
```c
// Indent with 4 spaces (no tabs)
// K&R brace style for functions
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // Brace on same line for control structures
        do_something();
    }
}

// Line length: 100 characters max
// Use spaces around operators
int result = (a + b) * c;

// Pointer asterisk with type
char *string;   // Good
char* string;   // Avoid
char * string;  // Avoid
```

**Convenciones de nombres:**
```c
// Functions: lowercase_with_underscores
void eval_expression(ASTNode *node);

// Types: PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// Constants: UPPERCASE_WITH_UNDERSCORES
#define MAX_BUFFER_SIZE 4096

// Variables: lowercase_with_underscores
int item_count;
Value *current_value;

// Enums: TYPE_PREFIX_NAME
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**Comentarios:**
```c
// Single-line comments for brief explanations
// Use complete sentences with proper capitalization

/*
 * Multi-line comments for longer explanations
 * Align asterisks for readability
 */

/**
 * Function documentation comment
 * @param node - AST node to evaluate
 * @return Evaluated value
 */
Value eval_expr(ASTNode *node);
```

**Manejo de errores:**
```c
// Check all malloc calls
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Error: Out of memory\n");
    exit(1);
}

// Provide context in error messages
if (file == NULL) {
    fprintf(stderr, "Error: Failed to open '%s': %s\n",
            filename, strerror(errno));
    exit(1);
}

// Use meaningful error messages
// Bad: "Error: Invalid value"
// Good: "Error: Expected integer, got string"
```

**GestiÃ³n de memoria:**
```c
// Always free what you allocate
Value *val = value_create_i32(42);
// ... use val
value_free(val);

// Set pointers to NULL after freeing (prevents double-free)
free(ptr);
ptr = NULL;

// Document ownership in comments
// This function takes ownership of 'value' and will free it
void store_value(Value *value);

// This function does NOT take ownership (caller must free)
Value *get_value(void);
```

### OrganizaciÃ³n del CÃ³digo

**Estructura de archivos:**
```c
// 1. Includes (system headers first, then local)
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. Constants and macros
#define INITIAL_CAPACITY 16

// 3. Type definitions
typedef struct Foo Foo;

// 4. Static function declarations (internal helpers)
static void helper_function(void);

// 5. Public function implementations
void public_api_function(void)
{
    // Implementation
}

// 6. Static function implementations
static void helper_function(void)
{
    // Implementation
}
```

**Archivos de cabecera:**
```c
// Use header guards
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// Forward declarations
typedef struct Value Value;

// Public API only in headers
void public_function(Value *val);

// Document parameters and return values
/**
 * Evaluates an expression AST node
 * @param node - The AST node to evaluate
 * @param env - The current environment
 * @return The result value
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## QuÃ© Contribuir

### Contribuciones Recomendadas

**Correcciones de errores:**
- Fugas de memoria
- Fallos de segmentaciÃ³n
- Comportamiento incorrecto
- Mejoras en mensajes de error

**DocumentaciÃ³n:**
- Comentarios de cÃ³digo
- DocumentaciÃ³n de API
- GuÃ­as de usuario y tutoriales
- Programas de ejemplo
- DocumentaciÃ³n de casos de prueba

**Pruebas:**
- Casos de prueba adicionales para funcionalidades existentes
- Cobertura de casos lÃ­mite
- Pruebas de regresiÃ³n para errores corregidos
- Benchmarks de rendimiento

**Adiciones de funcionalidades pequeÃ±as:**
- Nuevas funciones incorporadas (si encajan con la filosofÃ­a)
- MÃ©todos de string/array
- Funciones utilitarias
- Mejoras en manejo de errores

**Mejoras de rendimiento:**
- Algoritmos mÃ¡s rÃ¡pidos (sin cambiar la semÃ¡ntica)
- ReducciÃ³n del uso de memoria
- Suite de benchmarks
- Herramientas de profiling

**Herramientas:**
- Resaltado de sintaxis para editores
- Protocolo de servidor de lenguaje (LSP)
- IntegraciÃ³n con depurador
- Mejoras del sistema de compilaciÃ³n

### Discutir Primero

**Funcionalidades mayores:**
- Nuevas construcciones del lenguaje
- Cambios en el sistema de tipos
- Adiciones de sintaxis
- Primitivas de concurrencia

**CÃ³mo discutir:**
1. Abre un issue o discusiÃ³n en GitHub
2. Describe la funcionalidad y justificaciÃ³n
3. Muestra cÃ³digo de ejemplo
4. Explica cÃ³mo encaja con la filosofÃ­a de Hemlock
5. Espera retroalimentaciÃ³n de los mantenedores
6. Itera en el diseÃ±o antes de implementar

---

## QuÃ© NO Contribuir

### Contribuciones Desaconsejadas

**No agregues funcionalidades que:**
- Ocultan complejidad al usuario
- Hacen el comportamiento implÃ­cito o mÃ¡gico
- Rompen la semÃ¡ntica o sintaxis existente
- Agregan recolecciÃ³n de basura o gestiÃ³n automÃ¡tica de memoria
- Violan el principio de "explÃ­cito sobre implÃ­cito"

**Ejemplos de contribuciones rechazadas:**

**1. InserciÃ³n automÃ¡tica de punto y coma**
```hemlock
// BAD: This would be rejected
let x = 5  // No semicolon
let y = 10 // No semicolon
```
Por quÃ©: Hace la sintaxis ambigua, oculta errores

**2. RAII/destructores**
```hemlock
// BAD: This would be rejected
let f = open("file.txt");
// File automatically closed at end of scope
```
Por quÃ©: Oculta cuÃ¡ndo se liberan los recursos, no es explÃ­cito

**3. CoerciÃ³n implÃ­cita de tipos que pierde datos**
```hemlock
// BAD: This would be rejected
let x: i32 = 3.14;  // Silently truncates to 3
```
Por quÃ©: La pÃ©rdida de datos debe ser explÃ­cita, no silenciosa

**4. RecolecciÃ³n de basura**
```c
// BAD: This would be rejected
void *gc_malloc(size_t size) {
    // Track allocation for automatic cleanup
}
```
Por quÃ©: Oculta la gestiÃ³n de memoria, rendimiento impredecible

**5. Sistema de macros complejo**
```hemlock
// BAD: This would be rejected
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
Por quÃ©: Demasiada magia, hace el cÃ³digo difÃ­cil de razonar

### Razones Comunes de Rechazo

**"Esto es demasiado implÃ­cito"**
- SoluciÃ³n: Haz el comportamiento explÃ­cito y documÃ©ntalo

**"Esto oculta complejidad"**
- SoluciÃ³n: Expone la complejidad pero hazla ergonÃ³mica

**"Esto rompe cÃ³digo existente"**
- SoluciÃ³n: Encuentra una alternativa no disruptiva o discute versionado

**"Esto no encaja con la filosofÃ­a de Hemlock"**
- SoluciÃ³n: Relee philosophy.md y reconsidera el enfoque

---

## Patrones Comunes

### PatrÃ³n de Manejo de Errores

```c
// Use this pattern for recoverable errors in Hemlock code
Value *divide(Value *a, Value *b)
{
    // Check preconditions
    if (b->type != TYPE_I32) {
        // Return error value or throw exception
        return create_error("Expected integer divisor");
    }

    if (b->i32_value == 0) {
        return create_error("Division by zero");
    }

    // Perform operation
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### PatrÃ³n de GestiÃ³n de Memoria

```c
// Pattern: Allocate, use, free
void process_data(void)
{
    // Allocate
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // Use
    if (buf && str) {
        // ... do work
    }

    // Free (in reverse order of allocation)
    free(str);
    free_buffer(buf);
}
```

### PatrÃ³n de CreaciÃ³n de Valores

```c
// Create values using constructors
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### PatrÃ³n de VerificaciÃ³n de Tipos

```c
// Check types before operations
Value *add_values(Value *a, Value *b)
{
    // Type checking
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("Type mismatch");
    }

    // Safe to proceed
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### PatrÃ³n de ConstrucciÃ³n de Strings

```c
// Build strings efficiently
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Error: %s (line %d)", detail, line_number);
}
```

---

## Agregar Nuevas Funcionalidades

### Lista de VerificaciÃ³n para AdiciÃ³n de Funcionalidades

Cuando agregues una nueva funcionalidad, sigue estos pasos:

#### 1. Fase de DiseÃ±o

- [ ] Lee philosophy.md para asegurar alineaciÃ³n
- [ ] Crea un issue en GitHub describiendo la funcionalidad
- [ ] ObtÃ©n aprobaciÃ³n de los mantenedores para el diseÃ±o
- [ ] Escribe especificaciÃ³n (sintaxis, semÃ¡ntica, ejemplos)
- [ ] Considera casos lÃ­mite y condiciones de error

#### 2. Fase de ImplementaciÃ³n

**Si agregas una construcciÃ³n del lenguaje:**

- [ ] Agrega tipo de token a `lexer.h` (si es necesario)
- [ ] Agrega regla del lexer en `lexer.c` (si es necesario)
- [ ] Agrega tipo de nodo AST en `ast.h`
- [ ] Agrega constructor AST en `ast.c`
- [ ] Agrega regla del parser en `parser.c`
- [ ] Agrega comportamiento en tiempo de ejecuciÃ³n en `runtime.c` o mÃ³dulo apropiado
- [ ] Maneja limpieza en funciones free del AST

**Si agregas una funciÃ³n incorporada:**

- [ ] Agrega implementaciÃ³n de la funciÃ³n en `builtins.c`
- [ ] Registra la funciÃ³n en `register_builtins()`
- [ ] Maneja todas las combinaciones de tipos de parÃ¡metros
- [ ] Retorna valores de error apropiados
- [ ] Documenta parÃ¡metros y tipo de retorno

**Si agregas un tipo de valor:**

- [ ] Agrega enum de tipo en `values.h`
- [ ] Agrega campo a la uniÃ³n Value
- [ ] Agrega constructor en `values.c`
- [ ] Agrega a `value_free()` para limpieza
- [ ] Agrega a `value_copy()` para copiar
- [ ] Agrega a `value_to_string()` para imprimir
- [ ] Agrega reglas de promociÃ³n de tipos si es numÃ©rico

#### 3. Fase de Pruebas

- [ ] Escribe casos de prueba (ver testing.md)
- [ ] Prueba casos exitosos
- [ ] Prueba casos de error
- [ ] Prueba casos lÃ­mite
- [ ] Ejecuta suite completa de pruebas (`make test`)
- [ ] Verifica fugas de memoria con valgrind
- [ ] Prueba en mÃºltiples plataformas (si es posible)

#### 4. Fase de DocumentaciÃ³n

- [ ] Actualiza CLAUDE.md con documentaciÃ³n visible al usuario
- [ ] Agrega comentarios de cÃ³digo explicando la implementaciÃ³n
- [ ] Crea ejemplos en `examples/`
- [ ] Actualiza archivos relevantes en docs/
- [ ] Documenta cualquier cambio incompatible

#### 5. Fase de EnvÃ­o

- [ ] Limpia cÃ³digo de depuraciÃ³n y comentarios
- [ ] Verifica cumplimiento del estilo de cÃ³digo
- [ ] Haz rebase sobre la Ãºltima main
- [ ] Crea pull request con descripciÃ³n detallada
- [ ] Responde a la retroalimentaciÃ³n de revisiÃ³n de cÃ³digo

### Ejemplo: Agregar un Nuevo Operador

Recorramos el proceso de agregar el operador mÃ³dulo `%` como ejemplo:

**1. Lexer (lexer.c):**
```c
// Add to switch statement in get_next_token()
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. Cabecera del Lexer (lexer.h):**
```c
typedef enum {
    // ... existing tokens
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h):**
```c
typedef enum {
    // ... existing operators
    OP_MOD,
    // ...
} BinaryOp;
```

**4. Parser (parser.c):**
```c
// Add to parse_multiplicative() or appropriate precedence level
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. Runtime (runtime.c):**
```c
// Add to eval_binary_op()
case OP_MOD:
    // Type checking
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Error: Modulo by zero\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... handle other type combinations
    break;
```

**6. Pruebas (tests/operators/modulo.hml):**
```hemlock
// Basic modulo
print(10 % 3);  // Expect: 2

// Negative modulo
print(-10 % 3); // Expect: -1

// Error case (should fail)
// print(10 % 0);  // Division by zero
```

**7. DocumentaciÃ³n (CLAUDE.md):**
```markdown
### Arithmetic Operators
- `+` - Addition
- `-` - Subtraction
- `*` - Multiplication
- `/` - Division
- `%` - Modulo (remainder)
```

---

## Proceso de RevisiÃ³n de CÃ³digo

### QuÃ© Buscan los Revisores

**1. CorrecciÃ³n**
- Â¿El cÃ³digo hace lo que dice que hace?
- Â¿Se manejan los casos lÃ­mite?
- Â¿Hay fugas de memoria?
- Â¿Se manejan los errores correctamente?

**2. AlineaciÃ³n con la FilosofÃ­a**
- Â¿Encaja esto con los principios de diseÃ±o de Hemlock?
- Â¿Es explÃ­cito o implÃ­cito?
- Â¿Oculta complejidad?

**3. Calidad de CÃ³digo**
- Â¿Es el cÃ³digo legible y mantenible?
- Â¿Son descriptivos los nombres de variables?
- Â¿Tienen las funciones un tamaÃ±o razonable?
- Â¿Hay documentaciÃ³n adecuada?

**4. Pruebas**
- Â¿Hay suficientes casos de prueba?
- Â¿Las pruebas cubren caminos de Ã©xito y fallo?
- Â¿Se prueban los casos lÃ­mite?

**5. DocumentaciÃ³n**
- Â¿Se actualizÃ³ la documentaciÃ³n visible al usuario?
- Â¿Son claros los comentarios de cÃ³digo?
- Â¿Se proporcionan ejemplos?

### Responder a la RetroalimentaciÃ³n

**SÃ­:**
- Agradece a los revisores por su tiempo
- Haz preguntas aclaratorias si no entiendes
- Explica tu razonamiento si no estÃ¡s de acuerdo
- Haz los cambios solicitados prontamente
- Actualiza la descripciÃ³n del PR si el alcance cambia

**No:**
- Tomes las crÃ­ticas personalmente
- Discutas defensivamente
- Ignores la retroalimentaciÃ³n
- Hagas force-push sobre comentarios de revisiÃ³n (a menos que hagas rebase)
- Agregues cambios no relacionados al PR

### Lograr que tu PR sea Fusionado

**Requisitos para fusiÃ³n:**
- [ ] Todas las pruebas pasan
- [ ] Sin fugas de memoria (valgrind limpio)
- [ ] AprobaciÃ³n de revisiÃ³n de cÃ³digo del mantenedor
- [ ] DocumentaciÃ³n actualizada
- [ ] Sigue las guÃ­as de estilo de cÃ³digo
- [ ] Se alinea con la filosofÃ­a de Hemlock

**Cronograma:**
- PRs pequeÃ±os (correcciones de errores): Usualmente revisados en unos dÃ­as
- PRs medianos (nuevas funcionalidades): Puede tomar 1-2 semanas
- PRs grandes (cambios mayores): Requiere discusiÃ³n extensa

---

## Recursos Adicionales

### Recursos de Aprendizaje

**Entender intÃ©rpretes:**
- "Crafting Interpreters" por Robert Nystrom
- "Writing An Interpreter In Go" por Thorsten Ball
- "Modern Compiler Implementation in C" por Andrew Appel

**ProgramaciÃ³n en C:**
- "The C Programming Language" por K&R
- "Expert C Programming" por Peter van der Linden
- "C Interfaces and Implementations" por David Hanson

**GestiÃ³n de memoria:**
- DocumentaciÃ³n de Valgrind
- "Understanding and Using C Pointers" por Richard Reese

### Comandos Ãštiles

```bash
# Build with debug symbols
make clean && make CFLAGS="-g -O0"

# Run with valgrind
valgrind --leak-check=full ./hemlock script.hml

# Run specific test category
./tests/run_tests.sh tests/strings/

# Generate tags file for code navigation
ctags -R .

# Find all TODOs and FIXMEs
grep -rn "TODO\|FIXME" src/ include/
```

---

## Â¿Preguntas?

Si tienes preguntas sobre contribuir:

1. Revisa la documentaciÃ³n en `docs/`
2. Busca en issues existentes de GitHub
3. Pregunta en GitHub Discussions
4. Abre un nuevo issue con tu pregunta

**Â¡Gracias por contribuir a Hemlock!**


--------------------------------------------------------------------------------
## Pruebas
--------------------------------------------------------------------------------

# GuÃ­a de Pruebas para Hemlock

Esta guÃ­a explica la filosofÃ­a de pruebas de Hemlock, cÃ³mo escribir pruebas y cÃ³mo ejecutar la suite de pruebas.

---

## Tabla de Contenidos

- [FilosofÃ­a de Pruebas](#filosofÃ­a-de-pruebas)
- [Estructura de la Suite de Pruebas](#estructura-de-la-suite-de-pruebas)
- [Ejecutar Pruebas](#ejecutar-pruebas)
- [Escribir Pruebas](#escribir-pruebas)
- [CategorÃ­as de Pruebas](#categorÃ­as-de-pruebas)
- [Pruebas de Fugas de Memoria](#pruebas-de-fugas-de-memoria)
- [IntegraciÃ³n Continua](#integraciÃ³n-continua)
- [Mejores PrÃ¡cticas](#mejores-prÃ¡cticas)

---

## FilosofÃ­a de Pruebas

### Principios Fundamentales

**1. Desarrollo Guiado por Pruebas (TDD)**

Escribe pruebas **antes** de implementar funcionalidades:

```
1. Write a failing test
2. Implement the feature
3. Run the test (should pass)
4. Refactor if needed
5. Repeat
```

**Beneficios:**
- Asegura que las funcionalidades realmente funcionan
- Previene regresiones
- Documenta el comportamiento esperado
- Hace la refactorizaciÃ³n mÃ¡s segura

**2. Cobertura Integral**

Prueba tanto los casos de Ã©xito como los de fallo:

```hemlock
// Success case
let x: u8 = 255;  // Should work

// Failure case
let y: u8 = 256;  // Should error
```

**3. Probar Temprano y Frecuentemente**

Ejecuta las pruebas:
- Antes de hacer commit del cÃ³digo
- DespuÃ©s de hacer cambios
- Antes de enviar pull requests
- Durante la revisiÃ³n de cÃ³digo

**Regla:** Todas las pruebas deben pasar antes de fusionar.

### QuÃ© Probar

**Siempre prueba:**
- Funcionalidad bÃ¡sica (camino feliz)
- Condiciones de error (camino triste)
- Casos lÃ­mite (condiciones de frontera)
- VerificaciÃ³n de tipos y conversiones
- GestiÃ³n de memoria (sin fugas)
- Concurrencia y condiciones de carrera

**Ejemplo de cobertura de pruebas:**
```hemlock
// Feature: String.substr(start, length)

// Happy path
print("hello".substr(0, 5));  // "hello"

// Edge cases
print("hello".substr(0, 0));  // "" (empty)
print("hello".substr(5, 0));  // "" (at end)
print("hello".substr(2, 100)); // "llo" (past end)

// Error cases
// "hello".substr(-1, 5);  // Error: negative index
// "hello".substr(0, -1);  // Error: negative length
```

---

## Estructura de la Suite de Pruebas

### OrganizaciÃ³n de Directorios

```
tests/
â”œâ”€â”€ run_tests.sh          # Main test runner script
â”œâ”€â”€ primitives/           # Type system tests
â”‚   â”œâ”€â”€ integers.hml
â”‚   â”œâ”€â”€ floats.hml
â”‚   â”œâ”€â”€ booleans.hml
â”‚   â”œâ”€â”€ i64.hml
â”‚   â””â”€â”€ u64.hml
â”œâ”€â”€ conversions/          # Type conversion tests
â”‚   â”œâ”€â”€ int_to_float.hml
â”‚   â”œâ”€â”€ promotion.hml
â”‚   â””â”€â”€ rune_conversions.hml
â”œâ”€â”€ memory/               # Pointer/buffer tests
â”‚   â”œâ”€â”€ alloc.hml
â”‚   â”œâ”€â”€ buffer.hml
â”‚   â””â”€â”€ memcpy.hml
â”œâ”€â”€ strings/              # String operation tests
â”‚   â”œâ”€â”€ concat.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ utf8.hml
â”‚   â””â”€â”€ runes.hml
â”œâ”€â”€ control/              # Control flow tests
â”‚   â”œâ”€â”€ if.hml
â”‚   â”œâ”€â”€ switch.hml
â”‚   â””â”€â”€ while.hml
â”œâ”€â”€ functions/            # Function and closure tests
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ closures.hml
â”‚   â””â”€â”€ recursion.hml
â”œâ”€â”€ objects/              # Object tests
â”‚   â”œâ”€â”€ literals.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ duck_typing.hml
â”‚   â””â”€â”€ serialization.hml
â”œâ”€â”€ arrays/               # Array operation tests
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â””â”€â”€ slicing.hml
â”œâ”€â”€ loops/                # Loop tests
â”‚   â”œâ”€â”€ for.hml
â”‚   â”œâ”€â”€ while.hml
â”‚   â”œâ”€â”€ break.hml
â”‚   â””â”€â”€ continue.hml
â”œâ”€â”€ exceptions/           # Error handling tests
â”‚   â”œâ”€â”€ try_catch.hml
â”‚   â”œâ”€â”€ finally.hml
â”‚   â””â”€â”€ throw.hml
â”œâ”€â”€ io/                   # File I/O tests
â”‚   â”œâ”€â”€ file_object.hml
â”‚   â”œâ”€â”€ read_write.hml
â”‚   â””â”€â”€ seek.hml
â”œâ”€â”€ async/                # Concurrency tests
â”‚   â”œâ”€â”€ spawn_join.hml
â”‚   â”œâ”€â”€ channels.hml
â”‚   â””â”€â”€ exceptions.hml
â”œâ”€â”€ ffi/                  # FFI tests
â”‚   â”œâ”€â”€ basic_call.hml
â”‚   â”œâ”€â”€ types.hml
â”‚   â””â”€â”€ dlopen.hml
â”œâ”€â”€ signals/              # Signal handling tests
â”‚   â”œâ”€â”€ basic.hml
â”‚   â”œâ”€â”€ handlers.hml
â”‚   â””â”€â”€ raise.hml
â””â”€â”€ args/                 # Command-line args tests
    â””â”€â”€ basic.hml
```

### Nomenclatura de Archivos de Prueba

**Convenciones:**
- Usa nombres descriptivos: `method_chaining.hml` no `test1.hml`
- Agrupa pruebas relacionadas: `string_substr.hml`, `string_slice.hml`
- Un Ã¡rea de funcionalidad por archivo
- MantÃ©n los archivos enfocados y pequeÃ±os

---

## Ejecutar Pruebas

### Ejecutar Todas las Pruebas

```bash
# From hemlock root directory
make test

# Or directly
./tests/run_tests.sh
```

**Salida:**
```
Running tests in tests/primitives/...
  âœ“ integers.hml
  âœ“ floats.hml
  âœ“ booleans.hml

Running tests in tests/strings/...
  âœ“ concat.hml
  âœ“ methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### Ejecutar CategorÃ­a EspecÃ­fica

```bash
# Run only string tests
./tests/run_tests.sh tests/strings/

# Run only one test file
./tests/run_tests.sh tests/strings/concat.hml

# Run multiple categories
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### Ejecutar con Valgrind (VerificaciÃ³n de Fugas de Memoria)

```bash
# Check single test for leaks
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# Check all tests (slow!)
for test in tests/**/*.hml; do
    echo "Testing $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### Depurar Pruebas Fallidas

```bash
# Run with verbose output
./hemlock tests/failing_test.hml

# Run with gdb
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # if it crashes
```

---

## Escribir Pruebas

### Formato de Archivos de Prueba

Los archivos de prueba son simplemente programas Hemlock con salida esperada:

**Ejemplo: tests/primitives/integers.hml**
```hemlock
// Test basic integer literals
let x = 42;
print(x);  // Expect: 42

let y: i32 = 100;
print(y);  // Expect: 100

// Test arithmetic
let sum = x + y;
print(sum);  // Expect: 142

// Test type inference
let small = 10;
print(typeof(small));  // Expect: i32

let large = 5000000000;
print(typeof(large));  // Expect: i64
```

**CÃ³mo funcionan las pruebas:**
1. El ejecutor de pruebas ejecuta el archivo .hml
2. Captura la salida stdout
3. Compara con la salida esperada (de comentarios o archivo .out separado)
4. Reporta Ã©xito/fallo

### MÃ©todos de Salida Esperada

**MÃ©todo 1: Comentarios en lÃ­nea (recomendado para pruebas simples)**

```hemlock
print("hello");  // Expect: hello
print(42);       // Expect: 42
```

El ejecutor de pruebas analiza los comentarios `// Expect: ...`.

**MÃ©todo 2: Archivo .out separado**

Crea `test_name.hml.out` con la salida esperada:

**test_name.hml:**
```hemlock
print("line 1");
print("line 2");
print("line 3");
```

**test_name.hml.out:**
```
line 1
line 2
line 3
```

### Probar Casos de Error

Las pruebas de error deben hacer que el programa termine con estado distinto de cero:

**Ejemplo: tests/primitives/range_error.hml**
```hemlock
// This should fail with a type error
let x: u8 = 256;  // Out of range for u8
```

**Comportamiento esperado:**
- El programa termina con estado distinto de cero
- Imprime mensaje de error a stderr

**Manejo del ejecutor de pruebas:**
- Las pruebas que esperan errores deben estar en archivos separados
- Usa convenciÃ³n de nombres: `*_error.hml` o `*_fail.hml`
- Documenta el error esperado en comentarios

### Probar Casos de Ã‰xito

**Ejemplo: tests/strings/methods.hml**
```hemlock
// Test substr
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // Expect: world

// Test find
let pos = s.find("world");
print(pos);  // Expect: 6

// Test contains
let has = s.contains("lo");
print(has);  // Expect: true

// Test trim
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // Expect: hello
```

### Probar Casos LÃ­mite

**Ejemplo: tests/arrays/edge_cases.hml**
```hemlock
// Empty array
let empty = [];
print(empty.length);  // Expect: 0

// Single element
let single = [42];
print(single[0]);  // Expect: 42

// Negative index (should error in separate test file)
// print(single[-1]);  // Error

// Past-end index (should error)
// print(single[100]);  // Error

// Boundary conditions
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // Expect: [] (empty)
print(arr.slice(3, 3));  // Expect: [] (empty)
print(arr.slice(1, 2));  // Expect: [2]
```

### Probar Sistema de Tipos

**Ejemplo: tests/conversions/promotion.hml**
```hemlock
// Test type promotion in binary operations

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // Expect: i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // Expect: f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // Expect: i32
```

### Probar Concurrencia

**Ejemplo: tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Spawn tasks
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// Join and print results
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // Expect: 45
print(r2);  // Expect: 190
```

### Probar Excepciones

**Ejemplo: tests/exceptions/try_catch.hml**
```hemlock
// Test basic try/catch
try {
    throw "error message";
} catch (e) {
    print("Caught: " + e);  // Expect: Caught: error message
}

// Test finally
let executed = false;
try {
    print("try");  // Expect: try
} finally {
    executed = true;
    print("finally");  // Expect: finally
}

// Test exception propagation
fn risky(): i32 {
    throw "failure";
}

try {
    risky();
} catch (e) {
    print(e);  // Expect: failure
}
```

---

## CategorÃ­as de Pruebas

### Pruebas de Primitivos

**QuÃ© probar:**
- Tipos enteros (i8, i16, i32, i64, u8, u16, u32, u64)
- Tipos de punto flotante (f32, f64)
- Tipo booleano
- Tipo string
- Tipo rune
- Tipo null

**Ãreas de ejemplo:**
- Sintaxis de literales
- Inferencia de tipos
- VerificaciÃ³n de rangos
- Comportamiento de desbordamiento
- Anotaciones de tipo

### Pruebas de ConversiÃ³n

**QuÃ© probar:**
- PromociÃ³n implÃ­cita de tipos
- ConversiÃ³n explÃ­cita de tipos
- Conversiones con pÃ©rdida (deben dar error)
- PromociÃ³n de tipos en operaciones
- Comparaciones entre tipos

### Pruebas de Memoria

**QuÃ© probar:**
- CorrecciÃ³n de alloc/free
- CreaciÃ³n y acceso a Buffer
- VerificaciÃ³n de lÃ­mites en buffers
- memset, memcpy, realloc
- DetecciÃ³n de fugas de memoria (valgrind)

### Pruebas de Strings

**QuÃ© probar:**
- ConcatenaciÃ³n
- Los 18 mÃ©todos de string
- Manejo de UTF-8
- IndexaciÃ³n de runes
- ConcatenaciÃ³n de string + rune
- Casos lÃ­mite (strings vacÃ­os, un solo carÃ¡cter, etc.)

### Pruebas de Flujo de Control

**QuÃ© probar:**
- if/else/else if
- Bucles while
- Bucles for
- Sentencias switch
- break/continue
- Sentencias return

### Pruebas de Funciones

**QuÃ© probar:**
- DefiniciÃ³n y llamada de funciones
- Paso de parÃ¡metros
- Valores de retorno
- RecursiÃ³n
- Closures y captura
- Funciones de primera clase
- Funciones anÃ³nimas

### Pruebas de Objetos

**QuÃ© probar:**
- Literales de objeto
- Acceso y asignaciÃ³n de campos
- MÃ©todos y binding de self
- Duck typing
- Campos opcionales
- SerializaciÃ³n/deserializaciÃ³n JSON
- DetecciÃ³n de referencias circulares

### Pruebas de Arrays

**QuÃ© probar:**
- CreaciÃ³n de arrays
- IndexaciÃ³n y asignaciÃ³n
- Los 15 mÃ©todos de array
- Tipos mezclados
- Redimensionamiento dinÃ¡mico
- Casos lÃ­mite (vacÃ­o, un solo elemento)

### Pruebas de Excepciones

**QuÃ© probar:**
- try/catch/finally
- Sentencia throw
- PropagaciÃ³n de excepciones
- try/catch anidados
- Return en try/catch/finally
- Excepciones no capturadas

### Pruebas de E/S

**QuÃ© probar:**
- Modos de apertura de archivos
- Operaciones de lectura/escritura
- Seek/tell
- Propiedades de archivos
- Manejo de errores (archivos faltantes, etc.)
- Limpieza de recursos

### Pruebas AsÃ­ncronas

**QuÃ© probar:**
- spawn/join/detach
- send/recv de Channel
- PropagaciÃ³n de excepciones en tareas
- MÃºltiples tareas concurrentes
- Comportamiento de bloqueo de canales

### Pruebas de FFI

**QuÃ© probar:**
- dlopen/dlclose
- dlsym
- dlcall con varios tipos
- ConversiÃ³n de tipos
- Manejo de errores

---

## Pruebas de Fugas de Memoria

### Usar Valgrind

**Uso bÃ¡sico:**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**Ejemplo de salida (sin fugas):**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**Ejemplo de salida (con fuga):**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### Fuentes Comunes de Fugas

**1. Llamadas free() faltantes:**
```c
// BAD
char *str = malloc(100);
// ... use str
// Forgot to free!

// GOOD
char *str = malloc(100);
// ... use str
free(str);
```

**2. Punteros perdidos:**
```c
// BAD
char *ptr = malloc(100);
ptr = malloc(200);  // Lost reference to first allocation!

// GOOD
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. Caminos de excepciÃ³n:**
```c
// BAD
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // Leak!
    }
    free(data);
}

// GOOD
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### Fugas Aceptables Conocidas

Algunas pequeÃ±as "fugas" son asignaciones intencionales de inicio:

**Funciones incorporadas globales:**
```hemlock
// Built-in functions, FFI types, and constants are allocated at startup
// and not freed at exit (typically ~200 bytes)
```

Estas no son fugas verdaderas - son asignaciones Ãºnicas que persisten durante la vida del programa y son limpiadas por el SO al salir.

---

## IntegraciÃ³n Continua

### GitHub Actions (Futuro)

Una vez que el CI estÃ© configurado, todas las pruebas se ejecutarÃ¡n automÃ¡ticamente en:
- Push a la rama main
- CreaciÃ³n/actualizaciÃ³n de pull request
- Ejecuciones programadas diarias

**Flujo de trabajo de CI:**
1. Compilar Hemlock
2. Ejecutar suite de pruebas
3. Verificar fugas de memoria (valgrind)
4. Reportar resultados en el PR

### Verificaciones Pre-Commit

Antes de hacer commit, ejecuta:

```bash
# Build fresh
make clean && make

# Run all tests
make test

# Check a few tests for leaks
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## Mejores PrÃ¡cticas

### Hacer

**Escribe pruebas primero (TDD)**
```bash
1. Create tests/feature/new_feature.hml
2. Implement feature in src/
3. Run tests until they pass
```

**Prueba tanto Ã©xito como fallo**
```hemlock
// Success: tests/feature/success.hml
let result = do_thing();
print(result);  // Expect: expected value

// Failure: tests/feature/failure.hml
do_invalid_thing();  // Should error
```

**Usa nombres de prueba descriptivos**
```
Good: tests/strings/substr_utf8_boundary.hml
Bad:  tests/test1.hml
```

**MantÃ©n las pruebas enfocadas**
- Un Ã¡rea de funcionalidad por archivo
- ConfiguraciÃ³n y aserciones claras
- CÃ³digo mÃ­nimo

**Agrega comentarios explicando pruebas complicadas**
```hemlock
// Test that closure captures outer variable by reference
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // Modify after closure creation
    return f();  // Should return 20, not 10
}
```

**Prueba casos lÃ­mite**
- Entradas vacÃ­as
- Valores null
- Valores de frontera (min/max)
- Entradas grandes
- Valores negativos

### No Hacer

**No omitas pruebas**
- Todas las pruebas deben pasar antes de fusionar
- No comentes pruebas que fallan
- Arregla el error o elimina la funcionalidad

**No escribas pruebas que dependan unas de otras**
```hemlock
// BAD: test2.hml depends on test1.hml output
// Tests should be independent
```

**No uses valores aleatorios en pruebas**
```hemlock
// BAD: Non-deterministic
let x = random();
print(x);  // Can't predict output

// GOOD: Deterministic
let x = 42;
print(x);  // Expect: 42
```

**No pruebes detalles de implementaciÃ³n**
```hemlock
// BAD: Testing internal structure
let obj = { x: 10 };
// Don't check internal field order, capacity, etc.

// GOOD: Testing behavior
print(obj.x);  // Expect: 10
```

**No ignores fugas de memoria**
- Todas las pruebas deben pasar valgrind sin errores
- Documenta fugas conocidas/aceptables
- Arregla las fugas antes de fusionar

### Mantenimiento de Pruebas

**CuÃ¡ndo actualizar pruebas:**
- El comportamiento de la funcionalidad cambia
- Las correcciones de errores requieren nuevos casos de prueba
- Se descubren casos lÃ­mite
- Mejoras de rendimiento

**CuÃ¡ndo eliminar pruebas:**
- La funcionalidad se elimina del lenguaje
- La prueba duplica cobertura existente
- La prueba era incorrecta

**Refactorizar pruebas:**
- Agrupa pruebas relacionadas
- Extrae cÃ³digo de configuraciÃ³n comÃºn
- Usa nombres consistentes
- MantÃ©n las pruebas simples y legibles

---

## SesiÃ³n de Prueba de Ejemplo

AquÃ­ hay un ejemplo completo de agregar una funcionalidad con pruebas:

### Funcionalidad: Agregar mÃ©todo `array.first()`

**1. Escribe la prueba primero:**

```bash
# Create test file
cat > tests/arrays/first_method.hml << 'EOF'
// Test array.first() method

// Basic case
let arr = [1, 2, 3];
print(arr.first());  // Expect: 1

// Single element
let single = [42];
print(single.first());  // Expect: 42

// Empty array (should error - separate test file)
// let empty = [];
// print(empty.first());  // Error
EOF
```

**2. Ejecuta la prueba (debe fallar):**

```bash
./hemlock tests/arrays/first_method.hml
# Error: Method 'first' not found on array
```

**3. Implementa la funcionalidad:**

Edita `src/interpreter/builtins.c`:

```c
// Add array_first method
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Error: Cannot get first element of empty array\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// Register in array method table
// ... add to array method registration
```

**4. Ejecuta la prueba (debe pasar):**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# Success!
```

**5. Verifica fugas de memoria:**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. Ejecuta la suite completa de pruebas:**

```bash
make test
# Total: 252 tests (251 + new one)
# Passed: 252
# Failed: 0
```

**7. Commit:**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "Add array.first() method with tests"
```

---

## Resumen

**Recuerda:**
- Escribe pruebas primero (TDD)
- Prueba casos de Ã©xito y fallo
- Ejecuta todas las pruebas antes de hacer commit
- Verifica fugas de memoria
- Documenta problemas conocidos
- MantÃ©n las pruebas simples y enfocadas

**Â¡La calidad de las pruebas es tan importante como la calidad del cÃ³digo!**



################################################################################
# HPM: PRIMEROS PASOS
################################################################################

--------------------------------------------------------------------------------
## ConfiguraciÃ³n del Proyecto
--------------------------------------------------------------------------------

# Configuracion del Proyecto

Guia completa para configurar proyectos Hemlock con hpm.

## Iniciar un Nuevo Proyecto

### Configuracion Basica

Crea un nuevo proyecto desde cero:

```bash
# Crear directorio del proyecto
mkdir my-project
cd my-project

# Inicializar package.json
hpm init

# Crear estructura de directorios
mkdir -p src test
```

### Plantillas de Proyecto

Aqui hay estructuras de proyecto comunes para diferentes casos de uso:

#### Paquete de Biblioteca

Para bibliotecas reutilizables:

```
my-library/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml          # Entrada principal, exporta API publica
â”‚   â”œâ”€â”€ core.hml           # Funcionalidad principal
â”‚   â”œâ”€â”€ utils.hml          # Funciones utilitarias
â”‚   â””â”€â”€ types.hml          # Definiciones de tipos
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml      # Framework de pruebas
    â”œâ”€â”€ run.hml            # Ejecutor de pruebas
    â””â”€â”€ test_core.hml      # Pruebas
```

**package.json:**

```json
{
  "name": "yourusername/my-library",
  "version": "1.0.0",
  "description": "A reusable Hemlock library",
  "main": "src/index.hml",
  "scripts": {
    "test": "hemlock test/run.hml"
  },
  "dependencies": {},
  "devDependencies": {}
}
```

#### Aplicacion

Para aplicaciones independientes:

```
my-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Punto de entrada de la aplicacion
â”‚   â”œâ”€â”€ config.hml         # Configuracion
â”‚   â”œâ”€â”€ commands/          # Comandos CLI
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ run.hml
â”‚   â””â”€â”€ lib/               # Bibliotecas internas
â”‚       â””â”€â”€ utils.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â””â”€â”€ data/                  # Archivos de datos
```

**package.json:**

```json
{
  "name": "yourusername/my-app",
  "version": "1.0.0",
  "description": "A Hemlock application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {}
}
```

#### Aplicacion Web

Para servidores web:

```
my-web-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Punto de entrada del servidor
â”‚   â”œâ”€â”€ routes/            # Manejadores de rutas
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â”œâ”€â”€ api.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ middleware/        # Middleware
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ models/            # Modelos de datos
â”‚   â”‚   â””â”€â”€ user.hml
â”‚   â””â”€â”€ services/          # Logica de negocio
â”‚       â””â”€â”€ user.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â”œâ”€â”€ static/                # Archivos estaticos
â”‚   â”œâ”€â”€ css/
â”‚   â””â”€â”€ js/
â””â”€â”€ views/                 # Plantillas
    â””â”€â”€ index.hml
```

**package.json:**

```json
{
  "name": "yourusername/my-web-app",
  "version": "1.0.0",
  "description": "A Hemlock web application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml"
  },
  "dependencies": {
    "hemlang/sprout": "^2.0.0",
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  }
}
```

## El Archivo package.json

### Campos Requeridos

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

### Todos los Campos

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "Package description",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "homepage": "https://yourusername.github.io/my-package",
  "bugs": "https://github.com/yourusername/my-package/issues",
  "main": "src/index.hml",
  "keywords": ["utility", "parser"],
  "dependencies": {
    "owner/package": "^1.0.0"
  },
  "devDependencies": {
    "owner/test-lib": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

### Referencia de Campos

| Campo | Tipo | Descripcion |
|-------|------|-------------|
| `name` | string | Nombre del paquete en formato owner/repo (requerido) |
| `version` | string | Version semantica (requerido) |
| `description` | string | Descripcion corta |
| `author` | string | Nombre y email del autor |
| `license` | string | Identificador de licencia (MIT, Apache-2.0, etc.) |
| `repository` | string | URL del repositorio |
| `homepage` | string | Pagina principal del proyecto |
| `bugs` | string | URL del rastreador de problemas |
| `main` | string | Archivo de punto de entrada (por defecto: src/index.hml) |
| `keywords` | array | Palabras clave de busqueda |
| `dependencies` | object | Dependencias de tiempo de ejecucion |
| `devDependencies` | object | Dependencias de desarrollo |
| `scripts` | object | Scripts con nombre |
| `files` | array | Archivos a incluir al publicar |
| `native` | object | Requisitos de bibliotecas nativas |

## El Archivo package-lock.json

El archivo de bloqueo se genera automaticamente y debe incluirse en el control de versiones. Asegura instalaciones reproducibles.

```json
{
  "lockVersion": 1,
  "hemlock": "1.0.0",
  "dependencies": {
    "hemlang/sprout": {
      "version": "2.1.0",
      "resolved": "https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz",
      "integrity": "sha256-abc123...",
      "dependencies": {
        "hemlang/router": "^1.5.0"
      }
    },
    "hemlang/router": {
      "version": "1.5.0",
      "resolved": "https://github.com/hemlang/router/archive/v1.5.0.tar.gz",
      "integrity": "sha256-def456...",
      "dependencies": {}
    }
  }
}
```

### Mejores Practicas del Archivo de Bloqueo

- **Incluye** package-lock.json en el control de versiones
- **No edites** manualmente - se genera automaticamente
- **Ejecuta `hpm install`** despues de hacer pull de cambios
- **Elimina y regenera** si esta corrupto:
  ```bash
  rm package-lock.json
  hpm install
  ```

## El Directorio hem_modules

Los paquetes instalados se almacenan en `hem_modules/`:

```
hem_modules/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ src/
â”‚   â””â”€â”€ router/
â”‚       â”œâ”€â”€ package.json
â”‚       â””â”€â”€ src/
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â”œâ”€â”€ package.json
        â””â”€â”€ src/
```

### Mejores Practicas de hem_modules

- **Agregar a .gitignore** - no incluir dependencias en commits
- **No modificar** - los cambios se sobrescribiran
- **Eliminar para reinstalar desde cero**:
  ```bash
  rm -rf hem_modules
  hpm install
  ```

## .gitignore

.gitignore recomendado para proyectos Hemlock:

```gitignore
# Dependencies
hem_modules/

# Build output
dist/
*.hmlc

# IDE files
.idea/
.vscode/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Environment
.env
.env.local

# Test coverage
coverage/
```

## Trabajar con Dependencias

### Agregar Dependencias

```bash
# Agregar dependencia de tiempo de ejecucion
hpm install hemlang/json

# Agregar con restriccion de version
hpm install hemlang/sprout@^2.0.0

# Agregar dependencia de desarrollo
hpm install hemlang/test-utils --dev
```

### Importar Dependencias

```hemlock
// Import from package (uses "main" entry)
import { parse, stringify } from "hemlang/json";

// Import from subpath
import { Router } from "hemlang/sprout/router";

// Import standard library
import { HashMap } from "@stdlib/collections";
import { readFile, writeFile } from "@stdlib/fs";
```

### Resolucion de Importaciones

hpm resuelve importaciones en este orden:

1. **Biblioteca estandar**: importaciones `@stdlib/*` cargan modulos integrados
2. **Raiz del paquete**: `owner/repo` usa el campo `main`
3. **Subruta**: `owner/repo/path` verifica:
   - `hem_modules/owner/repo/path.hml`
   - `hem_modules/owner/repo/path/index.hml`
   - `hem_modules/owner/repo/src/path.hml`
   - `hem_modules/owner/repo/src/path/index.hml`

## Scripts

### Definir Scripts

Agrega scripts a package.json:

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

### Ejecutar Scripts

```bash
hpm run start
hpm run dev
hpm run build

# Atajo para test
hpm test

# Pasar argumentos
hpm run test -- --verbose --filter=unit
```

### Convenciones de Nombres de Scripts

| Script | Proposito |
|--------|-----------|
| `start` | Ejecutar la aplicacion |
| `dev` | Ejecutar en modo desarrollo |
| `test` | Ejecutar todas las pruebas |
| `build` | Compilar para produccion |
| `clean` | Eliminar archivos generados |
| `lint` | Verificar estilo de codigo |
| `format` | Formatear codigo |

## Flujo de Trabajo de Desarrollo

### Configuracion Inicial

```bash
# Clonar proyecto
git clone https://github.com/yourusername/my-project.git
cd my-project

# Instalar dependencias
hpm install

# Ejecutar pruebas
hpm test

# Iniciar desarrollo
hpm run dev
```

### Flujo de Trabajo Diario

```bash
# Obtener ultimos cambios
git pull

# Instalar cualquier nueva dependencia
hpm install

# Hacer cambios...

# Ejecutar pruebas
hpm test

# Commit
git add .
git commit -m "Add feature"
git push
```

### Agregar una Nueva Caracteristica

```bash
# Crear rama de caracteristica
git checkout -b feature/new-feature

# Agregar nueva dependencia si es necesario
hpm install hemlang/new-lib

# Implementar caracteristica...

# Probar
hpm test

# Commit y push
git add .
git commit -m "Add new feature"
git push -u origin feature/new-feature
```

## Configuracion Especifica del Entorno

### Usar Variables de Entorno

```hemlock
import { getenv } from "@stdlib/env";

let db_host = getenv("DATABASE_HOST") ?? "localhost";
let api_key = getenv("API_KEY") ?? "";

if api_key == "" {
    print("Warning: API_KEY not set");
}
```

### Archivo de Configuracion

**config.hml:**

```hemlock
import { getenv } from "@stdlib/env";

export let config = {
    environment: getenv("HEMLOCK_ENV") ?? "development",
    database: {
        host: getenv("DB_HOST") ?? "localhost",
        port: int(getenv("DB_PORT") ?? "5432"),
        name: getenv("DB_NAME") ?? "myapp"
    },
    server: {
        port: int(getenv("PORT") ?? "3000"),
        host: getenv("HOST") ?? "0.0.0.0"
    }
};

export fn is_production(): bool {
    return config.environment == "production";
}
```

## Ver Tambien

- [Inicio Rapido](#hpm-project-setup-quick-start) - Comenzar rapidamente
- [Comandos](#hpm-project-setup-commands) - Referencia de comandos
- [Creacion de Paquetes](#hpm-project-setup-creating-packages) - Publicar paquetes
- [Configuracion](#hpm-project-setup-configuration) - Configuracion de hpm


--------------------------------------------------------------------------------
## Inicio RÃ¡pido
--------------------------------------------------------------------------------

# Inicio Rapido

Comienza a trabajar con hpm en 5 minutos.

## Instalar hpm

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Para mas opciones de instalacion, consulta la [Guia de Instalacion](#hpm-quick-start-installation).

## Crear un Nuevo Proyecto

Comienza creando un nuevo directorio e inicializando un paquete:

```bash
mkdir my-project
cd my-project
hpm init
```

Se te solicitaran los detalles del proyecto:

```
Package name (owner/repo): myname/my-project
Version (1.0.0):
Description: My awesome Hemlock project
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

Usa `--yes` para aceptar todos los valores por defecto:

```bash
hpm init --yes
```

## Estructura del Proyecto

Crea la estructura basica del proyecto:

```
my-project/
â”œâ”€â”€ package.json        # Manifiesto del proyecto
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml      # Punto de entrada principal
â””â”€â”€ test/
    â””â”€â”€ test.hml       # Pruebas
```

Crea tu archivo principal:

```bash
mkdir -p src test
```

**src/index.hml:**
```hemlock
// Main entry point
export fn greet(name: string): string {
    return "Hello, " + name + "!";
}

export fn main() {
    print(greet("World"));
}
```

## Instalar Dependencias

Busca paquetes en GitHub (los paquetes usan el formato `owner/repo`):

```bash
# Instalar un paquete
hpm install hemlang/sprout

# Instalar con restriccion de version
hpm install hemlang/json@^1.0.0

# Instalar como dependencia de desarrollo
hpm install hemlang/test-utils --dev
```

Despues de la instalacion, la estructura de tu proyecto incluye `hem_modules/`:

```
my-project/
â”œâ”€â”€ package.json
â”œâ”€â”€ package-lock.json   # Archivo de bloqueo (auto-generado)
â”œâ”€â”€ hem_modules/        # Paquetes instalados
â”‚   â””â”€â”€ hemlang/
â”‚       â””â”€â”€ sprout/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml
â””â”€â”€ test/
    â””â”€â”€ test.hml
```

## Usar Paquetes Instalados

Importa paquetes usando su ruta de GitHub:

```hemlock
// Import from installed package
import { app, router } from "hemlang/sprout";
import { parse, stringify } from "hemlang/json";

// Import from subpath
import { middleware } from "hemlang/sprout/middleware";

// Standard library (built-in)
import { HashMap } from "@stdlib/collections";
import { readFile } from "@stdlib/fs";
```

## Agregar Scripts

Agrega scripts a tu `package.json`:

```json
{
  "name": "myname/my-project",
  "version": "1.0.0",
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/test.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Ejecuta scripts con `hpm run`:

```bash
hpm run start
hpm run build

# Atajo para test
hpm test
```

## Flujos de Trabajo Comunes

### Instalar Todas las Dependencias

Cuando clonas un proyecto con un `package.json`:

```bash
git clone https://github.com/someone/project.git
cd project
hpm install
```

### Actualizar Dependencias

Actualiza todos los paquetes a las ultimas versiones dentro de las restricciones:

```bash
hpm update
```

Actualiza un paquete especifico:

```bash
hpm update hemlang/sprout
```

### Ver Paquetes Instalados

Lista todos los paquetes instalados:

```bash
hpm list
```

La salida muestra el arbol de dependencias:

```
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â””â”€â”€ hemlang/router@1.5.0
â””â”€â”€ hemlang/json@1.2.3
```

### Verificar Actualizaciones

Ve que paquetes tienen versiones mas nuevas:

```bash
hpm outdated
```

### Eliminar un Paquete

```bash
hpm uninstall hemlang/sprout
```

## Ejemplo: Aplicacion Web

Aqui hay un ejemplo completo usando un framework web:

**package.json:**
```json
{
  "name": "myname/my-web-app",
  "version": "1.0.0",
  "description": "A web application",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/sprout": "^2.0.0"
  },
  "scripts": {
    "start": "hemlock src/index.hml",
    "dev": "hemlock --watch src/index.hml"
  }
}
```

**src/index.hml:**
```hemlock
import { App, Router } from "hemlang/sprout";

fn main() {
    let app = App.new();
    let router = Router.new();

    router.get("/", fn(req, res) {
        res.send("Hello, World!");
    });

    router.get("/api/status", fn(req, res) {
        res.json({ status: "ok" });
    });

    app.use(router);
    app.listen(3000);

    print("Server running on http://localhost:3000");
}
```

Ejecuta la aplicacion:

```bash
hpm install
hpm run start
```

## Proximos Pasos

- [Referencia de Comandos](#hpm-quick-start-commands) - Aprende todos los comandos de hpm
- [Creacion de Paquetes](#hpm-quick-start-creating-packages) - Publica tus propios paquetes
- [Configuracion](#hpm-quick-start-configuration) - Configura hpm y tokens de GitHub
- [Configuracion del Proyecto](#hpm-quick-start-project-setup) - Configuracion detallada del proyecto


--------------------------------------------------------------------------------
## InstalaciÃ³n
--------------------------------------------------------------------------------

# Instalacion

Esta guia cubre como instalar hpm en tu sistema.

## Instalacion Rapida (Recomendada)

Instala la ultima version con un solo comando:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Esto automaticamente:
- Detecta tu sistema operativo (Linux, macOS)
- Detecta tu arquitectura (x86_64, arm64)
- Descarga el binario precompilado apropiado
- Instala en `/usr/local/bin` (o usa sudo si es necesario)

### Opciones de Instalacion

```bash
# Instalar en una ubicacion personalizada (no requiere sudo)
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local

# Instalar una version especifica
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5

# Combinar opciones
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5
```

### Plataformas Soportadas

| Plataforma | Arquitectura | Estado |
|------------|--------------|--------|
| Linux    | x86_64       | âœ“ Soportado |
| macOS    | x86_64       | âœ“ Soportado |
| macOS    | arm64 (M1/M2/M3) | âœ“ Soportado |
| Linux    | arm64        | Compilar desde fuente |

## Compilar desde Fuente

Si prefieres compilar desde fuente o necesitas una plataforma no cubierta por los binarios precompilados, sigue estas instrucciones.

### Prerrequisitos

hpm requiere que [Hemlock](https://github.com/hemlang/hemlock) este instalado primero. Sigue las instrucciones de instalacion de Hemlock antes de continuar.

Verifica que Hemlock este instalado:

```bash
hemlock --version
```

## Metodos de Instalacion

### Metodo 1: Make Install

Compila desde fuente e instala.

```bash
# Clonar el repositorio
git clone https://github.com/hemlang/hpm.git
cd hpm

# Instalar en /usr/local/bin (requiere sudo)
sudo make install
```

Despues de la instalacion, verifica que funcione:

```bash
hpm --version
```

### Metodo 2: Ubicacion Personalizada

Instala en un directorio personalizado (no requiere sudo):

```bash
# Clonar el repositorio
git clone https://github.com/hemlang/hpm.git
cd hpm

# Instalar en ~/.local/bin
make install PREFIX=$HOME/.local

# O cualquier ubicacion personalizada
make install PREFIX=/opt/hemlock
```

Asegurate de que tu directorio bin personalizado este en tu PATH:

```bash
# Agregar a ~/.bashrc o ~/.zshrc
export PATH="$HOME/.local/bin:$PATH"
```

### Metodo 3: Ejecutar Sin Instalar

Puedes ejecutar hpm directamente sin instalar:

```bash
# Clonar el repositorio
git clone https://github.com/hemlang/hpm.git
cd hpm

# Crear script wrapper local
make

# Ejecutar desde el directorio hpm
./hpm --help

# O ejecutar via hemlock directamente
hemlock src/main.hml --help
```

### Metodo 4: Instalacion Manual

Crea tu propio script wrapper:

```bash
# Clonar en una ubicacion permanente
git clone https://github.com/hemlang/hpm.git ~/.hpm-source

# Crear script wrapper
cat > ~/.local/bin/hpm << 'EOF'
#!/bin/sh
exec hemlock "$HOME/.hpm-source/src/main.hml" "$@"
EOF

chmod +x ~/.local/bin/hpm
```

## Variables de Instalacion

El Makefile soporta estas variables:

| Variable | Por Defecto | Descripcion |
|----------|-------------|-------------|
| `PREFIX` | `/usr/local` | Prefijo de instalacion |
| `BINDIR` | `$(PREFIX)/bin` | Directorio de binarios |
| `HEMLOCK` | `hemlock` | Ruta al interprete hemlock |

Ejemplo con variables personalizadas:

```bash
make install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock
```

## Como Funciona

El instalador crea un script shell wrapper que invoca el interprete Hemlock con el codigo fuente de hpm:

```bash
#!/bin/sh
exec hemlock "/path/to/hpm/src/main.hml" "$@"
```

Este enfoque:
- No requiere compilacion
- Siempre ejecuta el ultimo codigo fuente
- Funciona de manera confiable en todas las plataformas

## Actualizar hpm

Para actualizar hpm a la ultima version:

```bash
cd /path/to/hpm
git pull origin main

# Re-instalar si la ruta cambio
sudo make install
```

## Desinstalar

Eliminar hpm de tu sistema:

```bash
cd /path/to/hpm
sudo make uninstall
```

O eliminar manualmente:

```bash
sudo rm /usr/local/bin/hpm
```

## Verificar la Instalacion

Despues de la instalacion, verifica que todo funcione:

```bash
# Verificar version
hpm --version

# Ver ayuda
hpm --help

# Probar inicializacion (en un directorio vacio)
mkdir test-project && cd test-project
hpm init --yes
cat package.json
```

## Solucion de Problemas

### "hemlock: command not found"

Hemlock no esta instalado o no esta en tu PATH. Instala Hemlock primero:

```bash
# Verificar si hemlock existe
which hemlock

# Si no se encuentra, instalar Hemlock desde https://github.com/hemlang/hemlock
```

### "Permission denied"

Usa sudo para instalacion en todo el sistema, o instala en un directorio de usuario:

```bash
# Opcion 1: Usar sudo
sudo make install

# Opcion 2: Instalar en directorio de usuario
make install PREFIX=$HOME/.local
```

### "hpm: command not found" despues de la instalacion

Tu PATH puede no incluir el directorio de instalacion:

```bash
# Verificar donde se instalo hpm
ls -la /usr/local/bin/hpm

# Agregar al PATH si usas ubicacion personalizada
export PATH="$HOME/.local/bin:$PATH"
```

## Notas Especificas por Plataforma

### Linux

La instalacion estandar funciona en todas las distribuciones de Linux. Algunas distribuciones pueden requerir:

```bash
# Debian/Ubuntu: Asegurar herramientas de compilacion
sudo apt-get install build-essential git

# Fedora/RHEL
sudo dnf install make git
```

### macOS

La instalacion estandar funciona. Si usas Homebrew:

```bash
# Asegurar herramientas de linea de comandos de Xcode
xcode-select --install
```

### Windows (WSL)

hpm funciona en Windows Subsystem for Linux:

```bash
# En terminal WSL
git clone https://github.com/hemlang/hpm.git
cd hpm
make install PREFIX=$HOME/.local
```

## Proximos Pasos

Despues de la instalacion:

1. [Inicio Rapido](#hpm-installation-quick-start) - Crea tu primer proyecto
2. [Referencia de Comandos](#hpm-installation-commands) - Aprende todos los comandos
3. [Configuracion](#hpm-installation-configuration) - Configura hpm



################################################################################
# HPM: GUÃA DEL USUARIO
################################################################################

--------------------------------------------------------------------------------
## Comandos
--------------------------------------------------------------------------------

# Referencia de Comandos

Referencia completa de todos los comandos de hpm.

## Opciones Globales

Estas opciones funcionan con cualquier comando:

| Opcion | Descripcion |
|--------|-------------|
| `--help`, `-h` | Mostrar mensaje de ayuda |
| `--version`, `-v` | Mostrar version de hpm |
| `--verbose` | Mostrar salida detallada |

## Comandos

### hpm init

Crea un nuevo archivo `package.json`.

```bash
hpm init        # Modo interactivo
hpm init --yes  # Aceptar todos los valores por defecto
hpm init -y     # Forma corta
```

**Opciones:**

| Opcion | Descripcion |
|--------|-------------|
| `--yes`, `-y` | Aceptar valores por defecto para todas las preguntas |

**Preguntas interactivas:**
- Nombre del paquete (formato owner/repo)
- Version (por defecto: 1.0.0)
- Descripcion
- Autor
- Licencia (por defecto: MIT)
- Archivo principal (por defecto: src/index.hml)

**Ejemplo:**

```bash
$ hpm init
Package name (owner/repo): alice/my-lib
Version (1.0.0):
Description: A utility library
Author: Alice <alice@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

---

### hpm install

Instala dependencias o agrega nuevos paquetes.

```bash
hpm install                           # Instalar todo desde package.json
hpm install owner/repo                # Agregar e instalar paquete
hpm install owner/repo@^1.0.0        # Con restriccion de version
hpm install owner/repo --dev         # Como dependencia de desarrollo
hpm i owner/repo                      # Forma corta
```

**Opciones:**

| Opcion | Descripcion |
|--------|-------------|
| `--dev`, `-D` | Agregar a devDependencies |
| `--verbose` | Mostrar progreso detallado |
| `--dry-run` | Vista previa sin instalar |
| `--offline` | Instalar solo desde cache (sin red) |
| `--parallel` | Habilitar descargas paralelas (experimental) |

**Sintaxis de restriccion de version:**

| Sintaxis | Ejemplo | Significado |
|----------|---------|-------------|
| (ninguna) | `owner/repo` | Ultima version |
| Exacta | `owner/repo@1.2.3` | Exactamente 1.2.3 |
| Caret | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |
| Tilde | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |
| Rango | `owner/repo@>=1.0.0` | Al menos 1.0.0 |

**Ejemplos:**

```bash
# Instalar todas las dependencias
hpm install

# Instalar paquete especifico
hpm install hemlang/json

# Instalar con restriccion de version
hpm install hemlang/sprout@^2.0.0

# Instalar como dependencia de desarrollo
hpm install hemlang/test-utils --dev

# Vista previa de lo que se instalaria
hpm install hemlang/sprout --dry-run

# Salida detallada
hpm install --verbose

# Instalar solo desde cache (sin conexion)
hpm install --offline
```

**Salida:**

```
Installing dependencies...
  + hemlang/sprout@2.1.0
  + hemlang/router@1.5.0 (dependency of hemlang/sprout)

Installed 2 packages in 1.2s
```

---

### hpm uninstall

Elimina un paquete.

```bash
hpm uninstall owner/repo
hpm rm owner/repo          # Forma corta
hpm remove owner/repo      # Alternativa
```

**Ejemplos:**

```bash
hpm uninstall hemlang/sprout
```

**Salida:**

```
Removed hemlang/sprout@2.1.0
Updated package.json
Updated package-lock.json
```

---

### hpm update

Actualiza paquetes a las ultimas versiones dentro de las restricciones.

```bash
hpm update              # Actualizar todos los paquetes
hpm update owner/repo   # Actualizar paquete especifico
hpm up owner/repo       # Forma corta
```

**Opciones:**

| Opcion | Descripcion |
|--------|-------------|
| `--verbose` | Mostrar progreso detallado |
| `--dry-run` | Vista previa sin actualizar |

**Ejemplos:**

```bash
# Actualizar todos los paquetes
hpm update

# Actualizar paquete especifico
hpm update hemlang/sprout

# Vista previa de actualizaciones
hpm update --dry-run
```

**Salida:**

```
Updating dependencies...
  hemlang/sprout: 2.0.0 â†’ 2.1.0
  hemlang/router: 1.4.0 â†’ 1.5.0

Updated 2 packages
```

---

### hpm list

Muestra los paquetes instalados.

```bash
hpm list              # Mostrar arbol completo de dependencias
hpm list --depth=0    # Solo dependencias directas
hpm list --depth=1    # Un nivel de dependencias transitivas
hpm ls                # Forma corta
```

**Opciones:**

| Opcion | Descripcion |
|--------|-------------|
| `--depth=N` | Limitar profundidad del arbol (por defecto: todo) |

**Ejemplos:**

```bash
$ hpm list
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â”œâ”€â”€ hemlang/router@1.5.0
â”‚   â””â”€â”€ hemlang/middleware@1.2.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)

$ hpm list --depth=0
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)
```

---

### hpm outdated

Muestra los paquetes con versiones mas nuevas disponibles.

```bash
hpm outdated
```

**Salida:**

```
Package            Current  Wanted  Latest
hemlang/sprout     2.0.0    2.0.5   2.1.0
hemlang/router     1.4.0    1.4.2   1.5.0
```

- **Current**: Version instalada
- **Wanted**: Version mas alta que coincide con la restriccion
- **Latest**: Ultima version disponible

---

### hpm run

Ejecuta un script desde package.json.

```bash
hpm run <script>
hpm run <script> -- <args>
```

**Ejemplos:**

Dado este package.json:

```json
{
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Ejecutar scripts:

```bash
hpm run start
hpm run test
hpm run build

# Pasar argumentos al script
hpm run test -- --verbose
```

---

### hpm test

Atajo para `hpm run test`.

```bash
hpm test
hpm test -- --verbose
```

Equivalente a:

```bash
hpm run test
```

---

### hpm why

Explica por que un paquete esta instalado (muestra la cadena de dependencias).

```bash
hpm why owner/repo
```

**Ejemplo:**

```bash
$ hpm why hemlang/router

hemlang/router@1.5.0 is installed because:

my-project@1.0.0
â””â”€â”€ hemlang/sprout@2.1.0
    â””â”€â”€ hemlang/router@1.5.0
```

---

### hpm cache

Administra la cache global de paquetes.

```bash
hpm cache list    # Listar paquetes en cache
hpm cache clean   # Limpiar todos los paquetes en cache
```

**Subcomandos:**

| Subcomando | Descripcion |
|------------|-------------|
| `list` | Mostrar todos los paquetes en cache y sus tamanos |
| `clean` | Eliminar todos los paquetes en cache |

**Ejemplos:**

```bash
$ hpm cache list
Cached packages in ~/.hpm/cache:

hemlang/sprout
  2.0.0 (1.2 MB)
  2.1.0 (1.3 MB)
hemlang/router
  1.5.0 (450 KB)

Total: 2.95 MB

$ hpm cache clean
Cleared cache (2.95 MB freed)
```

---

## Atajos de Comandos

Por conveniencia, varios comandos tienen alias cortos:

| Comando | Atajos |
|---------|--------|
| `install` | `i` |
| `uninstall` | `rm`, `remove` |
| `list` | `ls` |
| `update` | `up` |

**Ejemplos:**

```bash
hpm i hemlang/sprout        # hpm install hemlang/sprout
hpm rm hemlang/sprout       # hpm uninstall hemlang/sprout
hpm ls                      # hpm list
hpm up                      # hpm update
```

---

## Codigos de Salida

hpm usa codigos de salida especificos para indicar diferentes condiciones de error:

| Codigo | Significado |
|--------|-------------|
| 0 | Exito |
| 1 | Conflicto de dependencias |
| 2 | Paquete no encontrado |
| 3 | Version no encontrada |
| 4 | Error de red |
| 5 | package.json invalido |
| 6 | Verificacion de integridad fallida |
| 7 | Limite de tasa de GitHub excedido |
| 8 | Dependencia circular |

Usa codigos de salida en scripts:

```bash
hpm install
if [ $? -ne 0 ]; then
    echo "Installation failed"
    exit 1
fi
```

---

## Variables de Entorno

hpm respeta estas variables de entorno:

| Variable | Descripcion |
|----------|-------------|
| `GITHUB_TOKEN` | Token de API de GitHub para autenticacion |
| `HPM_CACHE_DIR` | Sobrescribir ubicacion del directorio de cache |
| `HOME` | Directorio home del usuario (para config/cache) |

**Ejemplos:**

```bash
# Usar token de GitHub para mayores limites de tasa
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Usar directorio de cache personalizado
export HPM_CACHE_DIR=/tmp/hpm-cache
hpm install
```

---

## Ver Tambien

- [Configuracion](#hpm-commands-configuration) - Archivos de configuracion
- [Especificacion de Paquetes](#hpm-commands-package-spec) - formato de package.json
- [Solucion de Problemas](#hpm-commands-troubleshooting) - Problemas comunes


--------------------------------------------------------------------------------
## ConfiguraciÃ³n
--------------------------------------------------------------------------------

# Configuracion

Esta guia cubre todas las opciones de configuracion para hpm.

## Descripcion General

hpm puede configurarse a traves de:

1. **Variables de entorno** - Para configuraciones en tiempo de ejecucion
2. **Archivo de configuracion global** - `~/.hpm/config.json`
3. **Archivos del proyecto** - `package.json` y `package-lock.json`

## Variables de Entorno

### GITHUB_TOKEN

Token de API de GitHub para autenticacion.

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
```

**Beneficios de la autenticacion:**
- Mayores limites de tasa de API (5000 vs 60 solicitudes/hora)
- Acceso a repositorios privados
- Resolucion de dependencias mas rapida

**Crear un token:**

1. Ve a GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens
2. Haz clic en "Generate new token (classic)"
3. Selecciona los alcances:
   - `repo` - Para acceso a repositorios privados
   - `read:packages` - Para GitHub Packages (si se usa)
4. Genera y copia el token

### HPM_CACHE_DIR

Sobrescribe el directorio de cache por defecto.

```bash
export HPM_CACHE_DIR=/custom/cache/path
```

Por defecto: `~/.hpm/cache`

**Casos de uso:**
- Sistemas CI/CD con ubicaciones de cache personalizadas
- Cache compartida entre proyectos
- Cache temporal para compilaciones aisladas

### HOME

Directorio home del usuario. Se usa para ubicar:
- Directorio de configuracion: `$HOME/.hpm/`
- Directorio de cache: `$HOME/.hpm/cache/`

Normalmente establecido por el sistema; sobrescribe solo si es necesario.

### Ejemplo .bashrc / .zshrc

```bash
# GitHub authentication (recommended)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx

# Custom cache location (optional)
# export HPM_CACHE_DIR=/path/to/cache

# Add hpm to PATH (if using custom install location)
export PATH="$HOME/.local/bin:$PATH"
```

## Archivo de Configuracion Global

### Ubicacion

`~/.hpm/config.json`

### Formato

```json
{
  "github_token": "ghp_xxxxxxxxxxxxxxxxxxxx"
}
```

### Crear el Archivo de Configuracion

```bash
# Crear directorio de configuracion
mkdir -p ~/.hpm

# Crear archivo de configuracion
cat > ~/.hpm/config.json << 'EOF'
{
  "github_token": "ghp_your_token_here"
}
EOF

# Asegurar el archivo (recomendado)
chmod 600 ~/.hpm/config.json
```

### Prioridad del Token

Si ambos estan establecidos, la variable de entorno tiene precedencia:

1. Variable de entorno `GITHUB_TOKEN` (mayor)
2. Campo `github_token` de `~/.hpm/config.json`
3. Sin autenticacion (por defecto)

## Estructura de Directorios

### Directorios Globales

```
~/.hpm/
â”œâ”€â”€ config.json          # Configuracion global
â””â”€â”€ cache/               # Cache de paquetes
    â””â”€â”€ owner/
        â””â”€â”€ repo/
            â””â”€â”€ 1.0.0.tar.gz
```

### Directorios del Proyecto

```
my-project/
â”œâ”€â”€ package.json         # Manifiesto del proyecto
â”œâ”€â”€ package-lock.json    # Archivo de bloqueo de dependencias
â”œâ”€â”€ hem_modules/         # Paquetes instalados
â”‚   â””â”€â”€ owner/
â”‚       â””â”€â”€ repo/
â”‚           â”œâ”€â”€ package.json
â”‚           â””â”€â”€ src/
â”œâ”€â”€ src/                 # Codigo fuente
â””â”€â”€ test/                # Pruebas
```

## Cache de Paquetes

### Ubicacion

Por defecto: `~/.hpm/cache/`

Sobrescribir con: variable de entorno `HPM_CACHE_DIR`

### Estructura

```
~/.hpm/cache/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ 2.0.0.tar.gz
â”‚   â”‚   â””â”€â”€ 2.1.0.tar.gz
â”‚   â””â”€â”€ router/
â”‚       â””â”€â”€ 1.5.0.tar.gz
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â””â”€â”€ 1.0.0.tar.gz
```

### Administrar la Cache

```bash
# Ver paquetes en cache
hpm cache list

# Limpiar toda la cache
hpm cache clean
```

### Comportamiento de la Cache

- Los paquetes se almacenan en cache despues de la primera descarga
- Las instalaciones posteriores usan versiones en cache
- Usa `--offline` para instalar solo desde cache
- La cache se comparte entre todos los proyectos

## Limites de Tasa de API de GitHub

### Sin Autenticacion

- **60 solicitudes por hora** por direccion IP
- Compartido entre todos los usuarios no autenticados en la misma IP
- Se agota rapidamente en CI/CD o con muchas dependencias

### Con Autenticacion

- **5000 solicitudes por hora** por usuario autenticado
- Limite de tasa personal, no compartido

### Manejo de Limites de Tasa

hpm automaticamente:
- Reintenta con retroceso exponencial (1s, 2s, 4s, 8s)
- Reporta errores de limite de tasa con codigo de salida 7
- Sugiere autenticacion si se alcanza el limite

**Soluciones cuando se alcanza el limite:**

```bash
# Opcion 1: Autenticar con token de GitHub
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Opcion 2: Esperar a que se reinicie el limite de tasa
# (Los limites se reinician cada hora)

# Opcion 3: Usar modo sin conexion (si los paquetes estan en cache)
hpm install --offline
```

## Modo Sin Conexion

Instalar paquetes sin acceso a red:

```bash
hpm install --offline
```

**Requisitos:**
- Todos los paquetes deben estar en cache
- El archivo de bloqueo debe existir con versiones exactas

**Casos de uso:**
- Entornos aislados
- Compilaciones de CI/CD mas rapidas (con cache caliente)
- Evitar limites de tasa

## Configuracion de CI/CD

### GitHub Actions

```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Hemlock
      run: |
        # Install Hemlock (adjust based on your setup)
        curl -sSL https://hemlock.dev/install.sh | sh

    - name: Cache hpm packages
      uses: actions/cache@v3
      with:
        path: ~/.hpm/cache
        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-hpm-

    - name: Install dependencies
      run: hpm install
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Run tests
      run: hpm test
```

### GitLab CI

```yaml
stages:
  - build
  - test

variables:
  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache

cache:
  paths:
    - .hpm-cache/
  key: $CI_COMMIT_REF_SLUG

build:
  stage: build
  script:
    - hpm install
  artifacts:
    paths:
      - hem_modules/

test:
  stage: test
  script:
    - hpm test
```

### Docker

**Dockerfile:**

```dockerfile
FROM hemlock:latest

WORKDIR /app

# Copy package files first (for layer caching)
COPY package.json package-lock.json ./

# Install dependencies
RUN hpm install

# Copy source code
COPY . .

# Run application
CMD ["hemlock", "src/main.hml"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - hpm-cache:/root/.hpm/cache

volumes:
  hpm-cache:
```

## Configuracion de Proxy

Para entornos detras de un proxy, configura a nivel de sistema:

```bash
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080
export NO_PROXY=localhost,127.0.0.1

hpm install
```

## Mejores Practicas de Seguridad

### Seguridad de Tokens

1. **Nunca envies tokens** al control de versiones
2. **Usa variables de entorno** en CI/CD
3. **Restringe los alcances de tokens** al minimo requerido
4. **Rota tokens** regularmente
5. **Asegura el archivo de configuracion**:
   ```bash
   chmod 600 ~/.hpm/config.json
   ```

### Repositorios Privados

Para acceder a paquetes privados:

1. Crea un token con alcance `repo`
2. Configura la autenticacion (variable de entorno o archivo de configuracion)
3. Asegurate de que el token tenga acceso al repositorio

```bash
# Probar acceso
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install yourorg/private-package
```

## Solucion de Problemas de Configuracion

### Verificar Configuracion

```bash
# Verificar si el token esta establecido
echo $GITHUB_TOKEN | head -c 10

# Verificar archivo de configuracion
cat ~/.hpm/config.json

# Verificar directorio de cache
ls -la ~/.hpm/cache/

# Probar con salida detallada
hpm install --verbose
```

### Problemas Comunes

**"GitHub rate limit exceeded"**
- Configura autenticacion con `GITHUB_TOKEN`
- Espera a que se reinicie el limite de tasa
- Usa `--offline` si los paquetes estan en cache

**"Permission denied" en cache**
```bash
# Arreglar permisos de cache
chmod -R u+rw ~/.hpm/cache
```

**"Config file not found"**
```bash
# Crear directorio de configuracion
mkdir -p ~/.hpm
touch ~/.hpm/config.json
```

## Ver Tambien

- [Instalacion](#hpm-configuration-installation) - Instalar hpm
- [Solucion de Problemas](#hpm-configuration-troubleshooting) - Problemas comunes
- [Comandos](#hpm-configuration-commands) - Referencia de comandos


--------------------------------------------------------------------------------
## SoluciÃ³n de Problemas
--------------------------------------------------------------------------------

# Solucion de Problemas

Soluciones a problemas comunes de hpm.

## Problemas de Instalacion

### "hemlock: command not found"

**Causa:** Hemlock no esta instalado o no esta en el PATH.

**Solucion:**

```bash
# Verificar si hemlock existe
which hemlock

# Si no se encuentra, instalar Hemlock primero
# Visita: https://github.com/hemlang/hemlock

# Despues de la instalacion, verificar
hemlock --version
```

### "hpm: command not found"

**Causa:** hpm no esta instalado o no esta en el PATH.

**Solucion:**

```bash
# Verificar donde esta instalado hpm
ls -la /usr/local/bin/hpm
ls -la ~/.local/bin/hpm

# Si usas ubicacion personalizada, agregar al PATH
export PATH="$HOME/.local/bin:$PATH"

# Agregar a ~/.bashrc o ~/.zshrc para persistencia
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Reinstalar si es necesario
cd /path/to/hpm
sudo make install
```

### "Permission denied" durante la instalacion

**Causa:** Sin permiso de escritura en el directorio de instalacion.

**Solucion:**

```bash
# Opcion 1: Usar sudo para instalacion en todo el sistema
sudo make install

# Opcion 2: Instalar en directorio de usuario (sin sudo)
make install PREFIX=$HOME/.local
```

## Problemas de Dependencias

### "Package not found" (codigo de salida 2)

**Causa:** El paquete no existe en GitHub.

**Solucion:**

```bash
# Verificar que el paquete existe
# Verifica: https://github.com/owner/repo

# Verificar ortografia
hpm install hemlang/sprout  # Correcto
hpm install hemlan/sprout   # Owner incorrecto
hpm install hemlang/spout   # Repo incorrecto

# Verificar errores tipograficos en package.json
cat package.json | grep -A 5 dependencies
```

### "Version not found" (codigo de salida 3)

**Causa:** Ninguna version coincide con la restriccion de version.

**Solucion:**

```bash
# Listar versiones disponibles (verificar releases/tags en GitHub)
# Las etiquetas deben comenzar con 'v' (ej., v1.0.0)

# Usar una restriccion de version valida
hpm install owner/repo@^1.0.0

# Intentar ultima version
hpm install owner/repo

# Verificar etiquetas disponibles en GitHub
# https://github.com/owner/repo/tags
```

### "Dependency conflict" (codigo de salida 1)

**Causa:** Dos paquetes requieren versiones incompatibles de una dependencia.

**Solucion:**

```bash
# Ver el conflicto
hpm install --verbose

# Verificar que requiere la dependencia
hpm why conflicting/package

# Soluciones:
# 1. Actualizar el paquete en conflicto
hpm update problem/package

# 2. Cambiar restricciones de version en package.json
# Editar para permitir versiones compatibles

# 3. Eliminar uno de los paquetes en conflicto
hpm uninstall one/package
```

### "Circular dependency" (codigo de salida 8)

**Causa:** El paquete A depende de B, que depende de A.

**Solucion:**

```bash
# Identificar el ciclo
hpm install --verbose

# Esto generalmente es un error en los paquetes
# Contactar a los mantenedores del paquete

# Solucion alternativa: evitar uno de los paquetes
```

## Problemas de Red

### "Network error" (codigo de salida 4)

**Causa:** No se puede conectar a la API de GitHub.

**Solucion:**

```bash
# Verificar conexion a internet
ping github.com

# Verificar si la API de GitHub es accesible
curl -I https://api.github.com

# Intentar de nuevo (hpm reintenta automaticamente)
hpm install

# Usar modo sin conexion si los paquetes estan en cache
hpm install --offline

# Verificar configuracion de proxy si estas detras de un firewall
export HTTPS_PROXY=http://proxy:8080
hpm install
```

### "GitHub rate limit exceeded" (codigo de salida 7)

**Causa:** Demasiadas solicitudes a la API sin autenticacion.

**Solucion:**

```bash
# Opcion 1: Autenticar con token de GitHub (recomendado)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Crear token: GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens

# Opcion 2: Guardar token en archivo de configuracion
mkdir -p ~/.hpm
echo '{"github_token": "ghp_xxxxxxxxxxxx"}' > ~/.hpm/config.json

# Opcion 3: Esperar a que se reinicie el limite de tasa (se reinicia cada hora)

# Opcion 4: Usar modo sin conexion
hpm install --offline
```

### Timeout de conexion

**Causa:** Red lenta o problemas con la API de GitHub.

**Solucion:**

```bash
# hpm reintenta automaticamente con retroceso exponencial

# Verificar si GitHub tiene problemas
# Visita: https://www.githubstatus.com

# Intentar mas tarde
hpm install

# Usar paquetes en cache
hpm install --offline
```

## Problemas de Package.json

### "Invalid package.json" (codigo de salida 5)

**Causa:** Formato incorrecto o campos requeridos faltantes.

**Solucion:**

```bash
# Validar sintaxis JSON
cat package.json | python -m json.tool

# Verificar campos requeridos
cat package.json

# Campos requeridos:
# - "name": formato "owner/repo"
# - "version": formato "X.Y.Z"

# Regenerar si es necesario
rm package.json
hpm init
```

### Error de formato "name"

**Causa:** Nombre del paquete no esta en formato `owner/repo`.

**Solucion:**

```json
// Incorrecto
{
  "name": "my-package"
}

// Correcto
{
  "name": "yourusername/my-package"
}
```

### Error de formato "version"

**Causa:** Version no esta en formato semver.

**Solucion:**

```json
// Incorrecto
{
  "version": "1.0"
}

// Correcto
{
  "version": "1.0.0"
}
```

## Problemas del Archivo de Bloqueo

### Archivo de bloqueo desincronizado

**Causa:** package.json modificado sin ejecutar install.

**Solucion:**

```bash
# Regenerar archivo de bloqueo
rm package-lock.json
hpm install
```

### Archivo de bloqueo corrupto

**Causa:** JSON invalido o ediciones manuales.

**Solucion:**

```bash
# Verificar validez del JSON
cat package-lock.json | python -m json.tool

# Regenerar
rm package-lock.json
hpm install
```

## Problemas de hem_modules

### Los paquetes no se instalan

**Causa:** Varios problemas posibles.

**Solucion:**

```bash
# Limpiar y reinstalar
rm -rf hem_modules
hpm install

# Verificar salida detallada
hpm install --verbose
```

### La importacion no funciona

**Causa:** Paquete no instalado correctamente o ruta de importacion incorrecta.

**Solucion:**

```bash
# Verificar que el paquete este instalado
ls hem_modules/owner/repo/

# Verificar campo main de package.json
cat hem_modules/owner/repo/package.json

# Formato correcto de importacion
import { x } from "owner/repo";          # Usa entrada main
import { y } from "owner/repo/subpath";  # Importacion de subruta
```

### Error "Module not found"

**Causa:** La ruta de importacion no resuelve a un archivo.

**Solucion:**

```bash
# Verificar ruta de importacion
ls hem_modules/owner/repo/src/

# Verificar existencia de index.hml
ls hem_modules/owner/repo/src/index.hml

# Verificar campo main en package.json
cat hem_modules/owner/repo/package.json | grep main
```

## Problemas de Cache

### La cache ocupa demasiado espacio

**Solucion:**

```bash
# Ver tamano de cache
hpm cache list

# Limpiar cache
hpm cache clean
```

### Permisos de cache

**Solucion:**

```bash
# Arreglar permisos
chmod -R u+rw ~/.hpm/cache

# O eliminar y reinstalar
rm -rf ~/.hpm/cache
hpm install
```

### Usando cache incorrecta

**Solucion:**

```bash
# Verificar ubicacion de cache
echo $HPM_CACHE_DIR
ls ~/.hpm/cache

# Limpiar variable de entorno si es incorrecta
unset HPM_CACHE_DIR
```

## Problemas de Scripts

### "Script not found"

**Causa:** El nombre del script no existe en package.json.

**Solucion:**

```bash
# Listar scripts disponibles
cat package.json | grep -A 20 scripts

# Verificar ortografia
hpm run test    # Correcto
hpm run tests   # Incorrecto si el script se llama "test"
```

### El script falla

**Causa:** Error en el comando del script.

**Solucion:**

```bash
# Ejecutar comando directamente para ver el error
hemlock test/run.hml

# Verificar definicion del script
cat package.json | grep test
```

## Depuracion

### Habilitar salida detallada

```bash
hpm install --verbose
```

### Verificar version de hpm

```bash
hpm --version
```

### Verificar version de hemlock

```bash
hemlock --version
```

### Ejecucion en seco

Vista previa sin hacer cambios:

```bash
hpm install --dry-run
```

### Empezar de cero

Comenzar desde cero:

```bash
rm -rf hem_modules package-lock.json
hpm install
```

## Obtener Ayuda

### Ayuda de comandos

```bash
hpm --help
hpm install --help
```

### Reportar problemas

Si encuentras un error:

1. Verifica problemas existentes: https://github.com/hemlang/hpm/issues
2. Crea un nuevo problema con:
   - Version de hpm (`hpm --version`)
   - Version de Hemlock (`hemlock --version`)
   - Sistema operativo
   - Pasos para reproducir
   - Mensaje de error (usa `--verbose`)

## Referencia de Codigos de Salida

| Codigo | Significado | Solucion Comun |
|--------|-------------|----------------|
| 0 | Exito | - |
| 1 | Conflicto de dependencias | Actualizar o cambiar restricciones |
| 2 | Paquete no encontrado | Verificar ortografia, verificar que el repo existe |
| 3 | Version no encontrada | Verificar versiones disponibles en GitHub |
| 4 | Error de red | Verificar conexion, reintentar |
| 5 | package.json invalido | Arreglar sintaxis JSON y campos requeridos |
| 6 | Verificacion de integridad fallida | Limpiar cache, reinstalar |
| 7 | Limite de tasa de GitHub | Agregar GITHUB_TOKEN |
| 8 | Dependencia circular | Contactar mantenedores del paquete |

## Ver Tambien

- [Instalacion](#hpm-troubleshooting-installation) - Guia de instalacion
- [Configuracion](#hpm-troubleshooting-configuration) - Opciones de configuracion
- [Comandos](#hpm-troubleshooting-commands) - Referencia de comandos



################################################################################
# HPM: DESARROLLO DE PAQUETES
################################################################################

--------------------------------------------------------------------------------
## CreaciÃ³n de Paquetes
--------------------------------------------------------------------------------

# Creacion de Paquetes

Esta guia cubre como crear, estructurar y publicar paquetes Hemlock.

## Descripcion General

hpm usa GitHub como su registro de paquetes. Los paquetes se identifican por su ruta `owner/repo` de GitHub, y las versiones son etiquetas de Git. Publicar es simplemente enviar una version etiquetada.

## Crear un Nuevo Paquete

### 1. Inicializar el Paquete

Crea un nuevo directorio e inicializa:

```bash
mkdir my-package
cd my-package
hpm init
```

Responde las preguntas:

```
Package name (owner/repo): yourusername/my-package
Version (1.0.0):
Description: A useful Hemlock package
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

### 2. Crear la Estructura del Proyecto

Estructura recomendada para paquetes:

```
my-package/
â”œâ”€â”€ package.json          # Manifiesto del paquete
â”œâ”€â”€ README.md             # Documentacion
â”œâ”€â”€ LICENSE               # Archivo de licencia
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml         # Punto de entrada principal (exporta API publica)
â”‚   â”œâ”€â”€ utils.hml         # Utilidades internas
â”‚   â””â”€â”€ types.hml         # Definiciones de tipos
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml     # Framework de pruebas
    â””â”€â”€ test_utils.hml    # Pruebas
```

### 3. Definir Tu API Publica

**src/index.hml** - Punto de entrada principal:

```hemlock
// Re-export public API
export { parse, stringify } from "./parser.hml";
export { Config, Options } from "./types.hml";
export { process } from "./processor.hml";

// Direct exports
export fn create(options: Options): Config {
    // Implementation
}

export fn validate(config: Config): bool {
    // Implementation
}
```

### 4. Escribir Tu package.json

Ejemplo completo de package.json:

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "A useful Hemlock package",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/bundle.hmlc"
  },
  "keywords": ["utility", "parser", "config"],
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ]
}
```

## Nomenclatura de Paquetes

### Requisitos

- Debe estar en formato `owner/repo`
- `owner` debe ser tu nombre de usuario u organizacion de GitHub
- `repo` debe ser el nombre del repositorio
- Usa minusculas con guiones para nombres de varias palabras

### Buenos Nombres

```
hemlang/sprout
alice/http-client
myorg/json-utils
bob/date-formatter
```

### Evitar

```
my-package          # Falta owner
alice/MyPackage     # PascalCase
alice/my_package    # Guiones bajos
```

## Mejores Practicas de Estructura de Paquetes

### Punto de Entrada

El campo `main` en package.json especifica el punto de entrada:

```json
{
  "main": "src/index.hml"
}
```

Este archivo debe exportar tu API publica:

```hemlock
// Export everything users need
export { Parser, parse } from "./parser.hml";
export { Formatter, format } from "./formatter.hml";

// Types
export type { Config, Options } from "./types.hml";
```

### Interno vs Publico

Mantener los detalles de implementacion interna privados:

```
src/
â”œâ”€â”€ index.hml          # Publico: API exportada
â”œâ”€â”€ parser.hml         # Publico: usado por index.hml
â”œâ”€â”€ formatter.hml      # Publico: usado por index.hml
â””â”€â”€ internal/
    â”œâ”€â”€ helpers.hml    # Privado: solo uso interno
    â””â”€â”€ constants.hml  # Privado: solo uso interno
```

Los usuarios importan desde la raiz de tu paquete:

```hemlock
// Bien - importa desde API publica
import { parse, Parser } from "yourusername/my-package";

// Tambien funciona - importacion de subruta
import { validate } from "yourusername/my-package/validator";

// Desaconsejado - acceder a internos
import { helper } from "yourusername/my-package/internal/helpers";
```

### Exportaciones de Subrutas

Soportar importacion desde subrutas:

```
src/
â”œâ”€â”€ index.hml              # Entrada principal
â”œâ”€â”€ parser/
â”‚   â””â”€â”€ index.hml          # yourusername/pkg/parser
â”œâ”€â”€ formatter/
â”‚   â””â”€â”€ index.hml          # yourusername/pkg/formatter
â””â”€â”€ utils/
    â””â”€â”€ index.hml          # yourusername/pkg/utils
```

Los usuarios pueden importar:

```hemlock
import { parse } from "yourusername/my-package";           # Principal
import { Parser } from "yourusername/my-package/parser";   # Subruta
import { format } from "yourusername/my-package/formatter";
```

## Dependencias

### Agregar Dependencias

```bash
# Dependencia de tiempo de ejecucion
hpm install hemlang/json

# Dependencia de desarrollo
hpm install hemlang/test-utils --dev
```

### Mejores Practicas de Dependencias

1. **Usar rangos caret** para la mayoria de dependencias:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     }
   }
   ```

2. **Fijar versiones** solo cuando sea necesario (inestabilidad de API):
   ```json
   {
     "dependencies": {
       "unstable/lib": "1.2.3"
     }
   }
   ```

3. **Evitar rangos demasiado restrictivos**:
   ```json
   // Malo: demasiado restrictivo
   "hemlang/json": ">=1.2.3 <1.2.5"

   // Bueno: permite actualizaciones compatibles
   "hemlang/json": "^1.2.3"
   ```

4. **Separar dependencias de desarrollo**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     },
     "devDependencies": {
       "hemlang/test-utils": "^1.0.0"
     }
   }
   ```

## Probar Tu Paquete

### Escribir Pruebas

**test/run.hml:**

```hemlock
import { suite, test, assert_eq } from "./framework.hml";
import { parse, stringify } from "../src/index.hml";

fn run_tests() {
    suite("Parser", fn() {
        test("parses valid input", fn() {
            let result = parse("hello");
            assert_eq(result.value, "hello");
        });

        test("handles empty input", fn() {
            let result = parse("");
            assert_eq(result.value, "");
        });
    });

    suite("Stringify", fn() {
        test("stringifies object", fn() {
            let obj = { name: "test" };
            let result = stringify(obj);
            assert_eq(result, '{"name":"test"}');
        });
    });
}

run_tests();
```

### Ejecutar Pruebas

Agrega un script de pruebas:

```json
{
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

Ejecuta con:

```bash
hpm test
```

## Publicacion

### Prerrequisitos

1. Crear un repositorio en GitHub que coincida con el nombre de tu paquete
2. Asegurar que `package.json` este completo y sea valido
3. Todas las pruebas pasan

### Proceso de Publicacion

Publicar es simplemente enviar una etiqueta de Git:

```bash
# 1. Asegurar que todo este confirmado
git add .
git commit -m "Prepare v1.0.0 release"

# 2. Crear una etiqueta de version (debe comenzar con 'v')
git tag v1.0.0

# 3. Enviar codigo y etiquetas
git push origin main
git push origin v1.0.0
# O enviar todas las etiquetas a la vez
git push origin main --tags
```

### Etiquetas de Version

Las etiquetas deben seguir el formato `vX.Y.Z`:

```bash
git tag v1.0.0      # Release
git tag v1.0.1      # Parche
git tag v1.1.0      # Menor
git tag v2.0.0      # Mayor
git tag v1.0.0-beta.1  # Pre-release
```

### Lista de Verificacion de Lanzamiento

Antes de publicar una nueva version:

1. **Actualizar version** en package.json
2. **Ejecutar pruebas**: `hpm test`
3. **Actualizar CHANGELOG** (si tienes uno)
4. **Actualizar README** si la API cambio
5. **Confirmar cambios**
6. **Crear etiqueta**
7. **Enviar a GitHub**

### Ejemplo Automatizado

Crea un script de lanzamiento:

```bash
#!/bin/bash
# release.sh - Release a new version

VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Usage: ./release.sh 1.0.0"
    exit 1
fi

# Run tests
hpm test || exit 1

# Update version in package.json
sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

# Commit and tag
git add package.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# Push
git push origin main --tags

echo "Released v$VERSION"
```

## Usuarios Instalando Tu Paquete

Despues de publicar, los usuarios pueden instalar:

```bash
# Ultima version
hpm install yourusername/my-package

# Version especifica
hpm install yourusername/my-package@1.0.0

# Restriccion de version
hpm install yourusername/my-package@^1.0.0
```

E importar:

```hemlock
import { parse, stringify } from "yourusername/my-package";
```

## Documentacion

### README.md

Cada paquete debe tener un README:

```markdown
# my-package

A brief description of what this package does.

## Installation

\`\`\`bash
hpm install yourusername/my-package
\`\`\`

## Usage

\`\`\`hemlock
import { parse } from "yourusername/my-package";

let result = parse("input");
\`\`\`

## API

### parse(input: string): Result

Parses the input string.

### stringify(obj: any): string

Converts object to string.

## License

MIT
```

### Documentacion de API

Documenta todas las exportaciones publicas:

```hemlock
/// Parses the input string into a structured Result.
///
/// # Arguments
/// * `input` - The string to parse
///
/// # Returns
/// A Result containing the parsed data or an error
///
/// # Example
/// ```
/// let result = parse("hello world");
/// print(result.value);
/// ```
export fn parse(input: string): Result {
    // Implementation
}
```

## Directrices de Versionado

Sigue [Versionado Semantico](https://semver.org/):

- **MAJOR** (1.0.0 â†’ 2.0.0): Cambios incompatibles
- **MINOR** (1.0.0 â†’ 1.1.0): Nuevas caracteristicas, compatibles hacia atras
- **PATCH** (1.0.0 â†’ 1.0.1): Correcciones de errores, compatibles hacia atras

### Cuando Incrementar

| Tipo de Cambio | Incremento de Version |
|----------------|----------------------|
| Cambio de API incompatible | MAJOR |
| Eliminar funcion/tipo | MAJOR |
| Cambiar firma de funcion | MAJOR |
| Agregar nueva funcion | MINOR |
| Agregar nueva caracteristica | MINOR |
| Correccion de error | PATCH |
| Actualizacion de documentacion | PATCH |
| Refactorizacion interna | PATCH |

## Ver Tambien

- [Especificacion de Paquetes](#hpm-creating-packages-package-spec) - Referencia completa de package.json
- [Versionado](#hpm-creating-packages-versioning) - Detalles de versionado semantico
- [Configuracion](#hpm-creating-packages-configuration) - Autenticacion de GitHub


--------------------------------------------------------------------------------
## EspecificaciÃ³n de Paquetes
--------------------------------------------------------------------------------

# Especificacion de Paquetes

Referencia completa para el formato del archivo `package.json`.

## Descripcion General

Cada paquete de hpm requiere un archivo `package.json` en la raiz del proyecto. Este archivo define los metadatos del paquete, dependencias y scripts.

## Ejemplo Minimo

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

## Ejemplo Completo

```json
{
  "name": "hemlang/example-package",
  "version": "1.2.3",
  "description": "An example Hemlock package",
  "author": "Hemlock Team <team@hemlock.dev>",
  "license": "MIT",
  "repository": "https://github.com/hemlang/example-package",
  "homepage": "https://hemlang.github.io/example-package",
  "bugs": "https://github.com/hemlang/example-package/issues",
  "main": "src/index.hml",
  "keywords": ["example", "utility", "hemlock"],
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "^2.1.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/bundle.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

## Referencia de Campos

### name (requerido)

El nombre del paquete en formato `owner/repo`.

```json
{
  "name": "hemlang/sprout"
}
```

**Requisitos:**
- Debe estar en formato `owner/repo`
- `owner` debe ser tu nombre de usuario u organizacion de GitHub
- `repo` debe ser el nombre del repositorio
- Usa letras minusculas, numeros y guiones
- Maximo 214 caracteres en total

**Nombres validos:**
```
hemlang/sprout
alice/http-client
myorg/json-utils
bob123/my-lib
```

**Nombres invalidos:**
```
my-package          # Falta owner
hemlang/My_Package  # Mayusculas y guion bajo
hemlang             # Falta repo
```

### version (requerido)

La version del paquete siguiendo [Versionado Semantico](https://semver.org/).

```json
{
  "version": "1.2.3"
}
```

**Formato:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`

**Versiones validas:**
```
1.0.0
2.1.3
1.0.0-alpha
1.0.0-beta.1
1.0.0-rc.1+build.123
0.1.0
```

### description

Descripcion corta del paquete.

```json
{
  "description": "A fast JSON parser for Hemlock"
}
```

- Mantenla bajo 200 caracteres
- Describe lo que hace el paquete, no como

### author

Informacion del autor del paquete.

```json
{
  "author": "Your Name <email@example.com>"
}
```

**Formatos aceptados:**
```json
"author": "Your Name"
"author": "Your Name <email@example.com>"
"author": "Your Name <email@example.com> (https://website.com)"
```

### license

El identificador de licencia.

```json
{
  "license": "MIT"
}
```

**Licencias comunes:**
- `MIT` - Licencia MIT
- `Apache-2.0` - Licencia Apache 2.0
- `GPL-3.0` - Licencia Publica General GNU v3.0
- `BSD-3-Clause` - Licencia BSD de 3 clausulas
- `ISC` - Licencia ISC
- `UNLICENSED` - Propietario/privado

Usa [identificadores SPDX](https://spdx.org/licenses/) cuando sea posible.

### repository

Enlace al repositorio de codigo fuente.

```json
{
  "repository": "https://github.com/hemlang/sprout"
}
```

### homepage

URL de la pagina principal del proyecto.

```json
{
  "homepage": "https://sprout.hemlock.dev"
}
```

### bugs

URL del rastreador de problemas.

```json
{
  "bugs": "https://github.com/hemlang/sprout/issues"
}
```

### main

Archivo de punto de entrada para el paquete.

```json
{
  "main": "src/index.hml"
}
```

**Por defecto:** `src/index.hml`

Cuando los usuarios importan tu paquete:
```hemlock
import { x } from "owner/repo";
```

hpm carga el archivo especificado en `main`.

**Orden de resolucion para importaciones:**
1. Ruta exacta: `src/index.hml`
2. Con extension .hml: `src/index` â†’ `src/index.hml`
3. Archivo index: `src/index/` â†’ `src/index/index.hml`

### keywords

Array de palabras clave para descubrimiento.

```json
{
  "keywords": ["json", "parser", "utility", "hemlock"]
}
```

- Usa minusculas
- Se especifico y relevante
- Incluye el lenguaje ("hemlock") si es apropiado

### dependencies

Dependencias de tiempo de ejecucion requeridas para que el paquete funcione.

```json
{
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "~2.1.0",
    "alice/logger": ">=1.0.0 <2.0.0"
  }
}
```

**Clave:** Nombre del paquete (`owner/repo`)
**Valor:** Restriccion de version

**Sintaxis de restriccion de version:**

| Restriccion | Significado |
|-------------|-------------|
| `1.2.3` | Version exacta |
| `^1.2.3` | >=1.2.3 <2.0.0 |
| `~1.2.3` | >=1.2.3 <1.3.0 |
| `>=1.0.0` | Al menos 1.0.0 |
| `>=1.0.0 <2.0.0` | Rango |
| `*` | Cualquier version |

### devDependencies

Dependencias solo de desarrollo (pruebas, compilacion, etc.).

```json
{
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0",
    "hemlang/linter": "^2.0.0"
  }
}
```

Las dependencias de desarrollo son:
- Instaladas durante el desarrollo
- No instaladas cuando el paquete se usa como dependencia
- Usadas para pruebas, compilacion, linting, etc.

### scripts

Comandos con nombre que se pueden ejecutar con `hpm run`.

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

**Ejecutar scripts:**
```bash
hpm run start
hpm run build
hpm test        # Atajo para 'hpm run test'
```

**Pasar argumentos:**
```bash
hpm run test -- --verbose --filter=unit
```

**Scripts comunes:**

| Script | Proposito |
|--------|-----------|
| `start` | Iniciar la aplicacion |
| `dev` | Modo desarrollo con recarga en caliente |
| `test` | Ejecutar pruebas |
| `build` | Compilar para produccion |
| `clean` | Eliminar artefactos de compilacion |
| `lint` | Verificar estilo de codigo |
| `format` | Formatear codigo |

### files

Archivos y directorios a incluir cuando el paquete se instala.

```json
{
  "files": [
    "src/",
    "lib/",
    "LICENSE",
    "README.md"
  ]
}
```

**Comportamiento por defecto:** Si no se especifica, incluye:
- Todos los archivos en el repositorio
- Excluye `.git/`, `node_modules/`, `hem_modules/`

**Usar para:**
- Reducir el tamano del paquete
- Excluir archivos de prueba de la distribucion
- Incluir solo archivos necesarios

### native

Requisitos de bibliotecas nativas.

```json
{
  "native": {
    "requires": ["libcurl", "openssl", "sqlite3"]
  }
}
```

Documenta dependencias nativas que deben estar instaladas en el sistema.

## Validacion

hpm valida package.json en varias operaciones. Errores de validacion comunes:

### Campos requeridos faltantes

```
Error: package.json missing required field: name
```

**Solucion:** Agregar el campo requerido.

### Formato de nombre invalido

```
Error: Invalid package name. Must be in owner/repo format.
```

**Solucion:** Usar formato `owner/repo`.

### Version invalida

```
Error: Invalid version "1.0". Must be semver format (X.Y.Z).
```

**Solucion:** Usar formato semver completo (`1.0.0`).

### JSON invalido

```
Error: package.json is not valid JSON
```

**Solucion:** Verificar sintaxis JSON (comas, comillas, corchetes).

## Crear package.json

### Interactivo

```bash
hpm init
```

Solicita cada campo de forma interactiva.

### Con Valores por Defecto

```bash
hpm init --yes
```

Crea con valores por defecto:
```json
{
  "name": "directory-name/directory-name",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "license": "MIT",
  "main": "src/index.hml",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

### Manual

Crea el archivo manualmente:

```bash
cat > package.json << 'EOF'
{
  "name": "yourname/your-package",
  "version": "1.0.0",
  "description": "Your package description",
  "main": "src/index.hml",
  "dependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
EOF
```

## Mejores Practicas

1. **Siempre especifica main** - No dependas del valor por defecto
2. **Usa rangos caret** - `^1.0.0` para la mayoria de dependencias
3. **Separa dependencias de desarrollo** - Mantener dependencias de prueba/compilacion en devDependencies
4. **Incluye palabras clave** - Ayuda a los usuarios a encontrar tu paquete
5. **Documenta scripts** - Nombra los scripts claramente
6. **Especifica licencia** - Requerido para codigo abierto
7. **Agrega descripcion** - Ayuda a los usuarios a entender el proposito

## Ver Tambien

- [Creacion de Paquetes](#hpm-package-spec-creating-packages) - Guia de publicacion
- [Versionado](#hpm-package-spec-versioning) - Restricciones de version
- [Configuracion del Proyecto](#hpm-package-spec-project-setup) - Estructura del proyecto


--------------------------------------------------------------------------------
## Versionado
--------------------------------------------------------------------------------

# Versionado

Guia completa de versionado semantico en hpm.

## Versionado Semantico

hpm usa [Versionado Semantico 2.0.0](https://semver.org/) (semver) para versiones de paquetes.

### Formato de Version

```
MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
```

**Ejemplos:**
```
1.0.0           # Version de lanzamiento
2.1.3           # Version de lanzamiento
1.0.0-alpha     # Pre-lanzamiento
1.0.0-beta.1    # Pre-lanzamiento con numero
1.0.0-rc.1      # Candidato a lanzamiento
1.0.0+20231201  # Con metadatos de compilacion
1.0.0-beta+exp  # Pre-lanzamiento con metadatos de compilacion
```

### Componentes de Version

| Componente | Descripcion | Ejemplo |
|------------|-------------|---------|
| MAJOR | Cambios incompatibles | `1.0.0` â†’ `2.0.0` |
| MINOR | Nuevas caracteristicas (compatibles hacia atras) | `1.0.0` â†’ `1.1.0` |
| PATCH | Correcciones de errores (compatibles hacia atras) | `1.0.0` â†’ `1.0.1` |
| PRERELEASE | Identificador de pre-lanzamiento | `1.0.0-alpha` |
| BUILD | Metadatos de compilacion (ignorado en comparacion) | `1.0.0+build123` |

### Cuando Incrementar

| Tipo de Cambio | Incrementar | Ejemplo |
|----------------|-------------|---------|
| Cambio de API incompatible | MAJOR | Eliminar una funcion |
| Renombrar funcion publica | MAJOR | `parse()` â†’ `decode()` |
| Cambiar firma de funcion | MAJOR | Agregar parametro requerido |
| Agregar nueva funcion | MINOR | Agregar `validate()` |
| Agregar parametro opcional | MINOR | Nuevo argumento opcional `options` |
| Correccion de error | PATCH | Arreglar puntero nulo |
| Mejora de rendimiento | PATCH | Algoritmo mas rapido |
| Refactorizacion interna | PATCH | Sin cambio de API |

## Restricciones de Version

### Sintaxis de Restricciones

| Sintaxis | Significado | Resuelve a |
|----------|-------------|------------|
| `1.2.3` | Version exacta | Solo 1.2.3 |
| `^1.2.3` | Caret (compatible) | â‰¥1.2.3 y <2.0.0 |
| `~1.2.3` | Tilde (actualizaciones de parche) | â‰¥1.2.3 y <1.3.0 |
| `>=1.0.0` | Al menos | 1.0.0 o superior |
| `>1.0.0` | Mayor que | Superior a 1.0.0 |
| `<2.0.0` | Menor que | Inferior a 2.0.0 |
| `<=2.0.0` | Como maximo | 2.0.0 o inferior |
| `>=1.0.0 <2.0.0` | Rango | Entre 1.0.0 y 2.0.0 |
| `*` | Cualquiera | Cualquier version |

### Rangos Caret (^)

El caret (`^`) permite cambios que no modifican el digito mas a la izquierda que no es cero:

```
^1.2.3  â†’  >=1.2.3 <2.0.0   # Permite 1.x.x
^0.2.3  â†’  >=0.2.3 <0.3.0   # Permite 0.2.x
^0.0.3  â†’  >=0.0.3 <0.0.4   # Solo permite 0.0.3
```

**Usar cuando:** Quieres actualizaciones compatibles dentro de una version mayor.

**Restriccion mas comun** - recomendada para la mayoria de dependencias.

### Rangos Tilde (~)

El tilde (`~`) solo permite cambios a nivel de parche:

```
~1.2.3  â†’  >=1.2.3 <1.3.0   # Permite 1.2.x
~1.2    â†’  >=1.2.0 <1.3.0   # Permite 1.2.x
~1      â†’  >=1.0.0 <2.0.0   # Permite 1.x.x
```

**Usar cuando:** Solo quieres correcciones de errores, sin nuevas caracteristicas.

### Rangos de Comparacion

Combina operadores de comparacion para control preciso:

```json
{
  "dependencies": {
    "owner/pkg": ">=1.0.0 <2.0.0",
    "owner/other": ">1.5.0 <=2.1.0"
  }
}
```

### Cualquier Version (*)

Coincide con cualquier version:

```json
{
  "dependencies": {
    "owner/pkg": "*"
  }
}
```

**Advertencia:** No recomendado para produccion. Siempre obtendra la ultima version.

## Versiones de Pre-lanzamiento

### Identificadores de Pre-lanzamiento

Los pre-lanzamientos tienen menor precedencia que los lanzamientos:

```
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0
```

### Etiquetas Comunes de Pre-lanzamiento

| Etiqueta | Significado | Etapa |
|----------|-------------|-------|
| `alpha` | Desarrollo temprano | Muy inestable |
| `beta` | Caracteristicas completas | Pruebas |
| `rc` | Candidato a lanzamiento | Pruebas finales |
| `dev` | Snapshot de desarrollo | Inestable |

### Pre-lanzamiento en Restricciones

Las restricciones no coinciden con pre-lanzamientos por defecto:

```
^1.0.0    # NO coincide con 1.1.0-beta
>=1.0.0   # NO coincide con 2.0.0-alpha
```

Para incluir pre-lanzamientos, referencialos explicitamente:

```
>=1.0.0-alpha <2.0.0   # Incluye todos los pre-lanzamientos 1.x
```

## Comparacion de Versiones

### Reglas de Comparacion

1. Comparar MAJOR, MINOR, PATCH numericamente
2. Lanzamiento > pre-lanzamiento con la misma version
3. Pre-lanzamientos comparados alfanumericamente
4. Metadatos de compilacion ignorados

### Ejemplos

```
1.0.0 < 1.0.1 < 1.1.0 < 2.0.0

1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0

1.0.0 = 1.0.0+build123  # Metadatos de compilacion ignorados
```

### Ordenamiento

Las versiones se ordenan de forma ascendente:

```
1.0.0
1.0.1
1.1.0
1.1.1
2.0.0-alpha
2.0.0-beta
2.0.0
```

## Resolucion de Versiones

### Algoritmo de Resolucion

Cuando multiples paquetes requieren la misma dependencia:

1. Recopilar todas las restricciones
2. Encontrar la interseccion de todos los rangos
3. Seleccionar la version mas alta en la interseccion
4. Error si ninguna version satisface todas

### Ejemplo de Resolucion

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)

Interseccion: >=1.2.0 <1.3.0
Disponibles: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]
Resuelto: 1.2.5 (mas alta en la interseccion)
```

### Deteccion de Conflictos

El conflicto ocurre cuando ninguna version satisface todas las restricciones:

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)

Interseccion: (vacia)
Resultado: CONFLICTO - ninguna version satisface ambas
```

## Mejores Practicas

### Para Consumidores de Paquetes

1. **Usar rangos caret** para la mayoria de dependencias:
   ```json
   "hemlang/json": "^1.2.0"
   ```

2. **Usar rangos tilde** para dependencias criticas:
   ```json
   "critical/lib": "~1.2.0"
   ```

3. **Fijar versiones** solo cuando sea necesario:
   ```json
   "unstable/pkg": "1.2.3"
   ```

4. **Incluir tu archivo de bloqueo** para compilaciones reproducibles

5. **Actualizar regularmente** para obtener correcciones de seguridad:
   ```bash
   hpm update
   hpm outdated
   ```

### Para Autores de Paquetes

1. **Comenzar en 0.1.0** para desarrollo inicial:
   - La API puede cambiar frecuentemente
   - Los usuarios esperan inestabilidad

2. **Ir a 1.0.0** cuando la API sea estable:
   - Compromiso publico de estabilidad
   - Cambios incompatibles requieren incremento mayor

3. **Seguir semver estrictamente**:
   - Cambio incompatible = MAJOR
   - Nueva caracteristica = MINOR
   - Correccion de error = PATCH

4. **Usar pre-lanzamientos** para pruebas:
   ```bash
   git tag v2.0.0-beta.1
   git push --tags
   ```

5. **Documentar cambios incompatibles** en CHANGELOG

## Publicar Versiones

### Crear Lanzamientos

```bash
# Actualizar version en package.json
# Editar package.json: "version": "1.1.0"

# Confirmar cambio de version
git add package.json
git commit -m "Bump version to 1.1.0"

# Crear y enviar etiqueta
git tag v1.1.0
git push origin main --tags
```

### Formato de Etiqueta

Las etiquetas **deben** comenzar con `v`:

```
v1.0.0      âœ“ Correcto
v1.0.0-beta âœ“ Correcto
1.0.0       âœ— No sera reconocido
```

### Flujo de Trabajo de Lanzamiento

```bash
# 1. Asegurar que las pruebas pasen
hpm test

# 2. Actualizar version en package.json
# 3. Actualizar CHANGELOG.md
# 4. Confirmar cambios
git add -A
git commit -m "Release v1.2.0"

# 5. Crear etiqueta
git tag v1.2.0

# 6. Enviar todo
git push origin main --tags
```

## Verificar Versiones

### Listar Versiones Instaladas

```bash
hpm list
```

### Verificar Actualizaciones

```bash
hpm outdated
```

Salida:
```
Package         Current  Wanted  Latest
hemlang/json    1.0.0    1.0.5   1.2.0
hemlang/sprout  2.0.0    2.0.3   2.1.0
```

- **Current**: Version instalada
- **Wanted**: Mas alta que coincide con la restriccion
- **Latest**: Ultima disponible

### Actualizar Paquetes

```bash
# Actualizar todos
hpm update

# Actualizar paquete especifico
hpm update hemlang/json
```

## Ver Tambien

- [Creacion de Paquetes](#hpm-versioning-creating-packages) - Guia de publicacion
- [Especificacion de Paquetes](#hpm-versioning-package-spec) - Formato de package.json
- [Comandos](#hpm-versioning-commands) - Referencia de CLI



################################################################################
# HPM: REFERENCIA
################################################################################

--------------------------------------------------------------------------------
## Arquitectura
--------------------------------------------------------------------------------

# Arquitectura

Arquitectura interna y diseno de hpm. Este documento es para contribuidores y aquellos interesados en entender como funciona hpm.

## Descripcion General

hpm esta escrito en Hemlock y consiste en varios modulos que manejan diferentes aspectos de la gestion de paquetes:

```
src/
â”œâ”€â”€ main.hml        # Punto de entrada CLI y enrutamiento de comandos
â”œâ”€â”€ manifest.hml    # Manejo de package.json
â”œâ”€â”€ lockfile.hml    # Manejo de package-lock.json
â”œâ”€â”€ semver.hml      # Versionado semantico
â”œâ”€â”€ resolver.hml    # Resolucion de dependencias
â”œâ”€â”€ github.hml      # Cliente de API de GitHub
â”œâ”€â”€ installer.hml   # Descarga y extraccion de paquetes
â””â”€â”€ cache.hml       # Gestion de cache global
```

## Responsabilidades de los Modulos

### main.hml

El punto de entrada para la aplicacion CLI.

**Responsabilidades:**
- Parsear argumentos de linea de comandos
- Enrutar comandos a los manejadores apropiados
- Mostrar informacion de ayuda y version
- Manejar flags globales (--verbose, --dry-run, etc.)
- Salir con codigos apropiados

**Funciones principales:**
- `main()` - Punto de entrada, parsea args y despacha comandos
- `cmd_init()` - Manejar `hpm init`
- `cmd_install()` - Manejar `hpm install`
- `cmd_uninstall()` - Manejar `hpm uninstall`
- `cmd_update()` - Manejar `hpm update`
- `cmd_list()` - Manejar `hpm list`
- `cmd_outdated()` - Manejar `hpm outdated`
- `cmd_run()` - Manejar `hpm run`
- `cmd_why()` - Manejar `hpm why`
- `cmd_cache()` - Manejar `hpm cache`

**Atajos de comandos:**
```hemlock
let shortcuts = {
    "i": "install",
    "rm": "uninstall",
    "remove": "uninstall",
    "ls": "list",
    "up": "update"
};
```

### manifest.hml

Maneja lectura y escritura de archivos `package.json`.

**Responsabilidades:**
- Leer/escribir package.json
- Validar estructura del paquete
- Gestionar dependencias
- Parsear especificadores de paquetes (owner/repo@version)

**Funciones principales:**
```hemlock
create_default(): Manifest           // Crear manifiesto vacio
read_manifest(): Manifest            // Leer desde archivo
write_manifest(m: Manifest)          // Escribir a archivo
validate(m: Manifest): bool          // Validar estructura
get_all_dependencies(m): Map         // Obtener deps + devDeps
add_dependency(m, pkg, ver, dev)     // Agregar dependencia
remove_dependency(m, pkg)            // Eliminar dependencia
parse_specifier(spec): (name, ver)   // Parsear "owner/repo@^1.0.0"
split_name(name): (owner, repo)      // Parsear "owner/repo"
```

**Estructura de Manifest:**
```hemlock
type Manifest = {
    name: string,
    version: string,
    description: string?,
    author: string?,
    license: string?,
    repository: string?,
    main: string?,
    dependencies: Map<string, string>,
    devDependencies: Map<string, string>,
    scripts: Map<string, string>
};
```

### lockfile.hml

Gestiona el archivo `package-lock.json` para instalaciones reproducibles.

**Responsabilidades:**
- Crear/leer/escribir archivos de bloqueo
- Rastrear versiones exactas resueltas
- Almacenar URLs de descarga y hashes de integridad
- Podar dependencias huerfanas

**Funciones principales:**
```hemlock
create_empty(): Lockfile              // Crear lockfile vacio
read_lockfile(): Lockfile             // Leer desde archivo
write_lockfile(l: Lockfile)           // Escribir a archivo
create_entry(ver, url, hash, deps)    // Crear entrada de bloqueo
get_locked(l, pkg): LockEntry?        // Obtener version bloqueada
set_locked(l, pkg, entry)             // Establecer version bloqueada
remove_locked(l, pkg)                 // Eliminar entrada
prune(l, keep: Set)                   // Eliminar huerfanos
needs_update(l, m): bool              // Verificar si esta desincronizado
```

**Estructura de Lockfile:**
```hemlock
type Lockfile = {
    lockVersion: int,
    hemlock: string,
    dependencies: Map<string, LockEntry>
};

type LockEntry = {
    version: string,
    resolved: string,     // URL de descarga
    integrity: string,    // Hash SHA256
    dependencies: Map<string, string>
};
```

### semver.hml

Implementacion completa de Versionado Semantico 2.0.0.

**Responsabilidades:**
- Parsear cadenas de version
- Comparar versiones
- Parsear y evaluar restricciones de version
- Encontrar versiones que satisfacen restricciones

**Funciones principales:**
```hemlock
// Parseo
parse(s: string): Version             // "1.2.3-beta+build" â†’ Version
stringify(v: Version): string         // Version â†’ "1.2.3-beta+build"

// Comparacion
compare(a, b: Version): int           // -1, 0, o 1
gt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool

// Restricciones
parse_constraint(s: string): Constraint    // "^1.2.3" â†’ Constraint
satisfies(v: Version, c: Constraint): bool // Verificar si v coincide con c
max_satisfying(versions, c): Version?      // Encontrar coincidencia mas alta
sort(versions): [Version]                  // Ordenar ascendente

// Utilidades
constraints_overlap(a, b: Constraint): bool  // Verificar compatibilidad
```

**Estructura de Version:**
```hemlock
type Version = {
    major: int,
    minor: int,
    patch: int,
    prerelease: [string]?,  // ej., ["beta", "1"]
    build: string?          // ej., "20230101"
};
```

**Tipos de Restriccion:**
```hemlock
type Constraint =
    | Exact(Version)           // "1.2.3"
    | Caret(Version)           // "^1.2.3" â†’ >=1.2.3 <2.0.0
    | Tilde(Version)           // "~1.2.3" â†’ >=1.2.3 <1.3.0
    | Range(op, Version)       // ">=1.0.0", "<2.0.0"
    | And(Constraint, Constraint)  // Rangos combinados
    | Any;                     // "*"
```

### resolver.hml

Implementa resolucion de dependencias estilo npm.

**Responsabilidades:**
- Resolver arboles de dependencias
- Detectar conflictos de versiones
- Detectar dependencias circulares
- Construir arboles de visualizacion

**Funciones principales:**
```hemlock
resolve(manifest, lockfile): ResolveResult
    // Resolutor principal: retorna mapa plano de todas las dependencias con versiones resueltas

resolve_version(pkg, constraints: [string]): ResolvedPackage?
    // Encontrar version que satisface todas las restricciones

detect_cycles(deps: Map): [Cycle]?
    // Encontrar dependencias circulares usando DFS

build_tree(lockfile): Tree
    // Crear estructura de arbol para mostrar

find_why(pkg, lockfile): [Chain]
    // Encontrar cadenas de dependencia explicando por que pkg esta instalado
```

**Algoritmo de resolucion:**

1. **Recopilar restricciones**: Recorrer manifiesto y dependencias transitivas
2. **Resolver cada paquete**: Para cada paquete:
   - Obtener todas las restricciones de version de los dependientes
   - Obtener versiones disponibles de GitHub
   - Encontrar version maxima que satisface TODAS las restricciones
   - Error si ninguna version satisface todas (conflicto)
3. **Detectar ciclos**: Ejecutar DFS para encontrar dependencias circulares
4. **Retornar mapa plano**: Nombre del paquete â†’ informacion de version resuelta

**Estructura de ResolveResult:**
```hemlock
type ResolveResult = {
    packages: Map<string, ResolvedPackage>,
    conflicts: [Conflict]?,
    cycles: [Cycle]?
};

type ResolvedPackage = {
    name: string,
    version: Version,
    url: string,
    dependencies: Map<string, string>
};
```

### github.hml

Cliente de API de GitHub para descubrimiento y descarga de paquetes.

**Responsabilidades:**
- Obtener versiones disponibles (etiquetas)
- Descargar package.json de repositorios
- Descargar tarballs de lanzamientos
- Manejar autenticacion y limites de tasa

**Funciones principales:**
```hemlock
get_token(): string?
    // Obtener token de env o config

github_request(url, headers?): Response
    // Hacer solicitud a API con reintentos

get_tags(owner, repo): [string]
    // Obtener etiquetas de version (v1.0.0, v1.1.0, etc.)

get_package_json(owner, repo, ref): Manifest
    // Obtener package.json en etiqueta/commit especifico

download_tarball(owner, repo, tag): bytes
    // Descargar archivo de lanzamiento

repo_exists(owner, repo): bool
    // Verificar si el repositorio existe

get_repo_info(owner, repo): RepoInfo
    // Obtener metadatos del repositorio
```

**Logica de reintento:**
- Retroceso exponencial: 1s, 2s, 4s, 8s
- Reintenta en: 403 (limite de tasa), 5xx (error de servidor), errores de red
- Maximo 4 reintentos
- Reporta errores de limite de tasa claramente

**Endpoints de API usados:**
```
GET /repos/{owner}/{repo}/tags
GET /repos/{owner}/{repo}/contents/package.json?ref={tag}
GET /repos/{owner}/{repo}/tarball/{tag}
GET /repos/{owner}/{repo}
```

### installer.hml

Maneja descarga y extraccion de paquetes.

**Responsabilidades:**
- Descargar paquetes de GitHub
- Extraer tarballs a hem_modules
- Verificar/usar paquetes en cache
- Instalar/desinstalar paquetes

**Funciones principales:**
```hemlock
install_package(pkg: ResolvedPackage): bool
    // Descargar e instalar un solo paquete

install_all(packages: Map, options): InstallResult
    // Instalar todos los paquetes resueltos

uninstall_package(name: string): bool
    // Eliminar paquete de hem_modules

get_installed(): Map<string, string>
    // Listar paquetes actualmente instalados

verify_integrity(pkg): bool
    // Verificar integridad del paquete

prefetch_packages(packages: Map): void
    // Descarga paralela a cache (experimental)
```

**Proceso de instalacion:**

1. Verificar si ya esta instalado en la version correcta
2. Verificar cache por tarball
3. Si no esta en cache, descargar de GitHub
4. Almacenar en cache para uso futuro
5. Extraer a `hem_modules/owner/repo/`
6. Verificar instalacion

**Estructura de directorio creada:**
```
hem_modules/
â””â”€â”€ owner/
    â””â”€â”€ repo/
        â”œâ”€â”€ package.json
        â”œâ”€â”€ src/
        â””â”€â”€ ...
```

### cache.hml

Gestiona la cache global de paquetes.

**Responsabilidades:**
- Almacenar tarballs descargados
- Recuperar paquetes en cache
- Listar paquetes en cache
- Limpiar cache
- Gestionar configuracion

**Funciones principales:**
```hemlock
get_cache_dir(): string
    // Obtener directorio de cache (respeta HPM_CACHE_DIR)

get_config_dir(): string
    // Obtener directorio de configuracion (~/.hpm)

is_cached(owner, repo, version): bool
    // Verificar si tarball esta en cache

get_cached_path(owner, repo, version): string
    // Obtener ruta a tarball en cache

store_tarball_file(owner, repo, version, data): void
    // Guardar tarball en cache

list_cached(): [CachedPackage]
    // Listar todos los paquetes en cache

clear_cache(): int
    // Eliminar todos los paquetes en cache, retorna bytes liberados

get_cache_size(): int
    // Calcular tamano total de cache

read_config(): Config
    // Leer ~/.hpm/config.json

write_config(c: Config): void
    // Escribir archivo de configuracion
```

**Estructura de cache:**
```
~/.hpm/
â”œâ”€â”€ config.json
â””â”€â”€ cache/
    â””â”€â”€ owner/
        â””â”€â”€ repo/
            â”œâ”€â”€ 1.0.0.tar.gz
            â””â”€â”€ 1.1.0.tar.gz
```

## Flujo de Datos

### Flujo del Comando Install

```
hpm install owner/repo@^1.0.0
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ main.hml â”‚ Parsear args, llamar cmd_install
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚manifest.hmlâ”‚ Leer package.json, agregar dependencia
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚resolver.hmlâ”‚ Resolver todas las dependencias
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ semver.hmlâ”‚ Obtener versiones, encontrar satisfactoria
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚installer.hmlâ”‚ Descargar y extraer paquetes
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ cache.hmlâ”‚ Descargar o usar cache
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚lockfile.hmlâ”‚ Actualizar package-lock.json
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Detalle del Algoritmo de Resolucion

```
Entrada: manifest.dependencies, manifest.devDependencies, lockfile existente

1. Inicializar:
   - constraints = {} // Map<string, [Constraint]>
   - resolved = {}    // Map<string, ResolvedPackage>
   - queue = [dependencias directas]

2. Mientras queue no este vacia:
   a. pkg = queue.pop()
   b. Si pkg ya esta resuelto, saltar
   c. Obtener todas las restricciones para pkg de dependientes
   d. Obtener versiones disponibles de GitHub (cacheado)
   e. Encontrar version maxima que satisface TODAS las restricciones
   f. Si ninguna encontrada: CONFLICTO
   g. resolved[pkg] = {version, url, deps}
   h. Agregar dependencias de pkg a queue

3. Detectar ciclos en grafo resuelto
   - Si se encuentra ciclo: ERROR

4. Retornar mapa resuelto
```

## Manejo de Errores

### Codigos de Salida

Definidos en main.hml:

```hemlock
let EXIT_SUCCESS = 0;
let EXIT_CONFLICT = 1;
let EXIT_NOT_FOUND = 2;
let EXIT_VERSION_NOT_FOUND = 3;
let EXIT_NETWORK = 4;
let EXIT_INVALID_MANIFEST = 5;
let EXIT_INTEGRITY = 6;
let EXIT_RATE_LIMIT = 7;
let EXIT_CIRCULAR = 8;
```

### Propagacion de Errores

Los errores se propagan a traves de valores de retorno:

```hemlock
fn resolve_version(pkg): Result<Version, ResolveError> {
    let versions = github.get_tags(owner, repo)?;  // ? propaga
    // ...
}
```

## Pruebas

### Framework de Pruebas

Framework de pruebas personalizado en `test/framework.hml`:

```hemlock
fn suite(name: string, tests: fn()) {
    print("Suite: " + name);
    tests();
}

fn test(name: string, body: fn()) {
    try {
        body();
        print("  âœ“ " + name);
    } catch e {
        print("  âœ— " + name + ": " + e);
        failed += 1;
    }
}

fn assert_eq<T>(actual: T, expected: T) {
    if actual != expected {
        throw "Expected " + expected + ", got " + actual;
    }
}
```

### Archivos de Prueba

- `test/test_semver.hml` - Parseo de versiones, comparacion, restricciones
- `test/test_manifest.hml` - Lectura/escritura de manifiesto, validacion
- `test/test_lockfile.hml` - Operaciones de lockfile
- `test/test_cache.hml` - Gestion de cache

### Ejecutar Pruebas

```bash
# Todas las pruebas
make test

# Pruebas especificas
make test-semver
make test-manifest
make test-lockfile
make test-cache
```

## Mejoras Futuras

### Caracteristicas Planeadas

1. **Verificacion de integridad** - Verificacion completa de hash SHA256
2. **Espacios de trabajo** - Soporte de monorepo
3. **Sistema de plugins** - Comandos extensibles
4. **Auditoria** - Verificacion de vulnerabilidades de seguridad
5. **Registro privado** - Alojamiento de paquetes auto-hospedado

### Limitaciones Conocidas

1. **Error del bundler** - No puede crear ejecutable independiente
2. **Descargas paralelas** - Experimental, puede tener condiciones de carrera
3. **Integridad** - SHA256 no completamente implementado

## Contribuir

### Estilo de Codigo

- Usar indentacion de 4 espacios
- Las funciones deben hacer una cosa
- Comentar logica compleja
- Escribir pruebas para nuevas caracteristicas

### Agregar un Comando

1. Agregar manejador en `main.hml`:
   ```hemlock
   fn cmd_newcmd(args: [string]) {
       // Implementation
   }
   ```

2. Agregar al despacho de comandos:
   ```hemlock
   match command {
       "newcmd" => cmd_newcmd(args),
       // ...
   }
   ```

3. Actualizar texto de ayuda

### Agregar un Modulo

1. Crear `src/newmodule.hml`
2. Exportar interfaz publica
3. Importar en modulos que lo necesiten
4. Agregar pruebas en `test/test_newmodule.hml`

## Ver Tambien

- [Comandos](#hpm-architecture-commands) - Referencia de CLI
- [Creacion de Paquetes](#hpm-architecture-creating-packages) - Desarrollo de paquetes
- [Versionado](#hpm-architecture-versioning) - Versionado semantico


--------------------------------------------------------------------------------
## CÃ³digos de Salida
--------------------------------------------------------------------------------

# Codigos de Salida

Referencia de codigos de salida de hpm y sus significados.

## Tabla de Codigos de Salida

| Codigo | Nombre | Descripcion |
|--------|--------|-------------|
| 0 | SUCCESS | Comando completado exitosamente |
| 1 | CONFLICT | Conflicto de version de dependencia |
| 2 | NOT_FOUND | Paquete no encontrado |
| 3 | VERSION_NOT_FOUND | Version solicitada no encontrada |
| 4 | NETWORK | Error de red |
| 5 | INVALID_MANIFEST | package.json invalido |
| 6 | INTEGRITY | Verificacion de integridad fallida |
| 7 | RATE_LIMIT | Limite de tasa de API de GitHub excedido |
| 8 | CIRCULAR | Dependencia circular detectada |

## Descripciones Detalladas

### Codigo de Salida 0: SUCCESS

El comando se completo exitosamente.

```bash
$ hpm install
Installed 5 packages
$ echo $?
0
```

### Codigo de Salida 1: CONFLICT

Dos o mas paquetes requieren versiones incompatibles de una dependencia.

**Ejemplo:**
```
Error: Dependency conflict for hemlang/json

  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)
  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)

No version satisfies all constraints.
```

**Soluciones:**
1. Verificar que paquetes tienen el conflicto:
   ```bash
   hpm why hemlang/json
   ```
2. Actualizar el paquete en conflicto:
   ```bash
   hpm update package-a
   ```
3. Relajar restricciones de version en package.json
4. Eliminar uno de los paquetes en conflicto

### Codigo de Salida 2: NOT_FOUND

El paquete especificado no existe en GitHub.

**Ejemplo:**
```
Error: Package not found: hemlang/nonexistent

The repository hemlang/nonexistent does not exist on GitHub.
```

**Soluciones:**
1. Verificar la ortografia del nombre del paquete
2. Verificar si el repositorio existe: `https://github.com/owner/repo`
3. Verificar que tienes acceso (para repos privados, establecer GITHUB_TOKEN)

### Codigo de Salida 3: VERSION_NOT_FOUND

Ninguna version coincide con la restriccion especificada.

**Ejemplo:**
```
Error: No version of hemlang/json matches constraint ^5.0.0

Available versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0
```

**Soluciones:**
1. Verificar versiones disponibles en releases/tags de GitHub
2. Usar una restriccion de version valida
3. Las etiquetas de version deben comenzar con 'v' (ej., `v1.0.0`)

### Codigo de Salida 4: NETWORK

Ocurrio un error relacionado con la red.

**Ejemplo:**
```
Error: Network error: could not connect to api.github.com

Please check your internet connection and try again.
```

**Soluciones:**
1. Verificar conexion a internet
2. Verificar si GitHub es accesible
3. Verificar configuracion de proxy si estas detras de un firewall
4. Usar `--offline` si los paquetes estan en cache:
   ```bash
   hpm install --offline
   ```
5. Esperar y reintentar (hpm reintenta automaticamente)

### Codigo de Salida 5: INVALID_MANIFEST

El archivo package.json es invalido o tiene formato incorrecto.

**Ejemplo:**
```
Error: Invalid package.json

  - Missing required field: name
  - Invalid version format: "1.0"
```

**Soluciones:**
1. Verificar sintaxis JSON (usar un validador de JSON)
2. Asegurar que los campos requeridos existan (`name`, `version`)
3. Verificar formatos de campos:
   - name: formato `owner/repo`
   - version: formato semver `X.Y.Z`
4. Regenerar:
   ```bash
   rm package.json
   hpm init
   ```

### Codigo de Salida 6: INTEGRITY

La verificacion de integridad del paquete fallo.

**Ejemplo:**
```
Error: Integrity check failed for hemlang/json@1.0.0

Expected: sha256-abc123...
Actual:   sha256-def456...

The downloaded package may be corrupted.
```

**Soluciones:**
1. Limpiar cache y reinstalar:
   ```bash
   hpm cache clean
   hpm install
   ```
2. Verificar problemas de red (descargas parciales)
3. Verificar que el paquete no fue manipulado

### Codigo de Salida 7: RATE_LIMIT

Se ha excedido el limite de tasa de la API de GitHub.

**Ejemplo:**
```
Error: GitHub API rate limit exceeded

Unauthenticated rate limit: 60 requests/hour
Current usage: 60/60

Rate limit resets at: 2024-01-15 10:30:00 UTC
```

**Soluciones:**
1. **Autenticar con GitHub** (recomendado):
   ```bash
   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
   hpm install
   ```
2. Esperar a que se reinicie el limite de tasa (se reinicia cada hora)
3. Usar modo sin conexion si los paquetes estan en cache:
   ```bash
   hpm install --offline
   ```

### Codigo de Salida 8: CIRCULAR

Dependencia circular detectada en el grafo de dependencias.

**Ejemplo:**
```
Error: Circular dependency detected

  package-a@1.0.0
  â””â”€â”€ package-b@1.0.0
      â””â”€â”€ package-a@1.0.0  (circular!)

Cannot resolve dependency tree.
```

**Soluciones:**
1. Esto generalmente es un error en los paquetes mismos
2. Contactar a los mantenedores del paquete
3. Evitar usar uno de los paquetes circulares

## Usar Codigos de Salida en Scripts

### Bash

```bash
#!/bin/bash

hpm install
exit_code=$?

case $exit_code in
  0)
    echo "Installation successful"
    ;;
  1)
    echo "Dependency conflict - check version constraints"
    exit 1
    ;;
  2)
    echo "Package not found - check package name"
    exit 1
    ;;
  4)
    echo "Network error - check connection"
    exit 1
    ;;
  7)
    echo "Rate limited - set GITHUB_TOKEN"
    exit 1
    ;;
  *)
    echo "Unknown error: $exit_code"
    exit 1
    ;;
esac
```

### CI/CD

```yaml
# GitHub Actions
- name: Install dependencies
  run: |
    hpm install
    if [ $? -eq 7 ]; then
      echo "::error::GitHub rate limit exceeded. Add GITHUB_TOKEN."
      exit 1
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Make

```makefile
install:
	@hpm install || (echo "Installation failed with code $$?"; exit 1)

test: install
	@hpm test
```

## Solucion de Problemas por Codigo de Salida

### Referencia Rapida

| Codigo | Primer Paso a Verificar |
|--------|------------------------|
| 1 | Ejecutar `hpm why <paquete>` para ver conflicto |
| 2 | Verificar nombre del paquete en GitHub |
| 3 | Verificar versiones disponibles en etiquetas de GitHub |
| 4 | Verificar conexion a internet |
| 5 | Validar sintaxis de package.json |
| 6 | Ejecutar `hpm cache clean && hpm install` |
| 7 | Establecer variable de entorno `GITHUB_TOKEN` |
| 8 | Contactar mantenedores del paquete |

## Ver Tambien

- [Solucion de Problemas](#hpm-exit-codes-troubleshooting) - Soluciones detalladas
- [Comandos](#hpm-exit-codes-commands) - Referencia de comandos
- [Configuracion](#hpm-exit-codes-configuration) - Configurar token de GitHub



================================================================================
END OF DOCUMENTATION
================================================================================